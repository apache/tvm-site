<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::runtime::Array&lt; T, typename &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1runtime.html">runtime</a></li><li class="navelem"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1runtime_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::runtime::Array&lt; T, typename &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a>, container representing a contiguous sequence of ObjectRefs.  
 <a href="classtvm_1_1runtime_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8h_source.html">array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::runtime::Array&lt; T, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1runtime_1_1Array__inherit__graph.svg" width="190" height="610"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::runtime::Array&lt; T, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1runtime_1_1Array__coll__graph.svg" width="198" height="898"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1Array_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a203f4dc8f7a37ac325f6d1e192d2f8c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a203f4dc8f7a37ac325f6d1e192d2f8c1">value_type</a> = T</td></tr>
<tr class="separator:a203f4dc8f7a37ac325f6d1e192d2f8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e5ad633b8195d954c98067213ae29f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> = <a class="el" href="classtvm_1_1runtime_1_1IterAdapter.html">IterAdapter</a>&lt; <a class="el" href="structtvm_1_1runtime_1_1Array_1_1ValueConverter.html">ValueConverter</a>, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> * &gt;</td></tr>
<tr class="separator:a98e5ad633b8195d954c98067213ae29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4886f1509998e380f032896a5afb27b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a> = <a class="el" href="classtvm_1_1runtime_1_1ReverseIterAdapter.html">ReverseIterAdapter</a>&lt; <a class="el" href="structtvm_1_1runtime_1_1Array_1_1ValueConverter.html">ValueConverter</a>, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> * &gt;</td></tr>
<tr class="separator:a4886f1509998e380f032896a5afb27b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031d3a0bc8443b3895567333103a4bb2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a031d3a0bc8443b3895567333103a4bb2">ContainerType</a> = <a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a></td></tr>
<tr class="memdesc:a031d3a0bc8443b3895567333103a4bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify container node  <a href="#a031d3a0bc8443b3895567333103a4bb2">More...</a><br /></td></tr>
<tr class="separator:a031d3a0bc8443b3895567333103a4bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">ContainerType</a> = <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">type indicate the container type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">More...</a><br /></td></tr>
<tr class="separator:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8b7450aea8633a51d3e8c75ed9fe2be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#af8b7450aea8633a51d3e8c75ed9fe2be">Array</a> ()</td></tr>
<tr class="memdesc:af8b7450aea8633a51d3e8c75ed9fe2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#af8b7450aea8633a51d3e8c75ed9fe2be">More...</a><br /></td></tr>
<tr class="separator:af8b7450aea8633a51d3e8c75ed9fe2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87edbe5dfbdd7deda742bd187ebee234"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a87edbe5dfbdd7deda742bd187ebee234">Array</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a87edbe5dfbdd7deda742bd187ebee234"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#a87edbe5dfbdd7deda742bd187ebee234">More...</a><br /></td></tr>
<tr class="separator:a87edbe5dfbdd7deda742bd187ebee234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd47dead26bddcdd54db780a3135992"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a7bd47dead26bddcdd54db780a3135992">Array</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a7bd47dead26bddcdd54db780a3135992"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a7bd47dead26bddcdd54db780a3135992">More...</a><br /></td></tr>
<tr class="separator:a7bd47dead26bddcdd54db780a3135992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5035bdfd76577c89f9fcde46db7edc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#af5035bdfd76577c89f9fcde46db7edc4">Array</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; n)</td></tr>
<tr class="memdesc:af5035bdfd76577c89f9fcde46db7edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from pointer  <a href="#af5035bdfd76577c89f9fcde46db7edc4">More...</a><br /></td></tr>
<tr class="separator:af5035bdfd76577c89f9fcde46db7edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdeb14d66a7f85e94ee843c459f7959"><td class="memTemplParams" colspan="2">template&lt;typename IterType &gt; </td></tr>
<tr class="memitem:aacdeb14d66a7f85e94ee843c459f7959"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#aacdeb14d66a7f85e94ee843c459f7959">Array</a> (IterType first, IterType last)</td></tr>
<tr class="memdesc:aacdeb14d66a7f85e94ee843c459f7959"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from iterator.  <a href="#aacdeb14d66a7f85e94ee843c459f7959">More...</a><br /></td></tr>
<tr class="separator:aacdeb14d66a7f85e94ee843c459f7959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478af2e3338db97bf9dd3411de6d9a8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a478af2e3338db97bf9dd3411de6d9a8a">Array</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a478af2e3338db97bf9dd3411de6d9a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from initializer list  <a href="#a478af2e3338db97bf9dd3411de6d9a8a">More...</a><br /></td></tr>
<tr class="separator:a478af2e3338db97bf9dd3411de6d9a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af024da3af390f431b941e1378f813e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a9af024da3af390f431b941e1378f813e">Array</a> (const std::vector&lt; T &gt; &amp;init)</td></tr>
<tr class="memdesc:a9af024da3af390f431b941e1378f813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from vector  <a href="#a9af024da3af390f431b941e1378f813e">More...</a><br /></td></tr>
<tr class="separator:a9af024da3af390f431b941e1378f813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c03ae71aa89ec2591ae9ba7b3acc9d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a7c03ae71aa89ec2591ae9ba7b3acc9d1">Array</a> (const size_t n, const T &amp;val)</td></tr>
<tr class="memdesc:a7c03ae71aa89ec2591ae9ba7b3acc9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a container with n elements. Each element is a copy of val.  <a href="#a7c03ae71aa89ec2591ae9ba7b3acc9d1">More...</a><br /></td></tr>
<tr class="separator:a7c03ae71aa89ec2591ae9ba7b3acc9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52fa8c97344586060ca735a3b91b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a8f52fa8c97344586060ca735a3b91b39">operator=</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a8f52fa8c97344586060ca735a3b91b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assign operator  <a href="#a8f52fa8c97344586060ca735a3b91b39">More...</a><br /></td></tr>
<tr class="separator:a8f52fa8c97344586060ca735a3b91b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc26222aa0257ece4c3a9d4d70fa1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a5bc26222aa0257ece4c3a9d4d70fa1d8">operator=</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a5bc26222aa0257ece4c3a9d4d70fa1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assign operator  <a href="#a5bc26222aa0257ece4c3a9d4d70fa1d8">More...</a><br /></td></tr>
<tr class="separator:a5bc26222aa0257ece4c3a9d4d70fa1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9734c8e6324f9be27fce8d45d0aa6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#ae9734c8e6324f9be27fce8d45d0aa6f4">begin</a> () const</td></tr>
<tr class="separator:ae9734c8e6324f9be27fce8d45d0aa6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b097149e69ea03fe3b812a3f5f7fcd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a6b097149e69ea03fe3b812a3f5f7fcd9">end</a> () const</td></tr>
<tr class="separator:a6b097149e69ea03fe3b812a3f5f7fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f2fbd0d476ae66fe526f0685b7cb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#af3f2fbd0d476ae66fe526f0685b7cb6c">rbegin</a> () const</td></tr>
<tr class="separator:af3f2fbd0d476ae66fe526f0685b7cb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dda4b706346d1299cea059957e9ee70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a1dda4b706346d1299cea059957e9ee70">rend</a> () const</td></tr>
<tr class="separator:a1dda4b706346d1299cea059957e9ee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84683f61368eb10e26e72a0097cccd7"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#ac84683f61368eb10e26e72a0097cccd7">operator[]</a> (int64_t i) const</td></tr>
<tr class="memdesc:ac84683f61368eb10e26e72a0097cccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutably read i-th element from array.  <a href="#ac84683f61368eb10e26e72a0097cccd7">More...</a><br /></td></tr>
<tr class="separator:ac84683f61368eb10e26e72a0097cccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6387e67d18b9d5ad18f510fd600a25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#aed6387e67d18b9d5ad18f510fd600a25">size</a> () const</td></tr>
<tr class="separator:aed6387e67d18b9d5ad18f510fd600a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e3711ae1cdfc044e4f90b600e76cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a420e3711ae1cdfc044e4f90b600e76cd">capacity</a> () const</td></tr>
<tr class="separator:a420e3711ae1cdfc044e4f90b600e76cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afdaa55d2e55e942e732f072a97a862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a7afdaa55d2e55e942e732f072a97a862">empty</a> () const</td></tr>
<tr class="separator:a7afdaa55d2e55e942e732f072a97a862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b76dbe39fd58a3160cd898378a02469"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4b76dbe39fd58a3160cd898378a02469">front</a> () const</td></tr>
<tr class="separator:a4b76dbe39fd58a3160cd898378a02469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e68f408a65464de76fa5dc3e34a11"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a0f3e68f408a65464de76fa5dc3e34a11">back</a> () const</td></tr>
<tr class="separator:a0f3e68f408a65464de76fa5dc3e34a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa026b914ee05f81b6c20130b8905f257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#aa026b914ee05f81b6c20130b8905f257">push_back</a> (const T &amp;item)</td></tr>
<tr class="memdesc:aa026b914ee05f81b6c20130b8905f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">push a new item to the back of the list  <a href="#aa026b914ee05f81b6c20130b8905f257">More...</a><br /></td></tr>
<tr class="separator:aa026b914ee05f81b6c20130b8905f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b7d88d169c1305f5dac0818f34141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a78b7d88d169c1305f5dac0818f34141f">insert</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> position, const T &amp;val)</td></tr>
<tr class="memdesc:a78b7d88d169c1305f5dac0818f34141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the given position.  <a href="#a78b7d88d169c1305f5dac0818f34141f">More...</a><br /></td></tr>
<tr class="separator:a78b7d88d169c1305f5dac0818f34141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07747919e590f2a5b80c5c2f9bde6ce"><td class="memTemplParams" colspan="2">template&lt;typename IterType &gt; </td></tr>
<tr class="memitem:ab07747919e590f2a5b80c5c2f9bde6ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#ab07747919e590f2a5b80c5c2f9bde6ce">insert</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> position, IterType first, IterType last)</td></tr>
<tr class="memdesc:ab07747919e590f2a5b80c5c2f9bde6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range of elements into the given position.  <a href="#ab07747919e590f2a5b80c5c2f9bde6ce">More...</a><br /></td></tr>
<tr class="separator:ab07747919e590f2a5b80c5c2f9bde6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39300bd019f435ab23353b991019811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#aa39300bd019f435ab23353b991019811">pop_back</a> ()</td></tr>
<tr class="memdesc:aa39300bd019f435ab23353b991019811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last item of the list.  <a href="#aa39300bd019f435ab23353b991019811">More...</a><br /></td></tr>
<tr class="separator:aa39300bd019f435ab23353b991019811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd88d16147aad4ed810846ce53d21c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a0fd88d16147aad4ed810846ce53d21c9">erase</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> position)</td></tr>
<tr class="memdesc:a0fd88d16147aad4ed810846ce53d21c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element on the given position.  <a href="#a0fd88d16147aad4ed810846ce53d21c9">More...</a><br /></td></tr>
<tr class="separator:a0fd88d16147aad4ed810846ce53d21c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e661cb034323ccb707cd73ee3624e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a69e661cb034323ccb707cd73ee3624e4">erase</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> first, <a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> last)</td></tr>
<tr class="memdesc:a69e661cb034323ccb707cd73ee3624e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a given range of elements.  <a href="#a69e661cb034323ccb707cd73ee3624e4">More...</a><br /></td></tr>
<tr class="separator:a69e661cb034323ccb707cd73ee3624e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8064044f8928cf3fed003507d65604c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a8064044f8928cf3fed003507d65604c7">resize</a> (int64_t n)</td></tr>
<tr class="memdesc:a8064044f8928cf3fed003507d65604c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the array.  <a href="#a8064044f8928cf3fed003507d65604c7">More...</a><br /></td></tr>
<tr class="separator:a8064044f8928cf3fed003507d65604c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7727b86efaf35c58a5198ab1c139c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a1a7727b86efaf35c58a5198ab1c139c8">reserve</a> (int64_t n)</td></tr>
<tr class="memdesc:a1a7727b86efaf35c58a5198ab1c139c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the list has the capacity of at least n.  <a href="#a1a7727b86efaf35c58a5198ab1c139c8">More...</a><br /></td></tr>
<tr class="separator:a1a7727b86efaf35c58a5198ab1c139c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6b43e7ddd25655961a4bdf2251fd4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a0c6b43e7ddd25655961a4bdf2251fd4e">clear</a> ()</td></tr>
<tr class="memdesc:a0c6b43e7ddd25655961a4bdf2251fd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release reference to all the elements.  <a href="#a0c6b43e7ddd25655961a4bdf2251fd4e">More...</a><br /></td></tr>
<tr class="separator:a0c6b43e7ddd25655961a4bdf2251fd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5db2ee9a8be71931324dac552be24c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#ab5db2ee9a8be71931324dac552be24c4">Set</a> (int64_t i, T value)</td></tr>
<tr class="memdesc:ab5db2ee9a8be71931324dac552be24c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set i-th element of the array.  <a href="#ab5db2ee9a8be71931324dac552be24c4">More...</a><br /></td></tr>
<tr class="separator:ab5db2ee9a8be71931324dac552be24c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50385ee3535af422c478d91166331a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a50385ee3535af422c478d91166331a3c">GetArrayNode</a> () const</td></tr>
<tr class="separator:a50385ee3535af422c478d91166331a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ad9c17854dd8011d157f44f8bf012"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = std::invoke_result_t&lt;F, T&gt;&gt; </td></tr>
<tr class="memitem:a520ad9c17854dd8011d157f44f8bf012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a520ad9c17854dd8011d157f44f8bf012">Map</a> (F fmap) const</td></tr>
<tr class="memdesc:a520ad9c17854dd8011d157f44f8bf012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to apply a map function onto the array.  <a href="#a520ad9c17854dd8011d157f44f8bf012">More...</a><br /></td></tr>
<tr class="separator:a520ad9c17854dd8011d157f44f8bf012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ab0bf11149e69f6eb70059bd71fafe"><td class="memTemplParams" colspan="2">template&lt;typename F , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, std::invoke_result_t&lt;F, T&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a67ab0bf11149e69f6eb70059bd71fafe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a67ab0bf11149e69f6eb70059bd71fafe">MutateByApply</a> (F fmutate)</td></tr>
<tr class="memdesc:a67ab0bf11149e69f6eb70059bd71fafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to apply fmutate to mutate an array.  <a href="#a67ab0bf11149e69f6eb70059bd71fafe">More...</a><br /></td></tr>
<tr class="separator:a67ab0bf11149e69f6eb70059bd71fafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2918a29b15ea51e0ff7c88affa212f"><td class="memTemplParams" colspan="2">template&lt;typename IterType &gt; </td></tr>
<tr class="memitem:abd2918a29b15ea51e0ff7c88affa212f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#abd2918a29b15ea51e0ff7c88affa212f">Assign</a> (IterType first, IterType last)</td></tr>
<tr class="memdesc:abd2918a29b15ea51e0ff7c88affa212f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the array to content from iterator.  <a href="#abd2918a29b15ea51e0ff7c88affa212f">More...</a><br /></td></tr>
<tr class="separator:abd2918a29b15ea51e0ff7c88affa212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82a366999c6d2a503411868f3bcf6af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html#ae82a366999c6d2a503411868f3bcf6af">CopyOnWrite</a> ()</td></tr>
<tr class="memdesc:ae82a366999c6d2a503411868f3bcf6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy on write semantics Do nothing if current handle is the unique copy of the array. Otherwise make a new copy of the array to ensure the current handle hold a unique copy.  <a href="#ae82a366999c6d2a503411868f3bcf6af">More...</a><br /></td></tr>
<tr class="separator:ae82a366999c6d2a503411868f3bcf6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">ObjectRef</a> ()=default</td></tr>
<tr class="memdesc:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">More...</a><br /></td></tr>
<tr class="separator:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">ObjectRef</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; data)</td></tr>
<tr class="memdesc:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from existing object ptr.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">More...</a><br /></td></tr>
<tr class="separator:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">same_as</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">More...</a><br /></td></tr>
<tr class="separator:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">More...</a><br /></td></tr>
<tr class="separator:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">More...</a><br /></td></tr>
<tr class="separator:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">More...</a><br /></td></tr>
<tr class="separator:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a17d8d5ad92691f9e18e3e0ae8ef69e4f">defined</a> () const</td></tr>
<tr class="separator:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aadbc0886ffa80162ff31eefd0431ba09">get</a> () const</td></tr>
<tr class="separator:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3deeeac5827a88f375b8c6ae1039c219">operator-&gt;</a> () const</td></tr>
<tr class="separator:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4e7cdb1574b93a59e784d70aa47b8da7">unique</a> () const</td></tr>
<tr class="separator:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a0ae0da21d247cd87ea94fe3777c4405e">use_count</a> () const</td></tr>
<tr class="separator:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">const ObjectType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">as</a> () const</td></tr>
<tr class="memdesc:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to downcast the internal <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> to a raw pointer of a corresponding type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">More...</a><br /></td></tr>
<tr class="separator:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3e9b0901b6e01257b060a45e159cc37e">_type_is_nullable</a> = true</td></tr>
<tr class="separator:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae423057ecf93c18714d17f53cd1d318f">get_mutable</a> () const</td></tr>
<tr class="separator:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">DowncastNoCheck</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> ref)</td></tr>
<tr class="memdesc:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function downcast a ref without check.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">More...</a><br /></td></tr>
<tr class="separator:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">FFIClearAfterMove</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> *ref)</td></tr>
<tr class="memdesc:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the object ref data field without DecRef after we successfully moved the field.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">More...</a><br /></td></tr>
<tr class="separator:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ObjectType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">GetDataPtr</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ref)</td></tr>
<tr class="memdesc:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function get data_ as <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> of ObjectType.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">More...</a><br /></td></tr>
<tr class="separator:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">data_</a></td></tr>
<tr class="memdesc:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal pointer that backs the reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">More...</a><br /></td></tr>
<tr class="separator:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt;<br />
class tvm::runtime::Array&lt; T, typename &gt;</h3>

<p><a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a>, container representing a contiguous sequence of ObjectRefs. </p>
<p><a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a> implements in-place copy-on-write semantics.</p>
<p>As in typical copy-on-write, a method which would typically mutate the array instead opaquely copies the underlying container, and then acts on its copy.</p>
<p>If the array has reference count equal to one, we directly update the container in place without copying. This is optimization is sound because when the reference count is equal to one this reference is guranteed to be the sole pointer to the container.</p>
<p>operator[] only provides const access, use Set to mutate the content. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The content <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a031d3a0bc8443b3895567333103a4bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031d3a0bc8443b3895567333103a4bb2">&#9670;&nbsp;</a></span>ContainerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html#a031d3a0bc8443b3895567333103a4bb2">ContainerType</a> =  <a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify container node </p>

</div>
</div>
<a id="a98e5ad633b8195d954c98067213ae29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e5ad633b8195d954c98067213ae29f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> =  <a class="el" href="classtvm_1_1runtime_1_1IterAdapter.html">IterAdapter</a>&lt;<a class="el" href="structtvm_1_1runtime_1_1Array_1_1ValueConverter.html">ValueConverter</a>, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4886f1509998e380f032896a5afb27b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4886f1509998e380f032896a5afb27b9">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a> =  <a class="el" href="classtvm_1_1runtime_1_1ReverseIterAdapter.html">ReverseIterAdapter</a>&lt;<a class="el" href="structtvm_1_1runtime_1_1Array_1_1ValueConverter.html">ValueConverter</a>, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a203f4dc8f7a37ac325f6d1e192d2f8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203f4dc8f7a37ac325f6d1e192d2f8c1">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html#a203f4dc8f7a37ac325f6d1e192d2f8c1">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8b7450aea8633a51d3e8c75ed9fe2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b7450aea8633a51d3e8c75ed9fe2be">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a id="a87edbe5dfbdd7deda742bd187ebee234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87edbe5dfbdd7deda742bd187ebee234">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bd47dead26bddcdd54db780a3135992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd47dead26bddcdd54db780a3135992">&#9670;&nbsp;</a></span>Array() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5035bdfd76577c89f9fcde46db7edc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5035bdfd76577c89f9fcde46db7edc4">&#9670;&nbsp;</a></span>Array() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the container pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacdeb14d66a7f85e94ee843c459f7959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdeb14d66a7f85e94ee843c459f7959">&#9670;&nbsp;</a></span>Array() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of iterator </td></tr>
    <tr><td class="paramname">last</td><td>end of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterType</td><td>The type of iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a478af2e3338db97bf9dd3411de6d9a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478af2e3338db97bf9dd3411de6d9a8a">&#9670;&nbsp;</a></span>Array() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from initializer list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initializer list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af024da3af390f431b941e1378f813e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af024da3af390f431b941e1378f813e">&#9670;&nbsp;</a></span>Array() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c03ae71aa89ec2591ae9ba7b3acc9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c03ae71aa89ec2591ae9ba7b3acc9d1">&#9670;&nbsp;</a></span>Array() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the container </td></tr>
    <tr><td class="paramname">val</td><td>The init value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd2918a29b15ea51e0ff7c88affa212f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2918a29b15ea51e0ff7c88affa212f">&#9670;&nbsp;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the array to content from iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of iterator </td></tr>
    <tr><td class="paramname">last</td><td>end of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterType</td><td>The type of iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f3e68f408a65464de76fa5dc3e34a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e68f408a65464de76fa5dc3e34a11">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The last element of the array </dd></dl>

</div>
</div>
<a id="ae9734c8e6324f9be27fce8d45d0aa6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9734c8e6324f9be27fce8d45d0aa6f4">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>begin iterator </dd></dl>

</div>
</div>
<a id="a420e3711ae1cdfc044e4f90b600e76cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e3711ae1cdfc044e4f90b600e76cd">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The capacity of the array </dd></dl>

</div>
</div>
<a id="a0c6b43e7ddd25655961a4bdf2251fd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6b43e7ddd25655961a4bdf2251fd4e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release reference to all the elements. </p>

</div>
</div>
<a id="ae82a366999c6d2a503411868f3bcf6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82a366999c6d2a503411868f3bcf6af">&#9670;&nbsp;</a></span>CopyOnWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a>* <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::CopyOnWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy on write semantics Do nothing if current handle is the unique copy of the array. Otherwise make a new copy of the array to ensure the current handle hold a unique copy. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the internal node container(which ganrantees to be unique) </dd></dl>

</div>
</div>
<a id="a7afdaa55d2e55e942e732f072a97a862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afdaa55d2e55e942e732f072a97a862">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether array is empty </dd></dl>

</div>
</div>
<a id="a6b097149e69ea03fe3b812a3f5f7fcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b097149e69ea03fe3b812a3f5f7fcd9">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a> <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator </dd></dl>

</div>
</div>
<a id="a0fd88d16147aad4ed810846ce53d21c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd88d16147aad4ed810846ce53d21c9">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element on the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator pointing to the element to be erased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e661cb034323ccb707cd73ee3624e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e661cb034323ccb707cd73ee3624e4">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a given range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The begin iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>The end iterator of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b76dbe39fd58a3160cd898378a02469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b76dbe39fd58a3160cd898378a02469">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first element of the array </dd></dl>

</div>
</div>
<a id="a50385ee3535af422c478d91166331a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385ee3535af422c478d91166331a3c">&#9670;&nbsp;</a></span>GetArrayNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a>* <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::GetArrayNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The underlying <a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html" title="array node content in array ">ArrayNode</a> </dd></dl>

</div>
</div>
<a id="a78b7d88d169c1305f5dac0818f34141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b7d88d169c1305f5dac0818f34141f">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element into the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator pointing to the insertion point </td></tr>
    <tr><td class="paramname">val</td><td>The element to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab07747919e590f2a5b80c5c2f9bde6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07747919e590f2a5b80c5c2f9bde6ce">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a98e5ad633b8195d954c98067213ae29f">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range of elements into the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator pointing to the insertion point </td></tr>
    <tr><td class="paramname">first</td><td>The begin iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>The end iterator of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520ad9c17854dd8011d157f44f8bf012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520ad9c17854dd8011d157f44f8bf012">&#9670;&nbsp;</a></span>Map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = std::invoke_result_t&lt;F, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;U&gt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to apply a map function onto the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmap</td><td>The transformation function T -&gt; U.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the mutation function.</td></tr>
    <tr><td class="paramname">U</td><td>The type of the returned array, inferred from the return type of F. If overridden by the user, must be something that is convertible from the return type of F.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function performs copy on write optimization. If <code>fmap</code> returns an object of type <code>T</code>, and all elements of the array are mapped to themselves, then the returned array will be the same as the original, and reference counts of the elements in the array will not be incremented.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed array. </dd></dl>

</div>
</div>
<a id="a67ab0bf11149e69f6eb70059bd71fafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ab0bf11149e69f6eb70059bd71fafe">&#9670;&nbsp;</a></span>MutateByApply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename F , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, std::invoke_result_t&lt;F, T&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::MutateByApply </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmutate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to apply fmutate to mutate an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmutate</td><td>The transformation function T -&gt; T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>the type of the mutation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function performs copy on write optimization. </dd></dl>

</div>
</div>
<a id="a8f52fa8c97344586060ca735a3b91b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52fa8c97344586060ca735a3b91b39">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assign operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source of assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to self. </dd></dl>

</div>
</div>
<a id="a5bc26222aa0257ece4c3a9d4d70fa1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc26222aa0257ece4c3a9d4d70fa1d8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assign operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source of assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to self. </dd></dl>

</div>
</div>
<a id="ac84683f61368eb10e26e72a0097cccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84683f61368eb10e26e72a0097cccd7">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutably read i-th element from array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i-th element. </dd></dl>

</div>
</div>
<a id="aa39300bd019f435ab23353b991019811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39300bd019f435ab23353b991019811">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last item of the list. </p>

</div>
</div>
<a id="aa026b914ee05f81b6c20130b8905f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa026b914ee05f81b6c20130b8905f257">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>push a new item to the back of the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to be pushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f2fbd0d476ae66fe526f0685b7cb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f2fbd0d476ae66fe526f0685b7cb6c">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a> <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>rbegin iterator </dd></dl>

</div>
</div>
<a id="a1dda4b706346d1299cea059957e9ee70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dda4b706346d1299cea059957e9ee70">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html#a4886f1509998e380f032896a5afb27b9">reverse_iterator</a> <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>rend iterator </dd></dl>

</div>
</div>
<a id="a1a7727b86efaf35c58a5198ab1c139c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7727b86efaf35c58a5198ab1c139c8">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure the list has the capacity of at least n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>lower bound of the capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8064044f8928cf3fed003507d65604c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8064044f8928cf3fed003507d65604c7">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5db2ee9a8be71931324dac552be24c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5db2ee9a8be71931324dac552be24c4">&#9670;&nbsp;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set i-th element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index </td></tr>
    <tr><td class="paramname">value</td><td>The value to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed6387e67d18b9d5ad18f510fd600a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6387e67d18b9d5ad18f510fd600a25">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::runtime::Array</a>&lt; T, typename &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the array </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/runtime/container/<a class="el" href="array_8h_source.html">array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
