<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1builtin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html">builtin</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1builtin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of builtin intrinsics as ops. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1usmp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1usmp.html">usmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AddNode.html" title="a + b ">AddNode</a>.  <a href="classtvm_1_1tir_1_1Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AddNode.html">AddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + b  <a href="classtvm_1_1tir_1_1AddNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AllocateNode.html" title="Allocate a buffer that can be used in body. ">AllocateNode</a>.  <a href="classtvm_1_1tir_1_1Allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateConst.html">AllocateConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AllocateConstNode.html" title="Allocate a buffer that can be used in body. ">AllocateConstNode</a>.  <a href="classtvm_1_1tir_1_1AllocateConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateConstNode.html">AllocateConstNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateConstNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateNode.html">AllocateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1And.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AndNode.html" title="a &amp;&amp; b ">AndNode</a>.  <a href="classtvm_1_1tir_1_1And.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AndNode.html">AndNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &amp;&amp; b  <a href="classtvm_1_1tir_1_1AndNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Any.html">Any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AnyNode.html" title="Any shape. ">AnyNode</a>.  <a href="classtvm_1_1tir_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AnyNode.html">AnyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Any.html" title="Managed reference to AnyNode. ">Any</a> shape.  <a href="classtvm_1_1tir_1_1AnyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html" title="Assert condition, if an error occurs, return the error message. ">AssertStmtNode</a>.  <a href="classtvm_1_1tir_1_1AssertStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html">AssertStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert condition, if an error occurs, return the error message.  <a href="classtvm_1_1tir_1_1AssertStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmt.html">AttrStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html" title="Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary inform...">AttrStmtNode</a>.  <a href="classtvm_1_1tir_1_1AttrStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html">AttrStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body.  <a href="classtvm_1_1tir_1_1AttrStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html">BijectiveLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bijective function mapping for data layout transformation. Given two <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a>, <a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html" title="Bijective function mapping for data layout transformation. Given two Layout, BijectiveLayout build an...">BijectiveLayout</a> build and store the mapping rules, provides API to transform N-dimention tensor from the source indices (i0, i1, .., im) to the destination indices (j0, j1, .., jm).  <a href="classtvm_1_1tir_1_1BijectiveLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayoutNode.html">BijectiveLayoutNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BinaryOpNode.html">BinaryOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement binary ops.  <a href="classtvm_1_1tir_1_1BinaryOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BlockNode.html" title="A block is a basic schedule unit in TIR. ">BlockNode</a>.  <a href="classtvm_1_1tir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1BlockInfo.html">BlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a TensorIR block, it contains two categories of information 1) Info on the block scope rooted at a specific block, including dependency tracking, flags indicating if the scope is a stage pipeline, etc. 2) Info on the block itself, including if the block has a quasi-affine binding, if the regions it reads are completely covered by their producers, etc.  <a href="structtvm_1_1tir_1_1BlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockNode.html">BlockNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block is a basic schedule unit in TIR.  <a href="classtvm_1_1tir_1_1BlockNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockRealize.html">BlockRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BlockRealizeNode.html" title="A block realization node represents execution of the block at the binding values. ...">BlockRealizeNode</a>.  <a href="classtvm_1_1tir_1_1BlockRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockRealizeNode.html">BlockRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block realization node represents execution of the block at the binding values.  <a href="classtvm_1_1tir_1_1BlockRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BlockRVNode.html" title="A random variable that evaluates to a TensorIR block. ">BlockRVNode</a>.  <a href="classtvm_1_1tir_1_1BlockRV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockRVNode.html">BlockRVNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random variable that evaluates to a TensorIR block.  <a href="classtvm_1_1tir_1_1BlockRVNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockScope.html">BlockScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BlockScopeNode.html" title="An object with 1-to-1 correspondence with each block reference in the sref tree. This data structure ...">BlockScopeNode</a>.  <a href="classtvm_1_1tir_1_1BlockScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BlockScopeNode.html">BlockScopeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object with 1-to-1 correspondence with each block reference in the sref tree. This data structure is used to track the producer-consumer dependencies between blocks. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example even leaf nodes have a scope node, even though they have no dependencies.  <a href="classtvm_1_1tir_1_1BlockScopeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html" title="Create a vector where all the elements are value. ">BroadcastNode</a>.  <a href="classtvm_1_1tir_1_1Broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html">BroadcastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector where all the elements are value.  <a href="classtvm_1_1tir_1_1BroadcastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> is a symbolic n-darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input.  <a href="classtvm_1_1tir_1_1Buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoad.html">BufferLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html" title="Load value from the high dimension buffer. ">BufferLoadNode</a>.  <a href="classtvm_1_1tir_1_1BufferLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html">BufferLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> value from the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferNode.html">BufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to represent a buffer.  <a href="classtvm_1_1tir_1_1BufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRealize.html">BufferRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferRealizeNode.html" title="Annotate the region where the buffer need to be read and write in the body. We only need to allocate ...">BufferRealizeNode</a>.  <a href="classtvm_1_1tir_1_1BufferRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRealizeNode.html">BufferRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the region where the buffer need to be read and write in the body. We only need to allocate the space for the corresponding region.  <a href="classtvm_1_1tir_1_1BufferRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferRegionNode.html" title="Representing the region of multi-dimensional buffer access. ">BufferRegionNode</a>.  <a href="classtvm_1_1tir_1_1BufferRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRegionNode.html">BufferRegionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representing the region of multi-dimensional buffer access.  <a href="classtvm_1_1tir_1_1BufferRegionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStore.html">BufferStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html" title="Store value to the high dimension buffer. ">BufferStoreNode</a>.  <a href="classtvm_1_1tir_1_1BufferStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html">BufferStoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value to the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferStoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CallNode.html" title="Call node. ">CallNode</a>.  <a href="classtvm_1_1tir_1_1Call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> node.  <a href="classtvm_1_1tir_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CastNode.html" title="Cast value from one data type to another. ">CastNode</a>.  <a href="classtvm_1_1tir_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CastNode.html">CastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Cast.html" title="Managed reference to CastNode. ">Cast</a> value from one data type to another.  <a href="classtvm_1_1tir_1_1CastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CmpOpNode.html">CmpOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement comparison ops.  <a href="classtvm_1_1tir_1_1CmpOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducer.html">CommReducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html" title="A commutative reducer node to represent a commutative binary operator with identity element...">CommReducerNode</a>.  <a href="classtvm_1_1tir_1_1CommReducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html">CommReducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A commutative reducer node to represent a commutative binary operator with identity element.  <a href="classtvm_1_1tir_1_1CommReducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducer.html">DataProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html" title="Base node for data producers. ">DataProducerNode</a>.  <a href="classtvm_1_1tir_1_1DataProducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html">DataProducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node for data producers.  <a href="classtvm_1_1tir_1_1DataProducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DeclBuffer.html">DeclBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DeclBufferNode.html" title="Declare a buffer that can be used in the body. ">DeclBufferNode</a>.  <a href="classtvm_1_1tir_1_1DeclBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DeclBufferNode.html">DeclBufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a buffer that can be used in the body.  <a href="classtvm_1_1tir_1_1DeclBufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Dependency.html">Dependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DependencyNode.html" title="A tuple (src, dst, kind) representing certain types of dependency. For example, (A, B, kRAW) means block B depends on block A, and the dependency kind is read-after-write, which means block B reads the result written by block A. ">DependencyNode</a>.  <a href="classtvm_1_1tir_1_1Dependency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DependencyNode.html">DependencyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple (src, dst, kind) representing certain types of dependency. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example, (A, B, kRAW) means block B depends on block A, and the dependency kind is read-after-write, which means block B reads the result written by block A.  <a href="classtvm_1_1tir_1_1DependencyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DivNode.html" title="a / b in the C semnatics. ">DivNode</a>.  <a href="classtvm_1_1tir_1_1Div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DivNode.html">DivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a / b in the C semnatics.  <a href="classtvm_1_1tir_1_1DivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQ.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EQNode.html" title="a == b ">EQNode</a>.  <a href="classtvm_1_1tir_1_1EQ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQNode.html">EQNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b  <a href="classtvm_1_1tir_1_1EQNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html" title="Evaluates an expression. This is mostly used for putting a Call node into Stmt. ">EvaluateNode</a>.  <a href="classtvm_1_1tir_1_1Evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html">EvaluateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression. This is mostly used for putting a <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> node into <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="classtvm_1_1tir_1_1EvaluateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1ExprDeepEqual.html">ExprDeepEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions recursively and check if they are equal to each other without var remapping.  <a href="structtvm_1_1tir_1_1ExprDeepEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function.  <a href="classtvm_1_1tir_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const PrimExpr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html" title="ExprMutator that mutates expressions. ">ExprMutator</a> that mutates expressions.  <a href="classtvm_1_1tir_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html" title="ExprVisitor. ">ExprVisitor</a>.  <a href="classtvm_1_1tir_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDiv.html">FloorDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html" title="Floor division, floor(a/b) ">FloorDivNode</a>.  <a href="classtvm_1_1tir_1_1FloorDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html">FloorDivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor division, floor(a/b)  <a href="classtvm_1_1tir_1_1FloorDivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorMod.html">FloorMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorModNode.html" title="The remainder of the floordiv. ">FloorModNode</a>.  <a href="classtvm_1_1tir_1_1FloorMod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorModNode.html">FloorModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the floordiv.  <a href="classtvm_1_1tir_1_1FloorModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1For.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ForNode.html" title="A for loop, with poissible type annotations. ">ForNode</a>.  <a href="classtvm_1_1tir_1_1For.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ForNode.html">ForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop, with poissible type annotations.  <a href="classtvm_1_1tir_1_1ForNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GE.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GENode.html" title="a &gt;= b ">GENode</a>.  <a href="classtvm_1_1tir_1_1GE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GENode.html">GENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt;= b  <a href="classtvm_1_1tir_1_1GENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GT.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GTNode.html" title="a &gt; b ">GTNode</a>.  <a href="classtvm_1_1tir_1_1GT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GTNode.html">GTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt; b  <a href="classtvm_1_1tir_1_1GTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html" title="IfThenElse statment. ">IfThenElseNode</a>.  <a href="classtvm_1_1tir_1_1IfThenElse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html">IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> statment.  <a href="classtvm_1_1tir_1_1IfThenElseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IndexMapNode.html">IndexMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mapping between two representations of indices into a buffer.  <a href="classtvm_1_1tir_1_1IndexMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Instruction.html">Instruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1InstructionNode.html" title="Schedule instructions each corresponds to a schedule primitive. ">InstructionNode</a>.  <a href="classtvm_1_1tir_1_1Instruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1InstructionKind.html">InstructionKind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1InstructionKindNode.html" title="Kind of an instruction, e.g. Split, Reorder, etc. Besides the name, every kind of instruction has its...">InstructionKindNode</a>.  <a href="classtvm_1_1tir_1_1InstructionKind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1InstructionKindNode.html">InstructionKindNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of an instruction, e.g. Split, Reorder, etc. Besides the name, every kind of instruction has its own properties, including: 1) A boolean indicating if the instruction is pure, i.e. change nothing in the schedule state 2) A functor that applies the instruction to a TensorIR schedule 3) A functor that converts the instruction to a statement in python syntax 4) A functor that serialize its attributes to JSON 5) A functor that deserialize its attributes from JSON.  <a href="classtvm_1_1tir_1_1InstructionKindNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1InstructionKindRegEntry.html">InstructionKindRegEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry in the registry of <a class="el" href="classtvm_1_1tir_1_1InstructionKind.html" title="Managed reference to InstructionKindNode. ">InstructionKind</a>.  <a href="classtvm_1_1tir_1_1InstructionKindRegEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1InstructionNode.html">InstructionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Schedule.html" title="Managed reference to ScheduleNode. ">Schedule</a> instructions each corresponds to a schedule primitive.  <a href="classtvm_1_1tir_1_1InstructionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration Variable, represents an iteration over an integer interval.  <a href="classtvm_1_1tir_1_1IterVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVarNode.html">IterVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iteration variable representing an iteration over a one dimensional interval.  <a href="classtvm_1_1tir_1_1IterVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Layout.html">Layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LayoutNode.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">LayoutNode</a>.  <a href="classtvm_1_1tir_1_1Layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutAxis.html">LayoutAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutNode.html">LayoutNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a> is to describe how data is organized within an N-dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. Here subordinate axis channel_block=16 is the factor size of the primal axis C (channel). <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a> for scalar is defined, while both its name and axes have size 0.  <a href="classtvm_1_1tir_1_1LayoutNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LE.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="structtvm_1_1tir_1_1LENode.html" title="a &lt;= b ">LENode</a>.  <a href="classtvm_1_1tir_1_1LE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1LENode.html">LENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt;= b  <a href="structtvm_1_1tir_1_1LENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetNode.html" title="Let binding. Bind var to value then evaluate body. ">LetNode</a>.  <a href="classtvm_1_1tir_1_1Let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode. ">Let</a> binding. Bind var to value then evaluate body.  <a href="classtvm_1_1tir_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html" title="Let binding, bind var to value, then run body. ">LetStmtNode</a>.  <a href="classtvm_1_1tir_1_1LetStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html">LetStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode. ">Let</a> binding, bind var to value, then run body.  <a href="classtvm_1_1tir_1_1LetStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LoadNode.html" title="Load the value from buffer_var. ">LoadNode</a>.  <a href="classtvm_1_1tir_1_1Load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoadNode.html">LoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> the value from buffer_var.  <a href="classtvm_1_1tir_1_1LoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LoopRVNode.html" title="A random variable that evaluates to a TensorIR for loop. ">LoopRVNode</a>.  <a href="classtvm_1_1tir_1_1LoopRV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoopRVNode.html">LoopRVNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random variable that evaluates to a TensorIR for loop.  <a href="classtvm_1_1tir_1_1LoopRVNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LT.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LTNode.html" title="a &lt; b ">LTNode</a>.  <a href="classtvm_1_1tir_1_1LT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LTNode.html">LTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt; b  <a href="classtvm_1_1tir_1_1LTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MatchBufferRegion.html">MatchBufferRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MatchBufferRegionNode.html" title="Match introduces a constraint that the source buffer region can be remapped to the data layout specif...">MatchBufferRegionNode</a>.  <a href="classtvm_1_1tir_1_1MatchBufferRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MatchBufferRegionNode.html">MatchBufferRegionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match introduces a constraint that the source buffer region can be remapped to the data layout specified by the buffer field. The constraint can be checked in later part of lowering (or optionally during runtime).  <a href="classtvm_1_1tir_1_1MatchBufferRegionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MaxNode.html" title="max(a, b) ">MaxNode</a>.  <a href="classtvm_1_1tir_1_1Max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MaxNode.html">MaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">max(a, b)  <a href="classtvm_1_1tir_1_1MaxNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MinNode.html" title="min(a, b) ">MinNode</a>.  <a href="classtvm_1_1tir_1_1Min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MinNode.html">MinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(a, b)  <a href="classtvm_1_1tir_1_1MinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ModNode.html" title="a % b in the C semnatics. ">ModNode</a>.  <a href="classtvm_1_1tir_1_1Mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ModNode.html">ModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a % b in the C semnatics.  <a href="classtvm_1_1tir_1_1ModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MulNode.html" title="a * b ">MulNode</a>.  <a href="classtvm_1_1tir_1_1Mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MulNode.html">MulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a * b  <a href="classtvm_1_1tir_1_1MulNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NE.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NENode.html" title="a != b ">NENode</a>.  <a href="classtvm_1_1tir_1_1NE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NENode.html">NENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a != b  <a href="classtvm_1_1tir_1_1NENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NotNode.html" title="!a ">NotNode</a>.  <a href="classtvm_1_1tir_1_1Not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NotNode.html">NotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">!a  <a href="classtvm_1_1tir_1_1NotNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1OrNode.html" title="a || b ">OrNode</a>.  <a href="classtvm_1_1tir_1_1Or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1OrNode.html">OrNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a || b  <a href="classtvm_1_1tir_1_1OrNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Prefetch.html">Prefetch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html" title="A prefetch hint for a buffer. ">PrefetchNode</a>.  <a href="classtvm_1_1tir_1_1Prefetch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html">PrefetchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prefetch hint for a buffer.  <a href="classtvm_1_1tir_1_1PrefetchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html" title="Primitive functions that contains TIR statements. ">PrimFuncNode</a>.  <a href="classtvm_1_1tir_1_1PrimFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive functions that contains TIR statements.  <a href="classtvm_1_1tir_1_1PrimFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoad.html">ProducerLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html" title="Load value from the result produced by the producer. ">ProducerLoadNode</a>.  <a href="classtvm_1_1tir_1_1ProducerLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html">ProducerLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> value from the result produced by the producer.  <a href="classtvm_1_1tir_1_1ProducerLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerRealize.html">ProducerRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerRealizeNode.html" title="Annotate the bounds where the data produced by the producer need to be written and read in body...">ProducerRealizeNode</a>.  <a href="classtvm_1_1tir_1_1ProducerRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerRealizeNode.html">ProducerRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the bounds where the data produced by the producer need to be written and read in body. We will need to allocate space for the corresponding regions.  <a href="classtvm_1_1tir_1_1ProducerRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerStore.html">ProducerStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerStoreNode.html" title="Store value into mult-dimensional array that will be read by the consumer of the producer. ">ProducerStoreNode</a>.  <a href="classtvm_1_1tir_1_1ProducerStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerStoreNode.html">ProducerStoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value into mult-dimensional array that will be read by the consumer of the producer.  <a href="classtvm_1_1tir_1_1ProducerStoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1RampNode.html" title="Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load. ">RampNode</a>.  <a href="classtvm_1_1tir_1_1Ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RampNode.html">RampNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load.  <a href="classtvm_1_1tir_1_1RampNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Reduce.html">Reduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ReduceNode.html" title="Reduction operator operator. ">ReduceNode</a>.  <a href="classtvm_1_1tir_1_1Reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ReduceNode.html">ReduceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operator operator.  <a href="classtvm_1_1tir_1_1ReduceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html" title="The user-facing schedule class. ">ScheduleNode</a>.  <a href="classtvm_1_1tir_1_1Schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html">ScheduleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-facing schedule class.  <a href="classtvm_1_1tir_1_1ScheduleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleState.html">ScheduleState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ScheduleStateNode.html" title="The state of scheduling, which exposes a Replace method as the primary interface for all the scheduli...">ScheduleStateNode</a>.  <a href="classtvm_1_1tir_1_1ScheduleState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleStateNode.html">ScheduleStateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of scheduling, which exposes a <code>Replace</code> method as the primary interface for all the scheduling primitives to manipulate the TensorIR.  <a href="classtvm_1_1tir_1_1ScheduleStateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SelectNode.html" title="return true_value if condition is true, otherwise return false_value. ">SelectNode</a>.  <a href="classtvm_1_1tir_1_1Select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SelectNode.html">SelectNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true_value if condition is true, otherwise return false_value.  <a href="classtvm_1_1tir_1_1SelectNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt.html">SeqStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence statement.  <a href="classtvm_1_1tir_1_1SeqStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container of seq statement. Represent a sequence of statements.  <a href="classtvm_1_1tir_1_1SeqStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html" title="Shuffle instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...">ShuffleNode</a>.  <a href="classtvm_1_1tir_1_1Shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html">ShuffleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html" title="Managed reference to ShuffleNode. ">Shuffle</a> instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...)  <a href="classtvm_1_1tir_1_1ShuffleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVar.html">SizeVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable represents a tensor index size  <a href="classtvm_1_1tir_1_1SizeVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVarNode.html">SizeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node represent a tensor index size, whose value must be non-negative.  <a href="classtvm_1_1tir_1_1SizeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all statements.  <a href="classtvm_1_1tir_1_1Stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprMutator.html">StmtExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator that recursively mutates stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprVisitor.html">StmtExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor that recursively visit stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor.html">StmtFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> except it is applied on statements.  <a href="classtvm_1_1tir_1_1StmtFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8_01args_08_4.html">StmtFunctor&lt; R(const Stmt &amp;n, Args... args)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html">StmtMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html" title="StmtMutator that mutates the statements. ">StmtMutator</a> that mutates the statements.  <a href="classtvm_1_1tir_1_1StmtMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of all statements.  <a href="classtvm_1_1tir_1_1StmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html" title="An object that refers to schedulable elements (block/for-loop) in TensorIR, aka &quot;sref&quot;. ">StmtSRefNode</a>.  <a href="classtvm_1_1tir_1_1StmtSRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html">StmtSRefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that refers to schedulable elements (block/for-loop) in TensorIR, aka "sref".  <a href="classtvm_1_1tir_1_1StmtSRefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html">StmtVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html" title="StmtVisitor. ">StmtVisitor</a>.  <a href="classtvm_1_1tir_1_1StmtVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StoreNode.html" title="Store value to the buffer. ">StoreNode</a>.  <a href="classtvm_1_1tir_1_1Store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StoreNode.html">StoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value to the buffer.  <a href="classtvm_1_1tir_1_1StoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StringImmNode.html" title="String constants, only used in asserts. ">StringImmNode</a>.  <a href="classtvm_1_1tir_1_1StringImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants, only used in asserts.  <a href="classtvm_1_1tir_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SubNode.html" title="a - b ">SubNode</a>.  <a href="classtvm_1_1tir_1_1Sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SubNode.html">SubNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a - b  <a href="classtvm_1_1tir_1_1SubNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1TensorIntrin.html">TensorIntrin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1TensorIntrinNode.html" title="Tensor intrinsics for tensorization. ">TensorIntrinNode</a>.  <a href="classtvm_1_1tir_1_1TensorIntrin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1TensorIntrinNode.html">TensorIntrinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor intrinsics for tensorization.  <a href="classtvm_1_1tir_1_1TensorIntrinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Trace.html">Trace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1TraceNode.html" title="An execution trace of a scheduling program. ">TraceNode</a>.  <a href="classtvm_1_1tir_1_1Trace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1TraceNode.html">TraceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An execution trace of a scheduling program.  <a href="classtvm_1_1tir_1_1TraceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable in TIR  <a href="classtvm_1_1tir_1_1Var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node in the IR.  <a href="classtvm_1_1tir_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1While.html">While</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1WhileNode.html" title="A While loop. ">WhileNode</a>.  <a href="classtvm_1_1tir_1_1While.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1WhileNode.html">WhileNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtvm_1_1tir_1_1While.html" title="Managed reference to WhileNode. ">While</a> loop.  <a href="classtvm_1_1tir_1_1WhileNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">IntImmNode</a> = <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td></tr>
<tr class="separator:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb123be81447d2871f4c716ce2d1dc00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">FloatImmNode</a> = <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td></tr>
<tr class="separator:adb123be81447d2871f4c716ce2d1dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81e48fe15eb305b96806e55e01a8c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0a81e48fe15eb305b96806e55e01a8c1">TGlobalSymbol</a> = <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:a0a81e48fe15eb305b96806e55e01a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global symbol of the op after lowering.  <a href="#a0a81e48fe15eb305b96806e55e01a8c1">More...</a><br /></td></tr>
<tr class="separator:a0a81e48fe15eb305b96806e55e01a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">TVectorizable</a> = bool</td></tr>
<tr class="memdesc:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the op is overloaded for vector form.  <a href="#a0c5d42cf669b8ceeb42aa13d95cb5262">More...</a><br /></td></tr>
<tr class="separator:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b294c10c119c32ae3007ad3bfd48af6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2b294c10c119c32ae3007ad3bfd48af6">FLowerIntrinsic</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td></tr>
<tr class="memdesc:a2b294c10c119c32ae3007ad3bfd48af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic lowering function for given op.  <a href="#a2b294c10c119c32ae3007ad3bfd48af6">More...</a><br /></td></tr>
<tr class="separator:a2b294c10c119c32ae3007ad3bfd48af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7201c13348fb1712dad89521f7eeab50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a7201c13348fb1712dad89521f7eeab50">FLegalize</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td></tr>
<tr class="memdesc:a7201c13348fb1712dad89521f7eeab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The legalization function for given tir op.  <a href="#a7201c13348fb1712dad89521f7eeab50">More...</a><br /></td></tr>
<tr class="separator:a7201c13348fb1712dad89521f7eeab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e82a046f157a7d286b0985b3edb84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">TCallEffectKind</a> = <a class="el" href="classtvm_1_1Integer.html">Integer</a></td></tr>
<tr class="memdesc:a651e82a046f157a7d286b0985b3edb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use integer to record the kind.  <a href="#a651e82a046f157a7d286b0985b3edb84">More...</a><br /></td></tr>
<tr class="separator:a651e82a046f157a7d286b0985b3edb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f9f172368158c130f70d363c2166a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a6e4f9f172368158c130f70d363c2166a">FInstructionApply</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;(<a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a> sch, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;decision)&gt;</td></tr>
<tr class="memdesc:a6e4f9f172368158c130f70d363c2166a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that applies the instruction to a TensorIR schedule.  <a href="#a6e4f9f172368158c130f70d363c2166a">More...</a><br /></td></tr>
<tr class="separator:a6e4f9f172368158c130f70d363c2166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454359868d4097a13bb0ac8f9bbafdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad454359868d4097a13bb0ac8f9bbafdb">FInstructionAsPython</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>(const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;decision, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ad454359868d4097a13bb0ac8f9bbafdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that converts the instruction to a statement in python syntax.  <a href="#ad454359868d4097a13bb0ac8f9bbafdb">More...</a><br /></td></tr>
<tr class="separator:ad454359868d4097a13bb0ac8f9bbafdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9b06965f943fddf71ac8140938ebf2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aaf9b06965f943fddf71ac8140938ebf2">FInstructionAttrsAsJSON</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; attrs)&gt;</td></tr>
<tr class="memdesc:aaf9b06965f943fddf71ac8140938ebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that serialize its attributes to JSON.  <a href="#aaf9b06965f943fddf71ac8140938ebf2">More...</a><br /></td></tr>
<tr class="separator:aaf9b06965f943fddf71ac8140938ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608b54f31c0d65032f3949f752f5431d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a608b54f31c0d65032f3949f752f5431d">FInstructionAttrsFromJSON</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;(<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> json_attrs)&gt;</td></tr>
<tr class="memdesc:a608b54f31c0d65032f3949f752f5431d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that deserialize its attributes from JSON.  <a href="#a608b54f31c0d65032f3949f752f5431d">More...</a><br /></td></tr>
<tr class="separator:a608b54f31c0d65032f3949f752f5431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd06e6cee9a7879b254e868025f08eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> = <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a></td></tr>
<tr class="memdesc:a5cd06e6cee9a7879b254e868025f08eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expr random variable.  <a href="#a5cd06e6cee9a7879b254e868025f08eb">More...</a><br /></td></tr>
<tr class="separator:a5cd06e6cee9a7879b254e868025f08eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34ea4f276a7d76508fe458ff5430f3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad34ea4f276a7d76508fe458ff5430f3e">ExprRVNode</a> = <a class="el" href="classtvm_1_1PrimExprNode.html">PrimExprNode</a></td></tr>
<tr class="separator:ad34ea4f276a7d76508fe458ff5430f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75918aeef1136f9d6308556902d5bcae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a75918aeef1136f9d6308556902d5bcae">FTraceDecisionProvider</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(const <a class="el" href="classtvm_1_1tir_1_1Instruction.html">Instruction</a> &amp;inst, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;decision)&gt;</td></tr>
<tr class="memdesc:a75918aeef1136f9d6308556902d5bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that allows users to mutate decisions on the fly when applying instructions. The signature of the callback is:  <a href="#a75918aeef1136f9d6308556902d5bcae">More...</a><br /></td></tr>
<tr class="separator:a75918aeef1136f9d6308556902d5bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277e2a3d81a80a4776705673df51e0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">Region</a> = <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;</td></tr>
<tr class="separator:a8277e2a3d81a80a4776705673df51e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">BufferType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39">kDefault</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663">kAutoBroadcast</a> = 2
 }<tr class="memdesc:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer type  <a href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4a86b205145696c0555fd02bd37f46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b">CallEffectKind::kExprAnnotation</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a">CallEffectKind::kPure</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7">CallEffectKind::kReadState</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0">CallEffectKind::kUpdateState</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b">CallEffectKind::kSpecialCallArg</a> = 4, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373">CallEffectKind::kEmbedInfo</a> = 5, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a2ded73cfb5a05bf0e37b284e42769c9c">CallEffectKind::kControlJump</a> = 6
<br />
 }<tr class="memdesc:a8f4a86b205145696c0555fd02bd37f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The effect type of the call.  <a href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f4a86b205145696c0555fd02bd37f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">DepKind</a> : int32_t { <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12ea565ac768da7890c2660ff4b12d267f4b">DepKind::kRAW</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12eaf3b1d6a59161fbe655adccdd10c6eda4">DepKind::kWAW</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12ea8b16acbc820d7479d796a3a0ac180724">DepKind::kWAR</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = 3
 }<tr class="memdesc:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of dependency. Right now we have 4 types of dependencies 1) Read-after-write (kRAW) 2) Write-after-write (kWAW) 3) Write-after-read (kWAR) 4) Opaque dependency (kOpaque)  <a href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae244600a5e56c4adc9faf6d88f931e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931e">ScheduleErrorRenderLevel</a> : int32_t { <a class="el" href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931ead6733547bb237ce06cddf96357f1b66b">ScheduleErrorRenderLevel::kDetail</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931eae250345d92c29e0a7d8d215ac3b67997">ScheduleErrorRenderLevel::kFast</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931ea35c3ace1970663a16e5c65baa5941b13">ScheduleErrorRenderLevel::kNone</a> = 2
 }<tr class="memdesc:a9ae244600a5e56c4adc9faf6d88f931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of detailed error message rendering.  <a href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9ae244600a5e56c4adc9faf6d88f931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8232edeb2fcce8eb95477c5153237a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a> : int32_t { <a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237aa8604cf55a79d6bfdcb30f77d1622839b">BufferIndexType::kRead</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237aad3ac0ba447a9859ad2db8e498056429f">BufferIndexType::kWrite</a> = 1
 }<tr class="memdesc:a1c8232edeb2fcce8eb95477c5153237a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of buffer index.  <a href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1c8232edeb2fcce8eb95477c5153237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230fa4eb6152910f125f636dab3bd4e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a230fa4eb6152910f125f636dab3bd4e0">ScheduleDebugMask</a> : uint32_t { <a class="el" href="namespacetvm_1_1tir.html#a230fa4eb6152910f125f636dab3bd4e0a0a268a807e51e7631b27cbade225517a">kVerifySRefTree</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a230fa4eb6152910f125f636dab3bd4e0a94964b0d13eecd365705d870d658cc83">kVerifyCachedFlags</a> = 2
 }<tr class="memdesc:a230fa4eb6152910f125f636dab3bd4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bitmask of the debug flag in the ScheduleStateNode.  <a href="namespacetvm_1_1tir.html#a230fa4eb6152910f125f636dab3bd4e0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a230fa4eb6152910f125f636dab3bd4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aaf54983ae8eb79e77ee6be2f8384e1cb1">ForKind::kSerial</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aa6fb3551e3657204372d76d2d9b83a3b9">ForKind::kParallel</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6">kVectorized</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16">kUnrolled</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aa037de60b0cc37e063125a29b487104b7">ForKind::kThreadBinding</a> = 4
<br />
 }<tr class="memdesc:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of the loop.  <a href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422">kDataPar</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0">kThreadIndex</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4">kCommReduce</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b">kOrdered</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c">kOpaque</a> = 4, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = 3, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403">kUnrolled</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16">kUnrolled</a> = 3, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd">kVectorized</a> = 6, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6">kVectorized</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652">kParallelized</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47">kTensorized</a> = 8
<br />
 }<tr class="memdesc:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iteration variable. Each IterVar have a specific type.  <a href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memTemplParams" colspan="2">template&lt;class FLambda &gt; </td></tr>
<tr class="memitem:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1f69889b13455cd290e6b1a6453e3c1d">VisitPrimFuncs</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, FLambda fvisit)</td></tr>
<tr class="memdesc:a1f69889b13455cd290e6b1a6453e3c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#a1f69889b13455cd290e6b1a6453e3c1d">More...</a><br /></td></tr>
<tr class="separator:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1674ab4f532cf0bd0a96a12165105d82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1674ab4f532cf0bd0a96a12165105d82">EstimateTIRFlops</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a1674ab4f532cf0bd0a96a12165105d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the FLOPs of a TIR fragment.  <a href="#a1674ab4f532cf0bd0a96a12165105d82">More...</a><br /></td></tr>
<tr class="separator:a1674ab4f532cf0bd0a96a12165105d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bc659ab2088eef1e5ec2dbe139e3f9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac0bc659ab2088eef1e5ec2dbe139e3f9">EstimateTIRFlops</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ac0bc659ab2088eef1e5ec2dbe139e3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the FLOPs of TIRs in an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#ac0bc659ab2088eef1e5ec2dbe139e3f9">More...</a><br /></td></tr>
<tr class="separator:ac0bc659ab2088eef1e5ec2dbe139e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110e02855d8bc12eb8b6f92ed391844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae110e02855d8bc12eb8b6f92ed391844">UndefinedVars</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:ae110e02855d8bc12eb8b6f92ed391844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the statement.  <a href="#ae110e02855d8bc12eb8b6f92ed391844">More...</a><br /></td></tr>
<tr class="separator:ae110e02855d8bc12eb8b6f92ed391844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de316b20c7af2e8b4f06773ee69a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a99de316b20c7af2e8b4f06773ee69a5a">UndefinedVars</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:a99de316b20c7af2e8b4f06773ee69a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the expression.  <a href="#a99de316b20c7af2e8b4f06773ee69a5a">More...</a><br /></td></tr>
<tr class="separator:a99de316b20c7af2e8b4f06773ee69a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aeb03afda344eb4d3a5d2d3fd4e1d266d">SideEffect</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the side effect.  <a href="#aeb03afda344eb4d3a5d2d3fd4e1d266d">More...</a><br /></td></tr>
<tr class="separator:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad41992c8a069ebdfde7ff87d67dd66bd">UsesVar</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt; vset_contains)</td></tr>
<tr class="memdesc:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a> uses any var in the given variable set.  <a href="#ad41992c8a069ebdfde7ff87d67dd66bd">More...</a><br /></td></tr>
<tr class="separator:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a60b80ecfe05e8cbc1ae824c169c4dc5c">UsesVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr, std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt; vset_contains)</td></tr>
<tr class="memdesc:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> uses any var in the given variable set.  <a href="#a60b80ecfe05e8cbc1ae824c169c4dc5c">More...</a><br /></td></tr>
<tr class="separator:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38edd60b6ff952cefb74842a8ae826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826">VerifySSA</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:a3b38edd60b6ff952cefb74842a8ae826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> is defined and assigned once(in Let/For)  <a href="#a3b38edd60b6ff952cefb74842a8ae826">More...</a><br /></td></tr>
<tr class="separator:a3b38edd60b6ff952cefb74842a8ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69bcf127843e5e671379e44ab47ca27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27">VerifyMemory</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:ac69bcf127843e5e671379e44ab47ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if memory accesses are legal for a specific target device type.  <a href="#ac69bcf127843e5e671379e44ab47ca27">More...</a><br /></td></tr>
<tr class="separator:ac69bcf127843e5e671379e44ab47ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a53dfcb6ef7e178a83fda0bbb5dddcb39">VerifyGPUCode</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; constraints)</td></tr>
<tr class="memdesc:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit.  <a href="#a53dfcb6ef7e178a83fda0bbb5dddcb39">More...</a><br /></td></tr>
<tr class="separator:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dced72fc7ce982b9909f89162275d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a6dced72fc7ce982b9909f89162275d3d">GetBlockAccessRegion</a> (const <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a> &amp;block, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;buffer_var_map)</td></tr>
<tr class="memdesc:a6dced72fc7ce982b9909f89162275d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto detect the block access region according to its body stmt It will detect the access region as an array in order of appearance in AST.  <a href="#a6dced72fc7ce982b9909f89162275d3d">More...</a><br /></td></tr>
<tr class="separator:a6dced72fc7ce982b9909f89162275d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22fd3c129c23e8e724a4772084f802c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad22fd3c129c23e8e724a4772084f802c">GetBlockReadWriteRegion</a> (const <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a> &amp;block, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;buffer_var_map)</td></tr>
<tr class="memdesc:ad22fd3c129c23e8e724a4772084f802c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto detect the block read/write region according to its body stmt. An opaque access will be counted as both a read and a write access.  <a href="#ad22fd3c129c23e8e724a4772084f802c">More...</a><br /></td></tr>
<tr class="separator:ad22fd3c129c23e8e724a4772084f802c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfaeb3b1ce8601eab8d9b575d66f025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#accfaeb3b1ce8601eab8d9b575d66f025">CalculateExprComplexity</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:accfaeb3b1ce8601eab8d9b575d66f025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expresion complexity based on number of symbols it contains.  <a href="#accfaeb3b1ce8601eab8d9b575d66f025">More...</a><br /></td></tr>
<tr class="separator:accfaeb3b1ce8601eab8d9b575d66f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f9f5bc52105a2a38a7a97390c55f18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a24f9f5bc52105a2a38a7a97390c55f18">CalculateWorkspaceBytes</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;workspace_byte_alignment)</td></tr>
<tr class="memdesc:a24f9f5bc52105a2a38a7a97390c55f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the workspace size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a>.  <a href="#a24f9f5bc52105a2a38a7a97390c55f18">More...</a><br /></td></tr>
<tr class="separator:a24f9f5bc52105a2a38a7a97390c55f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd3ced524b506f532aa1d8ae36dadf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abbd3ced524b506f532aa1d8ae36dadf3">DetectBufferAccessLCA</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:abbd3ced524b506f532aa1d8ae36dadf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect the lowest common ancestor(LCA) of buffer access, including both high-level access(BufferLoad, BufferStore) and low-level access(Load, Store and opaque access). The LCA may be a <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loop or a <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a>.  <a href="#abbd3ced524b506f532aa1d8ae36dadf3">More...</a><br /></td></tr>
<tr class="separator:abbd3ced524b506f532aa1d8ae36dadf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3d251f82ef3a0f446ea23f8980d84e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aee3d251f82ef3a0f446ea23f8980d84e">VerifyWellFormed</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, bool assert_mode=true)</td></tr>
<tr class="memdesc:aee3d251f82ef3a0f446ea23f8980d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if the given TIR is well-formed. The verification includes:  <a href="#aee3d251f82ef3a0f446ea23f8980d84e">More...</a><br /></td></tr>
<tr class="separator:aee3d251f82ef3a0f446ea23f8980d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc94726eb40752523b952f500d00ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a65cc94726eb40752523b952f500d00ec">decl_buffer</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype=<a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32), <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> name=&quot;buffer&quot;, String storage_scope=&quot;&quot;, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; axis_separators={}, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a65cc94726eb40752523b952f500d00ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new buffer given shape, and dtype.  <a href="#a65cc94726eb40752523b952f500d00ec">More...</a><br /></td></tr>
<tr class="separator:a65cc94726eb40752523b952f500d00ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d21b3e013c52e289180cd6d7d0a420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac3d21b3e013c52e289180cd6d7d0a420">BufferWithOffsetAlignment</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype, std::string name, int data_alignment, int offset_factor, bool compact, std::string memory_scope=&quot;&quot;)</td></tr>
<tr class="memdesc:ac3d21b3e013c52e289180cd6d7d0a420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates TIR <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> for provided parameters.  <a href="#ac3d21b3e013c52e289180cd6d7d0a420">More...</a><br /></td></tr>
<tr class="separator:ac3d21b3e013c52e289180cd6d7d0a420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abb777c4f4d61883c0cbdf9116458b70d">as_unordered_map</a> (const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;dmap)</td></tr>
<tr class="separator:abb777c4f4d61883c0cbdf9116458b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b6f1b0014dc6e7dd390cff746e9782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a69b6f1b0014dc6e7dd390cff746e9782">Specialize</a> (<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> func, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;param_map)</td></tr>
<tr class="separator:a69b6f1b0014dc6e7dd390cff746e9782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd6ae7623f42cddbb05cc008c33711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48cd6ae7623f42cddbb05cc008c33711">IsPointerType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;type, const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;element_type)</td></tr>
<tr class="memdesc:a48cd6ae7623f42cddbb05cc008c33711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a pointer to a runtime element type.  <a href="#a48cd6ae7623f42cddbb05cc008c33711">More...</a><br /></td></tr>
<tr class="separator:a48cd6ae7623f42cddbb05cc008c33711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1a071208bbbab6b220cf46f5cdccdd86">make_const</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a1a071208bbbab6b220cf46f5cdccdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const value with certain data type.  <a href="#a1a071208bbbab6b220cf46f5cdccdd86">More...</a><br /></td></tr>
<tr class="separator:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3f57cf8d1c3546f075701898c5b70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aed3f57cf8d1c3546f075701898c5b70f">make_zero</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:aed3f57cf8d1c3546f075701898c5b70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const zero expr.  <a href="#aed3f57cf8d1c3546f075701898c5b70f">More...</a><br /></td></tr>
<tr class="separator:aed3f57cf8d1c3546f075701898c5b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd84303a9864b5b366835fa628a7824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8dd84303a9864b5b366835fa628a7824">const_true</a> (int lanes=1, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a8dd84303a9864b5b366835fa628a7824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant true expression.  <a href="#a8dd84303a9864b5b366835fa628a7824">More...</a><br /></td></tr>
<tr class="separator:a8dd84303a9864b5b366835fa628a7824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875c28f423ab96ae8f0d21f1263abe14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a875c28f423ab96ae8f0d21f1263abe14">const_false</a> (int lanes=1, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a875c28f423ab96ae8f0d21f1263abe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant false expression.  <a href="#a875c28f423ab96ae8f0d21f1263abe14">More...</a><br /></td></tr>
<tr class="separator:a875c28f423ab96ae8f0d21f1263abe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8f225faaf34c540194921a7ee6a66"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#acbe8f225faaf34c540194921a7ee6a66">as_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:acbe8f225faaf34c540194921a7ee6a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get x as constant int expression.  <a href="#acbe8f225faaf34c540194921a7ee6a66">More...</a><br /></td></tr>
<tr class="separator:acbe8f225faaf34c540194921a7ee6a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c414d5e54c099ad7287be302aac8f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5c414d5e54c099ad7287be302aac8f02">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int64_t value)</td></tr>
<tr class="memdesc:a5c414d5e54c099ad7287be302aac8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer expression.  <a href="#a5c414d5e54c099ad7287be302aac8f02">More...</a><br /></td></tr>
<tr class="separator:a5c414d5e54c099ad7287be302aac8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8de8f843c6eb433b6ddfbf34e24099ef">is_no_op</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether stmt is nop.  <a href="#a8de8f843c6eb433b6ddfbf34e24099ef">More...</a><br /></td></tr>
<tr class="separator:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5104dcf0933da31329bb0b2580a947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9b5104dcf0933da31329bb0b2580a947">is_one</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a9b5104dcf0933da31329bb0b2580a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 1.  <a href="#a9b5104dcf0933da31329bb0b2580a947">More...</a><br /></td></tr>
<tr class="separator:a9b5104dcf0933da31329bb0b2580a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bad3db162b334837716bf8e7ba9285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48bad3db162b334837716bf8e7ba9285">is_zero</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a48bad3db162b334837716bf8e7ba9285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 0.  <a href="#a48bad3db162b334837716bf8e7ba9285">More...</a><br /></td></tr>
<tr class="separator:a48bad3db162b334837716bf8e7ba9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65923ae132fcc764357a8765878fb528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a65923ae132fcc764357a8765878fb528">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a65923ae132fcc764357a8765878fb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer constant.  <a href="#a65923ae132fcc764357a8765878fb528">More...</a><br /></td></tr>
<tr class="separator:a65923ae132fcc764357a8765878fb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96c80ce43c8276e39c15787d997651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5b96c80ce43c8276e39c15787d997651">is_const_number</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a5b96c80ce43c8276e39c15787d997651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer/float constant.  <a href="#a5b96c80ce43c8276e39c15787d997651">More...</a><br /></td></tr>
<tr class="separator:a5b96c80ce43c8276e39c15787d997651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6454dd89e85fc29a7e3b8620df90a6f6"><td class="memTemplParams" colspan="2">template&lt;typename FReduce &gt; </td></tr>
<tr class="memitem:a6454dd89e85fc29a7e3b8620df90a6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a6454dd89e85fc29a7e3b8620df90a6f6">foldl</a> (FReduce freduce, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> init_value, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;values, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a6454dd89e85fc29a7e3b8620df90a6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left fold.  <a href="#a6454dd89e85fc29a7e3b8620df90a6f6">More...</a><br /></td></tr>
<tr class="separator:a6454dd89e85fc29a7e3b8620df90a6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a246623a4a0c9cd8f8a209ec952a8d1c3">is_const_power_of_two_integer</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int *shift)</td></tr>
<tr class="memdesc:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant power of two If x is power of two, write the power to the shift.  <a href="#a246623a4a0c9cd8f8a209ec952a8d1c3">More...</a><br /></td></tr>
<tr class="separator:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dc226f8b2b537efdc56b1f76351d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a782dc226f8b2b537efdc56b1f76351d1">is_positive_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a782dc226f8b2b537efdc56b1f76351d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d552441331effb387b7c8fb241c454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a51d552441331effb387b7c8fb241c454">is_negative_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a51d552441331effb387b7c8fb241c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db485654cd60d43962f532a1b16026c"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a0db485654cd60d43962f532a1b16026c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0db485654cd60d43962f532a1b16026c">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="separator:a0db485654cd60d43962f532a1b16026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a79fc1666a383e629654ca5f8d2cdf9f4">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, bool value, <a class="el" href="classtvm_1_1Span.html">Span</a> span)</td></tr>
<tr class="separator:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf355a4fdeb063b1adb4946cad5fca68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abf355a4fdeb063b1adb4946cad5fca68">TypeAnnotation</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:abf355a4fdeb063b1adb4946cad5fca68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="#abf355a4fdeb063b1adb4946cad5fca68">More...</a><br /></td></tr>
<tr class="separator:abf355a4fdeb063b1adb4946cad5fca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba58d59be99ed4026f32b0c10f690929"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aba58d59be99ed4026f32b0c10f690929">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> kind)</td></tr>
<tr class="separator:aba58d59be99ed4026f32b0c10f690929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c36414c1be2960099e023ffba09f6e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a03c36414c1be2960099e023ffba09f6e">ForKind2String</a> (<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> t)</td></tr>
<tr class="separator:a03c36414c1be2960099e023ffba09f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47050a2baf7e047f4994700ce8959d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a47050a2baf7e047f4994700ce8959d50">IRTransform</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;preorder, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;postorder, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; only_enable=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="memdesc:a47050a2baf7e047f4994700ce8959d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir nodes in post DFS order, and transform it  <a href="#a47050a2baf7e047f4994700ce8959d50">More...</a><br /></td></tr>
<tr class="separator:a47050a2baf7e047f4994700ce8959d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5067fa233d111c9db9cc402ed599c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4b5067fa233d111c9db9cc402ed599c3">PostOrderVisit</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;node, std::function&lt; void(const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a4b5067fa233d111c9db9cc402ed599c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a4b5067fa233d111c9db9cc402ed599c3">More...</a><br /></td></tr>
<tr class="separator:a4b5067fa233d111c9db9cc402ed599c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ae87f765e4d8230e3572428cdbe3e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a34ae87f765e4d8230e3572428cdbe3e1">Substitute</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a34ae87f765e4d8230e3572428cdbe3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="#a34ae87f765e4d8230e3572428cdbe3e1">More...</a><br /></td></tr>
<tr class="separator:a34ae87f765e4d8230e3572428cdbe3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc8d64e0d78149a19413953dec6230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a71cc8d64e0d78149a19413953dec6230">Substitute</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a71cc8d64e0d78149a19413953dec6230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="#a71cc8d64e0d78149a19413953dec6230">More...</a><br /></td></tr>
<tr class="separator:a71cc8d64e0d78149a19413953dec6230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b45a979a166b673a05e3884bbdccda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a31b45a979a166b673a05e3884bbdccda">Substitute</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;vmap)</td></tr>
<tr class="memdesc:a31b45a979a166b673a05e3884bbdccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="#a31b45a979a166b673a05e3884bbdccda">More...</a><br /></td></tr>
<tr class="separator:a31b45a979a166b673a05e3884bbdccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655d133d1c775d6b63298a65bc0cca2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2655d133d1c775d6b63298a65bc0cca2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2655d133d1c775d6b63298a65bc0cca2">Substitute</a> (T input, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a2655d133d1c775d6b63298a65bc0cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sugar for substitute via a given map.  <a href="#a2655d133d1c775d6b63298a65bc0cca2">More...</a><br /></td></tr>
<tr class="separator:a2655d133d1c775d6b63298a65bc0cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5020900f638dead67cbeed15b478d6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5020900f638dead67cbeed15b478d6f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aa5020900f638dead67cbeed15b478d6f">Substitute</a> (T input, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:aa5020900f638dead67cbeed15b478d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sugar for substitute via a given map.  <a href="#aa5020900f638dead67cbeed15b478d6f">More...</a><br /></td></tr>
<tr class="separator:aa5020900f638dead67cbeed15b478d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982b5f74aafaa506a146ec8bed07b3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a982b5f74aafaa506a146ec8bed07b3f5">PreOrderVisit</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;stmt_or_expr, const std::function&lt; bool(const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;)&gt; &amp;fvisit)</td></tr>
<tr class="memdesc:a982b5f74aafaa506a146ec8bed07b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively visit the IR in pre DFS order node, apply fvisit. If fvisit returns false, it won't visit the children of the node.  <a href="#a982b5f74aafaa506a146ec8bed07b3f5">More...</a><br /></td></tr>
<tr class="separator:a982b5f74aafaa506a146ec8bed07b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e639c81d1c6875ead7764ab8a7cd553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2e639c81d1c6875ead7764ab8a7cd553">RenewDefs</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:a2e639c81d1c6875ead7764ab8a7cd553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renew the definition nodes for a TIR, including <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> and <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a>. This pass works as a simple DeepCopy to duplicate a function with different Vars and Buffers but the same behavior.  <a href="#a2e639c81d1c6875ead7764ab8a7cd553">More...</a><br /></td></tr>
<tr class="separator:a2e639c81d1c6875ead7764ab8a7cd553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fdee9fc81462318d59dbe64c8df26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afc0fdee9fc81462318d59dbe64c8df26">IterVarType2String</a> (<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> t)</td></tr>
<tr class="separator:afc0fdee9fc81462318d59dbe64c8df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5cd06e6cee9a7879b254e868025f08eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd06e6cee9a7879b254e868025f08eb">&#9670;&nbsp;</a></span>ExprRV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">tvm::tir::ExprRV</a> = typedef <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An expr random variable. </p>

</div>
</div>
<a id="ad34ea4f276a7d76508fe458ff5430f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34ea4f276a7d76508fe458ff5430f3e">&#9670;&nbsp;</a></span>ExprRVNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ad34ea4f276a7d76508fe458ff5430f3e">tvm::tir::ExprRVNode</a> = typedef <a class="el" href="classtvm_1_1PrimExprNode.html">PrimExprNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e4f9f172368158c130f70d363c2166a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f9f172368158c130f70d363c2166a">&#9670;&nbsp;</a></span>FInstructionApply</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a6e4f9f172368158c130f70d363c2166a">tvm::tir::FInstructionApply</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;( <a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a> sch, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; decision)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that applies the instruction to a TensorIR schedule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sch</td><td>The schedule to be applied on </td></tr>
    <tr><td class="paramname">inputs</td><td>The input random variables </td></tr>
    <tr><td class="paramname">attrs</td><td><a class="el" href="classtvm_1_1tir_1_1Instruction.html" title="Managed reference to InstructionNode. ">Instruction</a> attributes </td></tr>
    <tr><td class="paramname">decision</td><td>Decisions made on the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The functor returns an array of output random variables </dd></dl>

</div>
</div>
<a id="ad454359868d4097a13bb0ac8f9bbafdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad454359868d4097a13bb0ac8f9bbafdb">&#9670;&nbsp;</a></span>FInstructionAsPython</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ad454359868d4097a13bb0ac8f9bbafdb">tvm::tir::FInstructionAsPython</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>( const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; decision, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&gt;&amp; outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that converts the instruction to a statement in python syntax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Names of the input random variables </td></tr>
    <tr><td class="paramname">attrs</td><td><a class="el" href="classtvm_1_1tir_1_1Instruction.html" title="Managed reference to InstructionNode. ">Instruction</a> attributes </td></tr>
    <tr><td class="paramname">decisions</td><td>Decisions made on the instruction </td></tr>
    <tr><td class="paramname">outputs</td><td>Names of the output random variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the python api call </dd></dl>

</div>
</div>
<a id="aaf9b06965f943fddf71ac8140938ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9b06965f943fddf71ac8140938ebf2">&#9670;&nbsp;</a></span>FInstructionAttrsAsJSON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#aaf9b06965f943fddf71ac8140938ebf2">tvm::tir::FInstructionAttrsAsJSON</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that serialize its attributes to JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes to be serialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array, serialized attributes </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This functor is nullable </dd></dl>

</div>
</div>
<a id="a608b54f31c0d65032f3949f752f5431d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b54f31c0d65032f3949f752f5431d">&#9670;&nbsp;</a></span>FInstructionAttrsFromJSON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a608b54f31c0d65032f3949f752f5431d">tvm::tir::FInstructionAttrsFromJSON</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;(<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> json_attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of the functor that deserialize its attributes from JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json_attrs</td><td>The attributes to be serialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array, deserialized attributes </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This functor is nullable </dd></dl>

</div>
</div>
<a id="a7201c13348fb1712dad89521f7eeab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7201c13348fb1712dad89521f7eeab50">&#9670;&nbsp;</a></span>FLegalize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a7201c13348fb1712dad89521f7eeab50">tvm::tir::FLegalize</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The legalization function for given tir op. </p>

</div>
</div>
<a id="adb123be81447d2871f4c716ce2d1dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb123be81447d2871f4c716ce2d1dc00">&#9670;&nbsp;</a></span>FloatImmNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">tvm::tir::FloatImmNode</a> = typedef <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b294c10c119c32ae3007ad3bfd48af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b294c10c119c32ae3007ad3bfd48af6">&#9670;&nbsp;</a></span>FLowerIntrinsic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a2b294c10c119c32ae3007ad3bfd48af6">tvm::tir::FLowerIntrinsic</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intrinsic lowering function for given op. </p>

</div>
</div>
<a id="a75918aeef1136f9d6308556902d5bcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75918aeef1136f9d6308556902d5bcae">&#9670;&nbsp;</a></span>FTraceDecisionProvider</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a75918aeef1136f9d6308556902d5bcae">tvm::tir::FTraceDecisionProvider</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>( const <a class="el" href="classtvm_1_1tir_1_1Instruction.html">Instruction</a>&amp; inst, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&gt;&amp; decision)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback that allows users to mutate decisions on the fly when applying instructions. The signature of the callback is: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>The instruction </td></tr>
    <tr><td class="paramname">inputs</td><td>The input random variables </td></tr>
    <tr><td class="paramname">attrs</td><td>The attributes </td></tr>
    <tr><td class="paramname">decision</td><td>The original decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new decision </dd></dl>

</div>
</div>
<a id="ae8c7db788e840dc1c2ed1f365d5ea829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c7db788e840dc1c2ed1f365d5ea829">&#9670;&nbsp;</a></span>IntImmNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">tvm::tir::IntImmNode</a> = typedef <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8277e2a3d81a80a4776705673df51e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8277e2a3d81a80a4776705673df51e0a">&#9670;&nbsp;</a></span>Region</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">tvm::tir::Region</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a651e82a046f157a7d286b0985b3edb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651e82a046f157a7d286b0985b3edb84">&#9670;&nbsp;</a></span>TCallEffectKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">tvm::tir::TCallEffectKind</a> = typedef <a class="el" href="classtvm_1_1Integer.html">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use integer to record the kind. </p>

</div>
</div>
<a id="a0a81e48fe15eb305b96806e55e01a8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a81e48fe15eb305b96806e55e01a8c1">&#9670;&nbsp;</a></span>TGlobalSymbol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a0a81e48fe15eb305b96806e55e01a8c1">tvm::tir::TGlobalSymbol</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global symbol of the op after lowering. </p>

</div>
</div>
<a id="a0c5d42cf669b8ceeb42aa13d95cb5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5d42cf669b8ceeb42aa13d95cb5262">&#9670;&nbsp;</a></span>TVectorizable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">tvm::tir::TVectorizable</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the op is overloaded for vector form. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1c8232edeb2fcce8eb95477c5153237a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8232edeb2fcce8eb95477c5153237a">&#9670;&nbsp;</a></span>BufferIndexType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">tvm::tir::BufferIndexType</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of buffer index. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c8232edeb2fcce8eb95477c5153237aa8604cf55a79d6bfdcb30f77d1622839b"></a>kRead&#160;</td><td class="fielddoc"><p>Index of a read buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8232edeb2fcce8eb95477c5153237aad3ac0ba447a9859ad2db8e498056429f"></a>kWrite&#160;</td><td class="fielddoc"><p>Index of a written buffer. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9ac05a14db42ca73da1d3945e7ce2fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac05a14db42ca73da1d3945e7ce2fd1">&#9670;&nbsp;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">tvm::tir::BufferType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39"></a>kDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663"></a>kAutoBroadcast&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8f4a86b205145696c0555fd02bd37f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4a86b205145696c0555fd02bd37f46">&#9670;&nbsp;</a></span>CallEffectKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">tvm::tir::CallEffectKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The effect type of the call. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b"></a>kExprAnnotation&#160;</td><td class="fielddoc"><p>Function corresponds to an annotation(e.g. likely) and can translate to identity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a"></a>kPure&#160;</td><td class="fielddoc"><p>Pure function that do not interacts with any external state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7"></a>kReadState&#160;</td><td class="fielddoc"><p>Function's that may read from states(e.g. RAM) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0"></a>kUpdateState&#160;</td><td class="fielddoc"><p>Function that may read/write from states(e.g. RAM). </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"><p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b"></a>kSpecialCallArg&#160;</td><td class="fielddoc"><p>Special intrinsic to annotate call arguments info only valid as a direct argument to a call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373"></a>kEmbedInfo&#160;</td><td class="fielddoc"><p>Embed opaque information in the Expr, cannot be codegen. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a2ded73cfb5a05bf0e37b284e42769c9c"></a>kControlJump&#160;</td><td class="fielddoc"><p>Function that changes control flow. </p>
</td></tr>
</table>

</div>
</div>
<a id="a82f5fe564edbe0dadbc4a56a82dfe12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5fe564edbe0dadbc4a56a82dfe12e">&#9670;&nbsp;</a></span>DepKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">tvm::tir::DepKind</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of dependency. Right now we have 4 types of dependencies 1) Read-after-write (kRAW) 2) Write-after-write (kWAW) 3) Write-after-read (kWAR) 4) Opaque dependency (kOpaque) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12ea565ac768da7890c2660ff4b12d267f4b"></a>kRAW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12eaf3b1d6a59161fbe655adccdd10c6eda4"></a>kWAW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12ea8b16acbc820d7479d796a3a0ac180724"></a>kWAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9f59694e9c3912cc5e80654ddbc1e40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f59694e9c3912cc5e80654ddbc1e40a">&#9670;&nbsp;</a></span>ForKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">tvm::tir::ForKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kind of the loop. </p>
<p>ForKind can change the control flow semantics of the loop. So the kind field needs to be considered in all TIR passes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aaf54983ae8eb79e77ee6be2f8384e1cb1"></a>kSerial&#160;</td><td class="fielddoc"><p>default semantics &ndash; serial execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aa6fb3551e3657204372d76d2d9b83a3b9"></a>kParallel&#160;</td><td class="fielddoc"><p>Parallel execution on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6"></a>kVectorized&#160;</td><td class="fielddoc"><p>Vector SIMD loop. The loop body will be vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The loop body must be unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aa037de60b0cc37e063125a29b487104b7"></a>kThreadBinding&#160;</td><td class="fielddoc"><p>The loop variable is bound to a thread in an environment. In the final stage of lowering, the loop is simply removed and the loop variable is mapped to the corresponding context thread. </p>
</td></tr>
</table>

</div>
</div>
<a id="add7d0a6b1dd91f0c3c5dd2f4cf64358e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7d0a6b1dd91f0c3c5dd2f4cf64358e">&#9670;&nbsp;</a></span>IterVarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">tvm::tir::IterVarType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of iteration variable. Each <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> have a specific type. </p>
<p>The type of iter var can be overriden via stage.iter_var_attrs given they are compatible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422"></a>kDataPar&#160;</td><td class="fielddoc"><p>Data parallel iteration. This normally corresponds to axis of Tensor. Allow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations. </p>
<dl class="section note"><dt>Note</dt><dd>This does not mean the loop have to be executed in parallel fashion. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0"></a>kThreadIndex&#160;</td><td class="fielddoc"><p>The <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> itself is a thread-index of a fixed thread launching group. Note that this is already assumed to be parallelized. </p>
<p>Disallow: split/fuse/vectorize/parallel </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4"></a>kCommReduce&#160;</td><td class="fielddoc"><p>Communicative reduction. Cannot be directly parallelized. </p>
<p>Disallow: parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b"></a>kOrdered&#160;</td><td class="fielddoc"><p>Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-ordered. </p>
<p>Disallow: reorder/parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c"></a>kOpaque&#160;</td><td class="fielddoc"><p><a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> is opaque,. </p>
<p>May not corresponds to any generated loop Disallow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations and compute_at</p>
<dl class="section note"><dt>Note</dt><dd>This is usually used to implement composite op or external op, where the </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"><p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The execution is unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The loop body must be unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd"></a>kVectorized&#160;</td><td class="fielddoc"><p>The loop is vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6"></a>kVectorized&#160;</td><td class="fielddoc"><p>Vector SIMD loop. The loop body will be vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652"></a>kParallelized&#160;</td><td class="fielddoc"><p>The loop is parallelized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47"></a>kTensorized&#160;</td><td class="fielddoc"><p>Marks boundary of tensorization intrinsic. </p>
</td></tr>
</table>

</div>
</div>
<a id="a230fa4eb6152910f125f636dab3bd4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230fa4eb6152910f125f636dab3bd4e0">&#9670;&nbsp;</a></span>ScheduleDebugMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a230fa4eb6152910f125f636dab3bd4e0">tvm::tir::ScheduleDebugMask</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bitmask of the debug flag in the <a class="el" href="classtvm_1_1tir_1_1ScheduleStateNode.html" title="The state of scheduling, which exposes a Replace method as the primary interface for all the scheduli...">ScheduleStateNode</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1ScheduleStateNode.html" title="The state of scheduling, which exposes a Replace method as the primary interface for all the scheduli...">ScheduleStateNode</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a230fa4eb6152910f125f636dab3bd4e0a0a268a807e51e7631b27cbade225517a"></a>kVerifySRefTree&#160;</td><td class="fielddoc"><p>Verify the correctness of the sref tree. </p>
</td></tr>
<tr><td class="fieldname"><a id="a230fa4eb6152910f125f636dab3bd4e0a94964b0d13eecd365705d870d658cc83"></a>kVerifyCachedFlags&#160;</td><td class="fielddoc"><p>Verify the correctness of affine_binding, region_cover and stage_pipeline. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9ae244600a5e56c4adc9faf6d88f931e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae244600a5e56c4adc9faf6d88f931e">&#9670;&nbsp;</a></span>ScheduleErrorRenderLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9ae244600a5e56c4adc9faf6d88f931e">tvm::tir::ScheduleErrorRenderLevel</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level of detailed error message rendering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ae244600a5e56c4adc9faf6d88f931ead6733547bb237ce06cddf96357f1b66b"></a>kDetail&#160;</td><td class="fielddoc"><p>Render a detailed error message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ae244600a5e56c4adc9faf6d88f931eae250345d92c29e0a7d8d215ac3b67997"></a>kFast&#160;</td><td class="fielddoc"><p>Render the error in fast mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ae244600a5e56c4adc9faf6d88f931ea35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>No error message at all. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acbe8f225faaf34c540194921a7ee6a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe8f225faaf34c540194921a7ee6a66">&#9670;&nbsp;</a></span>as_const_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t* tvm::tir::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get x as constant int expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address to the int expression, return nullptr, if x is not <a class="el" href="classtvm_1_1IntImm.html" title="Managed reference class to IntImmNode. ">IntImm</a>. </dd></dl>

</div>
</div>
<a id="abb777c4f4d61883c0cbdf9116458b70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb777c4f4d61883c0cbdf9116458b70d">&#9670;&nbsp;</a></span>as_unordered_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;K, V&gt; tvm::tir::as_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>dmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3d21b3e013c52e289180cd6d7d0a420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d21b3e013c52e289180cd6d7d0a420">&#9670;&nbsp;</a></span>BufferWithOffsetAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> tvm::tir::BufferWithOffsetAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>memory_scope</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates TIR <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> for provided parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape of the buffer </td></tr>
    <tr><td class="paramname">dtype</td><td>data type </td></tr>
    <tr><td class="paramname">name</td><td>buffer name </td></tr>
    <tr><td class="paramname">data_alignment</td><td>alignment requirement of data pointer in bytes </td></tr>
    <tr><td class="paramname">offset_factor</td><td>Factor of elem_offset field, elem_offset is guaranteed to be multiple of offset_factor User can specify data_alignment and offset_factor to be 0 A default value will be picked. </td></tr>
    <tr><td class="paramname">compact</td><td>If the statement has already bound to a compact buffer. </td></tr>
    <tr><td class="paramname">memory_scope</td><td>memory scope of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accfaeb3b1ce8601eab8d9b575d66f025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfaeb3b1ce8601eab8d9b575d66f025">&#9670;&nbsp;</a></span>CalculateExprComplexity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::tir::CalculateExprComplexity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the expresion complexity based on number of symbols it contains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expr to be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f9f5bc52105a2a38a7a97390c55f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f9f5bc52105a2a38a7a97390c55f18">&#9670;&nbsp;</a></span>CalculateWorkspaceBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::tir::CalculateWorkspaceBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>workspace_byte_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the workspace size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> for which the workspace size to be calculated </td></tr>
    <tr><td class="paramname">workspace_byte_alignment</td><td>The byte alignment required for each tensor allocated in this workspace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a875c28f423ab96ae8f0d21f1263abe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875c28f423ab96ae8f0d21f1263abe14">&#9670;&nbsp;</a></span>const_false()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant false expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a id="a8dd84303a9864b5b366835fa628a7824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd84303a9864b5b366835fa628a7824">&#9670;&nbsp;</a></span>const_true()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant true expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a id="a65cc94726eb40752523b952f500d00ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cc94726eb40752523b952f500d00ec">&#9670;&nbsp;</a></span>decl_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> tvm::tir::decl_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;buffer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>storage_scope</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_separators</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new buffer given shape, and dtype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the buffer, </td></tr>
    <tr><td class="paramname">dtype</td><td>The content data type. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope associated with this buffer </td></tr>
    <tr><td class="paramname">axis_separators</td><td>Divisions defining the groups of axes that will be flattened together. </td></tr>
    <tr><td class="paramname">span</td><td>The location of this object in the source code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created buffer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> for complete constructor. </dd></dl>

</div>
</div>
<a id="abbd3ced524b506f532aa1d8ae36dadf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd3ced524b506f532aa1d8ae36dadf3">&#9670;&nbsp;</a></span>DetectBufferAccessLCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&gt; &gt; tvm::tir::DetectBufferAccessLCA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect the lowest common ancestor(LCA) of buffer access, including both high-level access(BufferLoad, BufferStore) and low-level access(Load, Store and opaque access). The LCA may be a <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loop or a <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Map from buffer to the LCA of all access to it. The lca is function root if the return stmt is NullOpt. </dd></dl>

</div>
</div>
<a id="a1674ab4f532cf0bd0a96a12165105d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1674ab4f532cf0bd0a96a12165105d82">&#9670;&nbsp;</a></span>EstimateTIRFlops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tvm::tir::EstimateTIRFlops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the FLOPs of a TIR fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The TIR fragment to be estimated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated FLOPs. </dd></dl>

</div>
</div>
<a id="ac0bc659ab2088eef1e5ec2dbe139e3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bc659ab2088eef1e5ec2dbe139e3f9">&#9670;&nbsp;</a></span>EstimateTIRFlops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tvm::tir::EstimateTIRFlops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the FLOPs of TIRs in an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> to be estimated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated FLOPs. </dd></dl>

</div>
</div>
<a id="a6454dd89e85fc29a7e3b8620df90a6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6454dd89e85fc29a7e3b8620df90a6f6">&#9670;&nbsp;</a></span>foldl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FReduce &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::foldl </td>
          <td>(</td>
          <td class="paramtype">FReduce&#160;</td>
          <td class="paramname"><em>freduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>init_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left fold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freduce</td><td>The reduction function. </td></tr>
    <tr><td class="paramname">init_value</td><td>The initial value. </td></tr>
    <tr><td class="paramname">values</td><td>The values to be folded. </td></tr>
    <tr><td class="paramname">span</td><td>The location of the fold in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FReduce</td><td>The type of the reduction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c36414c1be2960099e023ffba09f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c36414c1be2960099e023ffba09f6e">&#9670;&nbsp;</a></span>ForKind2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::ForKind2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dced72fc7ce982b9909f89162275d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dced72fc7ce982b9909f89162275d3d">&#9670;&nbsp;</a></span>GetBlockAccessRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a>&gt; &gt; tvm::tir::GetBlockAccessRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto detect the block access region according to its body stmt It will detect the access region as an array in order of appearance in AST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be detected </td></tr>
    <tr><td class="paramname">buffer_var_map</td><td>The outside buffers which may be accessed the block. It is a map from buffer var to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of access regions. There are three arrays of <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html" title="Managed reference to BufferRegionNode. ">BufferRegion</a>:<ul>
<li>first: read regions</li>
<li>second: write regions</li>
<li>third: opaque regions </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad22fd3c129c23e8e724a4772084f802c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22fd3c129c23e8e724a4772084f802c">&#9670;&nbsp;</a></span>GetBlockReadWriteRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a>&gt; &gt; tvm::tir::GetBlockReadWriteRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto detect the block read/write region according to its body stmt. An opaque access will be counted as both a read and a write access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be detected </td></tr>
    <tr><td class="paramname">buffer_var_map</td><td>The outside buffers which may be accessed the block. It is a map from buffer var to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array only consisting of the read regions and write regions of the input block </dd></dl>

</div>
</div>
<a id="a47050a2baf7e047f4994700ce8959d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47050a2baf7e047f4994700ce8959d50">&#9670;&nbsp;</a></span>IRTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::IRTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>postorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>only_enable</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir nodes in post DFS order, and transform it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The ir to be transformed. </td></tr>
    <tr><td class="paramname">preorder</td><td>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won't do further recursion. </td></tr>
    <tr><td class="paramname">postorder</td><td>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </td></tr>
    <tr><td class="paramname">only_enable</td><td>List of <a class="el" href="classtvm_1_1runtime_1_1String.html" title="Reference to string objects. ">runtime::String</a>. If it is null, all IRNode will call preorder/postorder If it is not null, preorder/postorder will only be called when the IRNode's type key is in the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c414d5e54c099ad7287be302aac8f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c414d5e54c099ad7287be302aac8f02">&#9670;&nbsp;</a></span>is_const_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
    <tr><td class="paramname">value</td><td>the value to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant expression. </dd></dl>

</div>
</div>
<a id="a65923ae132fcc764357a8765878fb528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65923ae132fcc764357a8765878fb528">&#9670;&nbsp;</a></span>is_const_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a id="a5b96c80ce43c8276e39c15787d997651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b96c80ce43c8276e39c15787d997651">&#9670;&nbsp;</a></span>is_const_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer/float constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a id="a246623a4a0c9cd8f8a209ec952a8d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246623a4a0c9cd8f8a209ec952a8d1c3">&#9670;&nbsp;</a></span>is_const_power_of_two_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether x is a constant power of two If x is power of two, write the power to the shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input expression. </td></tr>
    <tr><td class="paramname">shift</td><td>The output shift if x is power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant power of two </dd></dl>

</div>
</div>
<a id="a51d552441331effb387b7c8fb241c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d552441331effb387b7c8fb241c454">&#9670;&nbsp;</a></span>is_negative_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8de8f843c6eb433b6ddfbf34e24099ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de8f843c6eb433b6ddfbf34e24099ef">&#9670;&nbsp;</a></span>is_no_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether stmt is nop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The input statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether stmt is nop </dd></dl>

</div>
</div>
<a id="a9b5104dcf0933da31329bb0b2580a947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5104dcf0933da31329bb0b2580a947">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 1 </dd></dl>

</div>
</div>
<a id="a782dc226f8b2b537efdc56b1f76351d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782dc226f8b2b537efdc56b1f76351d1">&#9670;&nbsp;</a></span>is_positive_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48bad3db162b334837716bf8e7ba9285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bad3db162b334837716bf8e7ba9285">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>

</div>
</div>
<a id="a48cd6ae7623f42cddbb05cc008c33711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd6ae7623f42cddbb05cc008c33711">&#9670;&nbsp;</a></span>IsPointerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::IsPointerType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if type is a pointer to a runtime element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to be checked. </td></tr>
    <tr><td class="paramname">element_type</td><td>The corresponding element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The check results </dd></dl>

</div>
</div>
<a id="afc0fdee9fc81462318d59dbe64c8df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0fdee9fc81462318d59dbe64c8df26">&#9670;&nbsp;</a></span>IterVarType2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::IterVarType2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a071208bbbab6b220cf46f5cdccdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a071208bbbab6b220cf46f5cdccdd86">&#9670;&nbsp;</a></span>make_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const value with certain data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">value</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The constant value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed3f57cf8d1c3546f075701898c5b70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3f57cf8d1c3546f075701898c5b70f">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const zero expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>

</div>
</div>
<a id="a0db485654cd60d43962f532a1b16026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db485654cd60d43962f532a1b16026c">&#9670;&nbsp;</a></span>MakeConstScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79fc1666a383e629654ca5f8d2cdf9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fc1666a383e629654ca5f8d2cdf9f4">&#9670;&nbsp;</a></span>MakeConstScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba58d59be99ed4026f32b0c10f690929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba58d59be99ed4026f32b0c10f690929">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::tir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b5067fa233d111c9db9cc402ed599c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5067fa233d111c9db9cc402ed599c3">&#9670;&nbsp;</a></span>PostOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982b5f74aafaa506a146ec8bed07b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982b5f74aafaa506a146ec8bed07b3f5">&#9670;&nbsp;</a></span>PreOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PreOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt_or_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively visit the IR in pre DFS order node, apply fvisit. If fvisit returns false, it won't visit the children of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt_or_expr</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. If fvisit returns false, it won't visit the children of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e639c81d1c6875ead7764ab8a7cd553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e639c81d1c6875ead7764ab8a7cd553">&#9670;&nbsp;</a></span>RenewDefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> tvm::tir::RenewDefs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renew the definition nodes for a TIR, including <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> and <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a>. This pass works as a simple DeepCopy to duplicate a function with different Vars and Buffers but the same behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The input <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The renewed func. </dd></dl>

</div>
</div>
<a id="aeb03afda344eb4d3a5d2d3fd4e1d266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb03afda344eb4d3a5d2d3fd4e1d266d">&#9670;&nbsp;</a></span>SideEffect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> tvm::tir::SideEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the side effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CallEffectKind, can be kPure, kReadState or kUpdateState </dd></dl>

</div>
</div>
<a id="a69b6f1b0014dc6e7dd390cff746e9782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6f1b0014dc6e7dd390cff746e9782">&#9670;&nbsp;</a></span>Specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> tvm::tir::Specialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>param_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ae87f765e4d8230e3572428cdbe3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ae87f765e4d8230e3572428cdbe3e1">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a id="a71cc8d64e0d78149a19413953dec6230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cc8d64e0d78149a19413953dec6230">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a31b45a979a166b673a05e3884bbdccda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b45a979a166b673a05e3884bbdccda">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt; tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The object whose vars are to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a2655d133d1c775d6b63298a65bc0cca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2655d133d1c775d6b63298a65bc0cca2">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sugar for substitute via a given map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be updated. </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input type, can be <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> or <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5020900f638dead67cbeed15b478d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5020900f638dead67cbeed15b478d6f">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sugar for substitute via a given map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be updated. </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input type, can be <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> or <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf355a4fdeb063b1adb4946cad5fca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf355a4fdeb063b1adb4946cad5fca68">&#9670;&nbsp;</a></span>TypeAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::TypeAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a type annotation expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type </td></tr>
    <tr><td class="paramname">span</td><td>The location of this object in the source code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expr a expression with dtype. </dd></dl>

</div>
</div>
<a id="ae110e02855d8bc12eb8b6f92ed391844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae110e02855d8bc12eb8b6f92ed391844">&#9670;&nbsp;</a></span>UndefinedVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The function to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a id="a99de316b20c7af2e8b4f06773ee69a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de316b20c7af2e8b4f06773ee69a5a">&#9670;&nbsp;</a></span>UndefinedVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a id="ad41992c8a069ebdfde7ff87d67dd66bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41992c8a069ebdfde7ff87d67dd66bd">&#9670;&nbsp;</a></span>UsesVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::UsesVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>vset_contains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the given <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a> uses any var in the given variable set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a> to be checked. </td></tr>
    <tr><td class="paramname">vset_contains</td><td>The check function to see if a var is in the variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>stmt</code> uses any var in the given variable set. </dd></dl>

</div>
</div>
<a id="a60b80ecfe05e8cbc1ae824c169c4dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b80ecfe05e8cbc1ae824c169c4dc5c">&#9670;&nbsp;</a></span>UsesVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::UsesVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>vset_contains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the given <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> uses any var in the given variable set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> to be checked. </td></tr>
    <tr><td class="paramname">vset_contains</td><td>The check function to see if var is in the variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>expr</code> uses any var in the given variable set. </dd></dl>

</div>
</div>
<a id="a53dfcb6ef7e178a83fda0bbb5dddcb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dfcb6ef7e178a83fda0bbb5dddcb39">&#9670;&nbsp;</a></span>VerifyGPUCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be checked </td></tr>
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check. Possible keys are</td></tr>
  </table>
  </dd>
</dl>
<p>"max_local_memory_per_block": Total amount of local memory per block (in bytes). "max_shared_memory_per_block": Total amount of shared memory per block (in bytes). "max_threads_per_block": Maximum number of threads per block. "max_thread_x": Maximum length of threadIdx.x. "max_thread_y": Maximum length of threadIdx.y. "max_thread_z": Maximum length of threadIdx.z.</p>
<p>If one key is missing in this argument, the pass won't check for that item. </p><dl class="section return"><dt>Returns</dt><dd>valid Whether it is a valid GPU code </dd></dl>

</div>
</div>
<a id="ac69bcf127843e5e671379e44ab47ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69bcf127843e5e671379e44ab47ca27">&#9670;&nbsp;</a></span>VerifyMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if memory accesses are legal for a specific target device type. </p>
<p>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of memory verification. </dd></dl>

</div>
</div>
<a id="a3b38edd60b6ff952cefb74842a8ae826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38edd60b6ff952cefb74842a8ae826">&#9670;&nbsp;</a></span>VerifySSA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifySSA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> is defined and assigned once(in Let/For) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether IR is in SSA form.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All passes in TIR consume and produce SSA form. </dd></dl>

</div>
</div>
<a id="aee3d251f82ef3a0f446ea23f8980d84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3d251f82ef3a0f446ea23f8980d84e">&#9670;&nbsp;</a></span>VerifyWellFormed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyWellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assert_mode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if the given TIR is well-formed. The verification includes: </p>
<ul>
<li>Check if expressions not contain vars that is defined outside the block. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to be verified. </td></tr>
    <tr><td class="paramname">assert_mode</td><td>The indicator if it raises an error when the function is not well-formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether it is a well-formed TIR function. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1f69889b13455cd290e6b1a6453e3c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f69889b13455cd290e6b1a6453e3c1d">&#9670;&nbsp;</a></span>VisitPrimFuncs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FLambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::VisitPrimFuncs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLambda&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FLambda</td><td>The type of the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> visitor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> to be visited </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor to the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
