<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::attr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::attr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a385e883a7cecc309d063786e5fdf2c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a385e883a7cecc309d063786e5fdf2c4b">IsPragmaKey</a> (const std::string &amp;attr_key)</td></tr>
<tr class="memdesc:a385e883a7cecc309d063786e5fdf2c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if attr_key is a pragma key extension.  <a href="#a385e883a7cecc309d063786e5fdf2c4b">More...</a><br /></td></tr>
<tr class="separator:a385e883a7cecc309d063786e5fdf2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4933845b75cf4f08fb66f55fdd94986f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4933845b75cf4f08fb66f55fdd94986f">kDeviceThreadAxis</a> = &quot;tir.device_thread_axis&quot;</td></tr>
<tr class="memdesc:a4933845b75cf4f08fb66f55fdd94986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to.  <a href="#a4933845b75cf4f08fb66f55fdd94986f">More...</a><br /></td></tr>
<tr class="separator:a4933845b75cf4f08fb66f55fdd94986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a6644dc9ce51ba96b0364f7f891dcad9a">kDeviceUseDynSharedMemory</a> = &quot;tir.device_use_dyn_shared_memory&quot;</td></tr>
<tr class="memdesc:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not use dynamic shared memory.  <a href="#a6644dc9ce51ba96b0364f7f891dcad9a">More...</a><br /></td></tr>
<tr class="separator:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac74386674da85bc4b4dd1ee28a97ff63">kNoAlias</a> = &quot;tir.noalias&quot;</td></tr>
<tr class="memdesc:ac74386674da85bc4b4dd1ee28a97ff63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to set noalias rule on the function arguments.  <a href="#ac74386674da85bc4b4dd1ee28a97ff63">More...</a><br /></td></tr>
<tr class="separator:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a489d0cebd2820025bc3d6c5a9011cdd4">kIsEntryFunc</a> = &quot;tir.is_entry_func&quot;</td></tr>
<tr class="memdesc:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the function as the entry function of the final generated runtime module.  <a href="#a489d0cebd2820025bc3d6c5a9011cdd4">More...</a><br /></td></tr>
<tr class="separator:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a35dd6e2a9044b583daf52b0217a73"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a68a35dd6e2a9044b583daf52b0217a73">kLinkedParams</a> = &quot;tir.linked_params&quot;</td></tr>
<tr class="memdesc:a68a35dd6e2a9044b583daf52b0217a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used in the module that should be linked by the codegen.  <a href="#a68a35dd6e2a9044b583daf52b0217a73">More...</a><br /></td></tr>
<tr class="separator:a68a35dd6e2a9044b583daf52b0217a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399eed804ecc482a607f0f65f07b78dd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a399eed804ecc482a607f0f65f07b78dd">thread_extent</a> = &quot;thread_extent&quot;</td></tr>
<tr class="memdesc:a399eed804ecc482a607f0f65f07b78dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching extent of thread, used by device API.  <a href="#a399eed804ecc482a607f0f65f07b78dd">More...</a><br /></td></tr>
<tr class="separator:a399eed804ecc482a607f0f65f07b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464533c1560ace5e0b5071ba6902482e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a464533c1560ace5e0b5071ba6902482e">virtual_thread</a> = &quot;virtual_thread&quot;</td></tr>
<tr class="memdesc:a464533c1560ace5e0b5071ba6902482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching of a virtual thread.  <a href="#a464533c1560ace5e0b5071ba6902482e">More...</a><br /></td></tr>
<tr class="separator:a464533c1560ace5e0b5071ba6902482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a341bfebe5448f290aa54b0f84cac"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac62a341bfebe5448f290aa54b0f84cac">coproc_scope</a> = &quot;coproc_scope&quot;</td></tr>
<tr class="memdesc:ac62a341bfebe5448f290aa54b0f84cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is processed by a co-proccesor.  <a href="#ac62a341bfebe5448f290aa54b0f84cac">More...</a><br /></td></tr>
<tr class="separator:ac62a341bfebe5448f290aa54b0f84cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d3379e8d6486e79853e254ea9a724e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae1d3379e8d6486e79853e254ea9a724e">coproc_uop_scope</a> = &quot;coproc_uop_scope&quot;</td></tr>
<tr class="memdesc:ae1d3379e8d6486e79853e254ea9a724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent.  <a href="#ae1d3379e8d6486e79853e254ea9a724e">More...</a><br /></td></tr>
<tr class="separator:ae1d3379e8d6486e79853e254ea9a724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14c2370f3a08792a6aaf70d7a3c773e4">volatile_scope</a> = &quot;volatile_scope&quot;</td></tr>
<tr class="memdesc:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as volatile access for certain handle.  <a href="#a14c2370f3a08792a6aaf70d7a3c773e4">More...</a><br /></td></tr>
<tr class="separator:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd38b620e1e9907216f3e583839dea3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4bd38b620e1e9907216f3e583839dea3">extern_scope</a> = &quot;extern_scope&quot;</td></tr>
<tr class="memdesc:a4bd38b620e1e9907216f3e583839dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program.  <a href="#a4bd38b620e1e9907216f3e583839dea3">More...</a><br /></td></tr>
<tr class="separator:a4bd38b620e1e9907216f3e583839dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a6b89838348f152d844cead81b5016"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a00a6b89838348f152d844cead81b5016">compute_scope</a> = &quot;compute_scope&quot;</td></tr>
<tr class="memdesc:a00a6b89838348f152d844cead81b5016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute.  <a href="#a00a6b89838348f152d844cead81b5016">More...</a><br /></td></tr>
<tr class="separator:a00a6b89838348f152d844cead81b5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d464f2065dc5f77408df7b94d4bb6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af27d464f2065dc5f77408df7b94d4bb6">storage_alignment</a> = &quot;storage_alignment&quot;</td></tr>
<tr class="memdesc:af27d464f2065dc5f77408df7b94d4bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage alignement requirement of buffers.  <a href="#af27d464f2065dc5f77408df7b94d4bb6">More...</a><br /></td></tr>
<tr class="separator:af27d464f2065dc5f77408df7b94d4bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70bbdafa7344811d336422bf95cdc5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acf70bbdafa7344811d336422bf95cdc5">realize_scope</a> = &quot;realize_scope&quot;</td></tr>
<tr class="memdesc:acf70bbdafa7344811d336422bf95cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of realization.  <a href="#acf70bbdafa7344811d336422bf95cdc5">More...</a><br /></td></tr>
<tr class="separator:acf70bbdafa7344811d336422bf95cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a61b1ef1047fb722a4e5ec2167c9963d7">device_id</a> = &quot;device_id&quot;</td></tr>
<tr class="memdesc:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation device for global malloc in host.  <a href="#a61b1ef1047fb722a4e5ec2167c9963d7">More...</a><br /></td></tr>
<tr class="separator:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e7cd47471a9089022214d63d24206"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7e4e7cd47471a9089022214d63d24206">device_type</a> = &quot;device_type&quot;</td></tr>
<tr class="memdesc:a7e4e7cd47471a9089022214d63d24206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type.  <a href="#a7e4e7cd47471a9089022214d63d24206">More...</a><br /></td></tr>
<tr class="separator:a7e4e7cd47471a9089022214d63d24206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9125ab905a93924ee79269aa808ed517"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9125ab905a93924ee79269aa808ed517">loop_scope</a> = &quot;loop_scope&quot;</td></tr>
<tr class="memdesc:a9125ab905a93924ee79269aa808ed517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of loop scope.  <a href="#a9125ab905a93924ee79269aa808ed517">More...</a><br /></td></tr>
<tr class="separator:a9125ab905a93924ee79269aa808ed517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a50fc9633b9cfbcefa2393dbb2ece1846">reduce_scope</a> = &quot;reduce_scope&quot;</td></tr>
<tr class="memdesc:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of reduce scope.  <a href="#a50fc9633b9cfbcefa2393dbb2ece1846">More...</a><br /></td></tr>
<tr class="separator:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af08d3d2b645a914f1a64d81e45f3b86a">pragma_scope_prefix</a> = &quot;pragma_&quot;</td></tr>
<tr class="memdesc:af08d3d2b645a914f1a64d81e45f3b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is guarded by the pragma extension.  <a href="#af08d3d2b645a914f1a64d81e45f3b86a">More...</a><br /></td></tr>
<tr class="separator:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a2823f2e8c3ae9eec6c8f797752d1f9b5">pragma_import_c</a> = &quot;pragma_import_c&quot;</td></tr>
<tr class="memdesc:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import C source or file into the final code gen module.  <a href="#a2823f2e8c3ae9eec6c8f797752d1f9b5">More...</a><br /></td></tr>
<tr class="separator:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ba402645b1def7c543af3c48be80d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af00ba402645b1def7c543af3c48be80d">pragma_import_llvm</a> = &quot;pragma_import_llvm&quot;</td></tr>
<tr class="memdesc:af00ba402645b1def7c543af3c48be80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import llvm source or file into the final code gen module.  <a href="#af00ba402645b1def7c543af3c48be80d">More...</a><br /></td></tr>
<tr class="separator:af00ba402645b1def7c543af3c48be80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96774004fd5b6411f6c37b8923b71834"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a96774004fd5b6411f6c37b8923b71834">pragma_tensor_core</a> = &quot;pragma_tensor_core&quot;</td></tr>
<tr class="memdesc:a96774004fd5b6411f6c37b8923b71834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to modify the AST to support Tensor Core.  <a href="#a96774004fd5b6411f6c37b8923b71834">More...</a><br /></td></tr>
<tr class="separator:a96774004fd5b6411f6c37b8923b71834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac95fbd1c09a60b10c7a5d07f6c4b68a6">prefetch_scope</a> = &quot;prefetch_scope&quot;</td></tr>
<tr class="memdesc:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope.  <a href="#ac95fbd1c09a60b10c7a5d07f6c4b68a6">More...</a><br /></td></tr>
<tr class="separator:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9231fc0afe37a8d46a90a1c5fdf522bb">double_buffer_scope</a> = &quot;double_buffer_scope&quot;</td></tr>
<tr class="memdesc:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks production of double buffer data.  <a href="#a9231fc0afe37a8d46a90a1c5fdf522bb">More...</a><br /></td></tr>
<tr class="separator:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84871a6d841168f8501f141676dfaeb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af84871a6d841168f8501f141676dfaeb">double_buffer_write</a> = &quot;double_buffer_write&quot;</td></tr>
<tr class="memdesc:af84871a6d841168f8501f141676dfaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks region used by double buffer write.  <a href="#af84871a6d841168f8501f141676dfaeb">More...</a><br /></td></tr>
<tr class="separator:af84871a6d841168f8501f141676dfaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a84f5d42e968fd8f4cdd7a4aac7ba2137">scan_update_scope</a> = &quot;scan_update_scope&quot;</td></tr>
<tr class="memdesc:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan update scope.  <a href="#a84f5d42e968fd8f4cdd7a4aac7ba2137">More...</a><br /></td></tr>
<tr class="separator:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e3a9ba11d436e02b55e420647b22b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af18e3a9ba11d436e02b55e420647b22b">scan_init_scope</a> = &quot;scan_init_scope&quot;</td></tr>
<tr class="memdesc:af18e3a9ba11d436e02b55e420647b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan init scope.  <a href="#af18e3a9ba11d436e02b55e420647b22b">More...</a><br /></td></tr>
<tr class="separator:af18e3a9ba11d436e02b55e420647b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0ff3c4642eebe20842b1c26e98288a5d">buffer_dim_align</a> = &quot;buffer_dim_align&quot;</td></tr>
<tr class="memdesc:a0ff3c4642eebe20842b1c26e98288a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset.  <a href="#a0ff3c4642eebe20842b1c26e98288a5d">More...</a><br /></td></tr>
<tr class="separator:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac76fd8d0227265617e2f2bb8402d1e19">buffer_bound</a> = &quot;buffer_bound&quot;</td></tr>
<tr class="memdesc:ac76fd8d0227265617e2f2bb8402d1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark stores/loads with theirs bounds.  <a href="#ac76fd8d0227265617e2f2bb8402d1e19">More...</a><br /></td></tr>
<tr class="separator:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497d7cff1d672920c2fbd4d92869e62"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0497d7cff1d672920c2fbd4d92869e62">buffer_bind_scope</a> = &quot;buffer_bind_scope&quot;</td></tr>
<tr class="memdesc:a0497d7cff1d672920c2fbd4d92869e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase.  <a href="#a0497d7cff1d672920c2fbd4d92869e62">More...</a><br /></td></tr>
<tr class="separator:a0497d7cff1d672920c2fbd4d92869e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad39d05bd13aeed7af51e9f8e323d263b">channel_read_scope</a> = &quot;channel_read_scope&quot;</td></tr>
<tr class="memdesc:ad39d05bd13aeed7af51e9f8e323d263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel read scope  <a href="#ad39d05bd13aeed7af51e9f8e323d263b">More...</a><br /></td></tr>
<tr class="separator:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14632ed9597f1c21a0dbd23949e5916e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14632ed9597f1c21a0dbd23949e5916e">channel_read_advance</a> = &quot;channel_read_advance&quot;</td></tr>
<tr class="memdesc:a14632ed9597f1c21a0dbd23949e5916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#a14632ed9597f1c21a0dbd23949e5916e">More...</a><br /></td></tr>
<tr class="separator:a14632ed9597f1c21a0dbd23949e5916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a52f378fc437bd4f7f6508c8e2e9b3e05">channel_write_scope</a> = &quot;channel_write_scope&quot;</td></tr>
<tr class="memdesc:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel write scope  <a href="#a52f378fc437bd4f7f6508c8e2e9b3e05">More...</a><br /></td></tr>
<tr class="separator:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad8886f0bca07d9fa56db9edea67b1a8d">channel_write_advance</a> = &quot;channel_write_advance&quot;</td></tr>
<tr class="memdesc:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#ad8886f0bca07d9fa56db9edea67b1a8d">More...</a><br /></td></tr>
<tr class="separator:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ecbf068afc115a2282e533c0fe518d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a19ecbf068afc115a2282e533c0fe518d">pipeline_stage_scope</a> = &quot;pipeline_stage_scope&quot;</td></tr>
<tr class="memdesc:a19ecbf068afc115a2282e533c0fe518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline stage scope, implies always execution  <a href="#a19ecbf068afc115a2282e533c0fe518d">More...</a><br /></td></tr>
<tr class="separator:a19ecbf068afc115a2282e533c0fe518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14d4d24b86179fd19938a02bc15512"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#aee14d4d24b86179fd19938a02bc15512">pipeline_exec_scope</a> = &quot;pipeline_exec_scope&quot;</td></tr>
<tr class="memdesc:aee14d4d24b86179fd19938a02bc15512"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline execution scope, implies the scope can be pipelined.  <a href="#aee14d4d24b86179fd19938a02bc15512">More...</a><br /></td></tr>
<tr class="separator:aee14d4d24b86179fd19938a02bc15512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db026f638ad3d951c302796ddcae24"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a36db026f638ad3d951c302796ddcae24">device_scope</a> = &quot;device_scope&quot;</td></tr>
<tr class="memdesc:a36db026f638ad3d951c302796ddcae24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that it is in the device scope.  <a href="#a36db026f638ad3d951c302796ddcae24">More...</a><br /></td></tr>
<tr class="separator:a36db026f638ad3d951c302796ddcae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d76d80fd7252d66991dc650693c0ef"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a93d76d80fd7252d66991dc650693c0ef">fragment_shape</a> = &quot;fragment_shape&quot;</td></tr>
<tr class="memdesc:a93d76d80fd7252d66991dc650693c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the shape of TensorCore fragment.  <a href="#a93d76d80fd7252d66991dc650693c0ef">More...</a><br /></td></tr>
<tr class="separator:a93d76d80fd7252d66991dc650693c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cc65f756817e691b49782ee103bd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9b33cc65f756817e691b49782ee103bd">fragment_layout</a> = &quot;fragment_layout&quot;</td></tr>
<tr class="memdesc:a9b33cc65f756817e691b49782ee103bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the layout of TensorCore fragment.  <a href="#a9b33cc65f756817e691b49782ee103bd">More...</a><br /></td></tr>
<tr class="separator:a9b33cc65f756817e691b49782ee103bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d026645d3f86d9cc2e693fa232fddec"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0d026645d3f86d9cc2e693fa232fddec">hand_threaded</a> = &quot;hand_threaded&quot;</td></tr>
<tr class="memdesc:a0d026645d3f86d9cc2e693fa232fddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the kernel is hand threaded and doesn't need syncs inserted.  <a href="#a0d026645d3f86d9cc2e693fa232fddec">More...</a><br /></td></tr>
<tr class="separator:a0d026645d3f86d9cc2e693fa232fddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66b2c968e985c3f4264979c18622e8"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a3c66b2c968e985c3f4264979c18622e8">script_parsing_detect_access</a> = &quot;tir.script_parsing_detect_access&quot;</td></tr>
<tr class="memdesc:a3c66b2c968e985c3f4264979c18622e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark whether the script-completer need to fill in missing access region during script parsing.  <a href="#a3c66b2c968e985c3f4264979c18622e8">More...</a><br /></td></tr>
<tr class="separator:a3c66b2c968e985c3f4264979c18622e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae6bb4bdf780d88ac330ad27c6c94e0f7">pragma_loop_partition_hint</a> = &quot;pragma_loop_partition_hint&quot;</td></tr>
<tr class="memdesc:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the loop should be partitioned.  <a href="#ae6bb4bdf780d88ac330ad27c6c94e0f7">More...</a><br /></td></tr>
<tr class="separator:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. </p>
<p>namespace of possible attribute sin AttrStmt.attr_key</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1attr.html" title="Generic attribute names that can be attached to any function. ">tvm::attr</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a385e883a7cecc309d063786e5fdf2c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385e883a7cecc309d063786e5fdf2c4b">&#9670;&nbsp;</a></span>IsPragmaKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::attr::IsPragmaKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if attr_key is a pragma key extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>The attr key to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a pragma key </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0497d7cff1d672920c2fbd4d92869e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497d7cff1d672920c2fbd4d92869e62">&#9670;&nbsp;</a></span>buffer_bind_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bind_scope = &quot;buffer_bind_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. </p>

</div>
</div>
<a id="ac76fd8d0227265617e2f2bb8402d1e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76fd8d0227265617e2f2bb8402d1e19">&#9670;&nbsp;</a></span>buffer_bound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bound = &quot;buffer_bound&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark stores/loads with theirs bounds. </p>

</div>
</div>
<a id="a0ff3c4642eebe20842b1c26e98288a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c4642eebe20842b1c26e98288a5d">&#9670;&nbsp;</a></span>buffer_dim_align</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_dim_align = &quot;buffer_dim_align&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset. </p>

</div>
</div>
<a id="a14632ed9597f1c21a0dbd23949e5916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14632ed9597f1c21a0dbd23949e5916e">&#9670;&nbsp;</a></span>channel_read_advance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_advance = &quot;channel_read_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a id="ad39d05bd13aeed7af51e9f8e323d263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d05bd13aeed7af51e9f8e323d263b">&#9670;&nbsp;</a></span>channel_read_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_scope = &quot;channel_read_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel read scope </p>

</div>
</div>
<a id="ad8886f0bca07d9fa56db9edea67b1a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8886f0bca07d9fa56db9edea67b1a8d">&#9670;&nbsp;</a></span>channel_write_advance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_advance = &quot;channel_write_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a id="a52f378fc437bd4f7f6508c8e2e9b3e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f378fc437bd4f7f6508c8e2e9b3e05">&#9670;&nbsp;</a></span>channel_write_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_scope = &quot;channel_write_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel write scope </p>

</div>
</div>
<a id="a00a6b89838348f152d844cead81b5016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a6b89838348f152d844cead81b5016">&#9670;&nbsp;</a></span>compute_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::compute_scope = &quot;compute_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. </p>

</div>
</div>
<a id="ac62a341bfebe5448f290aa54b0f84cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62a341bfebe5448f290aa54b0f84cac">&#9670;&nbsp;</a></span>coproc_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_scope = &quot;coproc_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is processed by a co-proccesor. </p>

</div>
</div>
<a id="ae1d3379e8d6486e79853e254ea9a724e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d3379e8d6486e79853e254ea9a724e">&#9670;&nbsp;</a></span>coproc_uop_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_uop_scope = &quot;coproc_uop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. </p>

</div>
</div>
<a id="a61b1ef1047fb722a4e5ec2167c9963d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b1ef1047fb722a4e5ec2167c9963d7">&#9670;&nbsp;</a></span>device_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_id = &quot;device_id&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The allocation device for global malloc in host. </p>

</div>
</div>
<a id="a36db026f638ad3d951c302796ddcae24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db026f638ad3d951c302796ddcae24">&#9670;&nbsp;</a></span>device_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_scope = &quot;device_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that it is in the device scope. </p>

</div>
</div>
<a id="a7e4e7cd47471a9089022214d63d24206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4e7cd47471a9089022214d63d24206">&#9670;&nbsp;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_type = &quot;device_type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type. </p>

</div>
</div>
<a id="a9231fc0afe37a8d46a90a1c5fdf522bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231fc0afe37a8d46a90a1c5fdf522bb">&#9670;&nbsp;</a></span>double_buffer_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_scope = &quot;double_buffer_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks production of double buffer data. </p>

</div>
</div>
<a id="af84871a6d841168f8501f141676dfaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84871a6d841168f8501f141676dfaeb">&#9670;&nbsp;</a></span>double_buffer_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_write = &quot;double_buffer_write&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks region used by double buffer write. </p>

</div>
</div>
<a id="a4bd38b620e1e9907216f3e583839dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd38b620e1e9907216f3e583839dea3">&#9670;&nbsp;</a></span>extern_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::extern_scope = &quot;extern_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. </p>

</div>
</div>
<a id="a9b33cc65f756817e691b49782ee103bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b33cc65f756817e691b49782ee103bd">&#9670;&nbsp;</a></span>fragment_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_layout = &quot;fragment_layout&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the layout of TensorCore fragment. </p>

</div>
</div>
<a id="a93d76d80fd7252d66991dc650693c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d76d80fd7252d66991dc650693c0ef">&#9670;&nbsp;</a></span>fragment_shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_shape = &quot;fragment_shape&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the shape of TensorCore fragment. </p>

</div>
</div>
<a id="a0d026645d3f86d9cc2e693fa232fddec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d026645d3f86d9cc2e693fa232fddec">&#9670;&nbsp;</a></span>hand_threaded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::hand_threaded = &quot;hand_threaded&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the kernel is hand threaded and doesn't need syncs inserted. </p>

</div>
</div>
<a id="a4933845b75cf4f08fb66f55fdd94986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4933845b75cf4f08fb66f55fdd94986f">&#9670;&nbsp;</a></span>kDeviceThreadAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kDeviceThreadAxis = &quot;tir.device_thread_axis&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: Array&lt;tir::IterVar&gt;</p>
<p>We call a device kernel launch function f using the following convention:</p>
<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a>(f, [arg1, arg2, ..., arg_n, work_size_1, work_size_2, ... work_size_m, dyn_shmem_size])</p>
<p>Here n = len(arg), m = len(work_size) = len(device_thread_axis).</p>
<p>When kDeviceUseDynSharedMemory is not set, dyn_shmem_size argument is omitted.</p>
<p>The list of device_thread_axis indicates how can be bind the work_size arguments to the corresponding threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm.html#a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc" title="Device kernel launch. ">tvm::CallingConv::kDeviceKernelLaunch</a> </dd></dl>

</div>
</div>
<a id="a6644dc9ce51ba96b0364f7f891dcad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6644dc9ce51ba96b0364f7f891dcad9a">&#9670;&nbsp;</a></span>kDeviceUseDynSharedMemory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kDeviceUseDynSharedMemory = &quot;tir.device_use_dyn_shared_memory&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not use dynamic shared memory. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="a489d0cebd2820025bc3d6c5a9011cdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489d0cebd2820025bc3d6c5a9011cdd4">&#9670;&nbsp;</a></span>kIsEntryFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kIsEntryFunc = &quot;tir.is_entry_func&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the function as the entry function of the final generated runtime module. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a></p>
<dl class="section note"><dt>Note</dt><dd>There can only be one entry function per module. </dd></dl>

</div>
</div>
<a id="a68a35dd6e2a9044b583daf52b0217a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a35dd6e2a9044b583daf52b0217a73">&#9670;&nbsp;</a></span>kLinkedParams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kLinkedParams = &quot;tir.linked_params&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters used in the module that should be linked by the codegen. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: Map&lt;String, LinkableParam&gt;</p>
<dl class="section note"><dt>Note</dt><dd>This should be present only on a function named tvm::target::packed_func::kLookupLinkedParam. </dd></dl>

</div>
</div>
<a id="ac74386674da85bc4b4dd1ee28a97ff63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74386674da85bc4b4dd1ee28a97ff63">&#9670;&nbsp;</a></span>kNoAlias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kNoAlias = &quot;tir.noalias&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to set noalias rule on the function arguments. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="a9125ab905a93924ee79269aa808ed517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9125ab905a93924ee79269aa808ed517">&#9670;&nbsp;</a></span>loop_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::loop_scope = &quot;loop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of loop scope. </p>

</div>
</div>
<a id="aee14d4d24b86179fd19938a02bc15512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14d4d24b86179fd19938a02bc15512">&#9670;&nbsp;</a></span>pipeline_exec_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_exec_scope = &quot;pipeline_exec_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline execution scope, implies the scope can be pipelined. </p>

</div>
</div>
<a id="a19ecbf068afc115a2282e533c0fe518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ecbf068afc115a2282e533c0fe518d">&#9670;&nbsp;</a></span>pipeline_stage_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_stage_scope = &quot;pipeline_stage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline stage scope, implies always execution </p>

</div>
</div>
<a id="a2823f2e8c3ae9eec6c8f797752d1f9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2823f2e8c3ae9eec6c8f797752d1f9b5">&#9670;&nbsp;</a></span>pragma_import_c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_c = &quot;pragma_import_c&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import C source or file into the final code gen module. </p>

</div>
</div>
<a id="af00ba402645b1def7c543af3c48be80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00ba402645b1def7c543af3c48be80d">&#9670;&nbsp;</a></span>pragma_import_llvm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_llvm = &quot;pragma_import_llvm&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import llvm source or file into the final code gen module. </p>

</div>
</div>
<a id="ae6bb4bdf780d88ac330ad27c6c94e0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bb4bdf780d88ac330ad27c6c94e0f7">&#9670;&nbsp;</a></span>pragma_loop_partition_hint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_loop_partition_hint = &quot;pragma_loop_partition_hint&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the loop should be partitioned. </p>

</div>
</div>
<a id="af08d3d2b645a914f1a64d81e45f3b86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08d3d2b645a914f1a64d81e45f3b86a">&#9670;&nbsp;</a></span>pragma_scope_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_scope_prefix = &quot;pragma_&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is guarded by the pragma extension. </p>

</div>
</div>
<a id="a96774004fd5b6411f6c37b8923b71834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96774004fd5b6411f6c37b8923b71834">&#9670;&nbsp;</a></span>pragma_tensor_core</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_tensor_core = &quot;pragma_tensor_core&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to modify the AST to support Tensor Core. </p>

</div>
</div>
<a id="ac95fbd1c09a60b10c7a5d07f6c4b68a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95fbd1c09a60b10c7a5d07f6c4b68a6">&#9670;&nbsp;</a></span>prefetch_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::prefetch_scope = &quot;prefetch_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope. </p>

</div>
</div>
<a id="acf70bbdafa7344811d336422bf95cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf70bbdafa7344811d336422bf95cdc5">&#9670;&nbsp;</a></span>realize_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::realize_scope = &quot;realize_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of realization. </p>

</div>
</div>
<a id="a50fc9633b9cfbcefa2393dbb2ece1846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fc9633b9cfbcefa2393dbb2ece1846">&#9670;&nbsp;</a></span>reduce_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::reduce_scope = &quot;reduce_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of reduce scope. </p>

</div>
</div>
<a id="af18e3a9ba11d436e02b55e420647b22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18e3a9ba11d436e02b55e420647b22b">&#9670;&nbsp;</a></span>scan_init_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_init_scope = &quot;scan_init_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan init scope. </p>

</div>
</div>
<a id="a84f5d42e968fd8f4cdd7a4aac7ba2137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f5d42e968fd8f4cdd7a4aac7ba2137">&#9670;&nbsp;</a></span>scan_update_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_update_scope = &quot;scan_update_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan update scope. </p>

</div>
</div>
<a id="a3c66b2c968e985c3f4264979c18622e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c66b2c968e985c3f4264979c18622e8">&#9670;&nbsp;</a></span>script_parsing_detect_access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::script_parsing_detect_access = &quot;tir.script_parsing_detect_access&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark whether the script-completer need to fill in missing access region during script parsing. </p>
<dl class="section note"><dt>Note</dt><dd>The result should be a integer mask with range [0, 4). if (mask &amp; 1) the read region should be detected, if (mask &amp; 2) the write region should be detected. </dd></dl>

</div>
</div>
<a id="af27d464f2065dc5f77408df7b94d4bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27d464f2065dc5f77408df7b94d4bb6">&#9670;&nbsp;</a></span>storage_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::storage_alignment = &quot;storage_alignment&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage alignement requirement of buffers. </p>

</div>
</div>
<a id="a399eed804ecc482a607f0f65f07b78dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399eed804ecc482a607f0f65f07b78dd">&#9670;&nbsp;</a></span>thread_extent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::thread_extent = &quot;thread_extent&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching extent of thread, used by device API. </p>

</div>
</div>
<a id="a464533c1560ace5e0b5071ba6902482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464533c1560ace5e0b5071ba6902482e">&#9670;&nbsp;</a></span>virtual_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::virtual_thread = &quot;virtual_thread&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching of a virtual thread. </p>

</div>
</div>
<a id="a14c2370f3a08792a6aaf70d7a3c773e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2370f3a08792a6aaf70d7a3c773e4">&#9670;&nbsp;</a></span>volatile_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::volatile_scope = &quot;volatile_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as volatile access for certain handle. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
