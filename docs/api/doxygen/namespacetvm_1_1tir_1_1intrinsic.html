<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::tir::intrinsic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html">intrinsic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::intrinsic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace of TVM Intrinsic functions  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7aee573af86b33b88d123fc26a40cdd9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9">TVMStructFieldKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a4db7d8a5cd05d94fe63484b1a6a5f41e">kArrAddr</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9ac4fd2e6f182e390a5f12bc0b86a7bdde">kArrData</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9abd1c578a1b9382f7641e57d47cc0fef5">kArrShape</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a316dc2fac47b891f4a7cd4f6f1e2ea9c">kArrStrides</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a6848c5265a37e6d8ff900962cffd24f9">kArrNDim</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a754ca8d37cdfbcbc5969782b86ca9e62">kArrTypeCode</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a794b84c54e74f7eb76c55c8b757cb07a">kArrTypeBits</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a5d44e05899072b51faf77feef33a17e4">kArrTypeLanes</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9aace077df8be29cbf09dffeccb9c87361">kArrByteOffset</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a7010568a29d2c4672120433c51af8867">kArrDeviceId</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9a34a8c297dd601e3a693d8b4ad1268a12">kArrDeviceType</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9ad68bd1fb79d2f15de845fa682fea01c0">kArrKindBound_</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9ac6ce092b04c704569325ff038a18eaf7">kTVMValueContent</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9ac87458c0fb42f635a949331c07da6b58">kTVMValueKindBound_</a>
<br />
 }<tr class="memdesc:a7aee573af86b33b88d123fc26a40cdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of structure field info used in intrinsic.  <a href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7aee573af86b33b88d123fc26a40cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abdf19f5eab40c9dbc4952e76a29bd49c"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#abdf19f5eab40c9dbc4952e76a29bd49c">tvm_large_uint_imm</a> = &quot;tvm_large_uint_imm&quot;</td></tr>
<tr class="memdesc:abdf19f5eab40c9dbc4952e76a29bd49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#abdf19f5eab40c9dbc4952e76a29bd49c">More...</a><br /></td></tr>
<tr class="separator:abdf19f5eab40c9dbc4952e76a29bd49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cdd60cdf71a2b97109804ae5c9c78a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a58cdd60cdf71a2b97109804ae5c9c78a">tvm_address_of</a> = &quot;tvm_address_of&quot;</td></tr>
<tr class="memdesc:a58cdd60cdf71a2b97109804ae5c9c78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a58cdd60cdf71a2b97109804ae5c9c78a">More...</a><br /></td></tr>
<tr class="separator:a58cdd60cdf71a2b97109804ae5c9c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd194e010059c3229f6db9809e77e5a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#acbd194e010059c3229f6db9809e77e5a">tvm_if_then_else</a> = &quot;tvm_if_then_else&quot;</td></tr>
<tr class="memdesc:acbd194e010059c3229f6db9809e77e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as select, used for unsafe memory access.  <a href="#acbd194e010059c3229f6db9809e77e5a">More...</a><br /></td></tr>
<tr class="separator:acbd194e010059c3229f6db9809e77e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9606b4e3a5d65a1ef787969074340be1"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a9606b4e3a5d65a1ef787969074340be1">tvm_access_ptr</a> = &quot;tvm_access_ptr&quot;</td></tr>
<tr class="memdesc:a9606b4e3a5d65a1ef787969074340be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get head access address with memory access pattern info.  <a href="#a9606b4e3a5d65a1ef787969074340be1">More...</a><br /></td></tr>
<tr class="separator:a9606b4e3a5d65a1ef787969074340be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075f340d77d7e0b8b60616fe5e64d2cc"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a075f340d77d7e0b8b60616fe5e64d2cc">tvm_static_handle</a> = &quot;tvm_static_handle&quot;</td></tr>
<tr class="memdesc:a075f340d77d7e0b8b60616fe5e64d2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function local static handle that iniitalizes to nullptr. can be used to cache function local static resources.  <a href="#a075f340d77d7e0b8b60616fe5e64d2cc">More...</a><br /></td></tr>
<tr class="separator:a075f340d77d7e0b8b60616fe5e64d2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a86e8446b1f2b078597cb7cdadfbff"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#af3a86e8446b1f2b078597cb7cdadfbff">tvm_context_id</a> = &quot;tvm_context_id&quot;</td></tr>
<tr class="memdesc:af3a86e8446b1f2b078597cb7cdadfbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique context id, used for hint of workspace separation. Different context id ganrantees not having overlapping workspace.  <a href="#af3a86e8446b1f2b078597cb7cdadfbff">More...</a><br /></td></tr>
<tr class="separator:af3a86e8446b1f2b078597cb7cdadfbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fa5d609f7ae416ede0eb14f1b4b165"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a19fa5d609f7ae416ede0eb14f1b4b165">tvm_tuple</a> = &quot;tvm_tuple&quot;</td></tr>
<tr class="memdesc:a19fa5d609f7ae416ede0eb14f1b4b165"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm_tuple is not an actual function and cannot codegen. It is used to represent tuple structure in value field of <a class="el" href="classtvm_1_1tir_1_1AttrStmt.html" title="Managed reference to AttrStmtNode. ">AttrStmt</a>, for the sake of giving hint to optimization.  <a href="#a19fa5d609f7ae416ede0eb14f1b4b165">More...</a><br /></td></tr>
<tr class="separator:a19fa5d609f7ae416ede0eb14f1b4b165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1b46cdb01d149f49d6676b889142b5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#aba1b46cdb01d149f49d6676b889142b5">tvm_struct_get</a> = &quot;tvm_struct_get&quot;</td></tr>
<tr class="memdesc:aba1b46cdb01d149f49d6676b889142b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#aba1b46cdb01d149f49d6676b889142b5">More...</a><br /></td></tr>
<tr class="separator:aba1b46cdb01d149f49d6676b889142b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2857ab6a0557554feee6e21dbd37eab9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a2857ab6a0557554feee6e21dbd37eab9">tvm_struct_set</a> = &quot;tvm_struct_set&quot;</td></tr>
<tr class="memdesc:a2857ab6a0557554feee6e21dbd37eab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a2857ab6a0557554feee6e21dbd37eab9">More...</a><br /></td></tr>
<tr class="separator:a2857ab6a0557554feee6e21dbd37eab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5761917c5bd5b727203ddbc84763423"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ab5761917c5bd5b727203ddbc84763423">tvm_handle_is_null</a> = &quot;tvm_handle_is_null&quot;</td></tr>
<tr class="memdesc:ab5761917c5bd5b727203ddbc84763423"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#ab5761917c5bd5b727203ddbc84763423">More...</a><br /></td></tr>
<tr class="separator:ab5761917c5bd5b727203ddbc84763423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86e388d33768f6641d60a2e1d142cbb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad86e388d33768f6641d60a2e1d142cbb">tvm_throw_last_error</a> = &quot;tvm_throw_last_error&quot;</td></tr>
<tr class="memdesc:ad86e388d33768f6641d60a2e1d142cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#ad86e388d33768f6641d60a2e1d142cbb">More...</a><br /></td></tr>
<tr class="separator:ad86e388d33768f6641d60a2e1d142cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204b4be973bdf3e0c82f56a1273752bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a204b4be973bdf3e0c82f56a1273752bb">tvm_stack_alloca</a> = &quot;tvm_stack_alloca&quot;</td></tr>
<tr class="memdesc:a204b4be973bdf3e0c82f56a1273752bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a204b4be973bdf3e0c82f56a1273752bb">More...</a><br /></td></tr>
<tr class="separator:a204b4be973bdf3e0c82f56a1273752bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d9941d781b4b5bb399cffb9488fd6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#aab2d9941d781b4b5bb399cffb9488fd6">tvm_stack_make_shape</a> = &quot;tvm_stack_make_shape&quot;</td></tr>
<tr class="memdesc:aab2d9941d781b4b5bb399cffb9488fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a shape tuple on stack, return the handle.  <a href="#aab2d9941d781b4b5bb399cffb9488fd6">More...</a><br /></td></tr>
<tr class="separator:aab2d9941d781b4b5bb399cffb9488fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab210d3708ad9206af139d76f29727ab4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ab210d3708ad9206af139d76f29727ab4">tvm_stack_make_array</a> = &quot;tvm_stack_make_array&quot;</td></tr>
<tr class="memdesc:ab210d3708ad9206af139d76f29727ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a NDArray(DLTensor) on stack, return the handle.  <a href="#ab210d3708ad9206af139d76f29727ab4">More...</a><br /></td></tr>
<tr class="separator:ab210d3708ad9206af139d76f29727ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49ed1daf574a2544c8d3cbe3110d6c9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ac49ed1daf574a2544c8d3cbe3110d6c9">tvm_call_packed</a> = &quot;tvm_call_packed&quot;</td></tr>
<tr class="memdesc:ac49ed1daf574a2544c8d3cbe3110d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#ac49ed1daf574a2544c8d3cbe3110d6c9">More...</a><br /></td></tr>
<tr class="separator:ac49ed1daf574a2544c8d3cbe3110d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7127f9ff70e7e124403e6a22de1a82f3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7127f9ff70e7e124403e6a22de1a82f3">tvm_call_trace_packed</a> = &quot;tvm_call_trace_packed&quot;</td></tr>
<tr class="memdesc:a7127f9ff70e7e124403e6a22de1a82f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a7127f9ff70e7e124403e6a22de1a82f3">More...</a><br /></td></tr>
<tr class="separator:a7127f9ff70e7e124403e6a22de1a82f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3480cec5a6cf03c2cc894d6f889d1f39"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a3480cec5a6cf03c2cc894d6f889d1f39">tvm_thread_context</a> = &quot;tvm_thread_context&quot;</td></tr>
<tr class="memdesc:a3480cec5a6cf03c2cc894d6f889d1f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code Mark the content as thread local context, can get optimized by only call the call once at thread start.  <a href="#a3480cec5a6cf03c2cc894d6f889d1f39">More...</a><br /></td></tr>
<tr class="separator:a3480cec5a6cf03c2cc894d6f889d1f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1044b04b108f8d72d8468c7df8a426f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad1044b04b108f8d72d8468c7df8a426f">tvm_call_packed_lowered</a> = &quot;tvm_call_packed_lowered&quot;</td></tr>
<tr class="memdesc:ad1044b04b108f8d72d8468c7df8a426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowered version of call packed, the space of value and type codes are explicitly allocated.  <a href="#ad1044b04b108f8d72d8468c7df8a426f">More...</a><br /></td></tr>
<tr class="separator:ad1044b04b108f8d72d8468c7df8a426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad906c61d3e4610e103d5fee028e6147f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad906c61d3e4610e103d5fee028e6147f">tvm_call_trace_packed_lowered</a> = &quot;tvm_call_trace_packed_lowered&quot;</td></tr>
<tr class="memdesc:ad906c61d3e4610e103d5fee028e6147f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowered version of trace intrinsic, the space of value and type codes are explicitly allocated. The return value is the (end - 1) value on the stack.  <a href="#ad906c61d3e4610e103d5fee028e6147f">More...</a><br /></td></tr>
<tr class="separator:ad906c61d3e4610e103d5fee028e6147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327df78182d6687b72a93c468a3cd962"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a327df78182d6687b72a93c468a3cd962">tvm_storage_sync</a> = &quot;tvm_storage_sync&quot;</td></tr>
<tr class="memdesc:a327df78182d6687b72a93c468a3cd962"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pseudo code.  <a href="#a327df78182d6687b72a93c468a3cd962">More...</a><br /></td></tr>
<tr class="separator:a327df78182d6687b72a93c468a3cd962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5047acaa6e7e500840f9a1984f4e58"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a1c5047acaa6e7e500840f9a1984f4e58">tvm_warp_shuffle</a> = &quot;tvm_warp_shuffle&quot;</td></tr>
<tr class="memdesc:a1c5047acaa6e7e500840f9a1984f4e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pseudo code.  <a href="#a1c5047acaa6e7e500840f9a1984f4e58">More...</a><br /></td></tr>
<tr class="separator:a1c5047acaa6e7e500840f9a1984f4e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023119dd8af79c90ead8ea8408dfd47d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a023119dd8af79c90ead8ea8408dfd47d">tvm_warp_shuffle_up</a> = &quot;tvm_warp_shuffle_up&quot;</td></tr>
<tr class="separator:a023119dd8af79c90ead8ea8408dfd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35a64811e9e5ae75563c8e2d471a13"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a5d35a64811e9e5ae75563c8e2d471a13">tvm_warp_shuffle_down</a> = &quot;tvm_warp_shuffle_down&quot;</td></tr>
<tr class="separator:a5d35a64811e9e5ae75563c8e2d471a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64289d5d4dbd2120a8a9c5751d94087"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad64289d5d4dbd2120a8a9c5751d94087">tvm_warp_activemask</a> = &quot;tvm_warp_activemask&quot;</td></tr>
<tr class="separator:ad64289d5d4dbd2120a8a9c5751d94087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccada41188e0161827169ce24a6db16"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7ccada41188e0161827169ce24a6db16">tvm_global_barrier_kinit</a> = &quot;tvm_global_barrier_kinit&quot;</td></tr>
<tr class="memdesc:a7ccada41188e0161827169ce24a6db16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global barrier. <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> this at beginning of kernel that need global barrier.  <a href="#a7ccada41188e0161827169ce24a6db16">More...</a><br /></td></tr>
<tr class="separator:a7ccada41188e0161827169ce24a6db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a98c3ef9da28a660825a0457ae997"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a374a98c3ef9da28a660825a0457ae997">tvm_thread_allreduce</a> = &quot;tvm_thread_allreduce&quot;</td></tr>
<tr class="memdesc:a374a98c3ef9da28a660825a0457ae997"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a374a98c3ef9da28a660825a0457ae997">More...</a><br /></td></tr>
<tr class="separator:a374a98c3ef9da28a660825a0457ae997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec923ea4f1dad1fbbd4962684bd9b51"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a8ec923ea4f1dad1fbbd4962684bd9b51">tvm_load_matrix_sync</a> = &quot;tvm_load_matrix_sync&quot;</td></tr>
<tr class="memdesc:a8ec923ea4f1dad1fbbd4962684bd9b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core load operators.  <a href="#a8ec923ea4f1dad1fbbd4962684bd9b51">More...</a><br /></td></tr>
<tr class="separator:a8ec923ea4f1dad1fbbd4962684bd9b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78302097030bd1c144b826db84defdc"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#aa78302097030bd1c144b826db84defdc">tvm_mma_sync</a> = &quot;tvm_mma_sync&quot;</td></tr>
<tr class="memdesc:aa78302097030bd1c144b826db84defdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core mma_sync operators.  <a href="#aa78302097030bd1c144b826db84defdc">More...</a><br /></td></tr>
<tr class="separator:aa78302097030bd1c144b826db84defdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1287729e05d683af059be0faaf9014"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a4d1287729e05d683af059be0faaf9014">tvm_bmma_sync</a> = &quot;tvm_bmma_sync&quot;</td></tr>
<tr class="memdesc:a4d1287729e05d683af059be0faaf9014"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core bmma_sync operators.  <a href="#a4d1287729e05d683af059be0faaf9014">More...</a><br /></td></tr>
<tr class="separator:a4d1287729e05d683af059be0faaf9014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0862848e3eb5b6972c76f0b27585f9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a6c0862848e3eb5b6972c76f0b27585f9">tvm_fill_fragment</a> = &quot;tvm_fill_fragment&quot;</td></tr>
<tr class="memdesc:a6c0862848e3eb5b6972c76f0b27585f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core fill_fragment operators.  <a href="#a6c0862848e3eb5b6972c76f0b27585f9">More...</a><br /></td></tr>
<tr class="separator:a6c0862848e3eb5b6972c76f0b27585f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127cfee7b97ef7182019e69b7a3eb78"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a3127cfee7b97ef7182019e69b7a3eb78">tvm_store_matrix_sync</a> = &quot;tvm_store_matrix_sync&quot;</td></tr>
<tr class="memdesc:a3127cfee7b97ef7182019e69b7a3eb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core store operators.  <a href="#a3127cfee7b97ef7182019e69b7a3eb78">More...</a><br /></td></tr>
<tr class="separator:a3127cfee7b97ef7182019e69b7a3eb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of TVM Intrinsic functions </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9">tvm::tir::intrinsic::TVMStructFieldKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of structure field info used in intrinsic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a4db7d8a5cd05d94fe63484b1a6a5f41e"></a>kArrAddr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9ac4fd2e6f182e390a5f12bc0b86a7bdde"></a>kArrData&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9abd1c578a1b9382f7641e57d47cc0fef5"></a>kArrShape&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a316dc2fac47b891f4a7cd4f6f1e2ea9c"></a>kArrStrides&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a6848c5265a37e6d8ff900962cffd24f9"></a>kArrNDim&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a754ca8d37cdfbcbc5969782b86ca9e62"></a>kArrTypeCode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a794b84c54e74f7eb76c55c8b757cb07a"></a>kArrTypeBits&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a5d44e05899072b51faf77feef33a17e4"></a>kArrTypeLanes&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9aace077df8be29cbf09dffeccb9c87361"></a>kArrByteOffset&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a7010568a29d2c4672120433c51af8867"></a>kArrDeviceId&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9a34a8c297dd601e3a693d8b4ad1268a12"></a>kArrDeviceType&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9ad68bd1fb79d2f15de845fa682fea01c0"></a>kArrKindBound_&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9ac6ce092b04c704569325ff038a18eaf7"></a>kTVMValueContent&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7aee573af86b33b88d123fc26a40cdd9ac87458c0fb42f635a949331c07da6b58"></a>kTVMValueKindBound_&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9606b4e3a5d65a1ef787969074340be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_access_ptr = &quot;tvm_access_ptr&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get head access address with memory access pattern info. </p>
<p>This operator also marks range of the memory access The offset and extent are in unit of the DType(including vectorization factor). rw_mask is a bit_mask setting whether the access is a read(1) or write(2). The access is assume to happen in the current expression.</p>
<p>PtrType tvm_access_ptr(Expr dtype, DType* data, int offset, int extent, int rw_mask) { // DType == dtype.type(); return &amp;data[offset]; } </p>

</div>
</div>
<a class="anchor" id="a58cdd60cdf71a2b97109804ae5c9c78a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_address_of = &quot;tvm_address_of&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>Handle tvm_address_of(Load *op) { return &amp;op-&gt;buffer_var[index]; } </p>

</div>
</div>
<a class="anchor" id="a4d1287729e05d683af059be0faaf9014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_bmma_sync = &quot;tvm_bmma_sync&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core bmma_sync operators. </p>
<p>void tvm_bmma_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_d, Expr index_d, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_a, Expr index_a, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_b, Expr index_b, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_c, Expr index_c) { nvcuda::wmma::bmma_sync(fragment_d[index_d], fragment_a[index_a], fragment_b[index_b], fragment_c[index_c]); } </p>

</div>
</div>
<a class="anchor" id="ac49ed1daf574a2544c8d3cbe3110d6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_call_packed = &quot;tvm_call_packed&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>int tvm_call_packed(name, TVMValue* args) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); (*f)(args, type_code_of(args), len(args)); return 0; } </p>

</div>
</div>
<a class="anchor" id="ad1044b04b108f8d72d8468c7df8a426f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_call_packed_lowered = &quot;tvm_call_packed_lowered&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowered version of call packed, the space of value and type codes are explicitly allocated. </p>
<p>int tvm_call_packed_lowered(name, TVMValue* value_stack, int* tcode_stack, int begin, int end) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); f-&gt;CallPacked(TVMArgs(value_stack[begin:end], tcode_stack[begin:end]), TVMRetValue(value_stack + end, tcode_stack + end)); } </p>

</div>
</div>
<a class="anchor" id="a7127f9ff70e7e124403e6a22de1a82f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_call_trace_packed = &quot;tvm_call_trace_packed&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>int tvm_call_trace_packed(name, TVMValue* args) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); (*f)(args, type_code_of(args), len(args)); return 0; } </p>

</div>
</div>
<a class="anchor" id="ad906c61d3e4610e103d5fee028e6147f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_call_trace_packed_lowered = &quot;tvm_call_trace_packed_lowered&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowered version of trace intrinsic, the space of value and type codes are explicitly allocated. The return value is the (end - 1) value on the stack. </p>
<p>int tvm_call_trace_packed_lowered(name, TVMValue* value_stack, int* tcode_stack, int begin, int end) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); f-&gt;CallPacked(TVMArgs(value_stack[begin:end], tcode_stack[begin:end]), TVMRetValue(value_stack + end, tcode_stack + end)); } </p>

</div>
</div>
<a class="anchor" id="af3a86e8446b1f2b078597cb7cdadfbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_context_id = &quot;tvm_context_id&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a unique context id, used for hint of workspace separation. Different context id ganrantees not having overlapping workspace. </p>

</div>
</div>
<a class="anchor" id="a6c0862848e3eb5b6972c76f0b27585f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_fill_fragment = &quot;tvm_fill_fragment&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core fill_fragment operators. </p>
<p>void tvm_fill_fragment(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr value) { // m, n, k are the shape of wmma fragment // fragments must be in 'wmma.accumulator' scope. nvcuda::wmma::fill_fragment(fragment[index], value); } </p>

</div>
</div>
<a class="anchor" id="a7ccada41188e0161827169ce24a6db16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_global_barrier_kinit = &quot;tvm_global_barrier_kinit&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global barrier. <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> this at beginning of kernel that need global barrier. </p>

</div>
</div>
<a class="anchor" id="ab5761917c5bd5b727203ddbc84763423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_handle_is_null = &quot;tvm_handle_is_null&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>bool tvm_handle_is_null(void* handle) { return handle == nullptr } </p>

</div>
</div>
<a class="anchor" id="acbd194e010059c3229f6db9809e77e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_if_then_else = &quot;tvm_if_then_else&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as select, used for unsafe memory access. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_if_then_else(cond, a, b) { return cond ? a : b; } </p>

</div>
</div>
<a class="anchor" id="abdf19f5eab40c9dbc4952e76a29bd49c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_large_uint_imm = &quot;tvm_large_uint_imm&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>Construct a big uint that may not be representable by int64</p>
<p>Expr tvm_large_uint_imm(uint32_t v0, uin32_t v1) { return (v1 &lt;&lt; 32) | v0; } </p>

</div>
</div>
<a class="anchor" id="a8ec923ea4f1dad1fbbd4962684bd9b51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_load_matrix_sync = &quot;tvm_load_matrix_sync&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core load operators. </p>
<p>void tvm_load_matrix_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr buffer_ptr, Expr stride, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> layout) { // m, n, k are the shape of wmma fragment. // Determine fragment layout(column-major or row major) by layout. // fragments must be in 'wmma.matrix_a' or 'wmma.matrix_b' scope. nvcuda::wmma::load_matrix_sync(fragment[index], buffer_ptr, stride); } </p>

</div>
</div>
<a class="anchor" id="aa78302097030bd1c144b826db84defdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_mma_sync = &quot;tvm_mma_sync&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core mma_sync operators. </p>
<p>void tvm_mma_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_d, Expr index_d, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_a, Expr index_a, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_b, Expr index_b, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_c, Expr index_c) { nvcuda::wmma::mma_sync(fragment_d[index_d], fragment_a[index_a], fragment_b[index_b], fragment_c[index_c]); } </p>

</div>
</div>
<a class="anchor" id="a204b4be973bdf3e0c82f56a1273752bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_stack_alloca = &quot;tvm_stack_alloca&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>dtype in {shape, array, arg_value, arg_tcode}</p>
<p>Handle tvm_stack_alloca(string dtype, int num) { return new on stack dtype[num]; } </p>

</div>
</div>
<a class="anchor" id="ab210d3708ad9206af139d76f29727ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_stack_make_array = &quot;tvm_stack_make_array&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a NDArray(DLTensor) on stack, return the handle. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_stack_make_array(Expr data, Expr shape, Expr strides, Expr ndim, Expr dtype, Expr elem_offset) { ret = alloca stack DLTensor(); ret-&gt;data = data; ret-&gt;shape = shape; ret-&gt;strides = strides != 0 ? strides : nullptr; ret-&gt;ndim = ndim; ret-&gt;dtype = dtype.type(); ret-&gt;byte_offset = elem_offset * sizeof(dtype); return ret; } </p>

</div>
</div>
<a class="anchor" id="aab2d9941d781b4b5bb399cffb9488fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_stack_make_shape = &quot;tvm_stack_make_shape&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a shape tuple on stack, return the handle. </p>
<p>Handle tvm_stack_make_shape(list args) { ret = alloca stack int64_t[len(args)]; for i in range(len(args)): ret[i] = args[i] return &amp;ret[0]; } </p>

</div>
</div>
<a class="anchor" id="a075f340d77d7e0b8b60616fe5e64d2cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_static_handle = &quot;tvm_static_handle&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function local static handle that iniitalizes to nullptr. can be used to cache function local static resources. </p>

</div>
</div>
<a class="anchor" id="a327df78182d6687b72a93c468a3cd962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_storage_sync = &quot;tvm_storage_sync&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pseudo code. </p>
<p>int tvm_storage_sync(std::string storage_scope) { __sync(storage_scope); return 0; } </p>

</div>
</div>
<a class="anchor" id="a3127cfee7b97ef7182019e69b7a3eb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_store_matrix_sync = &quot;tvm_store_matrix_sync&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core store operators. </p>
<p>void tvm_store_matrix_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr buffer_ptr, Expr stride, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> layout) { // m, n, k are the shape of wmma fragment // fragments must be in 'wmma.accumulator' scope. nvcuda::wmma::store_matrix_sync(fragment[index], buffer_ptr, stride, layout); } </p>

</div>
</div>
<a class="anchor" id="aba1b46cdb01d149f49d6676b889142b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_struct_get = &quot;tvm_struct_get&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_struct_get(StructType* arr, int index, int field_id) { return arr[index]-&gt;field; } </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9" title="The kind of structure field info used in intrinsic. ">TVMStructFieldKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2857ab6a0557554feee6e21dbd37eab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_struct_set = &quot;tvm_struct_set&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>Handle tvm_struct_set(StructType* arr, int index, int field_id, value) { arr[index]-&gt;field = value; } </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#a7aee573af86b33b88d123fc26a40cdd9" title="The kind of structure field info used in intrinsic. ">TVMStructFieldKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a374a98c3ef9da28a660825a0457ae997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_thread_allreduce = &quot;tvm_thread_allreduce&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>void tvm_thread_allreduce(UIntImm size, Expr source0, ..., Expr cond, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> reduce_temp0, .., <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> thread_idx1, ...) { // constraint by the other thread_idx remain the same. // reduce_temp is used to save intermediate result. reduce_temp0, ... = reduce(combiner, source0, ..., cond over [thread_idx1, thread_idx2] passed by any caller) } </p>

</div>
</div>
<a class="anchor" id="a3480cec5a6cf03c2cc894d6f889d1f39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_thread_context = &quot;tvm_thread_context&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code Mark the content as thread local context, can get optimized by only call the call once at thread start. </p>
<p>Do not allow nesting(getting a thread context from another).</p>
<p>Handle tvm_thread_context(Expr call) { return call; } </p>

</div>
</div>
<a class="anchor" id="ad86e388d33768f6641d60a2e1d142cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_throw_last_error = &quot;tvm_throw_last_error&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>void <a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad86e388d33768f6641d60a2e1d142cbb" title="See pesudo code. ">tvm_throw_last_error()</a> { throw <a class="el" href="c__runtime__api_8h.html#a775383bcd8c0237e36bdf0c9654d62c3" title="return str message of the last error all function in this file will return 0 when success and -1 when...">TVMGetLastError()</a>; } </p>

</div>
</div>
<a class="anchor" id="a19fa5d609f7ae416ede0eb14f1b4b165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_tuple = &quot;tvm_tuple&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm_tuple is not an actual function and cannot codegen. It is used to represent tuple structure in value field of <a class="el" href="classtvm_1_1tir_1_1AttrStmt.html" title="Managed reference to AttrStmtNode. ">AttrStmt</a>, for the sake of giving hint to optimization. </p>
<p>Handle tvm_tuple(value0, value1, ..., value_n); </p>

</div>
</div>
<a class="anchor" id="ad64289d5d4dbd2120a8a9c5751d94087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_warp_activemask = &quot;tvm_warp_activemask&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c5047acaa6e7e500840f9a1984f4e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_warp_shuffle = &quot;tvm_warp_shuffle&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pseudo code. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle(mask, Type value, warp_id, width, warp_size) { return (value passed in by warp indicated by this_warp_id); }</p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle_up(mask, Type value, offset, width, warp_size) { return (value passed in by warp indicated by this_warp_id - offset); }</p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle_down(mask, Type value, offset, width, warp_size) { return (value passed in by warp indicated by this_warp_id + offset); }</p>
<p>unsigned <a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html#ad64289d5d4dbd2120a8a9c5751d94087">tvm_warp_activemask()</a> { return (32-bit mask of currently active threads in the calling warp); }</p>
<p>Parameter warp_id indicates the source thread ID in a warp.</p>
<p>Parameter offset indicates the relative distance to this_warp_id.</p>
<p>Parameter width indicates the number of threads involved in one shuffle. See CUDA document for __shfl_sync, __shfl_up_sync, __shfl_down_sync and __activemask.</p>
<p>Parameter warp_size is the size of a warp, which helps a backend to determine wheter the width paramter is legal. </p>

</div>
</div>
<a class="anchor" id="a5d35a64811e9e5ae75563c8e2d471a13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_warp_shuffle_down = &quot;tvm_warp_shuffle_down&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a023119dd8af79c90ead8ea8408dfd47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::intrinsic::tvm_warp_shuffle_up = &quot;tvm_warp_shuffle_up&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
