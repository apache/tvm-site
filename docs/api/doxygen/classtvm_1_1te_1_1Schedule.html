<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::te::Schedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1te.html">te</a></li><li class="navelem"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1te_1_1Schedule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::te::Schedule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global schedule container For operations and all the operations they depend on. The schedule per <a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">Operation</a> is named as stage.  
 <a href="classtvm_1_1te_1_1Schedule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::te::Schedule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1te_1_1Schedule__inherit__graph.svg" width="146" height="390"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::te::Schedule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1te_1_1Schedule__coll__graph.svg" width="146" height="390"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afba006836979a74a799189169534189e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#afba006836979a74a799189169534189e">ContainerType</a> = <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a></td></tr>
<tr class="separator:afba006836979a74a799189169534189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1eb19ccb06835a11edc39ed1410f01af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a1eb19ccb06835a11edc39ed1410f01af">Schedule</a> ()</td></tr>
<tr class="separator:a1eb19ccb06835a11edc39ed1410f01af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6a71ca3b51eb6cc0b65ee029ff9c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a5f6a71ca3b51eb6cc0b65ee029ff9c96">Schedule</a> (ObjectPtr&lt; Object &gt; n)</td></tr>
<tr class="separator:a5f6a71ca3b51eb6cc0b65ee029ff9c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991e4eaf1992f45708966c335b92307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a4991e4eaf1992f45708966c335b92307">copy</a> () const </td></tr>
<tr class="memdesc:a4991e4eaf1992f45708966c335b92307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of current schedule.  <a href="#a4991e4eaf1992f45708966c335b92307">More...</a><br /></td></tr>
<tr class="separator:a4991e4eaf1992f45708966c335b92307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63b27dcbddd06c550cc1a5a6562717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3f63b27dcbddd06c550cc1a5a6562717">operator[]</a> (const <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="memdesc:a3f63b27dcbddd06c550cc1a5a6562717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stage corresponds to the op.  <a href="#a3f63b27dcbddd06c550cc1a5a6562717">More...</a><br /></td></tr>
<tr class="separator:a3f63b27dcbddd06c550cc1a5a6562717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2040189df3b89304a12acce3efff04a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a2040189df3b89304a12acce3efff04a6">operator[]</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:a2040189df3b89304a12acce3efff04a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short hand for getting the stage of tensor's operation.  <a href="#a2040189df3b89304a12acce3efff04a6">More...</a><br /></td></tr>
<tr class="separator:a2040189df3b89304a12acce3efff04a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e7b946df3b5d2e2cde3acc0201da0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a638e7b946df3b5d2e2cde3acc0201da0">create_group</a> (const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;outputs, const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;inputs, bool include_inputs=false)</td></tr>
<tr class="memdesc:a638e7b946df3b5d2e2cde3acc0201da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stage group for all intermediate operations between inputs and outputs.  <a href="#a638e7b946df3b5d2e2cde3acc0201da0">More...</a><br /></td></tr>
<tr class="separator:a638e7b946df3b5d2e2cde3acc0201da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ef95a62faf0c15f132847efa20249b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b">cache_read</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const std::string &amp;scope, const Array&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt; &amp;readers)</td></tr>
<tr class="memdesc:a38ef95a62faf0c15f132847efa20249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cache read of original tensor for readers. This will mutate the body of the readers. A new stage will be created for the tensor.  <a href="#a38ef95a62faf0c15f132847efa20249b">More...</a><br /></td></tr>
<tr class="separator:a38ef95a62faf0c15f132847efa20249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9825f59ef130a0ab0b3a01ea348d71"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71">cache_write</a> (const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;tensor, const std::string &amp;scope)</td></tr>
<tr class="memdesc:ada9825f59ef130a0ab0b3a01ea348d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op.  <a href="#ada9825f59ef130a0ab0b3a01ea348d71">More...</a><br /></td></tr>
<tr class="separator:ada9825f59ef130a0ab0b3a01ea348d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a15582f96d0aaf9a2bd9f2afcad3935d4">cache_write</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const std::string &amp;scope)</td></tr>
<tr class="memdesc:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op.  <a href="#a15582f96d0aaf9a2bd9f2afcad3935d4">More...</a><br /></td></tr>
<tr class="separator:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ae85add41bbed0140726d024d08862"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a34ae85add41bbed0140726d024d08862">rfactor</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &amp;axis, int factor_axis=0)</td></tr>
<tr class="memdesc:a34ae85add41bbed0140726d024d08862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a reduction axis in tensor's schedule to be an explicit axis. This will create a new stage that generated the new tensor with axis as the first dimension. The tensor's body will be rewritten as a reduction over the factored tensor.  <a href="#a34ae85add41bbed0140726d024d08862">More...</a><br /></td></tr>
<tr class="separator:a34ae85add41bbed0140726d024d08862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3fcdec89d8dec36d7b2586b9b0414dfe">normalize</a> ()</td></tr>
<tr class="memdesc:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the schedule. This is needed before bound inference. Insert necessary <a class="el" href="classtvm_1_1te_1_1RebaseNode.html" title="Rebase the iteration to make min to be 0. This is useful to normalize the Schedule to make every leaf...">RebaseNode</a> to make sure all leaf_iter_vars are in form [0, extent)  <a href="#a3fcdec89d8dec36d7b2586b9b0414dfe">More...</a><br /></td></tr>
<tr class="separator:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81883ca270f853eaf92d5f364888b9f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a81883ca270f853eaf92d5f364888b9f4">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a81883ca270f853eaf92d5f364888b9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the internal node container  <a href="#a81883ca270f853eaf92d5f364888b9f4">More...</a><br /></td></tr>
<tr class="separator:a81883ca270f853eaf92d5f364888b9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30087792fd6d3b7372d56e7f3947c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#aa30087792fd6d3b7372d56e7f3947c3f">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:aa30087792fd6d3b7372d56e7f3947c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the internal node container  <a href="#aa30087792fd6d3b7372d56e7f3947c3f">More...</a><br /></td></tr>
<tr class="separator:aa30087792fd6d3b7372d56e7f3947c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global schedule container For operations and all the operations they depend on. The schedule per <a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">Operation</a> is named as stage. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afba006836979a74a799189169534189e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1te_1_1Schedule.html#afba006836979a74a799189169534189e">tvm::te::Schedule::ContainerType</a> =  <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1eb19ccb06835a11edc39ed1410f01af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::te::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f6a71ca3b51eb6cc0b65ee029ff9c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::te::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">ObjectPtr&lt; Object &gt;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a38ef95a62faf0c15f132847efa20249b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> tvm::te::Schedule::cache_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>readers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a cache read of original tensor for readers. This will mutate the body of the readers. A new stage will be created for the tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor cached. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the cache. </td></tr>
    <tr><td class="paramname">readers</td><td>The readers to redirect to the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="ada9825f59ef130a0ab0b3a01ea348d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&gt; tvm::te::Schedule::cache_write </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op. </p>
<p>This function can be used to do data layout transformation. If there is a split/fuse/reorder on the data parallel axis of tensor before cache_write is called. The intermediate cache stores the data in the layout as the iteration order of leave axis. The data will be transformed back to the original layout in the original tensor. User can further call compute_inline to inline the original layout and keep the data stored in the transformed layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensors to be produced. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="a15582f96d0aaf9a2bd9f2afcad3935d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> tvm::te::Schedule::cache_write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op. </p>
<p>This function can be used to do data layout transformation. If there is a split/fuse/reorder on the data parallel axis of tensor before cache_write is called. The intermediate cache stores the data in the layout as the iteration order of leave axis. The data will be transformed back to the original layout in the original tensor. User can further call compute_inline to inline the original layout and keep the data stored in the transformed layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be produced. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="a4991e4eaf1992f45708966c335b92307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a> tvm::te::Schedule::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of current schedule. </p>
<dl class="section return"><dt>Returns</dt><dd>The copied schedule. </dd></dl>

</div>
</div>
<a class="anchor" id="a638e7b946df3b5d2e2cde3acc0201da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::create_group </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_inputs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stage group for all intermediate operations between inputs and outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputs</td><td>The output boundary of the group. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input boundary of the group. </td></tr>
    <tr><td class="paramname">include_inputs</td><td>Whether include inputs if they are reachable from outputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new grouped stage. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fcdec89d8dec36d7b2586b9b0414dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a> tvm::te::Schedule::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the schedule. This is needed before bound inference. Insert necessary <a class="el" href="classtvm_1_1te_1_1RebaseNode.html" title="Rebase the iteration to make min to be 0. This is useful to normalize the Schedule to make every leaf...">RebaseNode</a> to make sure all leaf_iter_vars are in form [0, extent) </p>
<dl class="section return"><dt>Returns</dt><dd>A normalized schedule, can be same as current one. </dd></dl>

</div>
</div>
<a class="anchor" id="a81883ca270f853eaf92d5f364888b9f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> * tvm::te::Schedule::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the internal node container </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the internal node container </dd></dl>

</div>
</div>
<a class="anchor" id="aa30087792fd6d3b7372d56e7f3947c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> * tvm::te::Schedule::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the internal node container </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the internal node container </dd></dl>

</div>
</div>
<a class="anchor" id="a3f63b27dcbddd06c550cc1a5a6562717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stage corresponds to the op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2040189df3b89304a12acce3efff04a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short hand for getting the stage of tensor's operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stage corresponding to the tensor's op </dd></dl>

</div>
</div>
<a class="anchor" id="a34ae85add41bbed0140726d024d08862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&gt; tvm::te::Schedule::rfactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor_axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a reduction axis in tensor's schedule to be an explicit axis. This will create a new stage that generated the new tensor with axis as the first dimension. The tensor's body will be rewritten as a reduction over the factored tensor. </p>
<p>P. Suriana, A. Adams and S. Kamil. Parallel associative reductions in halide. CGO'17</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be factored. </td></tr>
    <tr><td class="paramname">axis</td><td>The reduction axis in tensor's schedule to be factored. </td></tr>
    <tr><td class="paramname">factor_axis</td><td>The position where the new axis is placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created factored tensors. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/te/<a class="el" href="schedule_8h_source.html">schedule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
