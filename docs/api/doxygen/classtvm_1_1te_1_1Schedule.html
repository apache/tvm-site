<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::te::Schedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1te.html">te</a></li><li class="navelem"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1te_1_1Schedule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::te::Schedule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global schedule container For operations and all the operations they depend on. The schedule per <a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">Operation</a> is named as stage.  
 <a href="classtvm_1_1te_1_1Schedule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="te_2schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::te::Schedule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1te_1_1Schedule__inherit__graph.svg" width="192" height="668"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::te::Schedule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1te_1_1Schedule__coll__graph.svg" width="198" height="956"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afba006836979a74a799189169534189e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#afba006836979a74a799189169534189e">ContainerType</a> = <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a></td></tr>
<tr class="separator:afba006836979a74a799189169534189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">ContainerType</a> = <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">type indicate the container type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">More...</a><br /></td></tr>
<tr class="separator:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1eb19ccb06835a11edc39ed1410f01af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a1eb19ccb06835a11edc39ed1410f01af">Schedule</a> ()</td></tr>
<tr class="separator:a1eb19ccb06835a11edc39ed1410f01af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6a71ca3b51eb6cc0b65ee029ff9c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a5f6a71ca3b51eb6cc0b65ee029ff9c96">Schedule</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; n)</td></tr>
<tr class="separator:a5f6a71ca3b51eb6cc0b65ee029ff9c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fb6686f85d6a0be14fe52de8f48402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a90fb6686f85d6a0be14fe52de8f48402">Schedule</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt; ops)</td></tr>
<tr class="memdesc:a90fb6686f85d6a0be14fe52de8f48402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a schedule for array of ops(and their dependencies).  <a href="#a90fb6686f85d6a0be14fe52de8f48402">More...</a><br /></td></tr>
<tr class="separator:a90fb6686f85d6a0be14fe52de8f48402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f7b3b60661fb56dd80892260d31189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#aa4f7b3b60661fb56dd80892260d31189">copy</a> () const</td></tr>
<tr class="memdesc:aa4f7b3b60661fb56dd80892260d31189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of current schedule.  <a href="#aa4f7b3b60661fb56dd80892260d31189">More...</a><br /></td></tr>
<tr class="separator:aa4f7b3b60661fb56dd80892260d31189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63b27dcbddd06c550cc1a5a6562717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3f63b27dcbddd06c550cc1a5a6562717">operator[]</a> (const <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="memdesc:a3f63b27dcbddd06c550cc1a5a6562717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stage corresponds to the op.  <a href="#a3f63b27dcbddd06c550cc1a5a6562717">More...</a><br /></td></tr>
<tr class="separator:a3f63b27dcbddd06c550cc1a5a6562717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2040189df3b89304a12acce3efff04a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a2040189df3b89304a12acce3efff04a6">operator[]</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:a2040189df3b89304a12acce3efff04a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short hand for getting the stage of tensor's operation.  <a href="#a2040189df3b89304a12acce3efff04a6">More...</a><br /></td></tr>
<tr class="separator:a2040189df3b89304a12acce3efff04a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e7b946df3b5d2e2cde3acc0201da0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a638e7b946df3b5d2e2cde3acc0201da0">create_group</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;outputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;inputs, bool include_inputs=false)</td></tr>
<tr class="memdesc:a638e7b946df3b5d2e2cde3acc0201da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stage group for all intermediate operations between inputs and outputs.  <a href="#a638e7b946df3b5d2e2cde3acc0201da0">More...</a><br /></td></tr>
<tr class="separator:a638e7b946df3b5d2e2cde3acc0201da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ef95a62faf0c15f132847efa20249b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b">cache_read</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const std::string &amp;scope, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt; &amp;readers)</td></tr>
<tr class="memdesc:a38ef95a62faf0c15f132847efa20249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cache read of original tensor for readers. This will mutate the body of the readers. A new stage will be created for the tensor.  <a href="#a38ef95a62faf0c15f132847efa20249b">More...</a><br /></td></tr>
<tr class="separator:a38ef95a62faf0c15f132847efa20249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9825f59ef130a0ab0b3a01ea348d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71">cache_write</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;tensor, const std::string &amp;scope)</td></tr>
<tr class="memdesc:ada9825f59ef130a0ab0b3a01ea348d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op.  <a href="#ada9825f59ef130a0ab0b3a01ea348d71">More...</a><br /></td></tr>
<tr class="separator:ada9825f59ef130a0ab0b3a01ea348d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a15582f96d0aaf9a2bd9f2afcad3935d4">cache_write</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const std::string &amp;scope)</td></tr>
<tr class="memdesc:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op.  <a href="#a15582f96d0aaf9a2bd9f2afcad3935d4">More...</a><br /></td></tr>
<tr class="separator:a15582f96d0aaf9a2bd9f2afcad3935d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ae85add41bbed0140726d024d08862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a34ae85add41bbed0140726d024d08862">rfactor</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;tensor, const <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &amp;axis, int factor_axis=0)</td></tr>
<tr class="memdesc:a34ae85add41bbed0140726d024d08862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a reduction axis in tensor's schedule to be an explicit axis. This will create a new stage that generated the new tensor with axis as the first dimension. The tensor's body will be rewritten as a reduction over the factored tensor.  <a href="#a34ae85add41bbed0140726d024d08862">More...</a><br /></td></tr>
<tr class="separator:a34ae85add41bbed0140726d024d08862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3fcdec89d8dec36d7b2586b9b0414dfe">normalize</a> ()</td></tr>
<tr class="memdesc:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the schedule. This is needed before bound inference. Insert necessary <a class="el" href="classtvm_1_1te_1_1RebaseNode.html" title="Rebase the iteration to make min to be 0. This is useful to normalize the Schedule to make every leaf...">RebaseNode</a> to make sure all leaf_iter_vars are in form [0, extent)  <a href="#a3fcdec89d8dec36d7b2586b9b0414dfe">More...</a><br /></td></tr>
<tr class="separator:a3fcdec89d8dec36d7b2586b9b0414dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b572232c5cf46bbeaaae4d83458202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a15b572232c5cf46bbeaaae4d83458202">normalize_for_feature_extraction</a> ()</td></tr>
<tr class="memdesc:a15b572232c5cf46bbeaaae4d83458202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the schedule for feature extraction in auto-scheduler. This is similar to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3fcdec89d8dec36d7b2586b9b0414dfe" title="Normalize the schedule. This is needed before bound inference. Insert necessary RebaseNode to make su...">Schedule::normalize</a></code>, but we do aggressive simplification to the TE compute with const_matrix=True for faster compilation and feature extraction. The resulted schedule may be wrong, but it is good enough for feature extraction purposes.  <a href="#a15b572232c5cf46bbeaaae4d83458202">More...</a><br /></td></tr>
<tr class="separator:a15b572232c5cf46bbeaaae4d83458202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d0647fe483156e98e76830db7c5130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#a45d0647fe483156e98e76830db7c5130">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a45d0647fe483156e98e76830db7c5130"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the internal node container  <a href="#a45d0647fe483156e98e76830db7c5130">More...</a><br /></td></tr>
<tr class="separator:a45d0647fe483156e98e76830db7c5130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30087792fd6d3b7372d56e7f3947c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1te_1_1Schedule.html#aa30087792fd6d3b7372d56e7f3947c3f">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:aa30087792fd6d3b7372d56e7f3947c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the internal node container  <a href="#aa30087792fd6d3b7372d56e7f3947c3f">More...</a><br /></td></tr>
<tr class="separator:aa30087792fd6d3b7372d56e7f3947c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">ObjectRef</a> ()=default</td></tr>
<tr class="memdesc:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">More...</a><br /></td></tr>
<tr class="separator:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">ObjectRef</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; data)</td></tr>
<tr class="memdesc:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from existing object ptr.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">More...</a><br /></td></tr>
<tr class="separator:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">same_as</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">More...</a><br /></td></tr>
<tr class="separator:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">More...</a><br /></td></tr>
<tr class="separator:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">More...</a><br /></td></tr>
<tr class="separator:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">More...</a><br /></td></tr>
<tr class="separator:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a17d8d5ad92691f9e18e3e0ae8ef69e4f">defined</a> () const</td></tr>
<tr class="separator:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aadbc0886ffa80162ff31eefd0431ba09">get</a> () const</td></tr>
<tr class="separator:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3deeeac5827a88f375b8c6ae1039c219">operator-&gt;</a> () const</td></tr>
<tr class="separator:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4e7cdb1574b93a59e784d70aa47b8da7">unique</a> () const</td></tr>
<tr class="separator:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a0ae0da21d247cd87ea94fe3777c4405e">use_count</a> () const</td></tr>
<tr class="separator:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">const ObjectType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">as</a> () const</td></tr>
<tr class="memdesc:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to downcast the internal <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> to a raw pointer of a corresponding type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">More...</a><br /></td></tr>
<tr class="separator:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3e9b0901b6e01257b060a45e159cc37e">_type_is_nullable</a> = true</td></tr>
<tr class="separator:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae423057ecf93c18714d17f53cd1d318f">get_mutable</a> () const</td></tr>
<tr class="separator:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">DowncastNoCheck</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> ref)</td></tr>
<tr class="memdesc:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function downcast a ref without check.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">More...</a><br /></td></tr>
<tr class="separator:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">FFIClearAfterMove</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> *ref)</td></tr>
<tr class="memdesc:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the object ref data field without DecRef after we successfully moved the field.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">More...</a><br /></td></tr>
<tr class="separator:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ObjectType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">GetDataPtr</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ref)</td></tr>
<tr class="memdesc:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function get data_ as <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> of ObjectType.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">More...</a><br /></td></tr>
<tr class="separator:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">data_</a></td></tr>
<tr class="memdesc:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal pointer that backs the reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">More...</a><br /></td></tr>
<tr class="separator:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global schedule container For operations and all the operations they depend on. The schedule per <a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">Operation</a> is named as stage. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afba006836979a74a799189169534189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba006836979a74a799189169534189e">&#9670;&nbsp;</a></span>ContainerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1te_1_1Schedule.html#afba006836979a74a799189169534189e">tvm::te::Schedule::ContainerType</a> =  <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1eb19ccb06835a11edc39ed1410f01af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb19ccb06835a11edc39ed1410f01af">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::te::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f6a71ca3b51eb6cc0b65ee029ff9c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6a71ca3b51eb6cc0b65ee029ff9c96">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::te::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90fb6686f85d6a0be14fe52de8f48402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fb6686f85d6a0be14fe52de8f48402">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::te::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a schedule for array of ops(and their dependencies). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>The ops to be scheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sch The created <a class="el" href="classtvm_1_1te_1_1Schedule.html" title="Global schedule container For operations and all the operations they depend on. The schedule per Oper...">Schedule</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a38ef95a62faf0c15f132847efa20249b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ef95a62faf0c15f132847efa20249b">&#9670;&nbsp;</a></span>cache_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> tvm::te::Schedule::cache_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>readers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a cache read of original tensor for readers. This will mutate the body of the readers. A new stage will be created for the tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor cached. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the cache. </td></tr>
    <tr><td class="paramname">readers</td><td>The readers to redirect to the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a id="ada9825f59ef130a0ab0b3a01ea348d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9825f59ef130a0ab0b3a01ea348d71">&#9670;&nbsp;</a></span>cache_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&gt; tvm::te::Schedule::cache_write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op. </p>
<p>This function can be used to do data layout transformation. If there is a split/fuse/reorder on the data parallel axis of tensor before cache_write is called. The intermediate cache stores the data in the layout as the iteration order of leave axis. The data will be transformed back to the original layout in the original tensor. User can further call compute_inline to inline the original layout and keep the data stored in the transformed layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensors to be produced. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a id="a15582f96d0aaf9a2bd9f2afcad3935d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15582f96d0aaf9a2bd9f2afcad3935d4">&#9670;&nbsp;</a></span>cache_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> tvm::te::Schedule::cache_write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cache write tensor for producing tensor. The the tensor will take over body of original tensor op. </p>
<p>This function can be used to do data layout transformation. If there is a split/fuse/reorder on the data parallel axis of tensor before cache_write is called. The intermediate cache stores the data in the layout as the iteration order of leave axis. The data will be transformed back to the original layout in the original tensor. User can further call compute_inline to inline the original layout and keep the data stored in the transformed layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be produced. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope of the storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created tensor. </dd></dl>

</div>
</div>
<a id="aa4f7b3b60661fb56dd80892260d31189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f7b3b60661fb56dd80892260d31189">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a> tvm::te::Schedule::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of current schedule. </p>
<dl class="section return"><dt>Returns</dt><dd>The copied schedule. </dd></dl>

</div>
</div>
<a id="a638e7b946df3b5d2e2cde3acc0201da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638e7b946df3b5d2e2cde3acc0201da0">&#9670;&nbsp;</a></span>create_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::create_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_inputs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stage group for all intermediate operations between inputs and outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputs</td><td>The output boundary of the group. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input boundary of the group. </td></tr>
    <tr><td class="paramname">include_inputs</td><td>Whether include inputs if they are reachable from outputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new grouped stage. </dd></dl>

</div>
</div>
<a id="a3fcdec89d8dec36d7b2586b9b0414dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcdec89d8dec36d7b2586b9b0414dfe">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a> tvm::te::Schedule::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the schedule. This is needed before bound inference. Insert necessary <a class="el" href="classtvm_1_1te_1_1RebaseNode.html" title="Rebase the iteration to make min to be 0. This is useful to normalize the Schedule to make every leaf...">RebaseNode</a> to make sure all leaf_iter_vars are in form [0, extent) </p>
<dl class="section return"><dt>Returns</dt><dd>A normalized schedule, can be same as current one. </dd></dl>

</div>
</div>
<a id="a15b572232c5cf46bbeaaae4d83458202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b572232c5cf46bbeaaae4d83458202">&#9670;&nbsp;</a></span>normalize_for_feature_extraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Schedule.html">Schedule</a> tvm::te::Schedule::normalize_for_feature_extraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the schedule for feature extraction in auto-scheduler. This is similar to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a3fcdec89d8dec36d7b2586b9b0414dfe" title="Normalize the schedule. This is needed before bound inference. Insert necessary RebaseNode to make su...">Schedule::normalize</a></code>, but we do aggressive simplification to the TE compute with const_matrix=True for faster compilation and feature extraction. The resulted schedule may be wrong, but it is good enough for feature extraction purposes. </p>
<dl class="section return"><dt>Returns</dt><dd>A normalized schedule, can be same as current one. </dd></dl>

</div>
</div>
<a id="a45d0647fe483156e98e76830db7c5130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d0647fe483156e98e76830db7c5130">&#9670;&nbsp;</a></span>operator->() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> * tvm::te::Schedule::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the internal node container </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the internal node container </dd></dl>

</div>
</div>
<a id="aa30087792fd6d3b7372d56e7f3947c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30087792fd6d3b7372d56e7f3947c3f">&#9670;&nbsp;</a></span>operator->() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1ScheduleNode.html">ScheduleNode</a> * tvm::te::Schedule::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the internal node container </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the internal node container </dd></dl>

</div>
</div>
<a id="a3f63b27dcbddd06c550cc1a5a6562717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f63b27dcbddd06c550cc1a5a6562717">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stage corresponds to the op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2040189df3b89304a12acce3efff04a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2040189df3b89304a12acce3efff04a6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Stage.html">Stage</a> tvm::te::Schedule::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short hand for getting the stage of tensor's operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stage corresponding to the tensor's op </dd></dl>

</div>
</div>
<a id="a34ae85add41bbed0140726d024d08862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ae85add41bbed0140726d024d08862">&#9670;&nbsp;</a></span>rfactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&gt; tvm::te::Schedule::rfactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor_axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a reduction axis in tensor's schedule to be an explicit axis. This will create a new stage that generated the new tensor with axis as the first dimension. The tensor's body will be rewritten as a reduction over the factored tensor. </p>
<p>P. Suriana, A. Adams and S. Kamil. Parallel associative reductions in halide. CGO'17</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be factored. </td></tr>
    <tr><td class="paramname">axis</td><td>The reduction axis in tensor's schedule to be factored. </td></tr>
    <tr><td class="paramname">factor_axis</td><td>The position where the new axis is placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created factored tensors. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/te/<a class="el" href="te_2schedule_8h_source.html">schedule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
