<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::tir::attr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::attr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a385e883a7cecc309d063786e5fdf2c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a385e883a7cecc309d063786e5fdf2c4b">IsPragmaKey</a> (const std::string &amp;attr_key)</td></tr>
<tr class="memdesc:a385e883a7cecc309d063786e5fdf2c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if attr_key is a pragma key extension.  <a href="#a385e883a7cecc309d063786e5fdf2c4b">More...</a><br /></td></tr>
<tr class="separator:a385e883a7cecc309d063786e5fdf2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4933845b75cf4f08fb66f55fdd94986f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4933845b75cf4f08fb66f55fdd94986f">kDeviceThreadAxis</a> = &quot;tir.device_thread_axis&quot;</td></tr>
<tr class="memdesc:a4933845b75cf4f08fb66f55fdd94986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to.  <a href="#a4933845b75cf4f08fb66f55fdd94986f">More...</a><br /></td></tr>
<tr class="separator:a4933845b75cf4f08fb66f55fdd94986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac74386674da85bc4b4dd1ee28a97ff63">kNoAlias</a> = &quot;tir.noalias&quot;</td></tr>
<tr class="memdesc:ac74386674da85bc4b4dd1ee28a97ff63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to set noalias rule on the function arguments.  <a href="#ac74386674da85bc4b4dd1ee28a97ff63">More...</a><br /></td></tr>
<tr class="separator:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a489d0cebd2820025bc3d6c5a9011cdd4">kIsEntryFunc</a> = &quot;tir.is_entry_func&quot;</td></tr>
<tr class="memdesc:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the function as the entry function of the final generated runtime module.  <a href="#a489d0cebd2820025bc3d6c5a9011cdd4">More...</a><br /></td></tr>
<tr class="separator:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399eed804ecc482a607f0f65f07b78dd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a399eed804ecc482a607f0f65f07b78dd">thread_extent</a> = &quot;thread_extent&quot;</td></tr>
<tr class="memdesc:a399eed804ecc482a607f0f65f07b78dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching extent of thread, used by device API.  <a href="#a399eed804ecc482a607f0f65f07b78dd">More...</a><br /></td></tr>
<tr class="separator:a399eed804ecc482a607f0f65f07b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464533c1560ace5e0b5071ba6902482e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a464533c1560ace5e0b5071ba6902482e">virtual_thread</a> = &quot;virtual_thread&quot;</td></tr>
<tr class="memdesc:a464533c1560ace5e0b5071ba6902482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching of a virtual thread.  <a href="#a464533c1560ace5e0b5071ba6902482e">More...</a><br /></td></tr>
<tr class="separator:a464533c1560ace5e0b5071ba6902482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a341bfebe5448f290aa54b0f84cac"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac62a341bfebe5448f290aa54b0f84cac">coproc_scope</a> = &quot;coproc_scope&quot;</td></tr>
<tr class="memdesc:ac62a341bfebe5448f290aa54b0f84cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is processed by a co-proccesor.  <a href="#ac62a341bfebe5448f290aa54b0f84cac">More...</a><br /></td></tr>
<tr class="separator:ac62a341bfebe5448f290aa54b0f84cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d3379e8d6486e79853e254ea9a724e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae1d3379e8d6486e79853e254ea9a724e">coproc_uop_scope</a> = &quot;coproc_uop_scope&quot;</td></tr>
<tr class="memdesc:ae1d3379e8d6486e79853e254ea9a724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent.  <a href="#ae1d3379e8d6486e79853e254ea9a724e">More...</a><br /></td></tr>
<tr class="separator:ae1d3379e8d6486e79853e254ea9a724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14c2370f3a08792a6aaf70d7a3c773e4">volatile_scope</a> = &quot;volatile_scope&quot;</td></tr>
<tr class="memdesc:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as volatile access for certain handle.  <a href="#a14c2370f3a08792a6aaf70d7a3c773e4">More...</a><br /></td></tr>
<tr class="separator:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd38b620e1e9907216f3e583839dea3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4bd38b620e1e9907216f3e583839dea3">extern_scope</a> = &quot;extern_scope&quot;</td></tr>
<tr class="memdesc:a4bd38b620e1e9907216f3e583839dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program.  <a href="#a4bd38b620e1e9907216f3e583839dea3">More...</a><br /></td></tr>
<tr class="separator:a4bd38b620e1e9907216f3e583839dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a6b89838348f152d844cead81b5016"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a00a6b89838348f152d844cead81b5016">compute_scope</a> = &quot;compute_scope&quot;</td></tr>
<tr class="memdesc:a00a6b89838348f152d844cead81b5016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute.  <a href="#a00a6b89838348f152d844cead81b5016">More...</a><br /></td></tr>
<tr class="separator:a00a6b89838348f152d844cead81b5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f015503117e6b781ade61e103b074a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a04f015503117e6b781ade61e103b074a">storage_scope</a> = &quot;storage_scope&quot;</td></tr>
<tr class="memdesc:a04f015503117e6b781ade61e103b074a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of buffers.  <a href="#a04f015503117e6b781ade61e103b074a">More...</a><br /></td></tr>
<tr class="separator:a04f015503117e6b781ade61e103b074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d464f2065dc5f77408df7b94d4bb6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af27d464f2065dc5f77408df7b94d4bb6">storage_alignment</a> = &quot;storage_alignment&quot;</td></tr>
<tr class="memdesc:af27d464f2065dc5f77408df7b94d4bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage alignement requirement of buffers.  <a href="#af27d464f2065dc5f77408df7b94d4bb6">More...</a><br /></td></tr>
<tr class="separator:af27d464f2065dc5f77408df7b94d4bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70bbdafa7344811d336422bf95cdc5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acf70bbdafa7344811d336422bf95cdc5">realize_scope</a> = &quot;realize_scope&quot;</td></tr>
<tr class="memdesc:acf70bbdafa7344811d336422bf95cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of realization.  <a href="#acf70bbdafa7344811d336422bf95cdc5">More...</a><br /></td></tr>
<tr class="separator:acf70bbdafa7344811d336422bf95cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3aac4e433fcd6d93f8982540960263"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a5f3aac4e433fcd6d93f8982540960263">device_context_id</a> = &quot;device_context_id&quot;</td></tr>
<tr class="memdesc:a5f3aac4e433fcd6d93f8982540960263"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation context for global malloc in host.  <a href="#a5f3aac4e433fcd6d93f8982540960263">More...</a><br /></td></tr>
<tr class="separator:a5f3aac4e433fcd6d93f8982540960263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e64432b8b1b9323c5ad18957ba88b23"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9e64432b8b1b9323c5ad18957ba88b23">device_context_type</a> = &quot;device_context_type&quot;</td></tr>
<tr class="memdesc:a9e64432b8b1b9323c5ad18957ba88b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type.  <a href="#a9e64432b8b1b9323c5ad18957ba88b23">More...</a><br /></td></tr>
<tr class="separator:a9e64432b8b1b9323c5ad18957ba88b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9125ab905a93924ee79269aa808ed517"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9125ab905a93924ee79269aa808ed517">loop_scope</a> = &quot;loop_scope&quot;</td></tr>
<tr class="memdesc:a9125ab905a93924ee79269aa808ed517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of loop scope.  <a href="#a9125ab905a93924ee79269aa808ed517">More...</a><br /></td></tr>
<tr class="separator:a9125ab905a93924ee79269aa808ed517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a50fc9633b9cfbcefa2393dbb2ece1846">reduce_scope</a> = &quot;reduce_scope&quot;</td></tr>
<tr class="memdesc:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of reduce scope.  <a href="#a50fc9633b9cfbcefa2393dbb2ece1846">More...</a><br /></td></tr>
<tr class="separator:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af08d3d2b645a914f1a64d81e45f3b86a">pragma_scope_prefix</a> = &quot;pragma_&quot;</td></tr>
<tr class="memdesc:af08d3d2b645a914f1a64d81e45f3b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is guarded by the pragma extension.  <a href="#af08d3d2b645a914f1a64d81e45f3b86a">More...</a><br /></td></tr>
<tr class="separator:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a2823f2e8c3ae9eec6c8f797752d1f9b5">pragma_import_c</a> = &quot;pragma_import_c&quot;</td></tr>
<tr class="memdesc:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import C source or file into the final code gen module.  <a href="#a2823f2e8c3ae9eec6c8f797752d1f9b5">More...</a><br /></td></tr>
<tr class="separator:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ba402645b1def7c543af3c48be80d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af00ba402645b1def7c543af3c48be80d">pragma_import_llvm</a> = &quot;pragma_import_llvm&quot;</td></tr>
<tr class="memdesc:af00ba402645b1def7c543af3c48be80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import llvm source or file into the final code gen module.  <a href="#af00ba402645b1def7c543af3c48be80d">More...</a><br /></td></tr>
<tr class="separator:af00ba402645b1def7c543af3c48be80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96774004fd5b6411f6c37b8923b71834"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a96774004fd5b6411f6c37b8923b71834">pragma_tensor_core</a> = &quot;pragma_tensor_core&quot;</td></tr>
<tr class="memdesc:a96774004fd5b6411f6c37b8923b71834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to modify the AST to support Tensor Core.  <a href="#a96774004fd5b6411f6c37b8923b71834">More...</a><br /></td></tr>
<tr class="separator:a96774004fd5b6411f6c37b8923b71834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac95fbd1c09a60b10c7a5d07f6c4b68a6">prefetch_scope</a> = &quot;prefetch_scope&quot;</td></tr>
<tr class="memdesc:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope.  <a href="#ac95fbd1c09a60b10c7a5d07f6c4b68a6">More...</a><br /></td></tr>
<tr class="separator:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9231fc0afe37a8d46a90a1c5fdf522bb">double_buffer_scope</a> = &quot;double_buffer_scope&quot;</td></tr>
<tr class="memdesc:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks production of double buffer data.  <a href="#a9231fc0afe37a8d46a90a1c5fdf522bb">More...</a><br /></td></tr>
<tr class="separator:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84871a6d841168f8501f141676dfaeb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af84871a6d841168f8501f141676dfaeb">double_buffer_write</a> = &quot;double_buffer_write&quot;</td></tr>
<tr class="memdesc:af84871a6d841168f8501f141676dfaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks region used by double buffer write.  <a href="#af84871a6d841168f8501f141676dfaeb">More...</a><br /></td></tr>
<tr class="separator:af84871a6d841168f8501f141676dfaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a84f5d42e968fd8f4cdd7a4aac7ba2137">scan_update_scope</a> = &quot;scan_update_scope&quot;</td></tr>
<tr class="memdesc:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan update scope.  <a href="#a84f5d42e968fd8f4cdd7a4aac7ba2137">More...</a><br /></td></tr>
<tr class="separator:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e3a9ba11d436e02b55e420647b22b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af18e3a9ba11d436e02b55e420647b22b">scan_init_scope</a> = &quot;scan_init_scope&quot;</td></tr>
<tr class="memdesc:af18e3a9ba11d436e02b55e420647b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan init scope.  <a href="#af18e3a9ba11d436e02b55e420647b22b">More...</a><br /></td></tr>
<tr class="separator:af18e3a9ba11d436e02b55e420647b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0ff3c4642eebe20842b1c26e98288a5d">buffer_dim_align</a> = &quot;buffer_dim_align&quot;</td></tr>
<tr class="memdesc:a0ff3c4642eebe20842b1c26e98288a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset.  <a href="#a0ff3c4642eebe20842b1c26e98288a5d">More...</a><br /></td></tr>
<tr class="separator:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac76fd8d0227265617e2f2bb8402d1e19">buffer_bound</a> = &quot;buffer_bound&quot;</td></tr>
<tr class="memdesc:ac76fd8d0227265617e2f2bb8402d1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark stores/loads with theirs bounds.  <a href="#ac76fd8d0227265617e2f2bb8402d1e19">More...</a><br /></td></tr>
<tr class="separator:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497d7cff1d672920c2fbd4d92869e62"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0497d7cff1d672920c2fbd4d92869e62">buffer_bind_scope</a> = &quot;buffer_bind_scope&quot;</td></tr>
<tr class="memdesc:a0497d7cff1d672920c2fbd4d92869e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase.  <a href="#a0497d7cff1d672920c2fbd4d92869e62">More...</a><br /></td></tr>
<tr class="separator:a0497d7cff1d672920c2fbd4d92869e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad39d05bd13aeed7af51e9f8e323d263b">channel_read_scope</a> = &quot;channel_read_scope&quot;</td></tr>
<tr class="memdesc:ad39d05bd13aeed7af51e9f8e323d263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel read scope  <a href="#ad39d05bd13aeed7af51e9f8e323d263b">More...</a><br /></td></tr>
<tr class="separator:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14632ed9597f1c21a0dbd23949e5916e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14632ed9597f1c21a0dbd23949e5916e">channel_read_advance</a> = &quot;channel_read_advance&quot;</td></tr>
<tr class="memdesc:a14632ed9597f1c21a0dbd23949e5916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#a14632ed9597f1c21a0dbd23949e5916e">More...</a><br /></td></tr>
<tr class="separator:a14632ed9597f1c21a0dbd23949e5916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a52f378fc437bd4f7f6508c8e2e9b3e05">channel_write_scope</a> = &quot;channel_write_scope&quot;</td></tr>
<tr class="memdesc:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel write scope  <a href="#a52f378fc437bd4f7f6508c8e2e9b3e05">More...</a><br /></td></tr>
<tr class="separator:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad8886f0bca07d9fa56db9edea67b1a8d">channel_write_advance</a> = &quot;channel_write_advance&quot;</td></tr>
<tr class="memdesc:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#ad8886f0bca07d9fa56db9edea67b1a8d">More...</a><br /></td></tr>
<tr class="separator:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ecbf068afc115a2282e533c0fe518d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a19ecbf068afc115a2282e533c0fe518d">pipeline_stage_scope</a> = &quot;pipeline_stage_scope&quot;</td></tr>
<tr class="memdesc:a19ecbf068afc115a2282e533c0fe518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline stage scope, implies always execution  <a href="#a19ecbf068afc115a2282e533c0fe518d">More...</a><br /></td></tr>
<tr class="separator:a19ecbf068afc115a2282e533c0fe518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14d4d24b86179fd19938a02bc15512"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#aee14d4d24b86179fd19938a02bc15512">pipeline_exec_scope</a> = &quot;pipeline_exec_scope&quot;</td></tr>
<tr class="memdesc:aee14d4d24b86179fd19938a02bc15512"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline execution scope, implies the scope can be pipelined.  <a href="#aee14d4d24b86179fd19938a02bc15512">More...</a><br /></td></tr>
<tr class="separator:aee14d4d24b86179fd19938a02bc15512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db026f638ad3d951c302796ddcae24"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a36db026f638ad3d951c302796ddcae24">device_scope</a> = &quot;device_scope&quot;</td></tr>
<tr class="memdesc:a36db026f638ad3d951c302796ddcae24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that it is in the device scope.  <a href="#a36db026f638ad3d951c302796ddcae24">More...</a><br /></td></tr>
<tr class="separator:a36db026f638ad3d951c302796ddcae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d76d80fd7252d66991dc650693c0ef"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a93d76d80fd7252d66991dc650693c0ef">fragment_shape</a> = &quot;fragment_shape&quot;</td></tr>
<tr class="memdesc:a93d76d80fd7252d66991dc650693c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the shape of TensorCore fragment.  <a href="#a93d76d80fd7252d66991dc650693c0ef">More...</a><br /></td></tr>
<tr class="separator:a93d76d80fd7252d66991dc650693c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cc65f756817e691b49782ee103bd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9b33cc65f756817e691b49782ee103bd">fragment_layout</a> = &quot;fragment_layout&quot;</td></tr>
<tr class="memdesc:a9b33cc65f756817e691b49782ee103bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the layout of TensorCore fragment.  <a href="#a9b33cc65f756817e691b49782ee103bd">More...</a><br /></td></tr>
<tr class="separator:a9b33cc65f756817e691b49782ee103bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. </p>
<p>namespace of possible attribute sin AttrStmt.attr_key</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1attr.html" title="Generic attribute names that can be attached to any function. ">tvm::attr</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a385e883a7cecc309d063786e5fdf2c4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::attr::IsPragmaKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if attr_key is a pragma key extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>The attr key to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a pragma key </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a0497d7cff1d672920c2fbd4d92869e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bind_scope = &quot;buffer_bind_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. </p>

</div>
</div>
<a class="anchor" id="ac76fd8d0227265617e2f2bb8402d1e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bound = &quot;buffer_bound&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark stores/loads with theirs bounds. </p>

</div>
</div>
<a class="anchor" id="a0ff3c4642eebe20842b1c26e98288a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_dim_align = &quot;buffer_dim_align&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset. </p>

</div>
</div>
<a class="anchor" id="a14632ed9597f1c21a0dbd23949e5916e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_advance = &quot;channel_read_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a class="anchor" id="ad39d05bd13aeed7af51e9f8e323d263b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_scope = &quot;channel_read_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel read scope </p>

</div>
</div>
<a class="anchor" id="ad8886f0bca07d9fa56db9edea67b1a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_advance = &quot;channel_write_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a class="anchor" id="a52f378fc437bd4f7f6508c8e2e9b3e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_scope = &quot;channel_write_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel write scope </p>

</div>
</div>
<a class="anchor" id="a00a6b89838348f152d844cead81b5016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::compute_scope = &quot;compute_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. </p>

</div>
</div>
<a class="anchor" id="ac62a341bfebe5448f290aa54b0f84cac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_scope = &quot;coproc_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is processed by a co-proccesor. </p>

</div>
</div>
<a class="anchor" id="ae1d3379e8d6486e79853e254ea9a724e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_uop_scope = &quot;coproc_uop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. </p>

</div>
</div>
<a class="anchor" id="a5f3aac4e433fcd6d93f8982540960263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_context_id = &quot;device_context_id&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The allocation context for global malloc in host. </p>

</div>
</div>
<a class="anchor" id="a9e64432b8b1b9323c5ad18957ba88b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_context_type = &quot;device_context_type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type. </p>

</div>
</div>
<a class="anchor" id="a36db026f638ad3d951c302796ddcae24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_scope = &quot;device_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that it is in the device scope. </p>

</div>
</div>
<a class="anchor" id="a9231fc0afe37a8d46a90a1c5fdf522bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_scope = &quot;double_buffer_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks production of double buffer data. </p>

</div>
</div>
<a class="anchor" id="af84871a6d841168f8501f141676dfaeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_write = &quot;double_buffer_write&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks region used by double buffer write. </p>

</div>
</div>
<a class="anchor" id="a4bd38b620e1e9907216f3e583839dea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::extern_scope = &quot;extern_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. </p>

</div>
</div>
<a class="anchor" id="a9b33cc65f756817e691b49782ee103bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_layout = &quot;fragment_layout&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the layout of TensorCore fragment. </p>

</div>
</div>
<a class="anchor" id="a93d76d80fd7252d66991dc650693c0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_shape = &quot;fragment_shape&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the shape of TensorCore fragment. </p>

</div>
</div>
<a class="anchor" id="a4933845b75cf4f08fb66f55fdd94986f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kDeviceThreadAxis = &quot;tir.device_thread_axis&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: Array&lt;tir::IterVar&gt;</p>
<p>We call a device kernel launch function f using the following convention:</p>
<p>Call(f, [arg1, arg2, ..., arg_n, work_size_1, work_size_2, ... work_size_m])</p>
<p>Here n = len(arg), m = len(work_size) = len(device_thread_axis).</p>
<p>The list of device_thread_axis indicates how can be bind the work_size arguments to the corresponding threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm.html#a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc" title="Device kernel launch. ">tvm::CallingConv::kDeviceKernelLaunch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a489d0cebd2820025bc3d6c5a9011cdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kIsEntryFunc = &quot;tir.is_entry_func&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the function as the entry function of the final generated runtime module. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a></p>
<dl class="section note"><dt>Note</dt><dd>There can only be one entry function per module. </dd></dl>

</div>
</div>
<a class="anchor" id="ac74386674da85bc4b4dd1ee28a97ff63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kNoAlias = &quot;tir.noalias&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to set noalias rule on the function arguments. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a class="anchor" id="a9125ab905a93924ee79269aa808ed517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::loop_scope = &quot;loop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of loop scope. </p>

</div>
</div>
<a class="anchor" id="aee14d4d24b86179fd19938a02bc15512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_exec_scope = &quot;pipeline_exec_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline execution scope, implies the scope can be pipelined. </p>

</div>
</div>
<a class="anchor" id="a19ecbf068afc115a2282e533c0fe518d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_stage_scope = &quot;pipeline_stage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline stage scope, implies always execution </p>

</div>
</div>
<a class="anchor" id="a2823f2e8c3ae9eec6c8f797752d1f9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_c = &quot;pragma_import_c&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import C source or file into the final code gen module. </p>

</div>
</div>
<a class="anchor" id="af00ba402645b1def7c543af3c48be80d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_llvm = &quot;pragma_import_llvm&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import llvm source or file into the final code gen module. </p>

</div>
</div>
<a class="anchor" id="af08d3d2b645a914f1a64d81e45f3b86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_scope_prefix = &quot;pragma_&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is guarded by the pragma extension. </p>

</div>
</div>
<a class="anchor" id="a96774004fd5b6411f6c37b8923b71834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_tensor_core = &quot;pragma_tensor_core&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to modify the AST to support Tensor Core. </p>

</div>
</div>
<a class="anchor" id="ac95fbd1c09a60b10c7a5d07f6c4b68a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::prefetch_scope = &quot;prefetch_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope. </p>

</div>
</div>
<a class="anchor" id="acf70bbdafa7344811d336422bf95cdc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::realize_scope = &quot;realize_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of realization. </p>

</div>
</div>
<a class="anchor" id="a50fc9633b9cfbcefa2393dbb2ece1846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::reduce_scope = &quot;reduce_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of reduce scope. </p>

</div>
</div>
<a class="anchor" id="af18e3a9ba11d436e02b55e420647b22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_init_scope = &quot;scan_init_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan init scope. </p>

</div>
</div>
<a class="anchor" id="a84f5d42e968fd8f4cdd7a4aac7ba2137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_update_scope = &quot;scan_update_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan update scope. </p>

</div>
</div>
<a class="anchor" id="af27d464f2065dc5f77408df7b94d4bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::storage_alignment = &quot;storage_alignment&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage alignement requirement of buffers. </p>

</div>
</div>
<a class="anchor" id="a04f015503117e6b781ade61e103b074a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::storage_scope = &quot;storage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of buffers. </p>

</div>
</div>
<a class="anchor" id="a399eed804ecc482a607f0f65f07b78dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::thread_extent = &quot;thread_extent&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching extent of thread, used by device API. </p>

</div>
</div>
<a class="anchor" id="a464533c1560ace5e0b5071ba6902482e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::virtual_thread = &quot;virtual_thread&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching of a virtual thread. </p>

</div>
</div>
<a class="anchor" id="a14c2370f3a08792a6aaf70d7a3c773e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::volatile_scope = &quot;volatile_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as volatile access for certain handle. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
