

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tvm.relay.nn &mdash; tvm 0.7.dev1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/tvm-logo-square.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/tvm_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="tvm.relay.vision" href="vision.html" />
    <link rel="prev" title="tvm.relay.frontend" href="frontend.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.7.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vta/index.html">VTA: Deep Learning Accelerator Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deploy/index.html">Deploy and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contribute to TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../langref/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../runtime.html">tvm.runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ndarray.html">tvm.runtime.ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error.html">tvm.error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ir.html">tvm.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ir.html#module-tvm.transform">tvm.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">tvm.target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html">tvm.tir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html#module-tvm.tir.transform">tvm.tir.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html#module-tvm.tir.analysis">tvm.tir.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html#module-tvm.tir.stmt_functor">tvm.tir.stmt_functor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../te.html">tvm.te</a></li>
<li class="toctree-l2"><a class="reference internal" href="../te.html#module-tvm.te.hybrid">tvm.te.hybrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../driver.html">tvm.driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html">tvm.relay</a></li>
<li class="toctree-l2"><a class="reference internal" href="frontend.html">tvm.relay.frontend</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">tvm.relay.nn</a></li>
<li class="toctree-l2"><a class="reference internal" href="vision.html">tvm.relay.vision</a></li>
<li class="toctree-l2"><a class="reference internal" href="image.html">tvm.relay.image</a></li>
<li class="toctree-l2"><a class="reference internal" href="transform.html">tvm.relay.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="analysis.html">tvm.relay.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="backend.html">tvm.relay.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing.html">tvm.relay.testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../autotvm.html">tvm.autotvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rpc.html">tvm.rpc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contrib.html">tvm.contrib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph_runtime.html">tvm.contrib.graph_runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vta/index.html">vta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../topi.html">topi</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links to API References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Design and Developer Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../frontend/tensorflow.html">TensorFlow Frontend</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tvm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Python API</a> &raquo;</li>
        
      <li>tvm.relay.nn</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/api/python/relay/nn.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-tvm.relay.nn">
<span id="tvm-relay-nn"></span><h1>tvm.relay.nn<a class="headerlink" href="#module-tvm.relay.nn" title="Permalink to this headline">¶</a></h1>
<p>Neural network related operators.</p>
<p><strong>Functions</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.adaptive_avg_pool2d" title="tvm.relay.nn.adaptive_avg_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_avg_pool2d</span></code></a>(data[, output_size, layout])</p></td>
<td><p>2D adaptive average pooling operator. This operator is experimental.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.adaptive_avg_pool3d" title="tvm.relay.nn.adaptive_avg_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_avg_pool3d</span></code></a>(data[, output_size, layout])</p></td>
<td><p>3D adaptive avg pooling operator. This operator is experimental.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.adaptive_max_pool2d" title="tvm.relay.nn.adaptive_max_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_max_pool2d</span></code></a>(data[, output_size, layout])</p></td>
<td><p>2D adaptive max pooling operator. This operator is experimental.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.adaptive_max_pool3d" title="tvm.relay.nn.adaptive_max_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_max_pool3d</span></code></a>(data[, output_size, layout])</p></td>
<td><p>3D adaptive max pooling operator. This operator is experimental.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.avg_pool1d" title="tvm.relay.nn.avg_pool1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avg_pool1d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>1D average pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.avg_pool2d" title="tvm.relay.nn.avg_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avg_pool2d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>2D average pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.avg_pool2d_grad" title="tvm.relay.nn.avg_pool2d_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avg_pool2d_grad</span></code></a>(out_grad, data[, pool_size, …])</p></td>
<td><p>Gradient of 2D average pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.avg_pool3d" title="tvm.relay.nn.avg_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avg_pool3d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>3D average pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.batch_flatten" title="tvm.relay.nn.batch_flatten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_flatten</span></code></a>(data)</p></td>
<td><p>BatchFlatten.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.batch_matmul" title="tvm.relay.nn.batch_matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_matmul</span></code></a>(x, y)</p></td>
<td><p>Computes batch matrix multiplication of <cite>x</cite> and <cite>y</cite> when <cite>x</cite> and <cite>y</cite> are data in batch.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.batch_norm" title="tvm.relay.nn.batch_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_norm</span></code></a>(data, gamma, beta, moving_mean, …)</p></td>
<td><p>Batch normalization layer (Ioffe and Szegedy, 2014).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.bias_add" title="tvm.relay.nn.bias_add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bias_add</span></code></a>(data, bias[, axis])</p></td>
<td><p>add_bias operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.bitpack" title="tvm.relay.nn.bitpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitpack</span></code></a>(data[, bits, pack_axis, bit_axis, …])</p></td>
<td><p>Tensor packing for bitserial operations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.bitserial_conv2d" title="tvm.relay.nn.bitserial_conv2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitserial_conv2d</span></code></a>(data, weight[, strides, …])</p></td>
<td><p>2D convolution using bitserial computation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.bitserial_dense" title="tvm.relay.nn.bitserial_dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitserial_dense</span></code></a>(data, weight[, units, …])</p></td>
<td><p>Bitserial Dense operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv2d_nchwc" title="tvm.relay.nn.contrib_conv2d_nchwc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv2d_nchwc</span></code></a>(data, kernel[, …])</p></td>
<td><p>Variant of 2D convolution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv2d_winograd_nnpack_weight_transform" title="tvm.relay.nn.contrib_conv2d_winograd_nnpack_weight_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv2d_winograd_nnpack_weight_transform</span></code></a>(…)</p></td>
<td><p>Weight Transformation part for 2D convolution with winograd algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv2d_winograd_weight_transform" title="tvm.relay.nn.contrib_conv2d_winograd_weight_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv2d_winograd_weight_transform</span></code></a>(…)</p></td>
<td><p>Weight Transformation part for 2D convolution with winograd algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv2d_winograd_without_weight_transform" title="tvm.relay.nn.contrib_conv2d_winograd_without_weight_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv2d_winograd_without_weight_transform</span></code></a>(…)</p></td>
<td><p>2D convolution with winograd algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv3d_winograd_weight_transform" title="tvm.relay.nn.contrib_conv3d_winograd_weight_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv3d_winograd_weight_transform</span></code></a>(…)</p></td>
<td><p>Weight Transformation part for 3D convolution with winograd algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_conv3d_winograd_without_weight_transform" title="tvm.relay.nn.contrib_conv3d_winograd_without_weight_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_conv3d_winograd_without_weight_transform</span></code></a>(…)</p></td>
<td><p>3D convolution with winograd algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.contrib_depthwise_conv2d_nchwc" title="tvm.relay.nn.contrib_depthwise_conv2d_nchwc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contrib_depthwise_conv2d_nchwc</span></code></a>(data, kernel)</p></td>
<td><p>Variant of 2D depthwise convolution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.conv1d" title="tvm.relay.nn.conv1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv1d</span></code></a>(data, weight[, strides, padding, …])</p></td>
<td><p>1D convolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.conv1d_transpose" title="tvm.relay.nn.conv1d_transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv1d_transpose</span></code></a>(data, weight[, strides, …])</p></td>
<td><p>One dimensional transposed convolution operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.conv2d" title="tvm.relay.nn.conv2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv2d</span></code></a>(data, weight[, strides, padding, …])</p></td>
<td><p>2D convolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.conv2d_transpose" title="tvm.relay.nn.conv2d_transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv2d_transpose</span></code></a>(data, weight[, strides, …])</p></td>
<td><p>Two dimensional transposed convolution operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.conv3d" title="tvm.relay.nn.conv3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conv3d</span></code></a>(data, weight[, strides, padding, …])</p></td>
<td><p>3D convolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.correlation" title="tvm.relay.nn.correlation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation</span></code></a>(data1, data2, kernel_size, …)</p></td>
<td><p>Applies correlation to inputs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.cross_entropy" title="tvm.relay.nn.cross_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_entropy</span></code></a>(predictions, targets)</p></td>
<td><p>CrossEntropy without logits.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.cross_entropy_with_logits" title="tvm.relay.nn.cross_entropy_with_logits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_entropy_with_logits</span></code></a>(predictions, targets)</p></td>
<td><p>CrossEntropy with logits.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.deformable_conv2d" title="tvm.relay.nn.deformable_conv2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deformable_conv2d</span></code></a>(data, offset, weight[, …])</p></td>
<td><p>Deformable 2d convolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.dense" title="tvm.relay.nn.dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dense</span></code></a>(data, weight[, units, out_dtype])</p></td>
<td><p>Dense operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.depth_to_space" title="tvm.relay.nn.depth_to_space"><code class="xref py py-obj docutils literal notranslate"><span class="pre">depth_to_space</span></code></a>(data, block_size[, layout, mode])</p></td>
<td><p>Convert channels into spatial blocks.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.dilate" title="tvm.relay.nn.dilate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dilate</span></code></a>(data, strides)</p></td>
<td><p>Dilate data with zeros.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.dropout" title="tvm.relay.nn.dropout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropout</span></code></a>(data[, rate])</p></td>
<td><p>Applies the dropout operation to the input array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.dropout_raw" title="tvm.relay.nn.dropout_raw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropout_raw</span></code></a>(data[, rate])</p></td>
<td><p>Applies the dropout operation to the input array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.fifo_buffer" title="tvm.relay.nn.fifo_buffer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fifo_buffer</span></code></a>(data, buffer, axis)</p></td>
<td><p>FIFO buffer to enable computation reuse in CNNs with sliding indow input</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.get_pad_tuple1d" title="tvm.relay.nn.get_pad_tuple1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pad_tuple1d</span></code></a>(padding)</p></td>
<td><p>Common code to get the 1 dimensional pad option</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.get_pad_tuple2d" title="tvm.relay.nn.get_pad_tuple2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pad_tuple2d</span></code></a>(padding)</p></td>
<td><p>Common code to get the pad option</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.get_pad_tuple3d" title="tvm.relay.nn.get_pad_tuple3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pad_tuple3d</span></code></a>(padding)</p></td>
<td><p>Common code to get the pad option</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.global_avg_pool2d" title="tvm.relay.nn.global_avg_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_avg_pool2d</span></code></a>(data[, layout])</p></td>
<td><p>2D global average pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.global_avg_pool3d" title="tvm.relay.nn.global_avg_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_avg_pool3d</span></code></a>(data[, layout])</p></td>
<td><p>3D global average pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.global_max_pool2d" title="tvm.relay.nn.global_max_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_max_pool2d</span></code></a>(data[, layout])</p></td>
<td><p>2D global maximum pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.global_max_pool3d" title="tvm.relay.nn.global_max_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_max_pool3d</span></code></a>(data[, layout])</p></td>
<td><p>3D global maximum pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.group_norm" title="tvm.relay.nn.group_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_norm</span></code></a>(data, gamma, beta, num_groups[, …])</p></td>
<td><p>Group normalization normalizes over group of channels for each training examples.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.instance_norm" title="tvm.relay.nn.instance_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">instance_norm</span></code></a>(data, gamma, beta[, axis, …])</p></td>
<td><p>Instance Normalization (Ulyanov and et al., 2016) Applies instance normalization to the n-dimensional input array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.l2_normalize" title="tvm.relay.nn.l2_normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l2_normalize</span></code></a>(data, eps[, axis])</p></td>
<td><p>Perform L2 normalization on the input data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.layer_norm" title="tvm.relay.nn.layer_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">layer_norm</span></code></a>(data, gamma, beta[, axis, …])</p></td>
<td><p>Layer normalization (Lei Ba and et al., 2016).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.leaky_relu" title="tvm.relay.nn.leaky_relu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">leaky_relu</span></code></a>(data, alpha)</p></td>
<td><p>This operator takes data as input and does Leaky version of a Rectified Linear Unit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.log_softmax" title="tvm.relay.nn.log_softmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_softmax</span></code></a>(data[, axis])</p></td>
<td><p>Computes log softmax.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.lrn" title="tvm.relay.nn.lrn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lrn</span></code></a>(data[, size, axis, bias, alpha, beta])</p></td>
<td><p>This operator takes data as input and does local response normalization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.max_pool1d" title="tvm.relay.nn.max_pool1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_pool1d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>1D maximum pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.max_pool2d" title="tvm.relay.nn.max_pool2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_pool2d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>2D maximum pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.max_pool2d_grad" title="tvm.relay.nn.max_pool2d_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_pool2d_grad</span></code></a>(out_grad, data[, pool_size, …])</p></td>
<td><p>Gradient of 2D maximum pooling operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.max_pool3d" title="tvm.relay.nn.max_pool3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_pool3d</span></code></a>(data[, pool_size, strides, …])</p></td>
<td><p>3D maximum pooling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.mirror_pad" title="tvm.relay.nn.mirror_pad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror_pad</span></code></a>(data, pad_width[, mode])</p></td>
<td><p>MirrorPadding</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.pad" title="tvm.relay.nn.pad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad</span></code></a>(data, pad_width[, pad_value, pad_mode])</p></td>
<td><p>Padding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.prelu" title="tvm.relay.nn.prelu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prelu</span></code></a>(data, alpha[, axis])</p></td>
<td><p>This operator takes data as input and does Leaky version of a Rectified Linear Unit.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.relu" title="tvm.relay.nn.relu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">relu</span></code></a>(data)</p></td>
<td><p>Rectified linear unit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.softmax" title="tvm.relay.nn.softmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">softmax</span></code></a>(data[, axis])</p></td>
<td><p>Computes softmax.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.space_to_depth" title="tvm.relay.nn.space_to_depth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">space_to_depth</span></code></a>(data, block_size[, layout])</p></td>
<td><p>Convert spatial blocks into channels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.sparse_dense" title="tvm.relay.nn.sparse_dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_dense</span></code></a>(data, weight)</p></td>
<td><p>Computes the matrix multiplication of <cite>data</cite> and <cite>weight</cite>, where <cite>data</cite> is a dense matrix and <cite>weight</cite> is a sparse (either BSR or CSR) namedtuple with fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.sparse_transpose" title="tvm.relay.nn.sparse_transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_transpose</span></code></a>(x)</p></td>
<td><p>Computes the fast matrix transpose of x, where x is a sparse tensor in CSR format (represented as a namedtuple with fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.relay.nn.upsampling" title="tvm.relay.nn.upsampling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upsampling</span></code></a>(data[, scale_h, scale_w, layout, …])</p></td>
<td><p>Upsampling.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.relay.nn.upsampling3d" title="tvm.relay.nn.upsampling3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upsampling3d</span></code></a>(data[, scale_d, scale_h, …])</p></td>
<td><p>3D Upsampling.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="tvm.relay.nn.adaptive_avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">adaptive_avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.adaptive_avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D adaptive average pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 2D average value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input height and width will be used
as output height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size) for any input (NCHW).</p>
<p>If a tuple of integers (height, width) are provided for output_size,
the output size is (N x C x height x width) for any input (NCHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.adaptive_avg_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">adaptive_avg_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.adaptive_avg_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D adaptive avg pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 3D avg value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_depth, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input depth, height and width will be used
as output depth, height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size x output_size) for any input (NCDHW).</p>
<p>If a tuple of integers (depth, height, width) are provided for output_size,
the output size is (N x C x depth x height x width) for any input (NCDHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.adaptive_max_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">adaptive_max_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.adaptive_max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D adaptive max pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 2D max value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input height and width will be used
as output height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size) for any input (NCHW).</p>
<p>If a tuple of integers (height, width) are provided for output_size,
the output size is (N x C x height x width) for any input (NCHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.adaptive_max_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">adaptive_max_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.adaptive_max_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D adaptive max pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 3D max value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_depth, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input depth, height and width will be used
as output depth, height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size x output_size) for any input (NCDHW).</p>
<p>If a tuple of integers (depth, height, width) are provided for output_size,
the output size is (N x C x depth x height x width) for any input (NCDHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.avg_pool1d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">avg_pool1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">count_include_pad</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.avg_pool1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D average pooling operator.</p>
<p>This operator takes data as input and does 1D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
a data Tensor with shape <cite>(batch_size, channels, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">count_include_pad</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D average pooling operator.</p>
<p>This operator takes data as input and does 2D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w), pool_size (kh, kw)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, y, x)  = \frac{1}{kh * kw} \sum_{m=0}^{kh-1} \sum_{n=0}^{kw-1}
     \mbox{data}(b, c, \mbox{stride}[0] * y + m, \mbox{stride}[1] * x + n)\]</div>
<p>Padding is applied to data before the computation.
ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.avg_pool2d_grad">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">avg_pool2d_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">out_grad</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">count_include_pad</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.avg_pool2d_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of 2D average pooling operator.</p>
<p>This operator takes out_grad and data as input and calculates gradient of avg_pool2d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out_grad</strong> (<em>tvm.relay.Expr</em>) – The output gradient</p></li>
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.avg_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">avg_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">count_include_pad</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.avg_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D average pooling operator.</p>
<p>This operator takes data as input and does 3D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, channels, depth, height, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.batch_flatten">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">batch_flatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.batch_flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>BatchFlatten.</p>
<p>This operator flattens all the dimensions except for the batch dimension.
which results a 2D output.</p>
<p>For data with shape <code class="docutils literal notranslate"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>
batch_flatten(data) returns reshaped output of shape <code class="docutils literal notranslate"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The Flattened result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.batch_matmul">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">batch_matmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.batch_matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes batch matrix multiplication of <cite>x</cite> and <cite>y</cite> when <cite>x</cite> and <cite>y</cite> are data
in batch.</p>
<div class="math notranslate nohighlight">
\[\mbox{batch_matmul}(x, y)[i, :, :] = \mbox{matmul}(x[i, :, :], y[i, :, :]^T)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tvm.relay.Expr</em>) – The first input.</p></li>
<li><p><strong>y</strong> (<em>tvm.relay.Expr</em>) – The second input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.batch_norm">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">batch_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">gamma</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">moving_mean</span></em>, <em class="sig-param"><span class="n">moving_var</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.batch_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization layer (Ioffe and Szegedy, 2014).
Normalizes the input at each batch, i.e. applies a transformation
that maintains the mean activation close to 0 and the activation
standard deviation close to 1.</p>
<div class="math notranslate nohighlight">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math notranslate nohighlight">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}}
    * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal notranslate"><span class="pre">gamma</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>
have shape <em>(k,)</em>.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal notranslate"><span class="pre">moving_mean</span></code> and <code class="docutils literal notranslate"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’ (separately normalized groups).  The default is 1.
Specifying -1 sets the channel axis to be the last item in the input shape.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which batch_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>moving_mean</strong> (<em>tvm.relay.Expr</em>) – Running mean of input,</p></li>
<li><p><strong>moving_var</strong> (<em>tvm.relay.Expr</em>) – Running variance of input.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Specify along which shape axis the channel is specified.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If true, multiply by gamma. If False, gamma is not used.
When the next layer is piecewise linear (also e.g. nn.relu),
this can be disabled since the scaling will be done by the next layer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Tuple of normed data (same shape as input),
new running mean (k-length vector),
and new running variance (k-length vector)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple">relay.Tuple</a>([tvm.relay.Expr, tvm.relay.Expr, tvm.relay.Expr])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.bias_add">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">bias_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">bias</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.bias_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add_bias operator.</p>
<p>Add 1D bias to the axis of data.
This function is a special case of add which allows
inference of shape of the bias from data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>bias</strong> (<em>tvm.relay.Expr</em>) – The bias to be added.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The axis to add the bias.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The final result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.bitpack">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">bitpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">bits</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">pack_axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">bit_axis</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">pack_type</span><span class="o">=</span><span class="default_value">'uint32'</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'BitPack'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.bitpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor packing for bitserial operations.
The values along the input tensor’s pack_axis are quantized
and packed together into the specified pack_type in a new
bit axis.</p>
<p>For example, consider bitpacking with data to be a tensor with shape [1, 64, 128, 128],
pack_axis=1, bit_axis=4, pack_type=uint8, and bits=2. The output in this case will
be of shape [1, 8, 128, 128, 2]. The dimension of axis 1 has been reduced by a factor
of 8 since each value is packed into an 8-bit uint8. Axis 4 is now two bitplanes
representing the quantized value of the incoming data. The output tensor is now
ready to be used in a bitserial operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.expr</em>) – The incoming tensor to be packed.</p></li>
<li><p><strong>bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits that should be packed.</p></li>
<li><p><strong>pack_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Axis that should be decomposed and packed.</p></li>
<li><p><strong>bit_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – New axis containing bitplane.</p></li>
<li><p><strong>pack_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Datatype to pack bits into.</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The packed tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.bitserial_conv2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">bitserial_conv2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">3, 3</span></em>, <em class="sig-param"><span class="n">activation_bits</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">weight_bits</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">pack_dtype</span><span class="o">=</span><span class="default_value">'uint32'</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">'int16'</span></em>, <em class="sig-param"><span class="n">unipolar</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.bitserial_conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution using bitserial computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>activation_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits to pack for activations.</p></li>
<li><p><strong>weight_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits to pack for weights.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the kernel</p></li>
<li><p><strong>pack_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Datatype to pack bits into.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.bitserial_dense">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">bitserial_dense</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">units</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_bits</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">weight_bits</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">pack_dtype</span><span class="o">=</span><span class="default_value">'uint32'</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">'int16'</span></em>, <em class="sig-param"><span class="n">unipolar</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.bitserial_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitserial Dense operator.
Applies matrix multiplication of two quantized matrices
using a fast bitserial algorithm.</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p><cite>Y = X * W</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>units</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of hidden units of the dense transformation.</p></li>
<li><p><strong>data_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits incoming tensor should be packed with.</p></li>
<li><p><strong>weight_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits weight tensor should be packed with.</p></li>
<li><p><strong>pack_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Datatype to pack individual bits into before computation.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision dense.</p></li>
<li><p><strong>unipolar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to use unipolar or bipolar quantization for inputs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv2d_nchwc">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv2d_nchwc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">kernel</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW8c'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv2d_nchwc" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of 2D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output, following a specialized
NCHWc data layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>kernel</strong> (<em>tvm.relay.Expr</em>) – The kernel expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv2d_winograd_nnpack_weight_transform">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_nnpack_weight_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">convolution_algorithm</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv2d_winograd_nnpack_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight Transformation part for 2D convolution with winograd algorithm.</p>
<p>We separate this as a single op to enable pre-compute for inference.
Use this together with nn.contrib_conv2d_winograd_without_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>convolution_algorithm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv2d_winograd_weight_transform">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_weight_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tile_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv2d_winograd_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight Transformation part for 2D convolution with winograd algorithm.</p>
<p>We separate this as a single op to enable pre-compute for inference.
Use this together with nn.contrib_conv2d_winograd_without_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv2d_winograd_without_weight_transform">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_without_weight_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tile_size</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv2d_winograd_without_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution with winograd algorithm.</p>
<p>The basic parameters are the same as the ones in vanilla conv2d.
It assumes the weight is pre-transformed by nn.contrib_conv2d_winograd_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv3d_winograd_weight_transform">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv3d_winograd_weight_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tile_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv3d_winograd_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight Transformation part for 3D convolution with winograd algorithm.</p>
<p>We separate this as a single op to enable pre-compute for inference.
Use this together with nn.contrib_conv3d_winograd_without_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2x2, 3x3x3) and 4 for F(4x4x4, 3x3x3)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_conv3d_winograd_without_weight_transform">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_conv3d_winograd_without_weight_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tile_size</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIDHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_conv3d_winograd_without_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>3D convolution with winograd algorithm.</p>
<p>The basic parameters are the same as the ones in vanilla conv3d.
It assumes the weight is pre-transformed by nn.contrib_conv3d_winograd_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2x2, 3x3x3) and 4 for F(4x4x4, 3x3x3)</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.contrib_depthwise_conv2d_nchwc">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">contrib_depthwise_conv2d_nchwc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">kernel</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW8c'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.contrib_depthwise_conv2d_nchwc" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of 2D depthwise convolution.</p>
<p>This operator takes the weight as the depthwise convolution kernel
and depthwise convolves it with data to produce an output, following a specialized
NCHWc data layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>kernel</strong> (<em>tvm.relay.Expr</em>) – The kernel expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.conv1d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">conv1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.conv1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
and kernel_layout is <cite>OIW</cite>, conv1d takes in
a data Tensor with shape <cite>(batch_size, in_channels, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size)</cite>
to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, w] = \sum_{dw, k}
   \mbox{data}[b, k, \mbox{strides}[0] * w + dw] *
   \mbox{weight}[c, k, dw]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCW</cite> for data and <cite>OIW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of the input before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Currently unused for 1D convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial dimension of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.conv1d_transpose">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">conv1d_transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">output_padding</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.conv1d_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>One dimensional transposed convolution operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs.</p></li>
<li><p><strong>dilation</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>output_padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Additional zero-padding to be added to one side of the output.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.conv2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">conv2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
and kernel_layout is <cite>OIHW</cite>, conv2d takes in
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size[0], kernel_size[1])</cite>
to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, y, x] = \sum_{dy, dx, k}
   \mbox{data}[b, k, \mbox{strides}[0] * y  + dy, \mbox{strides}[1] * x + dx] *
   \mbox{weight}[c, k, dy, dx]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCHW</cite> for data and <cite>OIHW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.conv2d_transpose">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">conv2d_transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">output_padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.conv2d_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Two dimensional transposed convolution operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs.</p></li>
<li><p><strong>dilation</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>output_padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Additional zero-padding to be added to one side of the output.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.conv3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">conv3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIDHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.conv3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
and kernel_layout is <cite>OIDHW</cite>, conv3d takes in
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size[0], kernel_size[1],
kernel_size[2])</cite> to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, z, y, x] = \sum_{dz, dy, dx, k}
   \mbox{data}[b, k, \mbox{strides}[0] * z  + dz, \mbox{strides}[1] * y  + dy,
   \mbox{strides}[2] * x + dx] * \mbox{weight}[c, k, dz, dy, dx]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCDHW</cite> for data and <cite>OIDHW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.correlation">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">correlation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data1</span></em>, <em class="sig-param"><span class="n">data2</span></em>, <em class="sig-param"><span class="n">kernel_size</span></em>, <em class="sig-param"><span class="n">max_displacement</span></em>, <em class="sig-param"><span class="n">stride1</span></em>, <em class="sig-param"><span class="n">stride2</span></em>, <em class="sig-param"><span class="n">padding</span></em>, <em class="sig-param"><span class="n">is_multiply</span></em>, <em class="sig-param"><span class="n">layout</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies correlation to inputs.</p>
<p>The correlation layer performs multiplicative patch comparisons between two feature maps.
Given two multi-channel feature maps <span class="math notranslate nohighlight">\(f_{1}, f_{2}\)</span>, with <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(h\)</span>, and
<span class="math notranslate nohighlight">\(c\)</span> being their width, height, and number of channels, the correlation layer lets the
network compare each patch from <span class="math notranslate nohighlight">\(f_{1}\)</span> with each patch from <span class="math notranslate nohighlight">\(f_{2}\)</span>.</p>
<p>For now we consider only a single comparison of two patches. The ‘correlation’ of two patches
centered at <span class="math notranslate nohighlight">\(x_{1}\)</span> in the first map and <span class="math notranslate nohighlight">\(x_{2}\)</span> in the second map is then defined
as:</p>
<div class="math notranslate nohighlight">
\[c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o), f_{2}(x_{2} + o)&gt;\]</div>
<p>for a square patch of size <span class="math notranslate nohighlight">\(K:=2k+1\)</span>.</p>
<p>Note that the equation above is identical to one step of a convolution in neural networks, but
instead of convolving data with a filter, it convolves data with other    data. For this
reason, it has no training weights.</p>
<p>Computing <span class="math notranslate nohighlight">\(c(x_{1}, x_{2})\)</span> involves <span class="math notranslate nohighlight">\(c * K^{2}\)</span> multiplications. Comparing all
patch combinations involves <span class="math notranslate nohighlight">\(w^{2}*h^{2}\)</span> such computations.</p>
<p>Given a maximum displacement <span class="math notranslate nohighlight">\(d\)</span>, for each location <span class="math notranslate nohighlight">\(x_{1}\)</span> it computes
correlations <span class="math notranslate nohighlight">\(c(x_{1}, x_{2})\)</span> only in a neighborhood of size <span class="math notranslate nohighlight">\(D:=2d+1\)</span>,
by limiting the range of <span class="math notranslate nohighlight">\(x_{2}\)</span>. We use strides <span class="math notranslate nohighlight">\(s_{1}, s_{2}\)</span>, to quantize
<span class="math notranslate nohighlight">\(x_{1}\)</span> globally and to quantize <span class="math notranslate nohighlight">\(x_{2}\)</span> within the neighborhood
centered around <span class="math notranslate nohighlight">\(x_{1}\)</span>.</p>
<p>The final output is defined by the following expression:</p>
<div class="math notranslate nohighlight">
\[out[n, q, i, j] = c(x_{i, j}, x_{q})\]</div>
<p>where <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> enumerate spatial locations in <span class="math notranslate nohighlight">\(f_{1}\)</span>, and <span class="math notranslate nohighlight">\(q\)</span>
denotes the <span class="math notranslate nohighlight">\(q^{th}\)</span> neighborhood of <span class="math notranslate nohighlight">\(x_{i,j}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> (<a class="reference internal" href="../te.html#tvm.te.Tensor" title="tvm.te.Tensor"><em>tvm.te.Tensor</em></a>) – 4-D with shape [batch, channel, height, width]</p></li>
<li><p><strong>data2</strong> (<a class="reference internal" href="../te.html#tvm.te.Tensor" title="tvm.te.Tensor"><em>tvm.te.Tensor</em></a>) – 4-D with shape [batch, channel, height, width]</p></li>
<li><p><strong>kernel_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Kernel size for correlation, must be an odd number</p></li>
<li><p><strong>max_displacement</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Max displacement of Correlation</p></li>
<li><p><strong>stride1</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Stride for data1</p></li>
<li><p><strong>stride2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Stride for data2 within the neightborhood centered around data1</p></li>
<li><p><strong>padding</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>a list/tuple of 2</em><em> or </em><em>4 ints</em>) – Padding size, or
[pad_height, pad_width] for 2 ints, or
[pad_top, pad_left, pad_bottom, pad_right] for 4 ints</p></li>
<li><p><strong>is_multiply</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – operation type is either multiplication or substraction</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – layout of data1, data2 and the output</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Output</strong> – 4-D with shape [batch, out_channel, out_height, out_width]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../te.html#tvm.te.Tensor" title="tvm.te.Tensor">tvm.te.Tensor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.cross_entropy">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">cross_entropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predictions</span></em>, <em class="sig-param"><span class="n">targets</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.cross_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>CrossEntropy without logits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predictions</strong> (<em>tvm.relay.Expr</em>) – The predictions.</p></li>
<li><p><strong>targets</strong> (<em>tvm.relay.Expr</em>) – The targets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.cross_entropy_with_logits">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">cross_entropy_with_logits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predictions</span></em>, <em class="sig-param"><span class="n">targets</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.cross_entropy_with_logits" title="Permalink to this definition">¶</a></dt>
<dd><p>CrossEntropy with logits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predictions</strong> (<em>tvm.relay.Expr</em>) – The predictions.</p></li>
<li><p><strong>targets</strong> (<em>tvm.relay.Expr</em>) – The targets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.deformable_conv2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">deformable_conv2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">offset</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">dilation</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">deformable_groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">kernel_layout</span><span class="o">=</span><span class="default_value">'OIHW'</span></em>, <em class="sig-param"><span class="n">out_layout</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.deformable_conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Deformable 2d convolution.</p>
<p>The deformable convolution operation is described in <a class="reference external" href="https://arxiv.org/abs/1703.06211">https://arxiv.org/abs/1703.06211</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>offset</strong> (<em>tvm.relay.Expr</em>) – The offset expressions.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>deformable_groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of deformable groups.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.dense">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">dense</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">units</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense operator.
Applies a linear transformation</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p><cite>Y = X * W</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>units</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of hidden units of the dense transformation.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision dense.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.depth_to_space">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">depth_to_space</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">block_size</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'DCR'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.depth_to_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert channels into spatial blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input data with channels divisible by block_size**2</p></li>
<li><p><strong>block_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Size of blocks to convert channels into.</p></li>
<li><p><strong>layout</strong> (<em>string</em>) – One of NCHW or NHWC, indicates channel axis.</p></li>
<li><p><strong>mode</strong> (<em>string</em>) – One of DCR or CDR, indicates which order channels
are accessed in.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> –</p>
<dl class="simple">
<dt>Tensor with shape [in_batch, in_channel / block_size * block_size,</dt><dd><p>in_height * block_size, in_width * block_size]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.dilate">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">dilate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">strides</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.dilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Dilate data with zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – n-D, can be any layout.</p></li>
<li><p><strong>strides</strong> (<em>&lt;tuple of &lt;int&gt;</em>) – Dilation stride on each dimension, 1 means no dilation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Output</strong> – The computed result</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.dropout">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">dropout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">rate</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the dropout operation to the input array.</p>
<p>During training, each element of the input is set to zero with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. The whole array is rescaled by <code class="docutils literal notranslate"><span class="pre">1/(1-p)</span></code>
to keep the expected sum of the input unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – The probability for an element to be reset to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The result of dropout</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.dropout_raw">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">dropout_raw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">rate</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.dropout_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the dropout operation to the input array.</p>
<p>During training, each element of the input is set to zero with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. The whole array is rescaled by <code class="docutils literal notranslate"><span class="pre">1/(1-p)</span></code>
to keep the expected sum of the input unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – The probability for an element to be reset to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The result of dropout</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.fifo_buffer">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">fifo_buffer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">buffer</span></em>, <em class="sig-param"><span class="n">axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.fifo_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>FIFO buffer to enable computation reuse in CNNs with sliding indow input</p>
<p>Compute equivalent of</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">concat</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
<span class="o">.</span><span class="n">slice_axis</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">begin</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
            <span class="n">end</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">+</span><span class="nb">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
</pre></div>
</div>
<p>Useful for</p>
<ul class="simple">
<li><p>Encoding explicit re-use of computation in convolution ops operated on a sliding window input</p></li>
<li><p>Implementing a FIFO queue to cache intermediate results, e.g. as in Fast WaveNet.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data</p></li>
<li><p><strong>buffer</strong> (<em>tvm.relay.Expr</em>) – Previous value of the FIFO buffer</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Specify which axis should be used for buffering</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Updated value for the buffer</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.get_pad_tuple1d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">get_pad_tuple1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">padding</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.get_pad_tuple1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Common code to get the 1 dimensional pad option
:param padding: Padding size
:type padding: Union[int, Tuple[int, …]]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>pad_left</strong> (<em>int</em>) – Padding size on left</p></li>
<li><p><strong>pad_right</strong> (<em>int</em>) – Padding size on right.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.get_pad_tuple2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">get_pad_tuple2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">padding</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.get_pad_tuple2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Common code to get the pad option
:param padding: Padding size
:type padding: Union[int, Tuple[int, …]]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>pad_top</strong> (<em>int</em>) – Padding size on top</p></li>
<li><p><strong>pad_left</strong> (<em>int</em>) – Padding size on left</p></li>
<li><p><strong>pad_down</strong> (<em>int</em>) – Padding size on down.</p></li>
<li><p><strong>pad_right</strong> (<em>int</em>) – Padding size on right.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.get_pad_tuple3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">get_pad_tuple3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">padding</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.get_pad_tuple3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Common code to get the pad option
:param padding: Padding size
:type padding: Union[int, Tuple[int, …]]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>pad_front</strong> (<em>int</em>) – Padding size on front</p></li>
<li><p><strong>pad_top</strong> (<em>int</em>) – Padding size on top</p></li>
<li><p><strong>pad_left</strong> (<em>int</em>) – Padding size on left</p></li>
<li><p><strong>pad_back</strong> (<em>int</em>) – Padding size on back</p></li>
<li><p><strong>pad_down</strong> (<em>int</em>) – Padding size on down.</p></li>
<li><p><strong>pad_right</strong> (<em>int</em>) – Padding size on right.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.global_avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">global_avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.global_avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D global average pooling operator.</p>
<p>This operator takes data as input and does 2D average value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, 1, 1)  = \frac{1}{h * w} \sum_{m=0}^{h-1} \sum_{n=0}^{w-1}
     \mbox{data}(b, c, m, n)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.global_avg_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">global_avg_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.global_avg_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D global average pooling operator.</p>
<p>This operator takes data as input and does 3D average value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, d, h, w)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, 1, 1, 1)  = \frac{1}{d * h * w} \sum_{l=0}^{d-1}  \sum_{m=0}^{h-1}
     \sum_{n=0}^{w-1} \mbox{data}(b, c, l, m, n)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.global_max_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">global_max_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.global_max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D global maximum pooling operator.</p>
<p>This operator takes data as input and does 2D max value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, 1, 1)  = \max_{m=0, \ldots, h} \max_{n=0, \ldots, w}
     \mbox{data}(b, c, m, n)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.global_max_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">global_max_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.global_max_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D global maximum pooling operator.</p>
<p>This operator takes data as input and does 3D max value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, d, h, w)
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre>\<span class="n">mbox</span><span class="p">{</span><span class="n">out</span><span class="p">}(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="o">=</span>  \<span class="n">max_</span><span class="p">{</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \<span class="n">ldots</span><span class="p">,</span> <span class="n">d</span><span class="p">},</span>  \<span class="n">max_</span><span class="p">{</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \<span class="n">ldots</span><span class="p">,</span> <span class="n">h</span><span class="p">},</span>
     \<span class="n">max_</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \<span class="n">ldots</span><span class="p">,</span> <span class="n">w</span><span class="p">}</span> \<span class="n">mbox</span><span class="p">{</span><span class="n">data</span><span class="p">}(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.group_norm">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">group_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">gamma</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">num_groups</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.group_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Group normalization normalizes over group of channels for each training examples.
We can say that, Group Norm is in between Instance Norm and Layer Norm. When we put
all the channels into a single group, group normalization becomes Layer normalization.
And, when we put each channel into different groups it becomes Instance normalization</p>
<p><a class="reference external" href="https://arxiv.org/pdf/1803.08494.pdf">https://arxiv.org/pdf/1803.08494.pdf</a></p>
<p>Applies group normalization to the n-dimensional input array by seperating the input channels
into ‘num_groups’ groups, each containing ‘num_channels / num_groups’ channels.
The mean and standard-deviation are calculated separately over the each group. gamma and
beta are learnable per-channel affine transform parameter vectors of size num_channels.</p>
<div class="math notranslate nohighlight">
\[out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis)+\epsilon}}
    * gamma + beta\]</div>
<p>Unlike batch normalization, the mean and var are computed along a group of channels.</p>
<p>If the input has size k on axis 1, then both gamma and beta have shape (k,).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which group_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>num_groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of groups to separate the channels into.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – The axis of the channels.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, multiply by gamma. If False, gamma is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The normalized data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.instance_norm">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">instance_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">gamma</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.instance_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance Normalization (Ulyanov and et al., 2016)
Applies instance normalization to the n-dimensional input array.</p>
<div class="math notranslate nohighlight">
\[out = \frac{data - mean(data)}{\sqrt{var(data)+\epsilon}}
    * gamma + beta\]</div>
<p>The instance normalization is similar to batch normalization, but unlike
batch normalization, the mean and var are calculated per-dimension
separately for each object(instance) in a mini-batch, not over a batch.
And the same normalization is applied both at test and train time.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal notranslate"><span class="pre">gamma</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>
have shape <em>(k,)</em>.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’.  The default is 1. Specifying -1 sets the channel axis
to be the last item in the input shape.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which instance_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Specify along which shape axis the channel is specified.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, multiply by gamma. If False, gamma is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>result</strong> (<em>tvm.relay.Expr</em>) – The normalized data.</p></li>
<li><p><strong>.. _`Instance Normalization</strong> (The Missing Ingredient for Fast Stylization`:) – <a class="reference external" href="https://arxiv.org/abs/1607.08022">https://arxiv.org/abs/1607.08022</a></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.l2_normalize">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">l2_normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">eps</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.l2_normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform L2 normalization on the input data</p>
<div class="math notranslate nohighlight">
\[y(i, j) = x(i, j) / sqrt(max(sum(x^2), eps))\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – epsilon value</p></li>
<li><p><strong>axis</strong> (<em>list of int</em><em>, </em><em>optional</em>) – axis over the normalization applied</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.layer_norm">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">layer_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">gamma</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.layer_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer normalization (Lei Ba and et al., 2016).
Applies layer normalization to the n-dimensional input array.
This operator takes an n-dimensional input array and normalizes
the input using the given axis:</p>
<div class="math notranslate nohighlight">
\[out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis)+\epsilon}}
    * gamma + beta\]</div>
<p>Unlike batch normalization, the mean and var are computed along the channel dimension.</p>
<p>Assume the input has size k on axis 1, then both gamma and beta have shape (k,).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which layer_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – The axis that should be normalized, typically the axis of the channels.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, multiply by gamma. If False, gamma is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The normalized data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.leaky_relu">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">leaky_relu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.leaky_relu" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does Leaky version
of a Rectified Linear Unit.</p>
<div class="math notranslate nohighlight">
\[`y = x &gt; 0 ? x : alpha * x`\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Slope coefficient for the negative half axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.log_softmax">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">log_softmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.log_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes log softmax.</p>
<div class="math notranslate nohighlight">
\[\text{log_softmax}(x)_i = \log \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The axis to sum over when computing log softmax</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.lrn">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">lrn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">0.75</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.lrn" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does local response normalization.</p>
<p>Normalize the input in a local region across or within feature maps.
Each input value is divided by (data / (bias + (alpha * sum_data ^2 /size))^beta)
where n is the size of each local region, and the sum is taken over the region
centered at that value (zero padding is added where necessary).</p>
<div class="math notranslate nohighlight">
\[(data / (bias + (alpha * sum_data ^2 /size))^beta)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The size of the local region to be considered for normalization.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Input data layout channel axis. Default value is 1 for NCHW format</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The offset parameter to avoid dividing by 0.</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The scaling parameter.</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The exponent parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.max_pool1d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">max_pool1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.max_pool1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D maximum pooling operator.</p>
<p>This operator takes data as input and does 1D max value calculation
with in pool_size sized window by striding defined by stride.</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
a data Tensor with shape <cite>(batch_size, channels, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.max_pool2d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">max_pool2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D maximum pooling operator.</p>
<p>This operator takes data as input and does 2D max value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w) and pool_size (kh, kw)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, y, x)  = \max_{m=0, \ldots, kh-1} \max_{n=0, \ldots, kw-1}
     \mbox{data}(b, c, \mbox{stride}[0] * y + m, \mbox{stride}[1] * x + n)\]</div>
<p>Padding is applied to data before the computation.
ceil_mode is used to take ceil or floor while computing out shape.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.max_pool2d_grad">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">max_pool2d_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">out_grad</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.max_pool2d_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of 2D maximum pooling operator.</p>
<p>This operator takes out_grad and data as input and calculates gradient of max_pool2d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out_grad</strong> (<em>tvm.relay.Expr</em>) – The output gradient</p></li>
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.max_pool3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">max_pool3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pool_size</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em>, <em class="sig-param"><span class="n">ceil_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.max_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D maximum pooling operator.</p>
<p>This operator takes data as input and does 3D max value calculation
with in pool_size sized window by striding defined by stride.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, channels, depth, height, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>pool_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The size of window for pooling.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.mirror_pad">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">mirror_pad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pad_width</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'SYMMETRIC'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.mirror_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>MirrorPadding</p>
<p>This operator takes in a tensor and pads each axis by the specified
widths using mirroring of the border pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator</p></li>
<li><p><strong>pad_width</strong> (<em>tuple of &lt;tuple of &lt;int&gt;&gt;</em><em>, </em><em>required</em>) – Number of values padded to the edges of each axis, in the format
of ((before_1, after_1), …, (before_N, after_N))</p></li>
<li><p><strong>mode</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default='SYMMETRIC'</em>) – What type of mirroring to use, must be SYMMETRIC or REFLECT.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.pad">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">pad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pad_width</span></em>, <em class="sig-param"><span class="n">pad_value</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">pad_mode</span><span class="o">=</span><span class="default_value">'constant'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Padding</p>
<p>This operator takes in a tensor and pads each axis by the specified
widths using the specified value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator</p></li>
<li><p><strong>pad_width</strong> (<em>tuple of &lt;tuple of &lt;int&gt;&gt;</em><em>, </em><em>required</em>) – Number of values padded to the edges of each axis, in the format
of ((before_1, after_1), …, (before_N, after_N))</p></li>
<li><p><strong>pad_value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default=0.0</em>) – The value used for padding</p></li>
<li><p><strong>pad_mode</strong> (<em>'constant'</em><em>, </em><em>'edge'</em><em>, </em><em>'reflect'</em>) – ‘constant’ pads with constant_value pad_value
‘edge’ pads using the edge values of the input array
‘reflect’ pads by reflecting values with respect to the edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.prelu">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">prelu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.prelu" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does Leaky version
of a Rectified Linear Unit.</p>
<div class="math notranslate nohighlight">
\[`y = x &gt; 0 ? x : alpha * x`\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>alpha</strong> (<em>tvm.relay.Expr</em>) – Slope coefficient for the negative half axis.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Specify which shape axis the channel is specified.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.relu">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">relu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectified linear unit.</p>
<div class="math notranslate nohighlight">
\[out = max(x, 0)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.softmax">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">softmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes softmax.</p>
<div class="math notranslate nohighlight">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The axis to sum over when computing softmax</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.space_to_depth">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">space_to_depth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">block_size</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.space_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert spatial blocks into channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input data with spatial dimensions divisible by block_size</p></li>
<li><p><strong>block_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Size of blocks to decompose into channels.</p></li>
<li><p><strong>layout</strong> (<em>string</em>) – One of NCHW or NHWC, indicates channel axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> –</p>
<dl class="simple">
<dt>Tensor with shape [in_batch, in_channel * block_size * block_size,</dt><dd><p>in_height / block_size, in_width / block_size]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.sparse_dense">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">sparse_dense</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">weight</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.sparse_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix multiplication of <cite>data</cite> and <cite>weight</cite>, where <cite>data</cite> is
a dense matrix and <cite>weight</cite> is a sparse (either BSR or CSR) namedtuple with
fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>.</p>
<div class="math notranslate nohighlight">
\[\mbox{sparse_dense}(data, weight)[m, n] = \mbox{matmul}(x, \mbox{as_dense}(weight)^T)[m, n]\]</div>
<p>where <cite>as_dense</cite> returns dense equivalent of the given sparse matrix.</p>
<p>See
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html</a>
and
<a class="reference external" href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.bsr_matrix.html">https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.bsr_matrix.html</a>
for more detail on the sparse matrix representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data for the matrix multiplication</p></li>
<li><p><strong>weight</strong> (<em>namedtuple.</em>) – The sparse weight matrix for the matrix multiplication.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.sparse_transpose">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">sparse_transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.sparse_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the fast matrix transpose of x,
where x is a sparse tensor in CSR format (represented as a namedtuple
with fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>).</p>
<p>** Currently only support Square Matrices **</p>
<div class="math notranslate nohighlight">
\[\mbox{sparse_transpose}(x)[n, n] = (x^T)[n, n]\]</div>
<p>Please refer to <a class="reference external" href="https://github.com/scipy/scipy/blob/v1.3.0/scipy/sparse/csr.py">https://github.com/scipy/scipy/blob/v1.3.0/scipy/sparse/csr.py</a>
for the algorithm implemented in this operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>namedtuple.</em>) – The sparse weight matrix for the fast matrix transpose.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Tuple of output sparse tensor (same shape and format as input),
i.e. if CSR then output is in ([data, indices, indptr]) form</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple">relay.Tuple</a>([tvm.relay.Expr, tvm.relay.Expr, tvm.relay.Expr])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.upsampling">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">upsampling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">scale_h</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">scale_w</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCHW'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'nearest_neighbor'</span></em>, <em class="sig-param"><span class="n">align_corners</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.upsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsampling.</p>
<p>This operator takes data as input and does 2D scaling to the given scale factor.
In the default case, where the data_layout is <cite>NCHW</cite>
with data of shape (n, c, h, w)
out will have a shape (n, c, h*scale_h, w*scale_w)</p>
<p>method indicates the algorithm to be used while calculating the out value
and method can be one of (“bilinear”, “nearest_neighbor”, “bicubic”)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>scale_h</strong> (<em>tvm.relay.Expr</em>) – The scale factor for height upsampling.</p></li>
<li><p><strong>scale_w</strong> (<em>tvm.relay.Expr</em>) – The scale factor for width upsampling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Scale method to used [nearest_neighbor, bilinear, bicubic].</p></li>
<li><p><strong>align_corners</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to keep corners in proper place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.relay.nn.upsampling3d">
<code class="sig-prename descclassname">tvm.relay.nn.</code><code class="sig-name descname">upsampling3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">scale_d</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">scale_h</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">scale_w</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">layout</span><span class="o">=</span><span class="default_value">'NCDHW'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'nearest_neighbor'</span></em>, <em class="sig-param"><span class="n">coordinate_transformation_mode</span><span class="o">=</span><span class="default_value">'half_pixel'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.nn.upsampling3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D Upsampling.</p>
<p>This operator takes data as input and does 3D scaling to the given scale factor.
In the default case, where the data_layout is <cite>NCDHW</cite>
with data of shape (n, c, d, h, w)
out will have a shape (n, c, d*scale_d, h*scale_h, w*scale_w)</p>
<p>method indicates the algorithm to be used while calculating the out value
and method can be one of (“trilinear”, “nearest_neighbor”)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>scale_d</strong> (<em>tvm.relay.Expr</em>) – The scale factor for depth upsampling.</p></li>
<li><p><strong>scale_h</strong> (<em>tvm.relay.Expr</em>) – The scale factor for height upsampling.</p></li>
<li><p><strong>scale_w</strong> (<em>tvm.relay.Expr</em>) – The scale factor for width upsampling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Scale method to used [nearest_neighbor, trilinear].</p></li>
<li><p><strong>coordinate_transformation_mode</strong> (<em>string</em><em>, </em><em>optional</em>) – Describes how to transform the coordinate in the resized tensor
to the coordinate in the original tensor.
Refer to the ONNX Resize operator specification for details.
Available options are “half_pixel”, “align_corners” and “asymmetric”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vision.html" class="btn btn-neutral float-right" title="tvm.relay.vision" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="frontend.html" class="btn btn-neutral float-left" title="tvm.relay.frontend" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>