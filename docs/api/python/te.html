

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tvm.te &mdash; tvm 0.7.dev1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/tvm-logo-square.png"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/tvm_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="tvm.driver" href="driver.html" />
    <link rel="prev" title="tvm.tir" href="tir.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.7.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vta/index.html">VTA: Deep Learning Accelerator Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deploy/index.html">Deploy and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute to TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../langref/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="runtime.html">tvm.runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="ndarray.html">tvm.runtime.ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="error.html">tvm.error</a></li>
<li class="toctree-l2"><a class="reference internal" href="ir.html">tvm.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="ir.html#module-tvm.transform">tvm.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">tvm.target</a></li>
<li class="toctree-l2"><a class="reference internal" href="tir.html">tvm.tir</a></li>
<li class="toctree-l2"><a class="reference internal" href="tir.html#module-tvm.tir.transform">tvm.tir.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="tir.html#module-tvm.tir.analysis">tvm.tir.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="tir.html#module-tvm.tir.stmt_functor">tvm.tir.stmt_functor</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">tvm.te</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-tvm.te.hybrid">tvm.te.hybrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html">tvm.driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/index.html">tvm.relay</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/frontend.html">tvm.relay.frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/nn.html">tvm.relay.nn</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/vision.html">tvm.relay.vision</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/image.html">tvm.relay.image</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/transform.html">tvm.relay.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/analysis.html">tvm.relay.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/backend.html">tvm.relay.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/dataflow_pattern.html">tvm.relay.dataflow_pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay/testing.html">tvm.relay.testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="autotvm.html">tvm.autotvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="rpc.html">tvm.rpc</a></li>
<li class="toctree-l2"><a class="reference internal" href="micro.html">tvm.micro</a></li>
<li class="toctree-l2"><a class="reference internal" href="contrib.html">tvm.contrib</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_runtime.html">tvm.contrib.graph_runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="vta/index.html">vta</a></li>
<li class="toctree-l2"><a class="reference internal" href="topi.html">topi</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../links.html">Links to API References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/index.html">Design and Developer Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../frontend/tensorflow.html">TensorFlow Frontend</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tvm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Python API</a> &raquo;</li>
        
      <li>tvm.te</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api/python/te.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tvm-te">
<h1>tvm.te<a class="headerlink" href="#tvm-te" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-tvm.te"></span><p>Namespace for Tensor Expression Language</p>
<p><strong>Classes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.ComputeOp" title="tvm.te.ComputeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComputeOp</span></code></a></p></td>
<td><p>Scalar operation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.ExternOp" title="tvm.te.ExternOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExternOp</span></code></a></p></td>
<td><p>External operation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.HybridOp" title="tvm.te.HybridOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HybridOp</span></code></a></p></td>
<td><p>Hybrid operation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.PlaceholderOp" title="tvm.te.PlaceholderOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PlaceholderOp</span></code></a></p></td>
<td><p>Placeholder operation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.ScanOp" title="tvm.te.ScanOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScanOp</span></code></a></p></td>
<td><p>Scan operation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Schedule" title="tvm.te.Schedule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Schedule</span></code></a></p></td>
<td><p>Schedule for all the stages.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.SpecializedCondition" title="tvm.te.SpecializedCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpecializedCondition</span></code></a>(conditions)</p></td>
<td><p>Specialized condition to enable op specialization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage" title="tvm.te.Stage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stage</span></code></a></p></td>
<td><p>A Stage represents schedule for one operation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor</span></code></a></p></td>
<td><p>Tensor object, to construct, see function.Tensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.TensorComputeOp" title="tvm.te.TensorComputeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorComputeOp</span></code></a></p></td>
<td><p>Tensor operation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.TensorSlice" title="tvm.te.TensorSlice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorSlice</span></code></a>(tensor, indices)</p></td>
<td><p>Auxiliary data structure for enable slicing syntax from tensor.</p></td>
</tr>
</tbody>
</table>
<p><strong>Functions</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.abs" title="tvm.te.abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a>(x)</p></td>
<td><p>Get absolute value of the input element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.acos" title="tvm.te.acos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">acos</span></code></a>(x)</p></td>
<td><p>Take acos of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.acosh" title="tvm.te.acosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">acosh</span></code></a>(x)</p></td>
<td><p>Take acos of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.all" title="tvm.te.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>(*args)</p></td>
<td><p>Create a new experssion of the intersection of all conditions in the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.any" title="tvm.te.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>(*args)</p></td>
<td><p>Create a new experssion of the union of all conditions in the arguments</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.asin" title="tvm.te.asin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asin</span></code></a>(x)</p></td>
<td><p>Take asin of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.asinh" title="tvm.te.asinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asinh</span></code></a>(x)</p></td>
<td><p>Take asinh of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.atan" title="tvm.te.atan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atan</span></code></a>(x)</p></td>
<td><p>Take atan of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.atanh" title="tvm.te.atanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atanh</span></code></a>(x)</p></td>
<td><p>Take atanh of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.ceil" title="tvm.te.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>(x)</p></td>
<td><p>Take ceil of float input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.comm_reducer" title="tvm.te.comm_reducer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">comm_reducer</span></code></a>(fcombine, fidentity[, name])</p></td>
<td><p>Create a commutative reducer for reduction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.compute" title="tvm.te.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute</span></code></a>(shape, fcompute[, name, tag, attrs])</p></td>
<td><p>Construct a new tensor by computing over the shape domain.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.cos" title="tvm.te.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a>(x)</p></td>
<td><p>Take cos of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.cosh" title="tvm.te.cosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosh</span></code></a>(x)</p></td>
<td><p>Take cosh of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.create_schedule" title="tvm.te.create_schedule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_schedule</span></code></a>(ops)</p></td>
<td><p>Create a schedule for list of ops</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.decl_tensor_intrin" title="tvm.te.decl_tensor_intrin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decl_tensor_intrin</span></code></a>(op, fcompute[, name, …])</p></td>
<td><p>Declare a tensor intrinsic function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.div" title="tvm.te.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">div</span></code></a>(a, b)</p></td>
<td><p>Compute a / b as in C/C++ semantics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.erf" title="tvm.te.erf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">erf</span></code></a>(x)</p></td>
<td><p>Take gauss error function of the input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.exp" title="tvm.te.exp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp</span></code></a>(x)</p></td>
<td><p>Take exponetial of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.extern" title="tvm.te.extern"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extern</span></code></a>(shape, inputs, fcompute[, name, …])</p></td>
<td><p>Compute several tensor via extern function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.floor" title="tvm.te.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(x)</p></td>
<td><p>Take floor of float input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.floordiv" title="tvm.te.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floordiv</span></code></a>(a, b)</p></td>
<td><p>Compute the floordiv of two expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.floormod" title="tvm.te.floormod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floormod</span></code></a>(a, b)</p></td>
<td><p>Compute the floormod of two expressions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.fmod" title="tvm.te.fmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmod</span></code></a>(x, y)</p></td>
<td><p>Return the remainder of x divided by y with the same sign as x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.gradient" title="tvm.te.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>(output, inputs[, head])</p></td>
<td><p>Perform reverse-mode automatic differentiation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.if_then_else" title="tvm.te.if_then_else"><code class="xref py py-obj docutils literal notranslate"><span class="pre">if_then_else</span></code></a>(cond, t, f)</p></td>
<td><p>Conditional selection expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.indexdiv" title="tvm.te.indexdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexdiv</span></code></a>(a, b)</p></td>
<td><p>Compute floor(a / b) where a and b are non-negative.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.indexmod" title="tvm.te.indexmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexmod</span></code></a>(a, b)</p></td>
<td><p>Compute the remainder of indexdiv.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.isfinite" title="tvm.te.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a>(x)</p></td>
<td><p>Check if input value is finite.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.isinf" title="tvm.te.isinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinf</span></code></a>(x)</p></td>
<td><p>Check if input value is infinite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.isnan" title="tvm.te.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a>(x)</p></td>
<td><p>Check if input value is Nan.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.log" title="tvm.te.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a>(x)</p></td>
<td><p>Take log of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.log10" title="tvm.te.log10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log10</span></code></a>(x)</p></td>
<td><p>Take log10 of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.log2" title="tvm.te.log2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log2</span></code></a>(x)</p></td>
<td><p>Take log2 of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.max" title="tvm.te.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(expr, axis[, where])</p></td>
<td><p>Create a max expression over axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.max_value" title="tvm.te.max_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_value</span></code></a>(dtype)</p></td>
<td><p>maximum value of dtype</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.min" title="tvm.te.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(expr, axis[, where])</p></td>
<td><p>Create a min expression over axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.min_value" title="tvm.te.min_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_value</span></code></a>(dtype)</p></td>
<td><p>minimum value of dtype</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.nearbyint" title="tvm.te.nearbyint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nearbyint</span></code></a>(x)</p></td>
<td><p>Round elements of the array to the nearest integer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.placeholder" title="tvm.te.placeholder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">placeholder</span></code></a>(shape[, dtype, name])</p></td>
<td><p>Construct an empty tensor object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.popcount" title="tvm.te.popcount"><code class="xref py py-obj docutils literal notranslate"><span class="pre">popcount</span></code></a>(x)</p></td>
<td><p>Count the number of set bits in input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.power" title="tvm.te.power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">power</span></code></a>(x, y)</p></td>
<td><p>x power y</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.reduce_axis" title="tvm.te.reduce_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_axis</span></code></a>(dom[, name])</p></td>
<td><p>Create a new IterVar for reduction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.round" title="tvm.te.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a>(x)</p></td>
<td><p>Round elements of the array to the nearest integer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.rsqrt" title="tvm.te.rsqrt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsqrt</span></code></a>(x)</p></td>
<td><p>Take reciprocal of square root of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.scan" title="tvm.te.scan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scan</span></code></a>(init, update, state_placeholder[, …])</p></td>
<td><p>Construct new tensors by scanning over axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.sigmoid" title="tvm.te.sigmoid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sigmoid</span></code></a>(x)</p></td>
<td><p>Quick function to get sigmoid</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.sin" title="tvm.te.sin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sin</span></code></a>(x)</p></td>
<td><p>Take sin of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.sinh" title="tvm.te.sinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code></a>(x)</p></td>
<td><p>Take sinh of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.size_var" title="tvm.te.size_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size_var</span></code></a>([name, dtype])</p></td>
<td><p>Create a new variable represents a tensor shape size, which is non-negative.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.sqrt" title="tvm.te.sqrt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt</span></code></a>(x)</p></td>
<td><p>Take square root of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.sum" title="tvm.te.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(expr, axis[, where])</p></td>
<td><p>Create a sum expression over axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.tag_scope" title="tvm.te.tag_scope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tag_scope</span></code></a>(tag)</p></td>
<td><p>The operator tag scope.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.tan" title="tvm.te.tan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code></a>(x)</p></td>
<td><p>Take tan of input x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.tanh" title="tvm.te.tanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tanh</span></code></a>(x)</p></td>
<td><p>Take hyperbolic tanh of input x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.thread_axis" title="tvm.te.thread_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">thread_axis</span></code></a>([dom, tag, name])</p></td>
<td><p>Create a new IterVar to represent thread index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.trace" title="tvm.te.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>(args[, trace_action])</p></td>
<td><p>Trace tensor data at the runtime.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.trunc" title="tvm.te.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a>(x)</p></td>
<td><p>Get truncated value of the input.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.truncdiv" title="tvm.te.truncdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">truncdiv</span></code></a>(a, b)</p></td>
<td><p>Compute the truncdiv of two expressions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.truncmod" title="tvm.te.truncmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">truncmod</span></code></a>(a, b)</p></td>
<td><p>Compute the truncmod of two expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.var" title="tvm.te.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>([name, dtype])</p></td>
<td><p>Create a new variable with specified name and dtype</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="tvm.te.any">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new experssion of the union of all conditions in the arguments</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – List of symbolic boolean expressions</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>expr</strong> – Expression</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Expr</p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.any" title="tvm.tir.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.any()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.all">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.all" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Create a new experssion of the intersection of all conditions in the</dt><dd><p>arguments</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – List of symbolic boolean expressions</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>expr</strong> – Expression</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Expr</p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.all" title="tvm.tir.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.all()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.min_value">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">min_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dtype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.min_value" title="Permalink to this definition">¶</a></dt>
<dd><p>minimum value of dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The data type.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The minimum value of dtype.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.Expr</p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.min_value" title="tvm.tir.min_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.min_value()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.max_value">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">max_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dtype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.max_value" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum value of dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The data type.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The maximum value of dtype.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.Expr</p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.max_value" title="tvm.tir.max_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.max_value()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.trace">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">trace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">args</span></em>, <em class="sig-param"><span class="n">trace_action</span><span class="o">=</span><span class="default_value">'tvm.default_trace_action'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace tensor data at the runtime.</p>
<p>The trace function allows to trace specific tensor at the
runtime. The tracing value should come as last argument.
The trace action should be specified, by default
tvm.default_trace_action is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>list of Expr</em><em> or </em><em>Buffers.</em>) – Positional arguments.</p></li>
<li><p><strong>trace_action</strong> (<em>str.</em>) – The name of the trace action.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>call</strong> – The call expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="tir.html#tvm.tir.call_packed" title="tvm.tir.call_packed"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.call_packed()</span></code></a></dt><dd><p>Creates packed function.</p>
</dd>
</dl>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.trace" title="tvm.tir.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.trace()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.exp">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Take exponetial of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.exp" title="tvm.tir.exp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.exp()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.erf">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">erf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Take gauss error function of the input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.erf" title="tvm.tir.erf"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.erf()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.tanh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">tanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take hyperbolic tanh of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.tanh" title="tvm.tir.tanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.tanh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.sigmoid">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">sigmoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Quick function to get sigmoid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.sigmoid" title="tvm.tir.sigmoid"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.sigmoid()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.log">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Take log of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.log" title="tvm.tir.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.log()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.tan">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">tan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Take tan of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.tan" title="tvm.tir.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.tan()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.cos">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">cos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Take cos of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.cos" title="tvm.tir.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.cos()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.sin">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">sin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Take sin of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.sin" title="tvm.tir.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.sin()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.sqrt">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Take square root of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.sqrt" title="tvm.tir.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.sqrt()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.rsqrt">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">rsqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.rsqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Take reciprocal of square root of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.rsqrt" title="tvm.tir.rsqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.rsqrt()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.floor">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Take floor of float input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.floor" title="tvm.tir.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.floor()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.ceil">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Take ceil of float input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.ceil" title="tvm.tir.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.ceil()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.sinh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">sinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take sinh of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.sinh" title="tvm.tir.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.sinh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.cosh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">cosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take cosh of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.cosh" title="tvm.tir.cosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.cosh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.log2">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">log2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Take log2 of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.log2" title="tvm.tir.log2"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.log2()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.log10">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Take log10 of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.log10" title="tvm.tir.log10"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.log10()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.asin">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">asin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Take asin of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.asin" title="tvm.tir.asin"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.asin()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.asinh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">asinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.asinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take asinh of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.asinh" title="tvm.tir.asinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.asinh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.acos">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">acos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Take acos of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.acos" title="tvm.tir.acos"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.acos()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.acosh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">acosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.acosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take acos of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.acosh" title="tvm.tir.acosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.acosh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.atan">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">atan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Take atan of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.atan" title="tvm.tir.atan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.atan()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.atanh">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">atanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.atanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Take atanh of input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.atanh" title="tvm.tir.atanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.atanh()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.trunc">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">trunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get truncated value of the input.</p>
<p>The truncated value of the scalar x is the
nearest integer i which is closer to zero than x is.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.trunc" title="tvm.tir.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.trunc()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.abs">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get absolute value of the input element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.abs" title="tvm.tir.abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.abs()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.round">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round elements of the array to the nearest integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.round" title="tvm.tir.round"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.round()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.nearbyint">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">nearbyint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.nearbyint" title="Permalink to this definition">¶</a></dt>
<dd><p>Round elements of the array to the nearest integer.
This intrinsic uses llvm.nearbyint instead of llvm.round
which is faster but will results different from te.round.
Notably nearbyint rounds according to the rounding mode,
whereas te.round (llvm.round) ignores that.
For differences between the two see:
<a class="reference external" href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a>
<a class="reference external" href="https://en.cppreference.com/w/cpp/numeric/math/nearbyint">https://en.cppreference.com/w/cpp/numeric/math/nearbyint</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.nearbyint" title="tvm.tir.nearbyint"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.nearbyint()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.power">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.power" title="Permalink to this definition">¶</a></dt>
<dd><p>x power y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p></li>
<li><p><strong>y</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The exponent</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>z</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.power" title="tvm.tir.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.power()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.popcount">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">popcount</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.popcount" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of set bits in input x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.popcount" title="tvm.tir.popcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.popcount()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.fmod">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">fmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.fmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the remainder of x divided by y with the same sign as x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p></li>
<li><p><strong>y</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>z</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.fmod" title="tvm.tir.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.fmod()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.if_then_else">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">if_then_else</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cond</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.if_then_else" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditional selection expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cond</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The condition</p></li>
<li><p><strong>t</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The result expression if cond is true.</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The result expression if cond is false.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The result of conditional expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.Node" title="tvm.ir.Node">Node</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike Select, if_then_else will not execute
the branch that does not satisfy the condition.
You can use it to guard against out of bound access.
Unlike Select, if_then_else cannot be vectorized
if some lanes in the vector have different conditions.</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.if_then_else" title="tvm.tir.if_then_else"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.if_then_else()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.isnan">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">isnan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if input value is Nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.isnan" title="tvm.tir.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.isnan()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.isfinite">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">isfinite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.isfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if input value is finite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.isfinite" title="tvm.tir.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.isfinite()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.isinf">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">isinf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.isinf" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if input value is infinite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – Input argument.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.isinf" title="tvm.tir.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.isinf()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.div">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">div</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a / b as in C/C++ semantics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand, known to be non-negative.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand, known to be non-negative.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When operands are integers, returns truncdiv(a, b).</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.div" title="tvm.tir.div"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.div()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.indexdiv">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">indexdiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.indexdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute floor(a / b) where a and b are non-negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand, known to be non-negative.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand, known to be non-negative.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use this function to split non-negative indices.
This function may take advantage of operands’
non-negativeness.</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.indexdiv" title="tvm.tir.indexdiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.indexdiv()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.indexmod">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">indexmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.indexmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the remainder of indexdiv. a and b are non-negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand, known to be non-negative.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand, known to be non-negative.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use this function to split non-negative indices.
This function may take advantage of operands’
non-negativeness.</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.indexmod" title="tvm.tir.indexmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.indexmod()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.truncdiv">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">truncdiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.truncdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truncdiv of two expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the default integer division behavior in C.</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.truncdiv" title="tvm.tir.truncdiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.truncdiv()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.truncmod">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">truncmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.truncmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truncmod of two expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the default integer division behavior in C.</p>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.truncmod" title="tvm.tir.truncmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.truncmod()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.floordiv">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the floordiv of two expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.floordiv" title="tvm.tir.floordiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.floordiv()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.floormod">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">floormod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.floormod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the floormod of two expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The left hand operand</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The right hand operand</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result expression.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.floormod" title="tvm.tir.floormod"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.floormod()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.comm_reducer">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">comm_reducer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcombine</span></em>, <em class="sig-param"><span class="n">fidentity</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'reduce'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.comm_reducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a commutative reducer for reduction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcombine</strong> (<em>function</em><em>(</em><em>Expr -&gt; Expr -&gt; Expr</em><em>)</em>) – A binary function which takes two Expr as input to return a Expr.</p></li>
<li><p><strong>fidentity</strong> (<em>function</em><em>(</em><em>str -&gt; Expr</em><em>)</em>) – A function which takes a type string as input to return a const Expr.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>reducer</strong> – A function which creates a reduce expression over axis.
There are two ways to use it:</p>
<ol class="arabic simple">
<li><p>accept (expr, axis, where) to produce an Reduce Expr on
specified axis;</p></li>
<li><p>simply use it with multiple Exprs.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">mysum</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">comm_reducer</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">tir</span><span class="o">.</span><span class="n">const</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">t</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mysum&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">mysum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.comm_reducer" title="tvm.tir.comm_reducer"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.comm_reducer()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.min">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a min expression over axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The source expression.</p></li>
<li><p><strong>axis</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The reduction IterVar axis</p></li>
<li><p><strong>where</strong> (<em>optional</em><em>, </em><em>Expr</em>) – Filtering predicate of the reduction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The result value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>

<span class="c1"># there are two way to use this min reducer:</span>
<span class="c1"># mode 1, accept (expr, axis, where) to produce an Reduce Expr</span>
<span class="c1"># tvm.min represents tvm.te.min or tvm.tir.min.</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>

<span class="c1"># mode 2, simply use it with multiple Exprs:</span>
<span class="n">min_res</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.min" title="tvm.tir.min"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.min()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.max">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a max expression over axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The source expression.</p></li>
<li><p><strong>axis</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The reduction IterVar axis</p></li>
<li><p><strong>where</strong> (<em>optional</em><em>, </em><em>Expr</em>) – Filtering predicate of the reduction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The result value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>

<span class="c1"># there are two way to use this max reducer:</span>
<span class="c1"># mode 1, accept (expr, axis, where) to produce an Reduce Expr</span>
<span class="c1"># tvm.max represents tvm.te.max or tvm.tir.max.</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>

<span class="c1"># mode 2, simply use it with multiple Exprs:</span>
<span class="n">max_res</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.max" title="tvm.tir.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.max()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.sum">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sum expression over axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a>) – The source expression.</p></li>
<li><p><strong>axis</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The reduction IterVar axis</p></li>
<li><p><strong>where</strong> (<em>optional</em><em>, </em><em>Expr</em>) – Filtering predicate of the reduction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The result value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>

<span class="c1"># there are two way to use this sum reducer:</span>
<span class="c1"># mode 1, accept (expr, axis, where) to produce an Reduce Expr</span>
<span class="c1"># tvm.sum represents tvm.te.sum or tvm.tir.sum.</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>

<span class="c1"># mode 2, simply use it with multiple Exprs:</span>
<span class="n">sum_res</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Alias of <a class="reference internal" href="tir.html#tvm.tir.sum" title="tvm.tir.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.tir.sum()</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.Schedule">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">Schedule</code><a class="headerlink" href="#tvm.te.Schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule for all the stages.</p>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Schedule.cache_read" title="tvm.te.Schedule.cache_read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_read</span></code></a>(tensor, scope, readers)</p></td>
<td><p>Create a cache read of original tensor for readers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Schedule.cache_write" title="tvm.te.Schedule.cache_write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_write</span></code></a>(tensor, scope)</p></td>
<td><p>Create a cache write of original tensor, before storing into tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Schedule.create_group" title="tvm.te.Schedule.create_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_group</span></code></a>(outputs, inputs[, include_inputs])</p></td>
<td><p>Create stage group by giving output and input boundary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Schedule.normalize" title="tvm.te.Schedule.normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize</span></code></a>()</p></td>
<td><p>Build a normalized schedule from the current schedule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Schedule.rfactor" title="tvm.te.Schedule.rfactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfactor</span></code></a>(tensor, axis[, factor_axis])</p></td>
<td><p>Factor a reduction axis in tensor’s schedule to be an explicit axis.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.Schedule.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Schedule.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a normalized schedule from the current schedule.</p>
<p>Insert necessary rebase to make certain iter var to start from 0.
This is needed before bound inference and followup step.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sch</strong> – The normalized schedule.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.te.Schedule" title="tvm.te.Schedule">Schedule</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Schedule.create_group">
<code class="sig-name descname">create_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">outputs</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">include_inputs</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Schedule.create_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Create stage group by giving output and input boundary.</p>
<p>The operators between outputs and inputs are placed as member of group.
outputs are include in the group, while inputs are not included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outputs</strong> (<em>list of Tensors</em>) – The outputs of the group.</p></li>
<li><p><strong>inputs</strong> (<em>list of Tensors</em>) – The inputs of the group.</p></li>
<li><p><strong>include_inputs</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether include input operations in the group if they are used by outputs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>group</strong> – A virtual stage represents the group, user can use compute_at to move
the attachment point of the group.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Stage" title="tvm.te.Stage">Stage</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Schedule.cache_read">
<code class="sig-name descname">cache_read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor</span></em>, <em class="sig-param"><span class="n">scope</span></em>, <em class="sig-param"><span class="n">readers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Schedule.cache_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cache read of original tensor for readers.</p>
<p>This will mutate the body of the readers.
A new cache stage will be created for the tensor.
Call this before doing any split/fuse schedule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a>) – The tensor to be cached.</p></li>
<li><p><strong>scope</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The scope of cached</p></li>
<li><p><strong>readers</strong> (<em>list of Tensor</em><em> or </em><em>Operation</em>) – The readers to read the cache.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cache</strong> – The created cache tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Schedule.cache_write">
<code class="sig-name descname">cache_write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor</span></em>, <em class="sig-param"><span class="n">scope</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Schedule.cache_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cache write of original tensor, before storing into tensor.</p>
<p>This will mutate the body of the tensor.
A new cache stage will created before feed into the tensor.</p>
<p>This function can be used to support data layout transformation.
If there is a split/fuse/reorder on the data parallel axis of tensor
before cache_write is called. The intermediate cache stores
the data in the layout as the iteration order of leave axis.
The data will be transformed back to the original layout in the original tensor.
User can further call compute_inline to inline the original layout and keep
the data stored in the transformed layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a>) – The tensors to be feed to. All the tensors must be produced by one computeOp</p></li>
<li><p><strong>scope</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The scope of cached</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cache</strong> – The created cache tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Schedule.rfactor">
<code class="sig-name descname">rfactor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">factor_axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Schedule.rfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor a reduction axis in tensor’s schedule to be an explicit axis.</p>
<p>This will create a new stage that generated the new tensor with axis
as the first dimension. The tensor’s body will be rewritten as a reduction
over the factored tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a>) – The tensor to be factored.</p></li>
<li><p><strong>axis</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The reduction axis in the schedule to be factored.</p></li>
<li><p><strong>factor_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The position where the new axis is placed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tfactor</strong> – The created factored tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a> or Array of Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="tvm.te.Stage">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">Stage</code><a class="headerlink" href="#tvm.te.Stage" title="Permalink to this definition">¶</a></dt>
<dd><p>A Stage represents schedule for one operation.</p>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.bind" title="tvm.te.Stage.bind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bind</span></code></a>(ivar, thread_ivar)</p></td>
<td><p>Bind ivar to thread index thread_ivar</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.compute_at" title="tvm.te.Stage.compute_at"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_at</span></code></a>(parent, scope)</p></td>
<td><p>Attach the stage at parent’s scope</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.compute_inline" title="tvm.te.Stage.compute_inline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_inline</span></code></a>()</p></td>
<td><p>Mark stage as inline</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.compute_root" title="tvm.te.Stage.compute_root"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_root</span></code></a>()</p></td>
<td><p>Attach the stage at parent, and mark it as root</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.double_buffer" title="tvm.te.Stage.double_buffer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">double_buffer</span></code></a>()</p></td>
<td><p>Compute the current stage via double buffering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.env_threads" title="tvm.te.Stage.env_threads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">env_threads</span></code></a>(threads)</p></td>
<td><p>Mark threads to be launched at the outer scope of composed op.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.fuse" title="tvm.te.Stage.fuse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fuse</span></code></a>(*args)</p></td>
<td><p>Fuse multiple consecutive iteration variables into a single iteration variable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.parallel" title="tvm.te.Stage.parallel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parallel</span></code></a>(var)</p></td>
<td><p>Parallelize the iteration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.pragma" title="tvm.te.Stage.pragma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pragma</span></code></a>(var, pragma_type[, pragma_value])</p></td>
<td><p>Annotate the iteration with pragma</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.prefetch" title="tvm.te.Stage.prefetch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prefetch</span></code></a>(tensor, var, offset)</p></td>
<td><p>Prefetch the specified variable</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.reorder" title="tvm.te.Stage.reorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder</span></code></a>(*args)</p></td>
<td><p>reorder the arguments in the specified order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.set_scope" title="tvm.te.Stage.set_scope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_scope</span></code></a>(scope)</p></td>
<td><p>Set the thread scope of this stage</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.set_store_predicate" title="tvm.te.Stage.set_store_predicate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_store_predicate</span></code></a>(predicate)</p></td>
<td><p>Set predicate under which store to the array can be performed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.split" title="tvm.te.Stage.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(parent[, factor, nparts])</p></td>
<td><p>Split the stage either by factor providing outer scope, or both</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.storage_align" title="tvm.te.Stage.storage_align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage_align</span></code></a>(axis, factor, offset)</p></td>
<td><p>Set alignment requirement for specific axis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.tensorize" title="tvm.te.Stage.tensorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensorize</span></code></a>(var, tensor_intrin)</p></td>
<td><p>Tensorize the computation enclosed by var with tensor_intrin</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.tile" title="tvm.te.Stage.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(x_parent, y_parent, x_factor, y_factor)</p></td>
<td><p>Perform tiling on two dimensions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Stage.unroll" title="tvm.te.Stage.unroll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unroll</span></code></a>(var)</p></td>
<td><p>Unroll the iteration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Stage.vectorize" title="tvm.te.Stage.vectorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vectorize</span></code></a>(var)</p></td>
<td><p>Vectorize the iteration.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.Stage.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">factor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nparts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the stage either by factor providing outer scope, or both</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parent</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The parent iter var.</p></li>
<li><p><strong>factor</strong> (<em>Expr</em><em>, </em><em>optional</em>) – The splitting factor</p></li>
<li><p><strong>nparts</strong> (<em>Expr</em><em>, </em><em>optional</em>) – The number of outer parts.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>outer</strong> (<em>IterVar</em>) – The outer variable of iteration.</p></li>
<li><p><strong>inner</strong> (<em>IterVar</em>) – The inner variable of iteration.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.fuse">
<code class="sig-name descname">fuse</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.fuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuse multiple consecutive iteration variables into a single iteration variable.</p>
<p>fused = fuse(…fuse(fuse(args[0], args[1]), args[2]),…, args[-1])
The order is from outer to inner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<em>list of IterVars</em>) – Itervars that proceeds each other</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>fused</strong> – The fused variable of iteration.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar">IterVar</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.set_scope">
<code class="sig-name descname">set_scope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scope</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.set_scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the thread scope of this stage</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scope</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The thread scope of this stage</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.bind">
<code class="sig-name descname">bind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ivar</span></em>, <em class="sig-param"><span class="n">thread_ivar</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind ivar to thread index thread_ivar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ivar</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration to be binded to thread.</p></li>
<li><p><strong>thread_ivar</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The thread to be binded.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.env_threads">
<code class="sig-name descname">env_threads</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">threads</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.env_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark threads to be launched at the outer scope of composed op.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threads</strong> (<em>list of threads</em>) – The threads to be launched.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.set_store_predicate">
<code class="sig-name descname">set_store_predicate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.set_store_predicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set predicate under which store to the array can be performed.</p>
<p>Use this when there are duplicated threads doing the same store and we only
need one of them to do the store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>predicate</strong> (<em>Expr</em>) – The guard condition fo store.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.compute_at">
<code class="sig-name descname">compute_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">scope</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.compute_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach the stage at parent’s scope</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parent</strong> (<a class="reference internal" href="#tvm.te.Stage" title="tvm.te.Stage"><em>Stage</em></a>) – The parent stage</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The loop scope t be attached to.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.compute_inline">
<code class="sig-name descname">compute_inline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.compute_inline" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark stage as inline</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parent</strong> (<a class="reference internal" href="#tvm.te.Stage" title="tvm.te.Stage"><em>Stage</em></a>) – The parent stage</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.compute_root">
<code class="sig-name descname">compute_root</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.compute_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach the stage at parent, and mark it as root</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parent</strong> (<a class="reference internal" href="#tvm.te.Stage" title="tvm.te.Stage"><em>Stage</em></a>) – The parent stage</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.reorder">
<code class="sig-name descname">reorder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>reorder the arguments in the specified order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<em>list of IterVar</em>) – The order to be ordered</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.tile">
<code class="sig-name descname">tile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_parent</span></em>, <em class="sig-param"><span class="n">y_parent</span></em>, <em class="sig-param"><span class="n">x_factor</span></em>, <em class="sig-param"><span class="n">y_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform tiling on two dimensions</p>
<p>The final loop order from outmost to inner most are
[x_outer, y_outer, x_inner, y_inner]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_parent</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The original x dimension</p></li>
<li><p><strong>y_parent</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The original y dimension</p></li>
<li><p><strong>x_factor</strong> (<em>Expr</em>) – The stride factor on x axis</p></li>
<li><p><strong>y_factor</strong> (<em>Expr</em>) – The stride factor on y axis</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x_outer</strong> (<em>IterVar</em>) – Outer axis of x dimension</p></li>
<li><p><strong>y_outer</strong> (<em>IterVar</em>) – Outer axis of y dimension</p></li>
<li><p><strong>x_inner</strong> (<em>IterVar</em>) – Inner axis of x dimension</p></li>
<li><p><strong>p_y_inner</strong> (<em>IterVar</em>) – Inner axis of y dimension</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.vectorize">
<code class="sig-name descname">vectorize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorize the iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration to be vectorize</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.tensorize">
<code class="sig-name descname">tensorize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">tensor_intrin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.tensorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensorize the computation enclosed by var with tensor_intrin</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration boundary of tensorization.</p></li>
<li><p><strong>tensor_intrin</strong> (<em>TensorIntrin</em>) – The tensor intrinsic used for computation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.unroll">
<code class="sig-name descname">unroll</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.unroll" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll the iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration to be unrolled.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.parallel">
<code class="sig-name descname">parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallelize the iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration to be parallelized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.pragma">
<code class="sig-name descname">pragma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">pragma_type</span></em>, <em class="sig-param"><span class="n">pragma_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate the iteration with pragma</p>
<p>This will translate to a pragma_scope surrounding
the corresponding loop generated.
Useful to support experimental features and extensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The iteration to be anotated</p></li>
<li><p><strong>pragma_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The pragma string to be annotated</p></li>
<li><p><strong>pragma_value</strong> (<em>Expr</em><em>, </em><em>optional</em>) – The pragma value to pass along the pragma</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most pragmas are advanced/experimental features
and may subject to change. List of supported pragmas:</p>
<ul>
<li><p><strong>debug_skip_region</strong></p>
<p>Force skip the region marked by the axis and turn it into no-op.
This is useful for debug purposes.</p>
</li>
<li><p><strong>parallel_launch_point</strong></p>
<p>Specify to launch parallel threads outside the
specified iteration loop. By default the threads
launch at the point of parallel construct.
This pragma moves the launching point to even outer scope.
The threads are launched once and reused across multiple
parallel constructs as BSP style program.</p>
</li>
<li><p><strong>parallel_barrier_when_finish</strong></p>
<p>Insert a synchronization barrier between working threads
after the specified loop iteration finishes.</p>
</li>
<li><p><strong>parallel_stride_pattern</strong></p>
<p>Hint parallel loop to execute in strided pattern.
<code class="code docutils literal notranslate"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">task_id;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">end;</span> <span class="pre">i</span> <span class="pre">+=</span> <span class="pre">num_task)</span></code></p>
</li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.prefetch">
<code class="sig-name descname">prefetch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor</span></em>, <em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">offset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.prefetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Prefetch the specified variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a>) – The tensor to be prefetched</p></li>
<li><p><strong>var</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The loop point at which the prefetching is applied</p></li>
<li><p><strong>offset</strong> (<em>Expr</em>) – The number of iterations to be prefetched before actual execution</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.storage_align">
<code class="sig-name descname">storage_align</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">factor</span></em>, <em class="sig-param"><span class="n">offset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.storage_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Set alignment requirement for specific axis</p>
<p>This ensures that stride[axis] == k * factor + offset for some k.
This is useful to set memory layout to for more friendly memory
access pattern. For example, we can set alignment to be
factor=2, offset=1 to avoid bank conflict for thread access on
higher dimension in GPU shared memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a>) – The axis dimension to be aligned.</p></li>
<li><p><strong>factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The factor in alignment specification.</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The offset in the alignment specification.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Stage.double_buffer">
<code class="sig-name descname">double_buffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.Stage.double_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the current stage via double buffering.</p>
<p>This can only be applied to intermediate stage.
This will double the storage cost of the current stage.
Can be useful to hide load latency.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="tvm.te.create_schedule">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">create_schedule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ops</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.create_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a schedule for list of ops</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ops</strong> (<em>list of Operations</em>) – The source expression.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sch</strong> – The created schedule.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>schedule.Schedule</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.SpecializedCondition">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">SpecializedCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conditions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.SpecializedCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized condition to enable op specialization.</p>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.SpecializedCondition.current" title="tvm.te.SpecializedCondition.current"><code class="xref py py-obj docutils literal notranslate"><span class="pre">current</span></code></a>()</p></td>
<td><p>Returns the current specialized condition</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.SpecializedCondition.current">
<em class="property">static </em><code class="sig-name descname">current</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.SpecializedCondition.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current specialized condition</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="tvm.te.TensorSlice">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">TensorSlice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tensor</span></em>, <em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.TensorSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary data structure for enable slicing syntax from tensor.</p>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.TensorSlice.asobject" title="tvm.te.TensorSlice.asobject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asobject</span></code></a>()</p></td>
<td><p>Convert slice to object.</p></td>
</tr>
</tbody>
</table>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.TensorSlice.dtype" title="tvm.te.TensorSlice.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
<td><p>Data content of the tensor.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.TensorSlice.asobject">
<code class="sig-name descname">asobject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.TensorSlice.asobject" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert slice to object.</p>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.TensorSlice.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#tvm.te.TensorSlice.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data content of the tensor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="tvm.te.Tensor">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">Tensor</code><a class="headerlink" href="#tvm.te.Tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor object, to construct, see function.Tensor</p>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Tensor.axis" title="tvm.te.Tensor.axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code></a></p></td>
<td><p>Axis of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Tensor.ndim" title="tvm.te.Tensor.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></p></td>
<td><p>Dimension of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Tensor.op" title="tvm.te.Tensor.op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">op</span></code></a></p></td>
<td><p>The corressponding <code class="xref py py-class docutils literal notranslate"><span class="pre">Operation</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.Tensor.shape" title="tvm.te.Tensor.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></p></td>
<td><p>The output shape of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.Tensor.value_index" title="tvm.te.Tensor.value_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_index</span></code></a></p></td>
<td><p>The output value index the tensor corresponds to.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.Tensor.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#tvm.te.Tensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Tensor.axis">
<em class="property">property </em><code class="sig-name descname">axis</code><a class="headerlink" href="#tvm.te.Tensor.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Axis of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Tensor.op">
<em class="property">property </em><code class="sig-name descname">op</code><a class="headerlink" href="#tvm.te.Tensor.op" title="Permalink to this definition">¶</a></dt>
<dd><p>The corressponding <code class="xref py py-class docutils literal notranslate"><span class="pre">Operation</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Tensor.value_index">
<em class="property">property </em><code class="sig-name descname">value_index</code><a class="headerlink" href="#tvm.te.Tensor.value_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The output value index the tensor corresponds to.</p>
</dd></dl>

<dl class="py method">
<dt id="tvm.te.Tensor.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#tvm.te.Tensor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The output shape of the tensor.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="tvm.te.decl_tensor_intrin">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">decl_tensor_intrin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">op</span></em>, <em class="sig-param"><span class="n">fcompute</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'tensor_intrin'</span></em>, <em class="sig-param"><span class="n">binds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scalar_params</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">default_buffer_params</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.decl_tensor_intrin" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a tensor intrinsic function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> (<em>Operation</em>) – The symbolic description of the intrinsic operation</p></li>
<li><p><strong>fcompute</strong> (<em>lambda function of inputs</em><em>, </em><em>outputs-&gt; stmt</em>) – <p>Specifies the IR statement to do the computation.
See the following note for function signature of fcompute</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong>ins</strong> (list of <a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a>) - Placeholder for each inputs</p></li>
<li><p><strong>outs</strong> (list of <a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a>) - Placeholder for each outputs</p></li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><p><strong>stmt</strong> (<a class="reference internal" href="tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Stmt</span></code></a>, or tuple of three stmts)</p></li>
<li><p>If a single stmt is returned, it represents the body</p></li>
<li><p>If tuple of three stmts are returned they corresponds to body,
reduce_init, reduce_update</p></li>
</ul>
</div>
</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the intrinsic.</p></li>
<li><p><strong>binds</strong> (dict of <a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a> to <a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a>, optional) – Dictionary that maps the Tensor to Buffer which specified the data layout
requirement of the function. By default, a new compact buffer is created
for each tensor in the argument.</p></li>
<li><p><strong>scalar_params</strong> (<em>a list of variables used by op</em><em>, </em><em>whose values will be passed</em>) – as scalar_inputs when the tensor intrinsic is called.</p></li>
<li><p><strong>default_buffer_params</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>]</em>) – Dictionary of buffer arguments to be passed when constructing a buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intrin</strong> – A TensorIntrin that can be used in tensorize schedule.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>TensorIntrin</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.tag_scope">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">tag_scope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.tag_scope" title="Permalink to this definition">¶</a></dt>
<dd><p>The operator tag scope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The tag name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tag_scope</strong> – The tag scope object, which can be used as decorator or
context manger.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>TagScope</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">te</span><span class="o">.</span><span class="n">tag_scope</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s1">&#39;matmul&#39;</span><span class="p">):</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">te</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>

<span class="c1"># or use tag_scope as decorator</span>
<span class="nd">@tvm.te.tag_scope</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;conv&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_relu</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">i</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">tir</span><span class="o">.</span><span class="n">Select</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.placeholder">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">placeholder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'placeholder'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.placeholder" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an empty tensor object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Tuple of Expr</em>) – The shape of the tensor</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The data type of the tensor</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name hint of the tensor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tensor</strong> – The created tensor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.compute">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">compute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">fcompute</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'compute'</span></em>, <em class="sig-param"><span class="n">tag</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">attrs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new tensor by computing over the shape domain.</p>
<p>The compute rule is result[axis] = fcompute(axis)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Tuple of Expr</em>) – The shape of the tensor</p></li>
<li><p><strong>fcompute</strong> (<em>lambda function of indices-&gt; value</em>) – Specifies the input source expression</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name hint of the tensor</p></li>
<li><p><strong>tag</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Additional tag information about the compute.</p></li>
<li><p><strong>attrs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><em>optional</em>) – The additional auxiliary attributes about the compute.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tensor</strong> – The created tensor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.scan">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">scan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">init</span></em>, <em class="sig-param"><span class="n">update</span></em>, <em class="sig-param"><span class="n">state_placeholder</span></em>, <em class="sig-param"><span class="n">inputs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'scan'</span></em>, <em class="sig-param"><span class="n">tag</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">attrs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct new tensors by scanning over axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em> or </em><em>list of Tensor</em>) – The initial condition of first init.shape[0] timestamps</p></li>
<li><p><strong>update</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em> or </em><em>list of Tensor</em>) – The update rule of the scan given by symbolic tensor.</p></li>
<li><p><strong>state_placeholder</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em> or </em><em>list of Tensor</em>) – The placeholder variables used by update.</p></li>
<li><p><strong>inputs</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em> or </em><em>list of Tensor</em><em>, </em><em>optional</em>) – The list of inputs to the scan. This is not required, but can
be useful for the compiler to detect scan body faster.</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name hint of the tensor</p></li>
<li><p><strong>tag</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Additonal tag information about the compute.</p></li>
<li><p><strong>attrs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><em>optional</em>) – The additional auxiliary attributes about the compute.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tensor</strong> – The created tensor or tuple of tensors it it contains multiple outputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a> or list of Tensors</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="c1"># The following code is equivalent to numpy.cumsum</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="n">s_state</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="n">s_init</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
<span class="n">s_update</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">s_state</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">te</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">s_init</span><span class="p">,</span> <span class="n">s_update</span><span class="p">,</span> <span class="n">s_state</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.extern">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">extern</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">fcompute</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'extern'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">in_buffers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out_buffers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tag</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">attrs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.extern" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute several tensor via extern function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em> or </em><em>list of tuples.</em>) – The shape of the outputs.</p></li>
<li><p><strong>inputs</strong> (<em>list of Tensor</em>) – The inputs</p></li>
<li><p><strong>fcompute</strong> (<em>lambda function of inputs</em><em>, </em><em>outputs-&gt; stmt</em>) – <p>Specifies the IR statement to do the computation.
See the following note for function signature of fcompute</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong>ins</strong> (list of <a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a>) - Placeholder for each inputs</p></li>
<li><p><strong>outs</strong> (list of <a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a>) - Placeholder for each outputs</p></li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><p><strong>stmt</strong> (<a class="reference internal" href="tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Stmt</span></code></a>) - The statement that carries out array computation.</p></li>
</ul>
</div>
</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name hint of the tensor</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em> or </em><em>list of str</em><em>, </em><em>optional</em>) – The data types of outputs,
by default dtype will be same as inputs.</p></li>
<li><p><strong>in_buffers</strong> (<a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>Buffer</em></a><em> or </em><em>list of Buffer</em><em>, </em><em>optional</em>) – Input buffers.</p></li>
<li><p><strong>out_buffers</strong> (<a class="reference internal" href="tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>Buffer</em></a><em> or </em><em>list of Buffers</em><em>, </em><em>optional</em>) – Output buffers.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>tag: str, optional</dt><dd><p>Additonal tag information about the compute.</p>
</dd>
<dt>attrs: dict, optional</dt><dd><p>The additional auxiliary attributes about the compute.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tensor</strong> – The created tensor or tuple of tensors it it contains multiple outputs.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a> or list of Tensors</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In the code below, C is generated by calling external PackedFunc
<cite>tvm.contrib.cblas.matmul</cite></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">extern</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span>
               <span class="k">lambda</span> <span class="n">ins</span><span class="p">,</span> <span class="n">outs</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">tir</span><span class="o">.</span><span class="n">call_packed</span><span class="p">(</span>
                  <span class="s2">&quot;tvm.contrib.cblas.matmul&quot;</span><span class="p">,</span>
                    <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.var">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'tindex'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'int32'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable with specified name and dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The name</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>var</strong> – The result symbolic variable.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tir.html#tvm.tir.Var" title="tvm.tir.Var">Var</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.size_var">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">size_var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'size'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'int32'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.size_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable represents a tensor shape size, which is non-negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The name</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>var</strong> – The result symbolic shape variable.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tir.html#tvm.tir.SizeVar" title="tvm.tir.SizeVar">SizeVar</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.thread_axis">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">thread_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dom</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tag</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.thread_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new IterVar to represent thread index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dom</strong> (<a class="reference internal" href="ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The domain of iteration
When str is passed, dom is set to None and str is used as tag</p></li>
<li><p><strong>tag</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The thread tag</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the var.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>axis</strong> – The thread itervar.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar">IterVar</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.reduce_axis">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">reduce_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dom</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'rv'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.reduce_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new IterVar for reduction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dom</strong> (<a class="reference internal" href="ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a>) – The domain of iteration.</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The name of the variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>axis</strong> – An iteration variable representing the value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar">IterVar</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.PlaceholderOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">PlaceholderOp</code><a class="headerlink" href="#tvm.te.PlaceholderOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Placeholder operation.</p>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.ComputeOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">ComputeOp</code><a class="headerlink" href="#tvm.te.ComputeOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar operation.</p>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.TensorComputeOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">TensorComputeOp</code><a class="headerlink" href="#tvm.te.TensorComputeOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor operation.</p>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.ScanOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">ScanOp</code><a class="headerlink" href="#tvm.te.ScanOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan operation.</p>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.ScanOp.scan_axis" title="tvm.te.ScanOp.scan_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scan_axis</span></code></a></p></td>
<td><p>Represent the scan axis, only defined when it is a ScanOp</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.ScanOp.scan_axis">
<em class="property">property </em><code class="sig-name descname">scan_axis</code><a class="headerlink" href="#tvm.te.ScanOp.scan_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the scan axis, only defined when it is a ScanOp</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="tvm.te.ExternOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">ExternOp</code><a class="headerlink" href="#tvm.te.ExternOp" title="Permalink to this definition">¶</a></dt>
<dd><p>External operation.</p>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.HybridOp">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">HybridOp</code><a class="headerlink" href="#tvm.te.HybridOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Hybrid operation.</p>
<p><strong>Attributes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.HybridOp.axis" title="tvm.te.HybridOp.axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code></a></p></td>
<td><p>Represent the IterVar axis, also defined when it is a HybridOp</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.HybridOp.axis">
<em class="property">property </em><code class="sig-name descname">axis</code><a class="headerlink" href="#tvm.te.HybridOp.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the IterVar axis, also defined when it is a HybridOp</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="tvm.te.gradient">
<code class="sig-prename descclassname">tvm.te.</code><code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">head</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform reverse-mode automatic differentiation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a>) – The tensor to differentiate.</p></li>
<li><p><strong>inputs</strong> (<a class="reference internal" href="relay/dataflow_pattern.html#tvm.relay.dataflow_pattern.List" title="tvm.relay.dataflow_pattern.List"><em>List</em></a><em>[</em><a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a><em>]</em>) – The list of input tensors to be differentiated wrt.</p></li>
<li><p><strong>head</strong> (<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor"><em>Tensor</em></a>) – The adjoint of the output, in other words, some tensor, by which the Jacobians
will be multiplied. Its shape must be of the form <cite>prefix + output.shape</cite>.
If <cite>None</cite> is passed, the identity tensor of shape <cite>output.shape + output.shape</cite>
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tensors</strong> – The result gradient, in the same order as the inputs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="relay/dataflow_pattern.html#tvm.relay.dataflow_pattern.List" title="tvm.relay.dataflow_pattern.List">List</a>[<a class="reference internal" href="#tvm.te.Tensor" title="tvm.te.Tensor">Tensor</a>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">w1</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w1&#39;</span><span class="p">)</span>
<span class="n">w2</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w2&#39;</span><span class="p">)</span>
<span class="n">z1</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z2</span><span class="p">)</span>

<span class="c1"># produce gradients</span>
<span class="p">[</span><span class="n">dw1</span><span class="p">,</span> <span class="n">dw2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">])</span>

<span class="c1"># produce Jacobians</span>
<span class="p">[</span><span class="n">jw1</span><span class="p">,</span> <span class="n">jw2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">])</span>

<span class="c1"># produce gradients, the head adjoint for z2 is provided manually</span>
<span class="p">[</span><span class="n">dw1</span><span class="p">,</span> <span class="n">dw2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">],</span> <span class="n">topi</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-tvm.te.hybrid">
<span id="tvm-te-hybrid"></span><h1>tvm.te.hybrid<a class="headerlink" href="#module-tvm.te.hybrid" title="Permalink to this headline">¶</a></h1>
<p>Hybrid Programming APIs of TVM Python Package.</p>
<p>This package maps a subset of python to HalideIR so that:
1. Users can write some preliminary versions of the computation patterns
have not been supported yet and verify it across the real execution and
python semantic emulation.
2. So far, it is a text format dedicated to HalideIR Phase 0. Refer tvm.lower
for more details. A larger ambition of this module is to support all levels of
HalideIR.</p>
<p><strong>Classes</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.hybrid.HybridModule" title="tvm.te.hybrid.HybridModule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HybridModule</span></code></a>([src, name])</p></td>
<td><p>The usage of Hybrid Module is very similar to conventional TVM module, but conventional TVM module requires a function body which is already fully lowered.</p></td>
</tr>
</tbody>
</table>
<p><strong>Functions</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.hybrid.build" title="tvm.te.hybrid.build"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build</span></code></a>(sch, inputs, outputs[, name])</p></td>
<td><p>Dump the corrent schedule to hybrid module</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.hybrid.decorate" title="tvm.te.hybrid.decorate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decorate</span></code></a>(func, fwrapped)</p></td>
<td><p>A wrapper call of decorator package, differs to call time</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.hybrid.script" title="tvm.te.hybrid.script"><code class="xref py py-obj docutils literal notranslate"><span class="pre">script</span></code></a>(pyfunc)</p></td>
<td><p>Decorate a python function function as hybrid script.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tvm.te.hybrid.source_to_op" title="tvm.te.hybrid.source_to_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source_to_op</span></code></a>(src, args, symbols, closure_vars)</p></td>
<td><p>Another level of wrapper</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="tvm.te.hybrid.decorate">
<code class="sig-prename descclassname">tvm.te.hybrid.</code><code class="sig-name descname">decorate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">fwrapped</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.decorate" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper call of decorator package, differs to call time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> (<em>function</em>) – The original function</p></li>
<li><p><strong>fwrapped</strong> (<em>function</em>) – The wrapped function</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="tvm.te.hybrid.HybridModule">
<em class="property">class </em><code class="sig-prename descclassname">tvm.te.hybrid.</code><code class="sig-name descname">HybridModule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.HybridModule" title="Permalink to this definition">¶</a></dt>
<dd><p>The usage of Hybrid Module is very similar to conventional TVM module,
but conventional TVM module requires a function body which is already fully
lowered. This contradicts to the fact that Hybrid Module is originally a text
format for Phase 0 HalideIR. Thus, a totally separated module is defined.</p>
<p><strong>Methods</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tvm.te.hybrid.HybridModule.load" title="tvm.te.hybrid.HybridModule.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(path)</p></td>
<td><p>Load the module from a python file</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tvm.te.hybrid.HybridModule.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.HybridModule.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the module from a python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Path to the given python file</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="tvm.te.hybrid.source_to_op">
<code class="sig-prename descclassname">tvm.te.hybrid.</code><code class="sig-name descname">source_to_op</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src</span></em>, <em class="sig-param"><span class="n">args</span></em>, <em class="sig-param"><span class="n">symbols</span></em>, <em class="sig-param"><span class="n">closure_vars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.source_to_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Another level of wrapper</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>ast.node</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – If an ast.node, then directly lower it.
If a str, then parse it to ast and lower it.</p></li>
<li><p><strong>args</strong> (<em>list of Tensors</em><em> or </em><em>Vars</em>) – The argument lists to the function.
It is NOT encouraged to write a function without arguments.
It is NOT encouraged to write a function with side effect.</p></li>
<li><p><strong>symbols</strong> (<em>list of str</em>) – The symbol list of the global context of the function.</p></li>
<li><p><strong>closure_vars</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – A dict of external name reference captured by this function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The result of output tensors of the formed OpNode.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of output tensors</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.hybrid.script">
<code class="sig-prename descclassname">tvm.te.hybrid.</code><code class="sig-name descname">script</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pyfunc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.script" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a python function function as hybrid script.</p>
<p>The hybrid function support emulation mode and parsing to
the internal language IR.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hybrid_func</strong> – A decorated hybrid script function.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tvm.te.hybrid.build">
<code class="sig-prename descclassname">tvm.te.hybrid.</code><code class="sig-name descname">build</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sch</span></em>, <em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">outputs</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'hybrid_func'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.te.hybrid.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the corrent schedule to hybrid module</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sch</strong> (<a class="reference internal" href="#tvm.te.Schedule" title="tvm.te.Schedule"><em>Schedule</em></a>) – The schedule to be dumped</p></li>
<li><p><strong>inputs</strong> (<em>An array of Tensors</em><em> or </em><em>Vars</em>) – The inputs of the function body</p></li>
<li><p><strong>outputs</strong> (<em>An array of Tensors</em>) – The outputs of the function body</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>module</strong> – The built results is wrapped in a HybridModule.
The usage of HybridModule is roughly the same as normal TVM-built modules.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.te.hybrid.HybridModule" title="tvm.te.hybrid.HybridModule">HybridModule</a></p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="driver.html" class="btn btn-neutral float-right" title="tvm.driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tir.html" class="btn btn-neutral float-left" title="tvm.tir" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>