<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: include/tvm/runtime/c_runtime_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b4c7d8e826c599ba55146c099a14beb5.html">tvm</a></li><li class="navelem"><a class="el" href="dir_404558507ed35459f0d7a6d81d8c508d.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">c_runtime_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;dlpack/dlpack.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for c_runtime_api.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="c__runtime__api_8h__incl.svg" width="330" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="c__runtime__api_8h__dep__incl.svg" width="3588" height="1124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="c__runtime__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionTVMValue.html">TVMValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union type of values being passed through API and function calls.  <a href="unionTVMValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTVMByteArray.html">TVMByteArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte array type used to pass in byte array When kTVMBytes is used as data type.  <a href="structTVMByteArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4d6bcd569c115f7ae4ddc455b14ca395"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a4d6bcd569c115f7ae4ddc455b14ca395">TVM_WEAK</a>&#160;&#160;&#160;__attribute__((weak))</td></tr>
<tr class="separator:a4d6bcd569c115f7ae4ddc455b14ca395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429515e9851601ec44c8ed421521ab6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a429515e9851601ec44c8ed421521ab6d">TVM_VERSION</a>&#160;&#160;&#160;&quot;0.11.dev0&quot;</td></tr>
<tr class="separator:a429515e9851601ec44c8ed421521ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ace8007daffd9f2c6d954c24d870bfcc4"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ace8007daffd9f2c6d954c24d870bfcc4">tvm_index_t</a></td></tr>
<tr class="memdesc:ace8007daffd9f2c6d954c24d870bfcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of array index.  <a href="#ace8007daffd9f2c6d954c24d870bfcc4">More...</a><br /></td></tr>
<tr class="separator:ace8007daffd9f2c6d954c24d870bfcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca58cb32f4a4adf71d274dc1e27be4"><td class="memItemLeft" align="right" valign="top">typedef DLTensor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a></td></tr>
<tr class="memdesc:a73ca58cb32f4a4adf71d274dc1e27be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the array handle  <a href="#a73ca58cb32f4a4adf71d274dc1e27be4">More...</a><br /></td></tr>
<tr class="separator:a73ca58cb32f4a4adf71d274dc1e27be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b0321c489287dcf4637e15328298ce"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a></td></tr>
<tr class="memdesc:ac4b0321c489287dcf4637e15328298ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to TVM runtime modules.  <a href="#ac4b0321c489287dcf4637e15328298ce">More...</a><br /></td></tr>
<tr class="separator:ac4b0321c489287dcf4637e15328298ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf57d257a6e0841d84ebbd2a339d183e"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a></td></tr>
<tr class="memdesc:acf57d257a6e0841d84ebbd2a339d183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to packed function handle.  <a href="#acf57d257a6e0841d84ebbd2a339d183e">More...</a><br /></td></tr>
<tr class="separator:acf57d257a6e0841d84ebbd2a339d183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd1076476117e74454f67931c2da1d4"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a></td></tr>
<tr class="memdesc:a6cd1076476117e74454f67931c2da1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to hold return value.  <a href="#a6cd1076476117e74454f67931c2da1d4">More...</a><br /></td></tr>
<tr class="separator:a6cd1076476117e74454f67931c2da1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d5f6b7945e1410602a8a057fda5757"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a></td></tr>
<tr class="memdesc:ab1d5f6b7945e1410602a8a057fda5757"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream that is specific to device can be NULL, which indicates the default one.  <a href="#ab1d5f6b7945e1410602a8a057fda5757">More...</a><br /></td></tr>
<tr class="separator:ab1d5f6b7945e1410602a8a057fda5757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff795d001e3761c75b2b8f422465d5a0"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a></td></tr>
<tr class="memdesc:aff795d001e3761c75b2b8f422465d5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to Object.  <a href="#aff795d001e3761c75b2b8f422465d5a0">More...</a><br /></td></tr>
<tr class="separator:aff795d001e3761c75b2b8f422465d5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07954203342f2787acf988c4c351d9c3"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a07954203342f2787acf988c4c351d9c3">TVMPackedCFunc</a>) (<a class="el" href="unionTVMValue.html">TVMValue</a> *args, int *type_codes, int num_args, <a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a> ret, void *resource_handle)</td></tr>
<tr class="memdesc:a07954203342f2787acf988c4c351d9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C type of packed function.  <a href="#a07954203342f2787acf988c4c351d9c3">More...</a><br /></td></tr>
<tr class="separator:a07954203342f2787acf988c4c351d9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac035a1354f2e5d7f8613af73cc735742"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ac035a1354f2e5d7f8613af73cc735742">TVMPackedCFuncFinalizer</a>) (void *resource_handle)</td></tr>
<tr class="memdesc:ac035a1354f2e5d7f8613af73cc735742"><td class="mdescLeft">&#160;</td><td class="mdescRight">C callback to free the resource handle in C packed function.  <a href="#ac035a1354f2e5d7f8613af73cc735742">More...</a><br /></td></tr>
<tr class="separator:ac035a1354f2e5d7f8613af73cc735742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3980ab80477e57fc6045c12ea8b9e48d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a3980ab80477e57fc6045c12ea8b9e48d">TVMExtensionFuncDeclarer</a>) (<a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> register_func_handle)</td></tr>
<tr class="memdesc:a3980ab80477e57fc6045c12ea8b9e48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for extension function declarer.  <a href="#a3980ab80477e57fc6045c12ea8b9e48d">More...</a><br /></td></tr>
<tr class="separator:a3980ab80477e57fc6045c12ea8b9e48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a57cbccb14c35a0e62dbc1b911188fcef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcef">TVMDeviceExtType</a> { <br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcefad77aa5af5411ed9f3719f48af1f04b02">kDLAOCL</a> = 32, 
<a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcefacdc33f5efa9ddabe89e886c28d1ff65b">kDLSDAccel</a>, 
<a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcefa72361be679c1aca1c1be5f9b500a3315">kOpenGL</a>, 
<a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcefa3357ff71d095bc9bdbe5116599bade5f">kDLMicroDev</a>, 
<br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcefa474961a2b52fee7b33e529015162e884">TVMDeviceExtType_End</a>
<br />
 }<tr class="memdesc:a57cbccb14c35a0e62dbc1b911188fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension device types in TVM.  <a href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcef">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a57cbccb14c35a0e62dbc1b911188fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190e81769e805cca153514137a66e793"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793">TVMArgTypeCode</a> { <br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a72d85fbd104ae87b054f93ddd8e1476b">kTVMArgInt</a> = kDLInt, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793add0097597aa4905490e0140d9af406ae">kTVMArgFloat</a> = kDLFloat, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a9387f774bc8453afe4aa4cd17789a405">kTVMOpaqueHandle</a> = 3U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793ada22c3d9c62fa8f40d46e80ce83b96a1">kTVMNullptr</a> = 4U, 
<br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a6ee930a6be374837d4d85dbe1abeb842">kTVMDataType</a> = 5U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a924f1cfac1f15ee1995cb10fc0af4479">kDLDevice</a> = 6U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a8bd637c4caa55b04490fe26b250e3d86">kTVMDLTensorHandle</a> = 7U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793abe76912731a3c65bd7cdd9ab9a462c66">kTVMObjectHandle</a> = 8U, 
<br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a41343a05e42d08053d9fa1da85f70af6">kTVMModuleHandle</a> = 9U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a396e8ab64a9b33d46bcbedb84819f194">kTVMPackedFuncHandle</a> = 10U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793af2b95de1a09ed39055edfe8ef5ea484d">kTVMStr</a> = 11U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a4b2f3688d719f6e7c20ab00659e2383e">kTVMBytes</a> = 12U, 
<br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a3bab8c80e57b1ab2d7ab95962be4d2ec">kTVMNDArrayHandle</a> = 13U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793ad742641b52cb5098f576373021a1399d">kTVMObjectRValueRefArg</a> = 14U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a2bea0a5b50b0e24384610059bf1cbdc9">kTVMExtBegin</a> = 15U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a6aa6b0afb212bea097b2c71eb366214c">kTVMNNVMFirst</a> = 16U, 
<br />
&#160;&#160;<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a3b2e1234b4f579630a5a936e042912b6">kTVMNNVMLast</a> = 20U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a2a80307d3075829e12d14ba6ec52a6ee">kTVMExtReserveEnd</a> = 64U, 
<a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793a463445886242b0357db59f74241ce028">kTVMExtEnd</a> = 128U
<br />
 }<tr class="memdesc:a190e81769e805cca153514137a66e793"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type code in used and only used in TVM FFI for argument passing.  <a href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a190e81769e805cca153514137a66e793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a477111f9accd70633dc5f2e7139b6cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a477111f9accd70633dc5f2e7139b6cf4">TVMAPISetLastError</a> (const char *msg)</td></tr>
<tr class="memdesc:a477111f9accd70633dc5f2e7139b6cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for implementing C API function. Set last error message before return.  <a href="#a477111f9accd70633dc5f2e7139b6cf4">More...</a><br /></td></tr>
<tr class="separator:a477111f9accd70633dc5f2e7139b6cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775383bcd8c0237e36bdf0c9654d62c3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a775383bcd8c0237e36bdf0c9654d62c3">TVMGetLastError</a> (void)</td></tr>
<tr class="memdesc:a775383bcd8c0237e36bdf0c9654d62c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return str message of the last error all function in this file will return 0 when success and nonzero when an error occurred, TVMGetLastError can be called to retrieve the error  <a href="#a775383bcd8c0237e36bdf0c9654d62c3">More...</a><br /></td></tr>
<tr class="separator:a775383bcd8c0237e36bdf0c9654d62c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f79bb2004573a8e36a175d1b73fc64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a47f79bb2004573a8e36a175d1b73fc64">TVMModLoadFromFile</a> (const char *file_name, const char *format, <a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> *out)</td></tr>
<tr class="memdesc:a47f79bb2004573a8e36a175d1b73fc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load module from file.  <a href="#a47f79bb2004573a8e36a175d1b73fc64">More...</a><br /></td></tr>
<tr class="separator:a47f79bb2004573a8e36a175d1b73fc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb0d67f6d7e90e671dd5a53b1d6b81a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#aaeb0d67f6d7e90e671dd5a53b1d6b81a">TVMModImport</a> (<a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> mod, <a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> dep)</td></tr>
<tr class="memdesc:aaeb0d67f6d7e90e671dd5a53b1d6b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add dep to mod's dependency. This allows functions in this module to use modules.  <a href="#aaeb0d67f6d7e90e671dd5a53b1d6b81a">More...</a><br /></td></tr>
<tr class="separator:aaeb0d67f6d7e90e671dd5a53b1d6b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19a18084c94396a673efa309405a6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a5a19a18084c94396a673efa309405a6c">TVMModGetFunction</a> (<a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> mod, const char *func_name, int query_imports, <a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *out)</td></tr>
<tr class="memdesc:a5a19a18084c94396a673efa309405a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function from the module.  <a href="#a5a19a18084c94396a673efa309405a6c">More...</a><br /></td></tr>
<tr class="separator:a5a19a18084c94396a673efa309405a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16764609b45ac911a5c9971e195e377"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ac16764609b45ac911a5c9971e195e377">TVMModFree</a> (<a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> mod)</td></tr>
<tr class="memdesc:ac16764609b45ac911a5c9971e195e377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the Module.  <a href="#ac16764609b45ac911a5c9971e195e377">More...</a><br /></td></tr>
<tr class="separator:ac16764609b45ac911a5c9971e195e377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af420f0d74004615c03bb40270ad5d489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#af420f0d74004615c03bb40270ad5d489">TVMFuncFree</a> (<a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> func)</td></tr>
<tr class="memdesc:af420f0d74004615c03bb40270ad5d489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the function when it is no longer needed.  <a href="#af420f0d74004615c03bb40270ad5d489">More...</a><br /></td></tr>
<tr class="separator:af420f0d74004615c03bb40270ad5d489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01e20ffd5784465df0759c950154b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a8a01e20ffd5784465df0759c950154b5">TVMFuncCall</a> (<a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> func, <a class="el" href="unionTVMValue.html">TVMValue</a> *arg_values, int *type_codes, int num_args, <a class="el" href="unionTVMValue.html">TVMValue</a> *ret_val, int *ret_type_code)</td></tr>
<tr class="memdesc:a8a01e20ffd5784465df0759c950154b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a Packed TVM Function.  <a href="#a8a01e20ffd5784465df0759c950154b5">More...</a><br /></td></tr>
<tr class="separator:a8a01e20ffd5784465df0759c950154b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c98ff469bd844546a71f61d2e164f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ad0c98ff469bd844546a71f61d2e164f3">TVMCFuncSetReturn</a> (<a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a> ret, <a class="el" href="unionTVMValue.html">TVMValue</a> *value, int *type_code, int num_ret)</td></tr>
<tr class="memdesc:ad0c98ff469bd844546a71f61d2e164f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the return value of TVMPackedCFunc.  <a href="#ad0c98ff469bd844546a71f61d2e164f3">More...</a><br /></td></tr>
<tr class="separator:ad0c98ff469bd844546a71f61d2e164f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee438ab81fbf4235375d9f17f36d6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a6fee438ab81fbf4235375d9f17f36d6f">TVMCbArgToReturn</a> (<a class="el" href="unionTVMValue.html">TVMValue</a> *value, int *code)</td></tr>
<tr class="memdesc:a6fee438ab81fbf4235375d9f17f36d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace translate callback argument value to return value. This is only needed for non-POD arguments.  <a href="#a6fee438ab81fbf4235375d9f17f36d6f">More...</a><br /></td></tr>
<tr class="separator:a6fee438ab81fbf4235375d9f17f36d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8d1f9e7229625d4acd7da3b10287c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#adfd8d1f9e7229625d4acd7da3b10287c">TVMFuncCreateFromCFunc</a> (<a class="el" href="c__runtime__api_8h.html#a07954203342f2787acf988c4c351d9c3">TVMPackedCFunc</a> func, void *resource_handle, <a class="el" href="c__runtime__api_8h.html#ac035a1354f2e5d7f8613af73cc735742">TVMPackedCFuncFinalizer</a> fin, <a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *out)</td></tr>
<tr class="memdesc:adfd8d1f9e7229625d4acd7da3b10287c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a TVMPackedCFunc to become a FunctionHandle.  <a href="#adfd8d1f9e7229625d4acd7da3b10287c">More...</a><br /></td></tr>
<tr class="separator:adfd8d1f9e7229625d4acd7da3b10287c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642167d9a76bfe7e81174e8776d504b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a9642167d9a76bfe7e81174e8776d504b">TVMFuncRegisterGlobal</a> (const char *name, <a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> f, int override)</td></tr>
<tr class="memdesc:a9642167d9a76bfe7e81174e8776d504b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the function to runtime's global table.  <a href="#a9642167d9a76bfe7e81174e8776d504b">More...</a><br /></td></tr>
<tr class="separator:a9642167d9a76bfe7e81174e8776d504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd42da244a0e32ac82d7428e01a010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ad3bd42da244a0e32ac82d7428e01a010">TVMFuncGetGlobal</a> (const char *name, <a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *out)</td></tr>
<tr class="memdesc:ad3bd42da244a0e32ac82d7428e01a010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a global function.  <a href="#ad3bd42da244a0e32ac82d7428e01a010">More...</a><br /></td></tr>
<tr class="separator:ad3bd42da244a0e32ac82d7428e01a010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392740d028710fcd356b2b63ab90fd01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a392740d028710fcd356b2b63ab90fd01">TVMFuncListGlobalNames</a> (int *out_size, const char ***out_array)</td></tr>
<tr class="memdesc:a392740d028710fcd356b2b63ab90fd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all the globally registered function name.  <a href="#a392740d028710fcd356b2b63ab90fd01">More...</a><br /></td></tr>
<tr class="separator:a392740d028710fcd356b2b63ab90fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98d6b66089da8b33b662ccdb243b26b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ab98d6b66089da8b33b662ccdb243b26b">TVMFuncRemoveGlobal</a> (const char *name)</td></tr>
<tr class="memdesc:ab98d6b66089da8b33b662ccdb243b26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a global function.  <a href="#ab98d6b66089da8b33b662ccdb243b26b">More...</a><br /></td></tr>
<tr class="separator:ab98d6b66089da8b33b662ccdb243b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014b89c1a3b17473d82cb3973eeedba7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a014b89c1a3b17473d82cb3973eeedba7">TVMArrayAlloc</a> (const <a class="el" href="c__runtime__api_8h.html#ace8007daffd9f2c6d954c24d870bfcc4">tvm_index_t</a> *shape, int ndim, int dtype_code, int dtype_bits, int dtype_lanes, int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> *out)</td></tr>
<tr class="memdesc:a014b89c1a3b17473d82cb3973eeedba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a nd-array's memory, including space of shape, of given spec.  <a href="#a014b89c1a3b17473d82cb3973eeedba7">More...</a><br /></td></tr>
<tr class="separator:a014b89c1a3b17473d82cb3973eeedba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e48e52098965e235657dab56bc096"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a591e48e52098965e235657dab56bc096">TVMArrayFree</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle)</td></tr>
<tr class="memdesc:a591e48e52098965e235657dab56bc096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the TVM Array.  <a href="#a591e48e52098965e235657dab56bc096">More...</a><br /></td></tr>
<tr class="separator:a591e48e52098965e235657dab56bc096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e9b3dfdc1f4228bf52a26da14456a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a50e9b3dfdc1f4228bf52a26da14456a1">TVMArrayCopyFromBytes</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle, void *data, size_t nbytes)</td></tr>
<tr class="memdesc:a50e9b3dfdc1f4228bf52a26da14456a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy array data from CPU byte array.  <a href="#a50e9b3dfdc1f4228bf52a26da14456a1">More...</a><br /></td></tr>
<tr class="separator:a50e9b3dfdc1f4228bf52a26da14456a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae246eaa00342c042f3f194605ad9bc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ae246eaa00342c042f3f194605ad9bc7a">TVMArrayCopyToBytes</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle, void *data, size_t nbytes)</td></tr>
<tr class="memdesc:ae246eaa00342c042f3f194605ad9bc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy array data to CPU byte array.  <a href="#ae246eaa00342c042f3f194605ad9bc7a">More...</a><br /></td></tr>
<tr class="separator:ae246eaa00342c042f3f194605ad9bc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120628b5226af6deee4010c5a512f618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a120628b5226af6deee4010c5a512f618">TVMArrayCopyFromTo</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> from, <a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> to, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> stream)</td></tr>
<tr class="memdesc:a120628b5226af6deee4010c5a512f618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the array, both from and to must be valid during the copy.  <a href="#a120628b5226af6deee4010c5a512f618">More...</a><br /></td></tr>
<tr class="separator:a120628b5226af6deee4010c5a512f618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b8f8766fce6b62c82a458e3c9b053"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ad67b8f8766fce6b62c82a458e3c9b053">TVMArrayFromDLPack</a> (DLManagedTensor *from, <a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> *out)</td></tr>
<tr class="memdesc:ad67b8f8766fce6b62c82a458e3c9b053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce an array from the DLManagedTensor that shares data memory with the DLManagedTensor.  <a href="#ad67b8f8766fce6b62c82a458e3c9b053">More...</a><br /></td></tr>
<tr class="separator:ad67b8f8766fce6b62c82a458e3c9b053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae690840d1af9c7b0fe5b9b457456f60d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ae690840d1af9c7b0fe5b9b457456f60d">TVMArrayToDLPack</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> from, DLManagedTensor **out)</td></tr>
<tr class="memdesc:ae690840d1af9c7b0fe5b9b457456f60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DLMangedTensor from the array that shares data memory with the array.  <a href="#ae690840d1af9c7b0fe5b9b457456f60d">More...</a><br /></td></tr>
<tr class="separator:ae690840d1af9c7b0fe5b9b457456f60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483791fc218022e690b6e0d81a095b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a6483791fc218022e690b6e0d81a095b0">TVMDLManagedTensorCallDeleter</a> (DLManagedTensor *dltensor)</td></tr>
<tr class="memdesc:a6483791fc218022e690b6e0d81a095b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete (free) a DLManagedTensor's data.  <a href="#a6483791fc218022e690b6e0d81a095b0">More...</a><br /></td></tr>
<tr class="separator:a6483791fc218022e690b6e0d81a095b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d0c47cca9068b17cf0a1f4c58d8ca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a71d0c47cca9068b17cf0a1f4c58d8ca9">TVMStreamCreate</a> (int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> *out)</td></tr>
<tr class="memdesc:a71d0c47cca9068b17cf0a1f4c58d8ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new runtime stream.  <a href="#a71d0c47cca9068b17cf0a1f4c58d8ca9">More...</a><br /></td></tr>
<tr class="separator:a71d0c47cca9068b17cf0a1f4c58d8ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd0545318bfee4e2f4ccce7d7008e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a9dd0545318bfee4e2f4ccce7d7008e01">TVMStreamFree</a> (int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> stream)</td></tr>
<tr class="memdesc:a9dd0545318bfee4e2f4ccce7d7008e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a created stream handle.  <a href="#a9dd0545318bfee4e2f4ccce7d7008e01">More...</a><br /></td></tr>
<tr class="separator:a9dd0545318bfee4e2f4ccce7d7008e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac414ed248ddb1bfb561685bba3de5e89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ac414ed248ddb1bfb561685bba3de5e89">TVMSetStream</a> (int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> handle)</td></tr>
<tr class="memdesc:ac414ed248ddb1bfb561685bba3de5e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the runtime stream of current thread to be stream. The subsequent calls to the same device_type will use the setted stream handle. The specific type of stream is runtime device dependent.  <a href="#ac414ed248ddb1bfb561685bba3de5e89">More...</a><br /></td></tr>
<tr class="separator:ac414ed248ddb1bfb561685bba3de5e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d7efd946bc750af8bf109f93f6ce2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a386d7efd946bc750af8bf109f93f6ce2">TVMSynchronize</a> (int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> stream)</td></tr>
<tr class="memdesc:a386d7efd946bc750af8bf109f93f6ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all computations on stream completes.  <a href="#a386d7efd946bc750af8bf109f93f6ce2">More...</a><br /></td></tr>
<tr class="separator:a386d7efd946bc750af8bf109f93f6ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f776ed41a36790409f78725f81419"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#aa91f776ed41a36790409f78725f81419">TVMStreamStreamSynchronize</a> (int device_type, int device_id, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> src, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> dst)</td></tr>
<tr class="memdesc:aa91f776ed41a36790409f78725f81419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize two streams of execution.  <a href="#aa91f776ed41a36790409f78725f81419">More...</a><br /></td></tr>
<tr class="separator:aa91f776ed41a36790409f78725f81419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ddee6cf53918337cd4ca68d8bfc8b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ab9ddee6cf53918337cd4ca68d8bfc8b1">TVMObjectGetTypeIndex</a> (<a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a> obj, unsigned *out_tindex)</td></tr>
<tr class="memdesc:ab9ddee6cf53918337cd4ca68d8bfc8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type_index from an object.  <a href="#ab9ddee6cf53918337cd4ca68d8bfc8b1">More...</a><br /></td></tr>
<tr class="separator:ab9ddee6cf53918337cd4ca68d8bfc8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d84581b6d0d78c77d88139c6adbf81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a77d84581b6d0d78c77d88139c6adbf81">TVMObjectTypeKey2Index</a> (const char *type_key, unsigned *out_tindex)</td></tr>
<tr class="memdesc:a77d84581b6d0d78c77d88139c6adbf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type key to type index.  <a href="#a77d84581b6d0d78c77d88139c6adbf81">More...</a><br /></td></tr>
<tr class="separator:a77d84581b6d0d78c77d88139c6adbf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867a91b746fbe91e289b0d2ab0446aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ae867a91b746fbe91e289b0d2ab0446aa">TVMObjectTypeIndex2Key</a> (unsigned tindex, char **out_type_key)</td></tr>
<tr class="memdesc:ae867a91b746fbe91e289b0d2ab0446aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type index to type key.  <a href="#ae867a91b746fbe91e289b0d2ab0446aa">More...</a><br /></td></tr>
<tr class="separator:ae867a91b746fbe91e289b0d2ab0446aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae899a6a211b7913e92420a01b804db64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#ae899a6a211b7913e92420a01b804db64">TVMObjectRetain</a> (<a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a> obj)</td></tr>
<tr class="memdesc:ae899a6a211b7913e92420a01b804db64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference count of an object.  <a href="#ae899a6a211b7913e92420a01b804db64">More...</a><br /></td></tr>
<tr class="separator:ae899a6a211b7913e92420a01b804db64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b709e0d509be7909fc31e3690d3f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a660b709e0d509be7909fc31e3690d3f9">TVMObjectFree</a> (<a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a> obj)</td></tr>
<tr class="memdesc:a660b709e0d509be7909fc31e3690d3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the object.  <a href="#a660b709e0d509be7909fc31e3690d3f9">More...</a><br /></td></tr>
<tr class="separator:a660b709e0d509be7909fc31e3690d3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2237f2fdcb96a75e7f3c6fa4209aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#aa9f2237f2fdcb96a75e7f3c6fa4209aa">TVMByteArrayFree</a> (<a class="el" href="structTVMByteArray.html">TVMByteArray</a> *arr)</td></tr>
<tr class="memdesc:aa9f2237f2fdcb96a75e7f3c6fa4209aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <a class="el" href="structTVMByteArray.html" title="Byte array type used to pass in byte array When kTVMBytes is used as data type. ">TVMByteArray</a> returned from TVMFuncCall, and associated memory.  <a href="#aa9f2237f2fdcb96a75e7f3c6fa4209aa">More...</a><br /></td></tr>
<tr class="separator:aa9f2237f2fdcb96a75e7f3c6fa4209aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06455d20ce57f3d3d13776ff6bdf0b61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a06455d20ce57f3d3d13776ff6bdf0b61">TVMDeviceAllocDataSpace</a> (DLDevice dev, size_t nbytes, size_t alignment, DLDataType type_hint, void **out_data)</td></tr>
<tr class="memdesc:a06455d20ce57f3d3d13776ff6bdf0b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data space on device.  <a href="#a06455d20ce57f3d3d13776ff6bdf0b61">More...</a><br /></td></tr>
<tr class="separator:a06455d20ce57f3d3d13776ff6bdf0b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54212f093a2fc24a5fd7c3fecf29813a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a54212f093a2fc24a5fd7c3fecf29813a">TVMDeviceAllocDataSpaceWithScope</a> (DLDevice dev, int ndim, const int64_t *shape, DLDataType dtype, const char *mem_scope, void **out_data)</td></tr>
<tr class="memdesc:a54212f093a2fc24a5fd7c3fecf29813a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data space on device with special memory scope.  <a href="#a54212f093a2fc24a5fd7c3fecf29813a">More...</a><br /></td></tr>
<tr class="separator:a54212f093a2fc24a5fd7c3fecf29813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c7535a79c99bddaf9e3aebde6013e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a05c7535a79c99bddaf9e3aebde6013e6">TVMDeviceFreeDataSpace</a> (DLDevice dev, void *ptr)</td></tr>
<tr class="memdesc:a05c7535a79c99bddaf9e3aebde6013e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a data space on device.  <a href="#a05c7535a79c99bddaf9e3aebde6013e6">More...</a><br /></td></tr>
<tr class="separator:a05c7535a79c99bddaf9e3aebde6013e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588ee4bed71a4e7cb1f08ae8c46568f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#aa588ee4bed71a4e7cb1f08ae8c46568f">TVMDeviceCopyDataFromTo</a> (DLTensor *from, DLTensor *to, <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> stream)</td></tr>
<tr class="memdesc:aa588ee4bed71a4e7cb1f08ae8c46568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one place to another.  <a href="#aa588ee4bed71a4e7cb1f08ae8c46568f">More...</a><br /></td></tr>
<tr class="separator:aa588ee4bed71a4e7cb1f08ae8c46568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d193b0c247af874dad4b31afc8ee7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c__runtime__api_8h.html#a1d193b0c247af874dad4b31afc8ee7d8">TVMObjectDerivedFrom</a> (uint32_t child_type_index, uint32_t parent_type_index, int *is_derived)</td></tr>
<tr class="memdesc:a1d193b0c247af874dad4b31afc8ee7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that an object is derived from another.  <a href="#a1d193b0c247af874dad4b31afc8ee7d8">More...</a><br /></td></tr>
<tr class="separator:a1d193b0c247af874dad4b31afc8ee7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a429515e9851601ec44c8ed421521ab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429515e9851601ec44c8ed421521ab6d">&#9670;&nbsp;</a></span>TVM_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TVM_VERSION&#160;&#160;&#160;&quot;0.11.dev0&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d6bcd569c115f7ae4ddc455b14ca395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6bcd569c115f7ae4ddc455b14ca395">&#9670;&nbsp;</a></span>TVM_WEAK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TVM_WEAK&#160;&#160;&#160;__attribute__((weak))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ace8007daffd9f2c6d954c24d870bfcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8007daffd9f2c6d954c24d870bfcc4">&#9670;&nbsp;</a></span>tvm_index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="c__runtime__api_8h.html#ace8007daffd9f2c6d954c24d870bfcc4">tvm_index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of array index. </p>

</div>
</div>
<a id="a73ca58cb32f4a4adf71d274dc1e27be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ca58cb32f4a4adf71d274dc1e27be4">&#9670;&nbsp;</a></span>TVMArrayHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DLTensor* <a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the array handle </p>

</div>
</div>
<a id="a3980ab80477e57fc6045c12ea8b9e48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3980ab80477e57fc6045c12ea8b9e48d">&#9670;&nbsp;</a></span>TVMExtensionFuncDeclarer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* TVMExtensionFuncDeclarer) (<a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> register_func_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for extension function declarer. </p>
<p>TVM call this function to get the extension functions The declarer will call register_func to register function and their name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">register_func_handle</td><td>The register function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, -1 if failure happens </dd></dl>

</div>
</div>
<a id="acf57d257a6e0841d84ebbd2a339d183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf57d257a6e0841d84ebbd2a339d183e">&#9670;&nbsp;</a></span>TVMFunctionHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to packed function handle. </p>

</div>
</div>
<a id="ac4b0321c489287dcf4637e15328298ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b0321c489287dcf4637e15328298ce">&#9670;&nbsp;</a></span>TVMModuleHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to TVM runtime modules. </p>

</div>
</div>
<a id="aff795d001e3761c75b2b8f422465d5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff795d001e3761c75b2b8f422465d5a0">&#9670;&nbsp;</a></span>TVMObjectHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to Object. </p>

</div>
</div>
<a id="a07954203342f2787acf988c4c351d9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07954203342f2787acf988c4c351d9c3">&#9670;&nbsp;</a></span>TVMPackedCFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* TVMPackedCFunc) (<a class="el" href="unionTVMValue.html">TVMValue</a> *args, int *type_codes, int num_args, <a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a> ret, void *resource_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C type of packed function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments </td></tr>
    <tr><td class="paramname">type_codes</td><td>The type codes of the arguments </td></tr>
    <tr><td class="paramname">num_args</td><td>Number of arguments. </td></tr>
    <tr><td class="paramname">ret</td><td>The return value handle. </td></tr>
    <tr><td class="paramname">resource_handle</td><td>The handle additional resouce handle from front-end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, -1 if failure happens, set error via TVMAPISetLastError. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="c__runtime__api_8h.html#ad0c98ff469bd844546a71f61d2e164f3" title="Set the return value of TVMPackedCFunc. ">TVMCFuncSetReturn</a> </dd></dl>

</div>
</div>
<a id="ac035a1354f2e5d7f8613af73cc735742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac035a1354f2e5d7f8613af73cc735742">&#9670;&nbsp;</a></span>TVMPackedCFuncFinalizer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* TVMPackedCFuncFinalizer) (void *resource_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C callback to free the resource handle in C packed function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_handle</td><td>The handle additional resouce handle from front-end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cd1076476117e74454f67931c2da1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd1076476117e74454f67931c2da1d4">&#9670;&nbsp;</a></span>TVMRetValueHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to hold return value. </p>

</div>
</div>
<a id="ab1d5f6b7945e1410602a8a057fda5757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d5f6b7945e1410602a8a057fda5757">&#9670;&nbsp;</a></span>TVMStreamHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream that is specific to device can be NULL, which indicates the default one. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a190e81769e805cca153514137a66e793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190e81769e805cca153514137a66e793">&#9670;&nbsp;</a></span>TVMArgTypeCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="c__runtime__api_8h.html#a190e81769e805cca153514137a66e793">TVMArgTypeCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type code in used and only used in TVM FFI for argument passing. </p>
<p>DLPack consistency: 1) kTVMArgInt is compatible with kDLInt 2) kTVMArgFloat is compatible with kDLFloat 3) kDLUInt is not in ArgTypeCode, but has a spared slot</p>
<p>Downstream consistency: The kDLInt, kDLUInt, kDLFloat are kept consistent with the original ArgType code</p>
<p>It is only used in argument passing, and should not be confused with DataType::TypeCode, which is DLPack-compatible.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1runtime_1_1DataType.html#a3c9ce1627be2550f656cd37b6c698c7d" title="Type code for the DataType. ">tvm::runtime::DataType::TypeCode</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a72d85fbd104ae87b054f93ddd8e1476b"></a>kTVMArgInt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793add0097597aa4905490e0140d9af406ae"></a>kTVMArgFloat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a9387f774bc8453afe4aa4cd17789a405"></a>kTVMOpaqueHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793ada22c3d9c62fa8f40d46e80ce83b96a1"></a>kTVMNullptr&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a6ee930a6be374837d4d85dbe1abeb842"></a>kTVMDataType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a924f1cfac1f15ee1995cb10fc0af4479"></a>kDLDevice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a8bd637c4caa55b04490fe26b250e3d86"></a>kTVMDLTensorHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793abe76912731a3c65bd7cdd9ab9a462c66"></a>kTVMObjectHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a41343a05e42d08053d9fa1da85f70af6"></a>kTVMModuleHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a396e8ab64a9b33d46bcbedb84819f194"></a>kTVMPackedFuncHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793af2b95de1a09ed39055edfe8ef5ea484d"></a>kTVMStr&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a4b2f3688d719f6e7c20ab00659e2383e"></a>kTVMBytes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a3bab8c80e57b1ab2d7ab95962be4d2ec"></a>kTVMNDArrayHandle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793ad742641b52cb5098f576373021a1399d"></a>kTVMObjectRValueRefArg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a2bea0a5b50b0e24384610059bf1cbdc9"></a>kTVMExtBegin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a6aa6b0afb212bea097b2c71eb366214c"></a>kTVMNNVMFirst&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a3b2e1234b4f579630a5a936e042912b6"></a>kTVMNNVMLast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a2a80307d3075829e12d14ba6ec52a6ee"></a>kTVMExtReserveEnd&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a190e81769e805cca153514137a66e793a463445886242b0357db59f74241ce028"></a>kTVMExtEnd&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a57cbccb14c35a0e62dbc1b911188fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cbccb14c35a0e62dbc1b911188fcef">&#9670;&nbsp;</a></span>TVMDeviceExtType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="c__runtime__api_8h.html#a57cbccb14c35a0e62dbc1b911188fcef">TVMDeviceExtType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extension device types in TVM. </p>
<p>Additional enumerators to supplement those provided by DLPack's <code>DLDeviceType</code> enumeration.</p>
<p>MAINTAINERS NOTE #1: We need to ensure that the two devices are identified by the same integer. Currently this requires manual verification. Discussed here: <a href="https://github.com/dmlc/dlpack/issues/111">https://github.com/dmlc/dlpack/issues/111</a> As of DLPack v0.7, the highest-valued enumerator in <code>DLDeviceType</code> is kDLHexagon = 16.</p>
<p>MAINTAINERS NOTE #2: As of DLPack v0.7, the definition for <code>DLDeviceType</code> specifies an underlying storage type of <code>int32_t</code>. That guarantees a variable of type <code>DLDeviceType</code> is capable of holding any integers provided by <em>either</em> of these enumerations.</p>
<p>However, the <code>int32_t</code> specification only applies when the header file is compiled as C++, and this header file is also meant to work as C code. So the unspecified storage type could be a latent bug when compiled as C. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57cbccb14c35a0e62dbc1b911188fcefad77aa5af5411ed9f3719f48af1f04b02"></a>kDLAOCL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57cbccb14c35a0e62dbc1b911188fcefacdc33f5efa9ddabe89e886c28d1ff65b"></a>kDLSDAccel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57cbccb14c35a0e62dbc1b911188fcefa72361be679c1aca1c1be5f9b500a3315"></a>kOpenGL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57cbccb14c35a0e62dbc1b911188fcefa3357ff71d095bc9bdbe5116599bade5f"></a>kDLMicroDev&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57cbccb14c35a0e62dbc1b911188fcefa474961a2b52fee7b33e529015162e884"></a>TVMDeviceExtType_End&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a477111f9accd70633dc5f2e7139b6cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477111f9accd70633dc5f2e7139b6cf4">&#9670;&nbsp;</a></span>TVMAPISetLastError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TVMAPISetLastError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for implementing C API function. Set last error message before return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The error message to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a014b89c1a3b17473d82cb3973eeedba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014b89c1a3b17473d82cb3973eeedba7">&#9670;&nbsp;</a></span>TVMArrayAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayAlloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="c__runtime__api_8h.html#ace8007daffd9f2c6d954c24d870bfcc4">tvm_index_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype_lanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a nd-array's memory, including space of shape, of given spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the array, the data content will be copied to out </td></tr>
    <tr><td class="paramname">ndim</td><td>The number of dimension of the array. </td></tr>
    <tr><td class="paramname">dtype_code</td><td>The type code of the dtype </td></tr>
    <tr><td class="paramname">dtype_bits</td><td>The number of bits of dtype </td></tr>
    <tr><td class="paramname">dtype_lanes</td><td>The number of lanes in the dtype. </td></tr>
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">out</td><td>The output handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a50e9b3dfdc1f4228bf52a26da14456a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e9b3dfdc1f4228bf52a26da14456a1">&#9670;&nbsp;</a></span>TVMArrayCopyFromBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayCopyFromBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy array data from CPU byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The array handle. </td></tr>
    <tr><td class="paramname">data</td><td>the data pointer </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a120628b5226af6deee4010c5a512f618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120628b5226af6deee4010c5a512f618">&#9670;&nbsp;</a></span>TVMArrayCopyFromTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayCopyFromTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the array, both from and to must be valid during the copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The array to be copied from. </td></tr>
    <tr><td class="paramname">to</td><td>The target space. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream where the copy happens, can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ae246eaa00342c042f3f194605ad9bc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae246eaa00342c042f3f194605ad9bc7a">&#9670;&nbsp;</a></span>TVMArrayCopyToBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayCopyToBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy array data to CPU byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The array handle. </td></tr>
    <tr><td class="paramname">data</td><td>the data pointer </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a591e48e52098965e235657dab56bc096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591e48e52098965e235657dab56bc096">&#9670;&nbsp;</a></span>TVMArrayFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the TVM Array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The array handle to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ad67b8f8766fce6b62c82a458e3c9b053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b8f8766fce6b62c82a458e3c9b053">&#9670;&nbsp;</a></span>TVMArrayFromDLPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayFromDLPack </td>
          <td>(</td>
          <td class="paramtype">DLManagedTensor *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce an array from the DLManagedTensor that shares data memory with the DLManagedTensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The source DLManagedTensor. </td></tr>
    <tr><td class="paramname">out</td><td>The output array handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ae690840d1af9c7b0fe5b9b457456f60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae690840d1af9c7b0fe5b9b457456f60d">&#9670;&nbsp;</a></span>TVMArrayToDLPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMArrayToDLPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLManagedTensor **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a DLMangedTensor from the array that shares data memory with the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The source array. </td></tr>
    <tr><td class="paramname">out</td><td>The DLManagedTensor handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="aa9f2237f2fdcb96a75e7f3c6fa4209aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f2237f2fdcb96a75e7f3c6fa4209aa">&#9670;&nbsp;</a></span>TVMByteArrayFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMByteArrayFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTVMByteArray.html">TVMByteArray</a> *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a <a class="el" href="structTVMByteArray.html" title="Byte array type used to pass in byte array When kTVMBytes is used as data type. ">TVMByteArray</a> returned from TVMFuncCall, and associated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The <a class="el" href="structTVMByteArray.html" title="Byte array type used to pass in byte array When kTVMBytes is used as data type. ">TVMByteArray</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a6fee438ab81fbf4235375d9f17f36d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fee438ab81fbf4235375d9f17f36d6f">&#9670;&nbsp;</a></span>TVMCbArgToReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMCbArgToReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionTVMValue.html">TVMValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace translate callback argument value to return value. This is only needed for non-POD arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be translated. </td></tr>
    <tr><td class="paramname">code</td><td>The type code to be translated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will do a shallow copy when necessary.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens. </dd></dl>

</div>
</div>
<a id="ad0c98ff469bd844546a71f61d2e164f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c98ff469bd844546a71f61d2e164f3">&#9670;&nbsp;</a></span>TVMCFuncSetReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMCFuncSetReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a6cd1076476117e74454f67931c2da1d4">TVMRetValueHandle</a>&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionTVMValue.html">TVMValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the return value of TVMPackedCFunc. </p>
<p>This function is called by TVMPackedCFunc to set the return value. When this function is not called, the function returns null by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td>The return value handle, pass by ret in TVMPackedCFunc </td></tr>
    <tr><td class="paramname">value</td><td>The value to be returned. </td></tr>
    <tr><td class="paramname">type_code</td><td>The type of the value to be returned. </td></tr>
    <tr><td class="paramname">num_ret</td><td>Number of return values, for now only 1 is supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06455d20ce57f3d3d13776ff6bdf0b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06455d20ce57f3d3d13776ff6bdf0b61">&#9670;&nbsp;</a></span>TVMDeviceAllocDataSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMDeviceAllocDataSpace </td>
          <td>(</td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>type_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data space on device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to perform operation. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes in memory. </td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment of the memory. </td></tr>
    <tr><td class="paramname">type_hint</td><td>The type of elements. Only needed by certain backends such as nbytes &amp; alignment are sufficient for most backends. </td></tr>
    <tr><td class="paramname">out_data</td><td>The allocated device pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a54212f093a2fc24a5fd7c3fecf29813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54212f093a2fc24a5fd7c3fecf29813a">&#9670;&nbsp;</a></span>TVMDeviceAllocDataSpaceWithScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMDeviceAllocDataSpaceWithScope </td>
          <td>(</td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mem_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data space on device with special memory scope. </p>
<dl class="section note"><dt>Note</dt><dd>The memory could use a special multi-dimensional memory layout. That is why we pass shape and dtype instead of raw number of bytes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to perform operation. </td></tr>
    <tr><td class="paramname">ndim</td><td>The number of dimension of the tensor. </td></tr>
    <tr><td class="paramname">shape</td><td>The shape of the tensor. </td></tr>
    <tr><td class="paramname">dtype</td><td>The type of elements. </td></tr>
    <tr><td class="paramname">mem_scope</td><td>The memory scope of the tensor, can be nullptr, which indicate the default global DRAM </td></tr>
    <tr><td class="paramname">out_data</td><td>The allocated device pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="aa588ee4bed71a4e7cb1f08ae8c46568f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa588ee4bed71a4e7cb1f08ae8c46568f">&#9670;&nbsp;</a></span>TVMDeviceCopyDataFromTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMDeviceCopyDataFromTo </td>
          <td>(</td>
          <td class="paramtype">DLTensor *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLTensor *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from one place to another. </p>
<dl class="section note"><dt>Note</dt><dd>This API is designed to support special memory with shape dependent layout. We pass in DLTensor* with shape information to support these cases. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The source tensor. </td></tr>
    <tr><td class="paramname">to</td><td>The target tensor. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens. </dd></dl>

</div>
</div>
<a id="a05c7535a79c99bddaf9e3aebde6013e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c7535a79c99bddaf9e3aebde6013e6">&#9670;&nbsp;</a></span>TVMDeviceFreeDataSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMDeviceFreeDataSpace </td>
          <td>(</td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a data space on device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to perform operation. </td></tr>
    <tr><td class="paramname">ptr</td><td>The data space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a6483791fc218022e690b6e0d81a095b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483791fc218022e690b6e0d81a095b0">&#9670;&nbsp;</a></span>TVMDLManagedTensorCallDeleter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TVMDLManagedTensorCallDeleter </td>
          <td>(</td>
          <td class="paramtype">DLManagedTensor *&#160;</td>
          <td class="paramname"><em>dltensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete (free) a DLManagedTensor's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dltensor</td><td>Pointer to the DLManagedTensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a01e20ffd5784465df0759c950154b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a01e20ffd5784465df0759c950154b5">&#9670;&nbsp;</a></span>TVMFuncCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionTVMValue.html">TVMValue</a> *&#160;</td>
          <td class="paramname"><em>arg_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type_codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionTVMValue.html">TVMValue</a> *&#160;</td>
          <td class="paramname"><em>ret_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ret_type_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a Packed TVM Function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>node handle of the function. </td></tr>
    <tr><td class="paramname">arg_values</td><td>The arguments </td></tr>
    <tr><td class="paramname">type_codes</td><td>The type codes of the arguments </td></tr>
    <tr><td class="paramname">num_args</td><td>Number of arguments.</td></tr>
    <tr><td class="paramname">ret_val</td><td>The return value. </td></tr>
    <tr><td class="paramname">ret_type_code</td><td>the type code of return value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>
<dl class="section note"><dt>Note</dt><dd>TVM calls always exchanges with type bits=64, lanes=1</dd>
<dd>
API calls always exchanges with type bits=64, lanes=1 If API call returns container handles (e.g. FunctionHandle) these handles should be managed by the front-end. The front-end need to call free function (e.g. TVMFuncFree) to free these handles. </dd></dl>

</div>
</div>
<a id="adfd8d1f9e7229625d4acd7da3b10287c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8d1f9e7229625d4acd7da3b10287c">&#9670;&nbsp;</a></span>TVMFuncCreateFromCFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncCreateFromCFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a07954203342f2787acf988c4c351d9c3">TVMPackedCFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>resource_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac035a1354f2e5d7f8613af73cc735742">TVMPackedCFuncFinalizer</a>&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a TVMPackedCFunc to become a FunctionHandle. </p>
<p>The resource_handle will be managed by TVM API, until the function is no longer used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The packed C function. </td></tr>
    <tr><td class="paramname">resource_handle</td><td>The resource handle from front-end, can be NULL. </td></tr>
    <tr><td class="paramname">fin</td><td>The finalizer on resource handle when the FunctionHandle get freed, can be NULL </td></tr>
    <tr><td class="paramname">out</td><td>the result function handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="af420f0d74004615c03bb40270ad5d489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af420f0d74004615c03bb40270ad5d489">&#9670;&nbsp;</a></span>TVMFuncFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the function when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ad3bd42da244a0e32ac82d7428e01a010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd42da244a0e32ac82d7428e01a010">&#9670;&nbsp;</a></span>TVMFuncGetGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncGetGlobal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a global function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the function. </td></tr>
    <tr><td class="paramname">out</td><td>the result function pointer, NULL if it does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function handle of global function is managed by TVM runtime, So TVMFuncFree is should not be called when it get deleted. </dd></dl>

</div>
</div>
<a id="a392740d028710fcd356b2b63ab90fd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392740d028710fcd356b2b63ab90fd01">&#9670;&nbsp;</a></span>TVMFuncListGlobalNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncListGlobalNames </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***&#160;</td>
          <td class="paramname"><em>out_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List all the globally registered function name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_size</td><td>The number of functions </td></tr>
    <tr><td class="paramname">out_array</td><td>The array of function names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a9642167d9a76bfe7e81174e8776d504b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9642167d9a76bfe7e81174e8776d504b">&#9670;&nbsp;</a></span>TVMFuncRegisterGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncRegisterGlobal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>override</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the function to runtime's global table. </p>
<p>The registered function then can be pulled by the backend by the name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the function. </td></tr>
    <tr><td class="paramname">f</td><td>The function to be registered. </td></tr>
    <tr><td class="paramname">override</td><td>Whether allow override already registered function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab98d6b66089da8b33b662ccdb243b26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98d6b66089da8b33b662ccdb243b26b">&#9670;&nbsp;</a></span>TVMFuncRemoveGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMFuncRemoveGlobal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a global function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a775383bcd8c0237e36bdf0c9654d62c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775383bcd8c0237e36bdf0c9654d62c3">&#9670;&nbsp;</a></span>TVMGetLastError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TVMGetLastError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return str message of the last error all function in this file will return 0 when success and nonzero when an error occurred, TVMGetLastError can be called to retrieve the error </p>
<p>this function is threadsafe and can be called by different thread </p><dl class="section return"><dt>Returns</dt><dd>error info </dd></dl>

</div>
</div>
<a id="ac16764609b45ac911a5c9971e195e377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16764609b45ac911a5c9971e195e377">&#9670;&nbsp;</a></span>TVMModFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMModFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a>&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the Module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This may not free up the module's resources. If there is active TVMFunctionHandle uses the module Or if this module is imported by another active module.</dd></dl>
<p>The all functions remains valid until TVMFuncFree is called. </p><dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a5a19a18084c94396a673efa309405a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a19a18084c94396a673efa309405a6c">&#9670;&nbsp;</a></span>TVMModGetFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMModGetFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a>&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>query_imports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#acf57d257a6e0841d84ebbd2a339d183e">TVMFunctionHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module handle. </td></tr>
    <tr><td class="paramname">func_name</td><td>The name of the function. </td></tr>
    <tr><td class="paramname">query_imports</td><td>Whether to query imported modules </td></tr>
    <tr><td class="paramname">out</td><td>The result function, can be NULL if it is not available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when no error is thrown, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="aaeb0d67f6d7e90e671dd5a53b1d6b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb0d67f6d7e90e671dd5a53b1d6b81a">&#9670;&nbsp;</a></span>TVMModImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMModImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a>&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a>&#160;</td>
          <td class="paramname"><em>dep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add dep to mod's dependency. This allows functions in this module to use modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module handle. </td></tr>
    <tr><td class="paramname">dep</td><td>The dependent module to be imported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a47f79bb2004573a8e36a175d1b73fc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f79bb2004573a8e36a175d1b73fc64">&#9670;&nbsp;</a></span>TVMModLoadFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMModLoadFromFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ac4b0321c489287dcf4637e15328298ce">TVMModuleHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load module from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The file name to load the module from. </td></tr>
    <tr><td class="paramname">format</td><td>The format of the module. </td></tr>
    <tr><td class="paramname">out</td><td>The result module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The resulting module do not contain import relation. It can be reconstructed by TVMModImport. </dd></dl>

</div>
</div>
<a id="a1d193b0c247af874dad4b31afc8ee7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d193b0c247af874dad4b31afc8ee7d8">&#9670;&nbsp;</a></span>TVMObjectDerivedFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectDerivedFrom </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>child_type_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parent_type_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>is_derived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that an object is derived from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_type_index</td><td>The type index of the derived type. </td></tr>
    <tr><td class="paramname">parent_type_index</td><td>The type index of the parent type. </td></tr>
    <tr><td class="paramname">is_derived</td><td>A boolean representing whether this predicate holds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens. </dd></dl>

</div>
</div>
<a id="a660b709e0d509be7909fc31e3690d3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660b709e0d509be7909fc31e3690d3f9">&#9670;&nbsp;</a></span>TVMObjectFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Internally we decrease the reference counter of the object. The object will be freed when every reference to the object are removed. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ab9ddee6cf53918337cd4ca68d8bfc8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ddee6cf53918337cd4ca68d8bfc8b1">&#9670;&nbsp;</a></span>TVMObjectGetTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectGetTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>out_tindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type_index from an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object handle. </td></tr>
    <tr><td class="paramname">out_tindex</td><td>the output type index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ae899a6a211b7913e92420a01b804db64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae899a6a211b7913e92420a01b804db64">&#9670;&nbsp;</a></span>TVMObjectRetain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectRetain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#aff795d001e3761c75b2b8f422465d5a0">TVMObjectHandle</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the reference count of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Internally we increase the reference counter of the object. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ae867a91b746fbe91e289b0d2ab0446aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867a91b746fbe91e289b0d2ab0446aa">&#9670;&nbsp;</a></span>TVMObjectTypeIndex2Key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectTypeIndex2Key </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out_type_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert type index to type key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tindex</td><td>The type index. </td></tr>
    <tr><td class="paramname">out_type_key</td><td>The output type key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a77d84581b6d0d78c77d88139c6adbf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d84581b6d0d78c77d88139c6adbf81">&#9670;&nbsp;</a></span>TVMObjectTypeKey2Index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMObjectTypeKey2Index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>out_tindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert type key to type index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_key</td><td>The key of the type. </td></tr>
    <tr><td class="paramname">out_tindex</td><td>the corresponding type index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="ac414ed248ddb1bfb561685bba3de5e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac414ed248ddb1bfb561685bba3de5e89">&#9670;&nbsp;</a></span>TVMSetStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMSetStream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the runtime stream of current thread to be stream. The subsequent calls to the same device_type will use the setted stream handle. The specific type of stream is runtime device dependent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">handle</td><td>The stream handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a71d0c47cca9068b17cf0a1f4c58d8ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d0c47cca9068b17cf0a1f4c58d8ca9">&#9670;&nbsp;</a></span>TVMStreamCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMStreamCreate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new runtime stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">out</td><td>The new stream handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a9dd0545318bfee4e2f4ccce7d7008e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd0545318bfee4e2f4ccce7d7008e01">&#9670;&nbsp;</a></span>TVMStreamFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMStreamFree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a created stream handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="aa91f776ed41a36790409f78725f81419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91f776ed41a36790409f78725f81419">&#9670;&nbsp;</a></span>TVMStreamStreamSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMStreamStreamSynchronize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize two streams of execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">src</td><td>The source stream to synchronize. </td></tr>
    <tr><td class="paramname">dst</td><td>The destination stream to synchronize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
<a id="a386d7efd946bc750af8bf109f93f6ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386d7efd946bc750af8bf109f93f6ce2">&#9670;&nbsp;</a></span>TVMSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TVMSynchronize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#ab1d5f6b7945e1410602a8a057fda5757">TVMStreamHandle</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all computations on stream completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_type</td><td>The device type. </td></tr>
    <tr><td class="paramname">device_id</td><td>The device id. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream to be synchronized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when success, nonzero when failure happens </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
