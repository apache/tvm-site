<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::ScheduleNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html">ScheduleNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtvm_1_1tir_1_1ScheduleNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::ScheduleNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The user-facing schedule class.  
 <a href="classtvm_1_1tir_1_1ScheduleNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tir_2schedule_2schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::tir::ScheduleNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1tir_1_1ScheduleNode__inherit__graph.svg" width="290" height="815"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::tir::ScheduleNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1tir_1_1ScheduleNode__coll__graph.svg" width="366" height="802"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae637f126412479ed9bec05fd55376f7f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ae637f126412479ed9bec05fd55376f7f">~ScheduleNode</a> ()=default</td></tr>
<tr class="separator:ae637f126412479ed9bec05fd55376f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4294398b140f3ff13a33f94a2f9e5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#abc4294398b140f3ff13a33f94a2f9e5f">TVM_DECLARE_FINAL_OBJECT_INFO</a> (<a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html">ScheduleNode</a>, <a class="el" href="classtvm_1_1runtime_1_1Object.html">runtime::Object</a>)</td></tr>
<tr class="separator:abc4294398b140f3ff13a33f94a2f9e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd7ec20629e09cd0be1aa49e5f57c12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a6dd7ec20629e09cd0be1aa49e5f57c12">mod</a> () const</td></tr>
<tr class="memdesc:a6dd7ec20629e09cd0be1aa49e5f57c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> associated with this schedule.  <a href="#a6dd7ec20629e09cd0be1aa49e5f57c12">More...</a><br /></td></tr>
<tr class="separator:a6dd7ec20629e09cd0be1aa49e5f57c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3612c2598fa2d3ee0e6e3fc3de8a26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1ScheduleState.html">ScheduleState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#abb3612c2598fa2d3ee0e6e3fc3de8a26">state</a> () const =0</td></tr>
<tr class="separator:abb3612c2598fa2d3ee0e6e3fc3de8a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953bca4123b5a758adfdcd65634a5f3b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Trace.html">Trace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a953bca4123b5a758adfdcd65634a5f3b">trace</a> () const =0</td></tr>
<tr class="separator:a953bca4123b5a758adfdcd65634a5f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb747d074e1f99477f7132e4614221a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#acb747d074e1f99477f7132e4614221a3">WorkOn</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;func_name)=0</td></tr>
<tr class="memdesc:acb747d074e1f99477f7132e4614221a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the schedule to work on a function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#acb747d074e1f99477f7132e4614221a3">More...</a><br /></td></tr>
<tr class="separator:acb747d074e1f99477f7132e4614221a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fbececf8717a961436a36ccc79c1d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a70fbececf8717a961436a36ccc79c1d5">Copy</a> ()=0</td></tr>
<tr class="memdesc:a70fbececf8717a961436a36ccc79c1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the schedule, including both its state and its symbol table, guaranteeing that 1) SRef tree is completely reconstructed; 2) The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> being scheduled is not modified; 3) All the random variables are valid in the copy, pointing to the corresponding sref reconstructed.  <a href="#a70fbececf8717a961436a36ccc79c1d5">More...</a><br /></td></tr>
<tr class="separator:a70fbececf8717a961436a36ccc79c1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb60d6112fe5a443ef39bc005c9fbf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a3cb60d6112fe5a443ef39bc005c9fbf1">Seed</a> (<a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a> seed)=0</td></tr>
<tr class="memdesc:a3cb60d6112fe5a443ef39bc005c9fbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the randomness.  <a href="#a3cb60d6112fe5a443ef39bc005c9fbf1">More...</a><br /></td></tr>
<tr class="separator:a3cb60d6112fe5a443ef39bc005c9fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681c9b2a0d93e413cdec2caad7e74e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a9681c9b2a0d93e413cdec2caad7e74e8">ForkSeed</a> ()=0</td></tr>
<tr class="memdesc:a9681c9b2a0d93e413cdec2caad7e74e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fork the random state.  <a href="#a9681c9b2a0d93e413cdec2caad7e74e8">More...</a><br /></td></tr>
<tr class="separator:a9681c9b2a0d93e413cdec2caad7e74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0dd6e11e5c3cd85766a5a5ad9acd41"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#aec0dd6e11e5c3cd85766a5a5ad9acd41">Get</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:aec0dd6e11e5c3cd85766a5a5ad9acd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>.  <a href="#aec0dd6e11e5c3cd85766a5a5ad9acd41">More...</a><br /></td></tr>
<tr class="separator:aec0dd6e11e5c3cd85766a5a5ad9acd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2229f72137786e7ab892aa211191251"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1For.html">For</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ae2229f72137786e7ab892aa211191251">Get</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv) const =0</td></tr>
<tr class="memdesc:ae2229f72137786e7ab892aa211191251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the for loop corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a>.  <a href="#ae2229f72137786e7ab892aa211191251">More...</a><br /></td></tr>
<tr class="separator:ae2229f72137786e7ab892aa211191251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d34e09f35c6ca2f179165a041037c4c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a1d34e09f35c6ca2f179165a041037c4c">Get</a> (const <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &amp;expr_rv) const =0</td></tr>
<tr class="memdesc:a1d34e09f35c6ca2f179165a041037c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expr corresponding to the specific random variable.  <a href="#a1d34e09f35c6ca2f179165a041037c4c">More...</a><br /></td></tr>
<tr class="separator:a1d34e09f35c6ca2f179165a041037c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6d659b1a0a4b8175d7495afc3a791c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a3b6d659b1a0a4b8175d7495afc3a791c">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:a3b6d659b1a0a4b8175d7495afc3a791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block sref corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>.  <a href="#a3b6d659b1a0a4b8175d7495afc3a791c">More...</a><br /></td></tr>
<tr class="separator:a3b6d659b1a0a4b8175d7495afc3a791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7ed1ef1470fb1c9cfc272e14a1e32"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a08f7ed1ef1470fb1c9cfc272e14a1e32">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv) const =0</td></tr>
<tr class="memdesc:a08f7ed1ef1470fb1c9cfc272e14a1e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop sref corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a>.  <a href="#a08f7ed1ef1470fb1c9cfc272e14a1e32">More...</a><br /></td></tr>
<tr class="separator:a08f7ed1ef1470fb1c9cfc272e14a1e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8855eae5db733dcf21542b3dbd06e15"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ac8855eae5db733dcf21542b3dbd06e15">HasBlock</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:ac8855eae5db733dcf21542b3dbd06e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the existance of a specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>.  <a href="#ac8855eae5db733dcf21542b3dbd06e15">More...</a><br /></td></tr>
<tr class="separator:ac8855eae5db733dcf21542b3dbd06e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d50e4b429557302c5c6575bcc706d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a34d50e4b429557302c5c6575bcc706d5">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *stmt) const</td></tr>
<tr class="memdesc:a34d50e4b429557302c5c6575bcc706d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block/loop sref corresponding to the specific statement.  <a href="#a34d50e4b429557302c5c6575bcc706d5">More...</a><br /></td></tr>
<tr class="separator:a34d50e4b429557302c5c6575bcc706d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a52c8522a4bfc7d42a189250a462ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a2a52c8522a4bfc7d42a189250a462ce8">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt) const</td></tr>
<tr class="memdesc:a2a52c8522a4bfc7d42a189250a462ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block/loop sref corresponding to the specific statement.  <a href="#a2a52c8522a4bfc7d42a189250a462ce8">More...</a><br /></td></tr>
<tr class="separator:a2a52c8522a4bfc7d42a189250a462ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d353bb52f6fa29fedeb90a6ff872d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a70d353bb52f6fa29fedeb90a6ff872d5">RemoveRV</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a70d353bb52f6fa29fedeb90a6ff872d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block random variable from the symbol table.  <a href="#a70d353bb52f6fa29fedeb90a6ff872d5">More...</a><br /></td></tr>
<tr class="separator:a70d353bb52f6fa29fedeb90a6ff872d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c44d4f4ea662291ccb9d79383b6fefe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a7c44d4f4ea662291ccb9d79383b6fefe">RemoveRV</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a7c44d4f4ea662291ccb9d79383b6fefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a loop random variable from the symbol table.  <a href="#a7c44d4f4ea662291ccb9d79383b6fefe">More...</a><br /></td></tr>
<tr class="separator:a7c44d4f4ea662291ccb9d79383b6fefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fcf343d2bc8f36f170c04e5e29d2dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a00fcf343d2bc8f36f170c04e5e29d2dc">RemoveRV</a> (const <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &amp;expr_rv)=0</td></tr>
<tr class="memdesc:a00fcf343d2bc8f36f170c04e5e29d2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an integer random variable from the symbol table.  <a href="#a00fcf343d2bc8f36f170c04e5e29d2dc">More...</a><br /></td></tr>
<tr class="separator:a00fcf343d2bc8f36f170c04e5e29d2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2b3a98335b88f168b69deed49eb19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ab9d2b3a98335b88f168b69deed49eb19">SampleCategorical</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;candidates, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1FloatImm.html">FloatImm</a> &gt; &amp;probs, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; decision=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)=0</td></tr>
<tr class="memdesc:ab9d2b3a98335b88f168b69deed49eb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample an integer given the probability distribution.  <a href="#ab9d2b3a98335b88f168b69deed49eb19">More...</a><br /></td></tr>
<tr class="separator:ab9d2b3a98335b88f168b69deed49eb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c62b3f9486dd35714df50bc424d6698"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a2c62b3f9486dd35714df50bc424d6698">SamplePerfectTile</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, int n, int max_innermost_factor, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; decision=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)=0</td></tr>
<tr class="memdesc:a2c62b3f9486dd35714df50bc424d6698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the factors to perfect tile a specific loop.  <a href="#a2c62b3f9486dd35714df50bc424d6698">More...</a><br /></td></tr>
<tr class="separator:a2c62b3f9486dd35714df50bc424d6698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9fbec94271b7512c24b6eced230c39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#abf9fbec94271b7512c24b6eced230c39">SampleComputeLocation</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; decision=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)=0</td></tr>
<tr class="memdesc:abf9fbec94271b7512c24b6eced230c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a compute-at location of the given block.  <a href="#abf9fbec94271b7512c24b6eced230c39">More...</a><br /></td></tr>
<tr class="separator:abf9fbec94271b7512c24b6eced230c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f01524386f7e4dda4d8581c49cede"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ac75f01524386f7e4dda4d8581c49cede">GetBlock</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;name, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; &amp;func_name=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)=0</td></tr>
<tr class="memdesc:ac75f01524386f7e4dda4d8581c49cede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a block in a specific function with its name.  <a href="#ac75f01524386f7e4dda4d8581c49cede">More...</a><br /></td></tr>
<tr class="separator:ac75f01524386f7e4dda4d8581c49cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232186c0db6176db56df4cc30dd11829"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a232186c0db6176db56df4cc30dd11829">GetLoops</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a232186c0db6176db56df4cc30dd11829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent loops of the block in its scope, from outer to inner.  <a href="#a232186c0db6176db56df4cc30dd11829">More...</a><br /></td></tr>
<tr class="separator:a232186c0db6176db56df4cc30dd11829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47f456cb12d24b89fe4432d0304d506"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ab47f456cb12d24b89fe4432d0304d506">GetChildBlocks</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:ab47f456cb12d24b89fe4432d0304d506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf blocks of a specific scope.  <a href="#ab47f456cb12d24b89fe4432d0304d506">More...</a><br /></td></tr>
<tr class="separator:ab47f456cb12d24b89fe4432d0304d506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087bbdcd817e4afcef7ee4658c37a8a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a087bbdcd817e4afcef7ee4658c37a8a9">GetChildBlocks</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a087bbdcd817e4afcef7ee4658c37a8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf blocks of under a specific loop.  <a href="#a087bbdcd817e4afcef7ee4658c37a8a9">More...</a><br /></td></tr>
<tr class="separator:a087bbdcd817e4afcef7ee4658c37a8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d3e3fdd1ba180485bcae68ca528bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a448d3e3fdd1ba180485bcae68ca528bb">GetProducers</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a448d3e3fdd1ba180485bcae68ca528bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the producer of a specific block, under the same block scope.  <a href="#a448d3e3fdd1ba180485bcae68ca528bb">More...</a><br /></td></tr>
<tr class="separator:a448d3e3fdd1ba180485bcae68ca528bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e28e0b470d0e9299d953c2ee3f6261"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ac5e28e0b470d0e9299d953c2ee3f6261">GetConsumers</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:ac5e28e0b470d0e9299d953c2ee3f6261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the consumers of a specific block, under the same block scope.  <a href="#ac5e28e0b470d0e9299d953c2ee3f6261">More...</a><br /></td></tr>
<tr class="separator:ac5e28e0b470d0e9299d953c2ee3f6261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9a41d190be0f8d817b4936732bd0ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a5b9a41d190be0f8d817b4936732bd0ef">Fuse</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;loop_rvs, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a5b9a41d190be0f8d817b4936732bd0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse a list of consecutive loops into one. It requires: 1) The loops can't have annotations or thread bindings. 2) The (i+1)-th loop must be the only child of the i-th loop. 3) All loops must start with 0. 4) The domain of a loop to be fused cannot depend on another loop to be fused.  <a href="#a5b9a41d190be0f8d817b4936732bd0ef">More...</a><br /></td></tr>
<tr class="separator:a5b9a41d190be0f8d817b4936732bd0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac190a0ab76d8754a35209479bcc6dfa2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ac190a0ab76d8754a35209479bcc6dfa2">Split</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &gt;&gt; &amp;factors, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:ac190a0ab76d8754a35209479bcc6dfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a loop into a list of consecutive loops. It requires: 1) The loop can't have annotation or thread binding. 2) The loop must start with 0.  <a href="#ac190a0ab76d8754a35209479bcc6dfa2">More...</a><br /></td></tr>
<tr class="separator:ac190a0ab76d8754a35209479bcc6dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059229fe0e254961da406807a97f7a3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a059229fe0e254961da406807a97f7a3d">Reorder</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;ordered_loop_rvs)=0</td></tr>
<tr class="memdesc:a059229fe0e254961da406807a97f7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder a list of loops. It doesn't require the loops to be consecutive. It requires: 1) The loops are in the same chain. That means: the loops can be ordered to [l_1, l_2, ... , l_n] where l_i is an ancestor of l_{i+1} and there are only single-branch loops between l_1 and l_n (which also indicates they are under the same scope). 2) After reordering, the domain of an outer loop cannot depend on any of the inner loops. 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> every block under the loop nests, its block binding must be affine, and the block variables must be either data parallel or reduction. 4) No duplicated loops are allowed in the arguments.  <a href="#a059229fe0e254961da406807a97f7a3d">More...</a><br /></td></tr>
<tr class="separator:a059229fe0e254961da406807a97f7a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dca9b384aae8d67f66fd6759b5d716"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a18dca9b384aae8d67f66fd6759b5d716">AddUnitLoop</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a18dca9b384aae8d67f66fd6759b5d716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unit loop on top of the specific block.  <a href="#a18dca9b384aae8d67f66fd6759b5d716">More...</a><br /></td></tr>
<tr class="separator:a18dca9b384aae8d67f66fd6759b5d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc0f0d95448e33040e067697c37ce02"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a2fc0f0d95448e33040e067697c37ce02">AddUnitLoop</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a2fc0f0d95448e33040e067697c37ce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unit loop on top of the specific loop.  <a href="#a2fc0f0d95448e33040e067697c37ce02">More...</a><br /></td></tr>
<tr class="separator:a2fc0f0d95448e33040e067697c37ce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553dc17c0b49b175cd16881c81b6c789"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a553dc17c0b49b175cd16881c81b6c789">Parallel</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a553dc17c0b49b175cd16881c81b6c789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, the loop can only be contained in data-parallel block iters' bindings.  <a href="#a553dc17c0b49b175cd16881c81b6c789">More...</a><br /></td></tr>
<tr class="separator:a553dc17c0b49b175cd16881c81b6c789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a8cd91959ceab22855ec338978bcee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ab4a8cd91959ceab22855ec338978bcee">Vectorize</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:ab4a8cd91959ceab22855ec338978bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, the loop can only be contained in data-parallel block iters' bindings.  <a href="#ab4a8cd91959ceab22855ec338978bcee">More...</a><br /></td></tr>
<tr class="separator:ab4a8cd91959ceab22855ec338978bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae30e3d365afebdc96b58eac6fd731"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a7eae30e3d365afebdc96b58eac6fd731">Bind</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;thread_axis)=0</td></tr>
<tr class="memdesc:a7eae30e3d365afebdc96b58eac6fd731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the input loop to the given thread axis. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, if the thread axis starts with "threadIdx`, the loop can only be contained in data-parallel block iter and reduction block iters' bindings. Otherwise the loop can only be contained in data-parallel block iters' bindings.  <a href="#a7eae30e3d365afebdc96b58eac6fd731">More...</a><br /></td></tr>
<tr class="separator:a7eae30e3d365afebdc96b58eac6fd731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ec742f6295f59390592a6d0d90a552"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a84ec742f6295f59390592a6d0d90a552">Unroll</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a84ec742f6295f59390592a6d0d90a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the input loop. It requires nothing.  <a href="#a84ec742f6295f59390592a6d0d90a552">More...</a><br /></td></tr>
<tr class="separator:a84ec742f6295f59390592a6d0d90a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bf333c162865fa4d18eb20ecf9a9a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a55bf333c162865fa4d18eb20ecf9a9a7">CacheRead</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int read_buffer_index, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;storage_scope, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt; consumer_blocks={})=0</td></tr>
<tr class="memdesc:a55bf333c162865fa4d18eb20ecf9a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property.  <a href="#a55bf333c162865fa4d18eb20ecf9a9a7">More...</a><br /></td></tr>
<tr class="separator:a55bf333c162865fa4d18eb20ecf9a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f43b2ddd6e3b3bab64671345ecba72d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a9f43b2ddd6e3b3bab64671345ecba72d">CacheWrite</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int write_buffer_index, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;storage_scope, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt; consumer_blocks={})=0</td></tr>
<tr class="memdesc:a9f43b2ddd6e3b3bab64671345ecba72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property.  <a href="#a9f43b2ddd6e3b3bab64671345ecba72d">More...</a><br /></td></tr>
<tr class="separator:a9f43b2ddd6e3b3bab64671345ecba72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefe28d441bad8fc4b276e1bb35f9818"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#abefe28d441bad8fc4b276e1bb35f9818">CacheInplace</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int read_buffer_index, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;storage_scope)=0</td></tr>
<tr class="memdesc:abefe28d441bad8fc4b276e1bb35f9818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create 2 blocks that read&amp;write a buffer region into a read/write cache. It requires the the target block both read &amp; write the target buffer.  <a href="#abefe28d441bad8fc4b276e1bb35f9818">More...</a><br /></td></tr>
<tr class="separator:abefe28d441bad8fc4b276e1bb35f9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d3ae0b3d145cbe33a8162723aa9aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a3b1d3ae0b3d145cbe33a8162723aa9aa">CacheIndex</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index)=0</td></tr>
<tr class="memdesc:a3b1d3ae0b3d145cbe33a8162723aa9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block to cache precomputed index for later use. if there is no index computation, keep unchanged.  <a href="#a3b1d3ae0b3d145cbe33a8162723aa9aa">More...</a><br /></td></tr>
<tr class="separator:a3b1d3ae0b3d145cbe33a8162723aa9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e36a8a0e37a76e55068dd534e28c8c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a9e36a8a0e37a76e55068dd534e28c8c5">ReIndex</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a> buffer_index_type)=0</td></tr>
<tr class="memdesc:a9e36a8a0e37a76e55068dd534e28c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that read/write a buffer region into a read/write cache with reindexing. The layout of the cache will be the same as by the iterators of the block that reads/writes the buffer. It requires: 1) There is only one block who reads/writes the target buffer 2) There is only one buffer load/store of this buffer in the block.  <a href="#a9e36a8a0e37a76e55068dd534e28c8c5">More...</a><br /></td></tr>
<tr class="separator:a9e36a8a0e37a76e55068dd534e28c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af901a7fa1336ee2e6668a2e44a8a2efd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#af901a7fa1336ee2e6668a2e44a8a2efd">ComputeAt</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_loops, int index=-1)=0</td></tr>
<tr class="memdesc:af901a7fa1336ee2e6668a2e44a8a2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a producer block under the specific loop, and regenerate the loops induced by the block so that the buffer region produced by the producer block could cover those regions consumed by its consumer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) The block is not an output block with regard to the scope block, i.e. the buffers written by the block are allocated under the scope block 5) All the consumers of the block are under the given loop.  <a href="#af901a7fa1336ee2e6668a2e44a8a2efd">More...</a><br /></td></tr>
<tr class="separator:af901a7fa1336ee2e6668a2e44a8a2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e0424902b06dca23d46807a9a47d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ad75e0424902b06dca23d46807a9a47d5">ReverseComputeAt</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_loops, int index=-1)=0</td></tr>
<tr class="memdesc:ad75e0424902b06dca23d46807a9a47d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a consumer block under the specific loop, and regenerate the loops induced by the block so that the buffer region consumed by the consumer block could cover those regions produced by its producer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) All the producers of the block are under the given loop.  <a href="#ad75e0424902b06dca23d46807a9a47d5">More...</a><br /></td></tr>
<tr class="separator:ad75e0424902b06dca23d46807a9a47d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7310fe532cf9d168557ed792198c24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a5e7310fe532cf9d168557ed792198c24">ComputeInline</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block)=0</td></tr>
<tr class="memdesc:a5e7310fe532cf9d168557ed792198c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a block into its consumer(s). It requires: 1) The block is a complete non-root block, which only produces one buffer 2) The block must not be the only leaf in the scope. 3) The body of the block must be a <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> statement in the form of, A[i, j, k, ...] = ... where the indices of the LHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement.  <a href="#a5e7310fe532cf9d168557ed792198c24">More...</a><br /></td></tr>
<tr class="separator:a5e7310fe532cf9d168557ed792198c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c902d903680da14339842dd2fd29c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a99c902d903680da14339842dd2fd29c7">ReverseComputeInline</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block)=0</td></tr>
<tr class="memdesc:a99c902d903680da14339842dd2fd29c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a block into its only producer. It requires: 1) The block is a complete non-root block, which only produces and consumers one buffer 2) The block must not be the only leaf in the scope. 3) The only producer of the block is a read-after-write producer and a complete non-root block 4) The body of the block must be a <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> statement in the form of, B[f(i, j, k, ...)] = g(i, j, k, A[i, j, k, ...] ...) where the indices of each <code><a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode. ">BufferLoad</a></code> on the RHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement.  <a href="#a99c902d903680da14339842dd2fd29c7">More...</a><br /></td></tr>
<tr class="separator:a99c902d903680da14339842dd2fd29c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134eb33f96d69623a024c9c466183a00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a134eb33f96d69623a024c9c466183a00">DecomposeReduction</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a134eb33f96d69623a024c9c466183a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a reduction block into two separate blocks. a) The init block, which is translated from the init statement of the reduction block; b) The update block, which is the original block without init statement.  <a href="#a134eb33f96d69623a024c9c466183a00">More...</a><br /></td></tr>
<tr class="separator:a134eb33f96d69623a024c9c466183a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185c8eac1065290d84d58e7f4617232"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ab185c8eac1065290d84d58e7f4617232">RFactor</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, int factor_axis)=0</td></tr>
<tr class="memdesc:ab185c8eac1065290d84d58e7f4617232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize an associative reduction block by the specified loop.  <a href="#ab185c8eac1065290d84d58e7f4617232">More...</a><br /></td></tr>
<tr class="separator:ab185c8eac1065290d84d58e7f4617232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d1d23f24d903db844f75f51fe09a36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a93d1d23f24d903db844f75f51fe09a36">StorageAlign</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index, int axis, int factor, int offset)=0</td></tr>
<tr class="memdesc:a93d1d23f24d903db844f75f51fe09a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set alignment requirement for specific dimension such that stride[axis] == k * factor + offset for some k. This is useful to set memory layout for more friendly memory access pattern. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example, we can set alignment to be factor=2, offset=1 to avoid bank conflict for thread access on higher dimension in GPU shared memory.  <a href="#a93d1d23f24d903db844f75f51fe09a36">More...</a><br /></td></tr>
<tr class="separator:a93d1d23f24d903db844f75f51fe09a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4760135d373af488a08aaeba7114c48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#aa4760135d373af488a08aaeba7114c48">SetScope</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;storage_scope)=0</td></tr>
<tr class="memdesc:aa4760135d373af488a08aaeba7114c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage scope of a buffer, where the buffer is specified by the a block and a write-index.  <a href="#aa4760135d373af488a08aaeba7114c48">More...</a><br /></td></tr>
<tr class="separator:aa4760135d373af488a08aaeba7114c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad519f290c705afd441eaf683c4e24693"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ad519f290c705afd441eaf683c4e24693">Blockize</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:ad519f290c705afd441eaf683c4e24693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the subtree rooted at a specific loop into a block.  <a href="#ad519f290c705afd441eaf683c4e24693">More...</a><br /></td></tr>
<tr class="separator:ad519f290c705afd441eaf683c4e24693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66983e2dde6aeb18b443616398fff8bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a66983e2dde6aeb18b443616398fff8bf">Tensorize</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;intrin, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a66983e2dde6aeb18b443616398fff8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensorize the computation enclosed by loop with the tensor intrin.  <a href="#a66983e2dde6aeb18b443616398fff8bf">More...</a><br /></td></tr>
<tr class="separator:a66983e2dde6aeb18b443616398fff8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa67abdb51145a49d42cd1464429d928"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#afa67abdb51145a49d42cd1464429d928">Tensorize</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;intrin, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:afa67abdb51145a49d42cd1464429d928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensorize the computation enclosed by loop with the tensor intrin.  <a href="#afa67abdb51145a49d42cd1464429d928">More...</a><br /></td></tr>
<tr class="separator:afa67abdb51145a49d42cd1464429d928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57e90d92de36571a7d3b1c3677e6367"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#aa57e90d92de36571a7d3b1c3677e6367">Annotate</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;ann_key, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ann_val)=0</td></tr>
<tr class="memdesc:aa57e90d92de36571a7d3b1c3677e6367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate a loop with a key value pair.  <a href="#aa57e90d92de36571a7d3b1c3677e6367">More...</a><br /></td></tr>
<tr class="separator:aa57e90d92de36571a7d3b1c3677e6367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eafc8f0a4962114332a6a34289ff80e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a7eafc8f0a4962114332a6a34289ff80e">Annotate</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;ann_key, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ann_val)=0</td></tr>
<tr class="memdesc:a7eafc8f0a4962114332a6a34289ff80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate a block with a key value pair.  <a href="#a7eafc8f0a4962114332a6a34289ff80e">More...</a><br /></td></tr>
<tr class="separator:a7eafc8f0a4962114332a6a34289ff80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd553c09ec836dfcbff81379647f07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a45cd553c09ec836dfcbff81379647f07">Unannotate</a> (const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;ann_key)=0</td></tr>
<tr class="memdesc:a45cd553c09ec836dfcbff81379647f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unannotate a loop's annotation with key ann_key.  <a href="#a45cd553c09ec836dfcbff81379647f07">More...</a><br /></td></tr>
<tr class="separator:a45cd553c09ec836dfcbff81379647f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c310bca5d1583e61a3f27052a1dd5d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a7c310bca5d1583e61a3f27052a1dd5d0">Unannotate</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;ann_key)=0</td></tr>
<tr class="memdesc:a7c310bca5d1583e61a3f27052a1dd5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unannotate a block's annotation with key ann_key.  <a href="#a7c310bca5d1583e61a3f27052a1dd5d0">More...</a><br /></td></tr>
<tr class="separator:a7c310bca5d1583e61a3f27052a1dd5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55848f8f7a3293731cc4f4ed3832e901"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a55848f8f7a3293731cc4f4ed3832e901">TransformLayout</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a> buffer_index_type, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map, const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &gt; &amp;pad_value=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)=0</td></tr>
<tr class="memdesc:a55848f8f7a3293731cc4f4ed3832e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation represented by <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> to buffer.  <a href="#a55848f8f7a3293731cc4f4ed3832e901">More...</a><br /></td></tr>
<tr class="separator:a55848f8f7a3293731cc4f4ed3832e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998b22e37ef63a697a984c8ebcc39ca2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a998b22e37ef63a697a984c8ebcc39ca2">TransformBlockLayout</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map)=0</td></tr>
<tr class="memdesc:a998b22e37ef63a697a984c8ebcc39ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation represented by <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> to block.  <a href="#a998b22e37ef63a697a984c8ebcc39ca2">More...</a><br /></td></tr>
<tr class="separator:a998b22e37ef63a697a984c8ebcc39ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025b5eef0c2516fc1f72eed9ced88807"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a025b5eef0c2516fc1f72eed9ced88807">SetAxisSeparator</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a> buffer_index_type, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;axis_separators)=0</td></tr>
<tr class="memdesc:a025b5eef0c2516fc1f72eed9ced88807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the axis separator of a buffer, where the buffer is specified by a block and a read or write index.  <a href="#a025b5eef0c2516fc1f72eed9ced88807">More...</a><br /></td></tr>
<tr class="separator:a025b5eef0c2516fc1f72eed9ced88807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ef928082afe7f45b417f3e130792e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#af7ef928082afe7f45b417f3e130792e8">DecomposePadding</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:af7ef928082afe7f45b417f3e130792e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a padding block into a block filling const pad values and a block writing in-bound values.  <a href="#af7ef928082afe7f45b417f3e130792e8">More...</a><br /></td></tr>
<tr class="separator:af7ef928082afe7f45b417f3e130792e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac39c82aee1f8de30d5871d5923fc24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a1ac39c82aee1f8de30d5871d5923fc24">PadEinsum</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;padding)=0</td></tr>
<tr class="memdesc:a1ac39c82aee1f8de30d5871d5923fc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the computation of Einsum.  <a href="#a1ac39c82aee1f8de30d5871d5923fc24">More...</a><br /></td></tr>
<tr class="separator:a1ac39c82aee1f8de30d5871d5923fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1f70230fa5f01d406fc122e62b190"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ab1d1f70230fa5f01d406fc122e62b190">RollingBuffer</a> (const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;block_rv, int write_buffer_index)=0</td></tr>
<tr class="memdesc:ab1d1f70230fa5f01d406fc122e62b190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the target buffer via rolling buffering.  <a href="#ab1d1f70230fa5f01d406fc122e62b190">More...</a><br /></td></tr>
<tr class="separator:ab1d1f70230fa5f01d406fc122e62b190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2428fbd498ba2710a22d9ca4bc455957"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a2428fbd498ba2710a22d9ca4bc455957">EnterPostproc</a> ()=0</td></tr>
<tr class="memdesc:a2428fbd498ba2710a22d9ca4bc455957"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op that marks the start of postprocessing phase of scheduling.  <a href="#a2428fbd498ba2710a22d9ca4bc455957">More...</a><br /></td></tr>
<tr class="separator:a2428fbd498ba2710a22d9ca4bc455957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a481f01923b14e1851ebd38506e9c66ea inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a481f01923b14e1851ebd38506e9c66ea">type_index</a> () const</td></tr>
<tr class="separator:a481f01923b14e1851ebd38506e9c66ea inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d951e51832081b85875669eac90e940 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a4d951e51832081b85875669eac90e940">GetTypeKey</a> () const</td></tr>
<tr class="separator:a4d951e51832081b85875669eac90e940 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5693cbadcc1168b96db7b1cc5c200b86 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a5693cbadcc1168b96db7b1cc5c200b86">GetTypeKeyHash</a> () const</td></tr>
<tr class="separator:a5693cbadcc1168b96db7b1cc5c200b86 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e90b3f4ba8a590baff78c75807bbc7 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a90e90b3f4ba8a590baff78c75807bbc7 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a90e90b3f4ba8a590baff78c75807bbc7">IsInstance</a> () const</td></tr>
<tr class="separator:a90e90b3f4ba8a590baff78c75807bbc7 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd548730a6139d19fe24473ad66026d7 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#afd548730a6139d19fe24473ad66026d7">unique</a> () const</td></tr>
<tr class="separator:afd548730a6139d19fe24473ad66026d7 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133436a9ec5c4a768b94102bf95a660b inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a133436a9ec5c4a768b94102bf95a660b">Object</a> ()</td></tr>
<tr class="separator:a133436a9ec5c4a768b94102bf95a660b inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7968feb6ad38ecaffc320e13819d826 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#ab7968feb6ad38ecaffc320e13819d826">Object</a> (const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;other)</td></tr>
<tr class="separator:ab7968feb6ad38ecaffc320e13819d826 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1612f69ea5b4225d4cda759cd517323 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#aa1612f69ea5b4225d4cda759cd517323">Object</a> (<a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;&amp;other)</td></tr>
<tr class="separator:aa1612f69ea5b4225d4cda759cd517323 inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c32fbd96181f5c21d2c878ab285e4f inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a69c32fbd96181f5c21d2c878ab285e4f">operator=</a> (const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;other)</td></tr>
<tr class="separator:a69c32fbd96181f5c21d2c878ab285e4f inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae341e561272ff43cdcbc927bc29ac50d inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#ae341e561272ff43cdcbc927bc29ac50d">operator=</a> (<a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &amp;&amp;other)</td></tr>
<tr class="separator:ae341e561272ff43cdcbc927bc29ac50d inherit pub_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7e104017002884a4001cf9acb60a4000"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#a7e104017002884a4001cf9acb60a4000">_type_key</a> = &quot;tir.Schedule&quot;</td></tr>
<tr class="separator:a7e104017002884a4001cf9acb60a4000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a43d6bf3191bebb805eced0744d859c1e inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a43d6bf3191bebb805eced0744d859c1e">_type_key</a> = &quot;runtime.Object&quot;</td></tr>
<tr class="separator:a43d6bf3191bebb805eced0744d859c1e inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cb618bd4bbcd49317b35ea8e2996be inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a55cb618bd4bbcd49317b35ea8e2996be">_type_final</a> = false</td></tr>
<tr class="separator:a55cb618bd4bbcd49317b35ea8e2996be inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b234a745215da158b2386bbb34bd70 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a14b234a745215da158b2386bbb34bd70">_type_child_slots</a> = 0</td></tr>
<tr class="separator:a14b234a745215da158b2386bbb34bd70 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ece7bcb6bf73e88765c1f193a489ce inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a05ece7bcb6bf73e88765c1f193a489ce">_type_child_slots_can_overflow</a> = true</td></tr>
<tr class="separator:a05ece7bcb6bf73e88765c1f193a489ce inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e9f076b50b8b335b4a321e9b0bf03c inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a74e9f076b50b8b335b4a321e9b0bf03c">_type_has_method_visit_attrs</a> = true</td></tr>
<tr class="separator:a74e9f076b50b8b335b4a321e9b0bf03c inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fe62494027b70af1f7696d611c21b6 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a92fe62494027b70af1f7696d611c21b6">_type_has_method_sequal_reduce</a> = false</td></tr>
<tr class="separator:a92fe62494027b70af1f7696d611c21b6 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97054694d03dc5eac58315fb569ef88 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#ac97054694d03dc5eac58315fb569ef88">_type_has_method_shash_reduce</a> = false</td></tr>
<tr class="separator:ac97054694d03dc5eac58315fb569ef88 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aed95d70af7e44ce376a8d7be6c5f1 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#af6aed95d70af7e44ce376a8d7be6c5f1">_type_index</a> = <a class="el" href="structtvm_1_1runtime_1_1TypeIndex.html#aed93c7318efc8052201d4c404b21a40da83fed6b80a5bcb3247430922fd85ea47">TypeIndex::kDynamic</a></td></tr>
<tr class="separator:af6aed95d70af7e44ce376a8d7be6c5f1 inherit pub_static_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aae5808dc2e987bf17ef42196457a654d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#aae5808dc2e987bf17ef42196457a654d">Schedule</a></td></tr>
<tr class="separator:aae5808dc2e987bf17ef42196457a654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a9e84841ca982bff376a978ade0132631 inherit pub_types_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a9e84841ca982bff376a978ade0132631">FDeleter</a>) (<a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *self)</td></tr>
<tr class="memdesc:a9e84841ca982bff376a978ade0132631 inherit pub_types_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> deleter.  <a href="classtvm_1_1runtime_1_1Object.html#a9e84841ca982bff376a978ade0132631">More...</a><br /></td></tr>
<tr class="separator:a9e84841ca982bff376a978ade0132631 inherit pub_types_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55549a6c23987890246248682560a03d inherit pub_types_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a55549a6c23987890246248682560a03d">RefCounterType</a> = std::atomic&lt; int32_t &gt;</td></tr>
<tr class="separator:a55549a6c23987890246248682560a03d inherit pub_types_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a817ba6c23b7ee1821c48a75edf255a30 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a817ba6c23b7ee1821c48a75edf255a30">TypeIndex2Key</a> (uint32_t tindex)</td></tr>
<tr class="memdesc:a817ba6c23b7ee1821c48a75edf255a30 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type key of the corresponding index from runtime.  <a href="classtvm_1_1runtime_1_1Object.html#a817ba6c23b7ee1821c48a75edf255a30">More...</a><br /></td></tr>
<tr class="separator:a817ba6c23b7ee1821c48a75edf255a30 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee32a02dd44257da105fbbe5d9c8622 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a6ee32a02dd44257da105fbbe5d9c8622">TypeIndex2KeyHash</a> (uint32_t tindex)</td></tr>
<tr class="memdesc:a6ee32a02dd44257da105fbbe5d9c8622 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type key hash of the corresponding index from runtime.  <a href="classtvm_1_1runtime_1_1Object.html#a6ee32a02dd44257da105fbbe5d9c8622">More...</a><br /></td></tr>
<tr class="separator:a6ee32a02dd44257da105fbbe5d9c8622 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6841f97e06e6614dd7e82c6dd41b818a inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a6841f97e06e6614dd7e82c6dd41b818a">TypeKey2Index</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a6841f97e06e6614dd7e82c6dd41b818a inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type index of the corresponding key from runtime.  <a href="classtvm_1_1runtime_1_1Object.html#a6841f97e06e6614dd7e82c6dd41b818a">More...</a><br /></td></tr>
<tr class="separator:a6841f97e06e6614dd7e82c6dd41b818a inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbebc47be111ecc1d5869bcc0476e21 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a5fbebc47be111ecc1d5869bcc0476e21">_GetOrAllocRuntimeTypeIndex</a> ()</td></tr>
<tr class="separator:a5fbebc47be111ecc1d5869bcc0476e21 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94d79729ac85aa7c976e23d39066383 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#ad94d79729ac85aa7c976e23d39066383">RuntimeTypeIndex</a> ()</td></tr>
<tr class="separator:ad94d79729ac85aa7c976e23d39066383 inherit pub_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:ac9e5eed7719e322117bde996a171e33a inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#ac9e5eed7719e322117bde996a171e33a">IncRef</a> ()</td></tr>
<tr class="memdesc:ac9e5eed7719e322117bde996a171e33a inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">developer function, increases reference counter.  <a href="classtvm_1_1runtime_1_1Object.html#ac9e5eed7719e322117bde996a171e33a">More...</a><br /></td></tr>
<tr class="separator:ac9e5eed7719e322117bde996a171e33a inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb5361147634605d6595bb89381f03 inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a70fb5361147634605d6595bb89381f03">DecRef</a> ()</td></tr>
<tr class="memdesc:a70fb5361147634605d6595bb89381f03 inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">developer function, decrease reference counter.  <a href="classtvm_1_1runtime_1_1Object.html#a70fb5361147634605d6595bb89381f03">More...</a><br /></td></tr>
<tr class="separator:a70fb5361147634605d6595bb89381f03 inherit pro_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a726972ff315c446192df94027ddea032 inherit pro_static_methods_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a726972ff315c446192df94027ddea032">GetOrAllocRuntimeTypeIndex</a> (const std::string &amp;key, uint32_t static_tindex, uint32_t parent_tindex, uint32_t type_child_slots, bool type_child_slots_can_overflow)</td></tr>
<tr class="memdesc:a726972ff315c446192df94027ddea032 inherit pro_static_methods_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type index using type key.  <a href="classtvm_1_1runtime_1_1Object.html#a726972ff315c446192df94027ddea032">More...</a><br /></td></tr>
<tr class="separator:a726972ff315c446192df94027ddea032 inherit pro_static_methods_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtvm_1_1runtime_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtvm_1_1runtime_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1Object.html">tvm::runtime::Object</a></td></tr>
<tr class="memitem:a4bfc2586cb55f2af47728187b3256255 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a4bfc2586cb55f2af47728187b3256255">type_index_</a> {0}</td></tr>
<tr class="memdesc:a4bfc2586cb55f2af47728187b3256255 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> index(tag) that indicates the type of the object.  <a href="classtvm_1_1runtime_1_1Object.html#a4bfc2586cb55f2af47728187b3256255">More...</a><br /></td></tr>
<tr class="separator:a4bfc2586cb55f2af47728187b3256255 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d492efee331e2239a093f4b2017c10f inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a55549a6c23987890246248682560a03d">RefCounterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a0d492efee331e2239a093f4b2017c10f">ref_counter_</a> {0}</td></tr>
<tr class="memdesc:a0d492efee331e2239a093f4b2017c10f inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal reference counter.  <a href="classtvm_1_1runtime_1_1Object.html#a0d492efee331e2239a093f4b2017c10f">More...</a><br /></td></tr>
<tr class="separator:a0d492efee331e2239a093f4b2017c10f inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4407d2b59132e803ff791482dbe0145 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html#a9e84841ca982bff376a978ade0132631">FDeleter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html#af4407d2b59132e803ff791482dbe0145">deleter_</a> = nullptr</td></tr>
<tr class="memdesc:af4407d2b59132e803ff791482dbe0145 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleter of this object to enable customized allocation. If the deleter is nullptr, no deletion will be performed. The creator of the object must always set the deleter field properly.  <a href="classtvm_1_1runtime_1_1Object.html#af4407d2b59132e803ff791482dbe0145">More...</a><br /></td></tr>
<tr class="separator:af4407d2b59132e803ff791482dbe0145 inherit pro_attribs_classtvm_1_1runtime_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The user-facing schedule class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae637f126412479ed9bec05fd55376f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae637f126412479ed9bec05fd55376f7f">&#9670;&nbsp;</a></span>~ScheduleNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual tvm::tir::ScheduleNode::~ScheduleNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a18dca9b384aae8d67f66fd6759b5d716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18dca9b384aae8d67f66fd6759b5d716">&#9670;&nbsp;</a></span>AddUnitLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> tvm::tir::ScheduleNode::AddUnitLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new unit loop on top of the specific block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block above which the new loop is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop created </dd></dl>

</div>
</div>
<a id="a2fc0f0d95448e33040e067697c37ce02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc0f0d95448e33040e067697c37ce02">&#9670;&nbsp;</a></span>AddUnitLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> tvm::tir::ScheduleNode::AddUnitLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new unit loop on top of the specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop above which the new loop is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop created </dd></dl>

</div>
</div>
<a id="aa57e90d92de36571a7d3b1c3677e6367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57e90d92de36571a7d3b1c3677e6367">&#9670;&nbsp;</a></span>Annotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Annotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate a loop with a key value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be annotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
    <tr><td class="paramname">ann_val</td><td>The annotation value, a string or a ExprRV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eafc8f0a4962114332a6a34289ff80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eafc8f0a4962114332a6a34289ff80e">&#9670;&nbsp;</a></span>Annotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Annotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate a block with a key value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be annotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
    <tr><td class="paramname">ann_val</td><td>The annotation value, a string or a ExprRV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eae30e3d365afebdc96b58eac6fd731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eae30e3d365afebdc96b58eac6fd731">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the input loop to the given thread axis. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, if the thread axis starts with "threadIdx`, the loop can only be contained in data-parallel block iter and reduction block iters' bindings. Otherwise the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be bound to the thread axis </td></tr>
    <tr><td class="paramname">thread_axis</td><td>The thread axis to be bound to the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad519f290c705afd441eaf683c4e24693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad519f290c705afd441eaf683c4e24693">&#9670;&nbsp;</a></span>Blockize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::Blockize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the subtree rooted at a specific loop into a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>the root of the subtree </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new block </dd></dl>

</div>
</div>
<a id="a3b1d3ae0b3d145cbe33a8162723aa9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1d3ae0b3d145cbe33a8162723aa9aa">&#9670;&nbsp;</a></span>CacheIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::CacheIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block to cache precomputed index for later use. if there is no index computation, keep unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The target block </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the target buffer in block's read region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage blocks. </dd></dl>

</div>
</div>
<a id="abefe28d441bad8fc4b276e1bb35f9818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefe28d441bad8fc4b276e1bb35f9818">&#9670;&nbsp;</a></span>CacheInplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::CacheInplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create 2 blocks that read&amp;write a buffer region into a read/write cache. It requires the the target block both read &amp; write the target buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The target block operates on the target buffer. </td></tr>
    <tr><td class="paramname">read_buffer_index</td><td>The index of the buffer in block's read region. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage blocks, cache read block together with cache write block. </dd></dl>

</div>
</div>
<a id="a55bf333c162865fa4d18eb20ecf9a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bf333c162865fa4d18eb20ecf9a9a7">&#9670;&nbsp;</a></span>CacheRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::CacheRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td>
          <td class="paramname"><em>consumer_blocks</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The consumer block of the target buffer. </td></tr>
    <tr><td class="paramname">read_buffer_index</td><td>The index of the buffer in block's read region. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope. </td></tr>
    <tr><td class="paramname">consumer_blocks</td><td>An optional list of consumers of the cache to rewrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="a9f43b2ddd6e3b3bab64671345ecba72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43b2ddd6e3b3bab64671345ecba72d">&#9670;&nbsp;</a></span>CacheWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::CacheWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &gt;&#160;</td>
          <td class="paramname"><em>consumer_blocks</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer of the buffer </td></tr>
    <tr><td class="paramname">write_buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope </td></tr>
    <tr><td class="paramname">consumer_blocks</td><td>An optional list of consumers to read from cache directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="af901a7fa1336ee2e6668a2e44a8a2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af901a7fa1336ee2e6668a2e44a8a2efd">&#9670;&nbsp;</a></span>ComputeAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::ComputeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a producer block under the specific loop, and regenerate the loops induced by the block so that the buffer region produced by the producer block could cover those regions consumed by its consumer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) The block is not an output block with regard to the scope block, i.e. the buffers written by the block are allocated under the scope block 5) All the consumers of the block are under the given loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be moved </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop where the block to be moved under </td></tr>
    <tr><td class="paramname">preserve_unit_loops</td><td>Whether to keep the trivial loops whose extents are 1 </td></tr>
    <tr><td class="paramname">index</td><td>The block index of the loop body subtree blocks:<ul>
<li><code>index = -1</code> means inserted into the last possible insertion point;</li>
<li><code>index = -2</code> means inserted into the first possible insertion point;</li>
<li>Otherwise, <code>index</code> is a nonnegative number that indicates the insertion point </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e7310fe532cf9d168557ed792198c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7310fe532cf9d168557ed792198c24">&#9670;&nbsp;</a></span>ComputeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::ComputeInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline a block into its consumer(s). It requires: 1) The block is a complete non-root block, which only produces one buffer 2) The block must not be the only leaf in the scope. 3) The body of the block must be a <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> statement in the form of, A[i, j, k, ...] = ... where the indices of the LHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be inlined to its consumer(s) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70fbececf8717a961436a36ccc79c1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fbececf8717a961436a36ccc79c1d5">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a> tvm::tir::ScheduleNode::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the schedule, including both its state and its symbol table, guaranteeing that 1) SRef tree is completely reconstructed; 2) The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> being scheduled is not modified; 3) All the random variables are valid in the copy, pointing to the corresponding sref reconstructed. </p>

</div>
</div>
<a id="af7ef928082afe7f45b417f3e130792e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ef928082afe7f45b417f3e130792e8">&#9670;&nbsp;</a></span>DecomposePadding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::DecomposePadding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a padding block into a block filling const pad values and a block writing in-bound values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that match the padding pattern. </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop above which the const filling block is inserted before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const pad value filling block. </dd></dl>

</div>
</div>
<a id="a134eb33f96d69623a024c9c466183a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134eb33f96d69623a024c9c466183a00">&#9670;&nbsp;</a></span>DecomposeReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::DecomposeReduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a reduction block into two separate blocks. a) The init block, which is translated from the init statement of the reduction block; b) The update block, which is the original block without init statement. </p>
<p>The init block is inserted right before the given loop.</p>
<p>The schedule primitive requires: 1) The input block is a reduction block. 2) The input loop is the ancestor of the block. 3) The input loop is not lower than all the loops related to reduce block var. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The reduction block to be decomposed </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop above which the init block is inserted before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The init block </dd></dl>

</div>
</div>
<a id="a2428fbd498ba2710a22d9ca4bc455957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2428fbd498ba2710a22d9ca4bc455957">&#9670;&nbsp;</a></span>EnterPostproc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::EnterPostproc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A no-op that marks the start of postprocessing phase of scheduling. </p>

</div>
</div>
<a id="a9681c9b2a0d93e413cdec2caad7e74e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9681c9b2a0d93e413cdec2caad7e74e8">&#9670;&nbsp;</a></span>ForkSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a> tvm::tir::ScheduleNode::ForkSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fork the random state. </p>

</div>
</div>
<a id="a5b9a41d190be0f8d817b4936732bd0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9a41d190be0f8d817b4936732bd0ef">&#9670;&nbsp;</a></span>Fuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> tvm::tir::ScheduleNode::Fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loop_rvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse a list of consecutive loops into one. It requires: 1) The loops can't have annotations or thread bindings. 2) The (i+1)-th loop must be the only child of the i-th loop. 3) All loops must start with 0. 4) The domain of a loop to be fused cannot depend on another loop to be fused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rvs</td><td>The loops to be fused </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop after fusion </dd></dl>

</div>
</div>
<a id="aec0dd6e11e5c3cd85766a5a5ad9acd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0dd6e11e5c3cd85766a5a5ad9acd41">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1Block.html">Block</a> tvm::tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block </dd></dl>

</div>
</div>
<a id="ae2229f72137786e7ab892aa211191251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2229f72137786e7ab892aa211191251">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1For.html">For</a> tvm::tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the for loop corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding for loop </dd></dl>

</div>
</div>
<a id="a1d34e09f35c6ca2f179165a041037c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d34e09f35c6ca2f179165a041037c4c">&#9670;&nbsp;</a></span>Get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &amp;&#160;</td>
          <td class="paramname"><em>expr_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expr corresponding to the specific random variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr_rv</td><td>The random variable to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding expr </dd></dl>

</div>
</div>
<a id="ac75f01524386f7e4dda4d8581c49cede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75f01524386f7e4dda4d8581c49cede">&#9670;&nbsp;</a></span>GetBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::GetBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_name</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a block in a specific function with its name. </p>
<p>By default, if <code>func_name</code> is not specified, the schedule will search for the block in the function that is currently being "worked on". To switch the function to be worked on, use <code>WorkOn</code> before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the block to be retrieved </td></tr>
    <tr><td class="paramname">func_name</td><td>The name of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block retrieved </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Indexing error is raised if 0 or multiple blocks exist with the specific name</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#acb747d074e1f99477f7132e4614221a3" title="Instruct the schedule to work on a function in the IRModule. ">WorkOn</a> </dd></dl>

</div>
</div>
<a id="ab47f456cb12d24b89fe4432d0304d506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47f456cb12d24b89fe4432d0304d506">&#9670;&nbsp;</a></span>GetChildBlocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::GetChildBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the leaf blocks of a specific scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block where the scope is rooted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of child blocks </dd></dl>

</div>
</div>
<a id="a087bbdcd817e4afcef7ee4658c37a8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087bbdcd817e4afcef7ee4658c37a8a9">&#9670;&nbsp;</a></span>GetChildBlocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::GetChildBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the leaf blocks of under a specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop under which collecting is conducted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of child blocks </dd></dl>

</div>
</div>
<a id="ac5e28e0b470d0e9299d953c2ee3f6261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e28e0b470d0e9299d953c2ee3f6261">&#9670;&nbsp;</a></span>GetConsumers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::GetConsumers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the consumers of a specific block, under the same block scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of blocks, the consumers of the given block under the same scope of the given block </dd></dl>

</div>
</div>
<a id="a232186c0db6176db56df4cc30dd11829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232186c0db6176db56df4cc30dd11829">&#9670;&nbsp;</a></span>GetLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&gt; tvm::tir::ScheduleNode::GetLoops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parent loops of the block in its scope, from outer to inner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The query block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of loops above the given block in its scope, from outer to inner </dd></dl>

</div>
</div>
<a id="a448d3e3fdd1ba180485bcae68ca528bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d3e3fdd1ba180485bcae68ca528bb">&#9670;&nbsp;</a></span>GetProducers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a>&gt; tvm::tir::ScheduleNode::GetProducers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the producer of a specific block, under the same block scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block in the query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of blocks, the producers of the given block under the same scope of the given block </dd></dl>

</div>
</div>
<a id="a3b6d659b1a0a4b8175d7495afc3a791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6d659b1a0a4b8175d7495afc3a791c">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block sref corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block sref </dd></dl>

</div>
</div>
<a id="a08f7ed1ef1470fb1c9cfc272e14a1e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f7ed1ef1470fb1c9cfc272e14a1e32">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop sref corresponding to the specific <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The <a class="el" href="classtvm_1_1tir_1_1LoopRV.html" title="Managed reference to LoopRVNode. ">LoopRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding loop sref </dd></dl>

</div>
</div>
<a id="a34d50e4b429557302c5c6575bcc706d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d50e4b429557302c5c6575bcc706d5">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block/loop sref corresponding to the specific statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block/loop sref </dd></dl>

</div>
</div>
<a id="a2a52c8522a4bfc7d42a189250a462ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a52c8522a4bfc7d42a189250a462ce8">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block/loop sref corresponding to the specific statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block/loop sref </dd></dl>

</div>
</div>
<a id="ac8855eae5db733dcf21542b3dbd06e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8855eae5db733dcf21542b3dbd06e15">&#9670;&nbsp;</a></span>HasBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tvm::tir::ScheduleNode::HasBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the existance of a specific <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1tir_1_1BlockRV.html" title="Managed reference to BlockRVNode. ">BlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the corresponding block exists </dd></dl>

</div>
</div>
<a id="a6dd7ec20629e09cd0be1aa49e5f57c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd7ec20629e09cd0be1aa49e5f57c12">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> tvm::tir::ScheduleNode::mod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> associated with this schedule. </p>

</div>
</div>
<a id="a1ac39c82aee1f8de30d5871d5923fc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac39c82aee1f8de30d5871d5923fc24">&#9670;&nbsp;</a></span>PadEinsum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::PadEinsum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pad the computation of Einsum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that matches the Einsum pattern. </td></tr>
    <tr><td class="paramname">padding</td><td>The padding for each block iter.</td></tr>
  </table>
  </dd>
</dl>
<p>This schedule primitives identifies the Einsum pattern in the block body, and find its producer blocks. It then pads the computation of the Einsum pattern and its producer blocks. The output buffer and the producer buffer is resized according to the padding size. It requires the output buffer and the producer buffer to be allocated inside the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a>.</p>
<p>The padding is a list of non-negative integers, each element corresponds to the padding for each block iter in the order of block iters. The block and its producer blocks should have trivial bindings, i.e. each block iter is bound to a single loop variable. After padding, the block iter extent and the corresponding outer loop is extended by the padding size.</p>
<p>The size of the producer buffers are infered from the padding size of the Einsum computation. The producer buffers are padded by the initial value of the corresponding reduction. </p>

</div>
</div>
<a id="a553dc17c0b49b175cd16881c81b6c789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553dc17c0b49b175cd16881c81b6c789">&#9670;&nbsp;</a></span>Parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be parallelized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e36a8a0e37a76e55068dd534e28c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e36a8a0e37a76e55068dd534e28c8c5">&#9670;&nbsp;</a></span>ReIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::ReIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that read/write a buffer region into a read/write cache with reindexing. The layout of the cache will be the same as by the iterators of the block that reads/writes the buffer. It requires: 1) There is only one block who reads/writes the target buffer 2) There is only one buffer load/store of this buffer in the block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block operates on the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reindex stage block. </dd></dl>

</div>
</div>
<a id="a70d353bb52f6fa29fedeb90a6ff872d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d353bb52f6fa29fedeb90a6ff872d5">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a block random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c44d4f4ea662291ccb9d79383b6fefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c44d4f4ea662291ccb9d79383b6fefe">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a loop random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00fcf343d2bc8f36f170c04e5e29d2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fcf343d2bc8f36f170c04e5e29d2dc">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &amp;&#160;</td>
          <td class="paramname"><em>expr_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an integer random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059229fe0e254961da406807a97f7a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059229fe0e254961da406807a97f7a3d">&#9670;&nbsp;</a></span>Reorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ordered_loop_rvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder a list of loops. It doesn't require the loops to be consecutive. It requires: 1) The loops are in the same chain. That means: the loops can be ordered to [l_1, l_2, ... , l_n] where l_i is an ancestor of l_{i+1} and there are only single-branch loops between l_1 and l_n (which also indicates they are under the same scope). 2) After reordering, the domain of an outer loop cannot depend on any of the inner loops. 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> every block under the loop nests, its block binding must be affine, and the block variables must be either data parallel or reduction. 4) No duplicated loops are allowed in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ordered_loop_rvs</td><td>The loops in the new order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad75e0424902b06dca23d46807a9a47d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75e0424902b06dca23d46807a9a47d5">&#9670;&nbsp;</a></span>ReverseComputeAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::ReverseComputeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a consumer block under the specific loop, and regenerate the loops induced by the block so that the buffer region consumed by the consumer block could cover those regions produced by its producer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) All the producers of the block are under the given loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be moved </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop where the block to be moved under </td></tr>
    <tr><td class="paramname">preserve_unit_loops</td><td>Whether to keep the trivial loops whose extents are 1 </td></tr>
    <tr><td class="paramname">index</td><td>The block index of the loop body subtree blocks:<ul>
<li><code>index = -1</code> means inserted into the last possible insertion point;</li>
<li><code>index = -2</code> means inserted into the first possible insertion point;</li>
<li>Otherwise, <code>index</code> is a nonnegative number that indicates the insertion point </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c902d903680da14339842dd2fd29c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c902d903680da14339842dd2fd29c7">&#9670;&nbsp;</a></span>ReverseComputeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::ReverseComputeInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline a block into its only producer. It requires: 1) The block is a complete non-root block, which only produces and consumers one buffer 2) The block must not be the only leaf in the scope. 3) The only producer of the block is a read-after-write producer and a complete non-root block 4) The body of the block must be a <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> statement in the form of, B[f(i, j, k, ...)] = g(i, j, k, A[i, j, k, ...] ...) where the indices of each <code><a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode. ">BufferLoad</a></code> on the RHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be inlined to its producer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab185c8eac1065290d84d58e7f4617232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab185c8eac1065290d84d58e7f4617232">&#9670;&nbsp;</a></span>RFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> tvm::tir::ScheduleNode::RFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorize an associative reduction block by the specified loop. </p>
<p>An associative reduction cannot be parallelized directly, because it leads to potential race condition during accumulation. Alternatively, the reduction could be factorized on a loop with the following steps:</p><ul>
<li>Step 1: evenly slice the reduction into <code>n</code> separate chunks, where <code>n</code> is the loop extent</li>
<li>Step 2: compute the chunks separately and write the result into <code>n</code> intermediate buffers;</li>
<li>Step 3: accumulate the <code>n</code> separate buffer into the result buffer. Note that the Step 2 above introduces opportunities for parallelization. RFactor is a schedule primitive that implements the transformation described above. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop outside block we want to do rfactor </td></tr>
    <tr><td class="paramname">factor_axis</td><td>The position where the new dimension is placed in the new introduced rfactor buffer. Suppose the original reduction block writes to buffer <code>B</code> with ndim(B) dimensions, then <code>factor_axis</code> should be in range <code>[-ndim(B) - 1, ndim(B)]</code>, and the negative index will be normalized to a non-negative one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rfactor block </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab1d1f70230fa5f01d406fc122e62b190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1f70230fa5f01d406fc122e62b190">&#9670;&nbsp;</a></span>RollingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::RollingBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the target buffer via rolling buffering. </p>
<p>This primitive selects the outermost rollable axis with a positive bound overlap that appears in the block's ancestor loops as <code>rolling axis</code>, fold and circularize the buffer along the rolling dimension, append block predicate to avoid recomputing overlapping elements. It requires: 1) The buffer to be an intermediate buffer defined via <code>alloc_buffer</code>. 2) The LCA of the producer and consumer of the buffer is a for loop, typically, the producer and consumer of the buffer are cascaded through compute_at. 3) The access region of the buffer has at least one dimension that contains a positive bound overlap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer. </td></tr>
    <tr><td class="paramname">write_buffer_index</td><td>The index of the buffer in block's write region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9d2b3a98335b88f168b69deed49eb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d2b3a98335b88f168b69deed49eb19">&#9670;&nbsp;</a></span>SampleCategorical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> tvm::tir::ScheduleNode::SampleCategorical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1FloatImm.html">FloatImm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample an integer given the probability distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>The candidates </td></tr>
    <tr><td class="paramname">probs</td><td>The probability distribution of the candidates </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The random variable sampled from candidates </dd></dl>

</div>
</div>
<a id="abf9fbec94271b7512c24b6eced230c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9fbec94271b7512c24b6eced230c39">&#9670;&nbsp;</a></span>SampleComputeLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> tvm::tir::ScheduleNode::SampleComputeLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a compute-at location of the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block whose compute-at location is to be sampled </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampled loop where the input block is to be computed at </dd></dl>

</div>
</div>
<a id="a2c62b3f9486dd35714df50bc424d6698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c62b3f9486dd35714df50bc424d6698">&#9670;&nbsp;</a></span>SamplePerfectTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a>&gt; tvm::tir::ScheduleNode::SamplePerfectTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample the factors to perfect tile a specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be tiled </td></tr>
    <tr><td class="paramname">n</td><td>The number of tiles to be sampled </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum tile size allowed to be sampled in the innermost loop </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of length <code>n</code>, the random perfect tile sizes sampled </dd></dl>

</div>
</div>
<a id="a3cb60d6112fe5a443ef39bc005c9fbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb60d6112fe5a443ef39bc005c9fbf1">&#9670;&nbsp;</a></span>Seed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Seed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a>&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seed the randomness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The new random seed, -1 if use device random, otherwise non-negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a025b5eef0c2516fc1f72eed9ced88807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025b5eef0c2516fc1f72eed9ced88807">&#9670;&nbsp;</a></span>SetAxisSeparator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::SetAxisSeparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_separators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the axis separator of a buffer, where the buffer is specified by a block and a read or write index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that accesses the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
    <tr><td class="paramname">axis_separators</td><td>The axis separator of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4760135d373af488a08aaeba7114c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4760135d373af488a08aaeba7114c48">&#9670;&nbsp;</a></span>SetScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::SetScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the storage scope of a buffer, where the buffer is specified by the a block and a write-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac190a0ab76d8754a35209479bcc6dfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac190a0ab76d8754a35209479bcc6dfa2">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a>&gt; tvm::tir::ScheduleNode::Split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1tir.html#a5cd06e6cee9a7879b254e868025f08eb">ExprRV</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a loop into a list of consecutive loops. It requires: 1) The loop can't have annotation or thread binding. 2) The loop must start with 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be split </td></tr>
    <tr><td class="paramname">factors</td><td>The positive tiling factors, and at most one of which is <code>NullOpt</code>, which means that factor is inferred. </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loops after split </dd></dl>

</div>
</div>
<a id="abb3612c2598fa2d3ee0e6e3fc3de8a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3612c2598fa2d3ee0e6e3fc3de8a26">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1ScheduleState.html">ScheduleState</a> tvm::tir::ScheduleNode::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The internal state of scheduling </dd></dl>

</div>
</div>
<a id="a93d1d23f24d903db844f75f51fe09a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d1d23f24d903db844f75f51fe09a36">&#9670;&nbsp;</a></span>StorageAlign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::StorageAlign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set alignment requirement for specific dimension such that stride[axis] == k * factor + offset for some k. This is useful to set memory layout for more friendly memory access pattern. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example, we can set alignment to be factor=2, offset=1 to avoid bank conflict for thread access on higher dimension in GPU shared memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">axis</td><td>The dimension to be specified for alignment </td></tr>
    <tr><td class="paramname">factor</td><td>The factor multiple of alignment </td></tr>
    <tr><td class="paramname">offset</td><td>The required offset factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66983e2dde6aeb18b443616398fff8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66983e2dde6aeb18b443616398fff8bf">&#9670;&nbsp;</a></span>Tensorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Tensorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>intrin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tensorize the computation enclosed by loop with the tensor intrin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be tensorized </td></tr>
    <tr><td class="paramname">intrin</td><td>Name of the tensor intrinsic </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa67abdb51145a49d42cd1464429d928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa67abdb51145a49d42cd1464429d928">&#9670;&nbsp;</a></span>Tensorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Tensorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>intrin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tensorize the computation enclosed by loop with the tensor intrin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be tensorized </td></tr>
    <tr><td class="paramname">intrin</td><td>Name of the tensor intrinsic </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953bca4123b5a758adfdcd65634a5f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953bca4123b5a758adfdcd65634a5f3b">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Trace.html">Trace</a>&gt; tvm::tir::ScheduleNode::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The internally maintained trace of scheduling program execution </dd></dl>

</div>
</div>
<a id="a998b22e37ef63a697a984c8ebcc39ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998b22e37ef63a697a984c8ebcc39ca2">&#9670;&nbsp;</a></span>TransformBlockLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::TransformBlockLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a transformation represented by <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> to block. </p>
<p>The block iters and the block body are transformed by the given index_map. Outer loops corresponding to each new block iter are regenerated. The index_map is required to be bijective affine since we need its inverse mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be transformed </td></tr>
    <tr><td class="paramname">index_map</td><td>The transformation to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55848f8f7a3293731cc4f4ed3832e901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55848f8f7a3293731cc4f4ed3832e901">&#9670;&nbsp;</a></span>TransformLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::TransformLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a1c8232edeb2fcce8eb95477c5153237a">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pad_value</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a transformation represented by <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> to buffer. </p>
<p>The indices and the access region to the target buffer is transformed by the given index_map. The index_map is used to infer the new shape of the buffer. <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> must be either a function parameter, or allocated in a block (it cannot be a buffer subregion created via 'match_buffer'). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that accesses the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
    <tr><td class="paramname">index_map</td><td>The transformation to apply.</td></tr>
    <tr><td class="paramname">pad_value</td><td>The value to write into padding introduced by the transformation. If the schedule contains a producer block for the specified buffer, the pad value will be written as part of the producer block if possible, or after the producer block otherwise. Otherwise, if the buffer is an input, will insert an annotation block to state that the padding contains the known value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: If applied to an input buffer, the calling scope is responsible for ensuring that the pad_value is present. Algebraic symplifications, branch elimination, and other optimizations may assume that this precondition is met, and may result in incorrect results being returned. </p>

</div>
</div>
<a id="abc4294398b140f3ff13a33f94a2f9e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4294398b140f3ff13a33f94a2f9e5f">&#9670;&nbsp;</a></span>TVM_DECLARE_FINAL_OBJECT_INFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::tir::ScheduleNode::TVM_DECLARE_FINAL_OBJECT_INFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html">ScheduleNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Object.html">runtime::Object</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45cd553c09ec836dfcbff81379647f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cd553c09ec836dfcbff81379647f07">&#9670;&nbsp;</a></span>Unannotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Unannotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unannotate a loop's annotation with key ann_key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be unannotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c310bca5d1583e61a3f27052a1dd5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c310bca5d1583e61a3f27052a1dd5d0">&#9670;&nbsp;</a></span>Unannotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Unannotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">BlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unannotate a block's annotation with key ann_key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be unannotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84ec742f6295f59390592a6d0d90a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ec742f6295f59390592a6d0d90a552">&#9670;&nbsp;</a></span>Unroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unroll the input loop. It requires nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be unrolled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4a8cd91959ceab22855ec338978bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a8cd91959ceab22855ec338978bcee">&#9670;&nbsp;</a></span>Vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::Vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> each block under the loop, the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be vectorized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb747d074e1f99477f7132e4614221a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb747d074e1f99477f7132e4614221a3">&#9670;&nbsp;</a></span>WorkOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::tir::ScheduleNode::WorkOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>func_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the schedule to work on a function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<p>By default, the schedule works on the function with the name "main", or the only function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> if there is only one. If there is multiple functions in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>, and none of their names are "main", users will have to call this method to explicitly specify which function to work on.</p>
<p>This sugar function will guide the <code>GetBlock</code> method if its <code>func_name</code> is not specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the function to be working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1ScheduleNode.html#ac75f01524386f7e4dda4d8581c49cede" title="Retrieve a block in a specific function with its name. ">GetBlock</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aae5808dc2e987bf17ef42196457a654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5808dc2e987bf17ef42196457a654d">&#9670;&nbsp;</a></span>Schedule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classtvm_1_1tir_1_1Schedule.html">Schedule</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7e104017002884a4001cf9acb60a4000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e104017002884a4001cf9acb60a4000">&#9670;&nbsp;</a></span>_type_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::ScheduleNode::_type_key = &quot;tir.Schedule&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/tir/schedule/<a class="el" href="tir_2schedule_2schedule_8h_source.html">schedule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
