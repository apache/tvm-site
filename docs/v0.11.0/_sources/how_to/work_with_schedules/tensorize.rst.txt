
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "how_to/work_with_schedules/tensorize.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_how_to_work_with_schedules_tensorize.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_how_to_work_with_schedules_tensorize.py:


.. _tutorials-tensorize:

Use Tensorize to Leverage Hardware Intrinsics
=============================================
**Author**: `Yizhi Liu <https://github.com/yzhliu>`_

This is an introduction material on how to perform tensorization in TVM.

By using schedule primitive :code:`tensorize`,
people can replace a unit of computation with the corresponding intrinsics,
making it easy to leverage handcrafted micro-kernels,
as well as extend TVM to support new hardware architectures.

The purpose of this tutorial is to show the functionality
and usage of tensorize instead of providing an efficient solution.

.. GENERATED FROM PYTHON SOURCE LINES 35-43

.. code-block:: default

    from __future__ import absolute_import, print_function


    import tvm
    from tvm import te
    import tvm.testing
    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 49-56

Define Matrix Multiplication
----------------------------
Take matrix multiplication as our example.
Matmul first multiply the corresponding elements between two matrix,
then accumulate across a certain axis.
The following lines describe the computation :code:`A * B^T` in TVM.


.. GENERATED FROM PYTHON SOURCE LINES 56-64

.. code-block:: default

    N, M, L = 1024, 512, 64
    A = te.placeholder((N, L), name="A")
    B = te.placeholder((M, L), name="B")
    k = te.reduce_axis((0, L), name="k")
    C = te.compute((N, M), lambda i, j: te.sum(A[i, k] * B[j, k], axis=k), name="C")
    s = te.create_schedule(C.op)
    print(tvm.lower(s, [A, B, C], simple_mode=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    @main = primfn(A_1: handle, B_1: handle, C_1: handle) -> ()
      attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
      buffers = {A: Buffer(A_2: Pointer(float32), float32, [1024, 64], []),
                 B: Buffer(B_2: Pointer(float32), float32, [512, 64], []),
                 C: Buffer(C_2: Pointer(float32), float32, [1024, 512], [])}
      buffer_map = {A_1: A, B_1: B, C_1: C} {
      for (i: int32, 0, 1024) {
        for (j: int32, 0, 512) {
          C_3: Buffer(C_2, float32, [524288], [])[((i*512) + j)] = 0f32
          for (k: int32, 0, 64) {
            let cse_var_1: int32 = ((i*512) + j)
            C_3[cse_var_1] = (C_3[cse_var_1] + (A_3: Buffer(A_2, float32, [65536], [])[((i*64) + k)]*B_3: Buffer(B_2, float32, [32768], [])[((j*64) + k)]))
          }
        }
      }
    }






.. GENERATED FROM PYTHON SOURCE LINES 65-73

Schedule the Matmul
-------------------
Now, suppose we have an accelerator that supports
matrix-vector multiplication (GEMV) as a hardware primitive,
which can take arbitrary size of reduce axis,
but another axis needs to be no larger than 16.
Thus we break down the matmul loops to make the innermost loops a (16x64) GEMV.


.. GENERATED FROM PYTHON SOURCE LINES 73-80

.. code-block:: default

    factor = 16
    x, y = C.op.axis
    (z,) = C.op.reduce_axis
    yo, yi = s[C].split(y, factor=factor)
    s[C].reorder(x, yo, yi, z)
    print(tvm.lower(s, [A, B, C], simple_mode=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    @main = primfn(A_1: handle, B_1: handle, C_1: handle) -> ()
      attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
      buffers = {A: Buffer(A_2: Pointer(float32), float32, [1024, 64], []),
                 B: Buffer(B_2: Pointer(float32), float32, [512, 64], []),
                 C: Buffer(C_2: Pointer(float32), float32, [1024, 512], [])}
      buffer_map = {A_1: A, B_1: B, C_1: C} {
      for (i: int32, 0, 1024) {
        for (j.outer: int32, 0, 32) {
          for (j.inner: int32, 0, 16) {
            C_3: Buffer(C_2, float32, [524288], [])[(((i*512) + (j.outer*16)) + j.inner)] = 0f32
            for (k: int32, 0, 64) {
              let cse_var_1: int32 = (((i*512) + (j.outer*16)) + j.inner)
              C_3[cse_var_1] = (C_3[cse_var_1] + (A_3: Buffer(A_2, float32, [65536], [])[((i*64) + k)]*B_3: Buffer(B_2, float32, [32768], [])[(((j.outer*1024) + (j.inner*64)) + k)]))
            }
          }
        }
      }
    }






.. GENERATED FROM PYTHON SOURCE LINES 81-97

As showed in the IR printed above,
the inner loops :code:`j.inner` along with :code:`k` together form a computation of GEMV
- within the inner most two loops, the index :code:`i` is fixed,
the access to the matrix :code:`A` only varies by :code:`k`,
which makes the access pattern of :code:`A` a "vector".
In order to leverage our hypothetical hardware's GEMV instruction,
we can tensorize over :code:`j.inner`.

Define GEMV Tensorization Intrinsic
-----------------------------------
Before scheduling the tensorization, we need to first define the intrinsic function for GEMV.
It includes two parts, the first is a compute definition of GEMV.
TVM uses it to match the computing pattern in the original Matmul schedule.
The second is to specify how to execute GEMV on the device,
which is done in :code:`intrin_func` below.


.. GENERATED FROM PYTHON SOURCE LINES 97-127

.. code-block:: default

    def intrin_gemv(m, l):
        a = te.placeholder((l,), name="a")
        b = te.placeholder((m, l), name="b")
        k = te.reduce_axis((0, l), name="k")
        c = te.compute((m,), lambda i: te.sum(a[k] * b[i, k], axis=k), name="c")
        Ab = tvm.tir.decl_buffer(a.shape, a.dtype, name="A", offset_factor=1, strides=[1])
        Bb = tvm.tir.decl_buffer(b.shape, b.dtype, name="B", offset_factor=1, strides=[te.var("s1"), 1])
        Cb = tvm.tir.decl_buffer(c.shape, c.dtype, name="C", offset_factor=1, strides=[1])

        def intrin_func(ins, outs):
            ib = tvm.tir.ir_builder.create()
            aa, bb = ins
            cc = outs[0]
            ib.emit(
                tvm.tir.call_extern(
                    "int32",
                    "gemv_update",
                    cc.access_ptr("w"),
                    aa.access_ptr("r"),
                    bb.access_ptr("r"),
                    m,
                    l,
                    bb.strides[0],
                )
            )
            return ib.get()

        return te.decl_tensor_intrin(c.op, intrin_func, binds={a: Ab, b: Bb, c: Cb})









.. GENERATED FROM PYTHON SOURCE LINES 128-149

Here :code:`te.decl_tensor_intrin` declares how to execute the computation :code:`c.op`.
Our implementation simply takes the inputs and outputs,
converts them to pointers and emit an external function call.
Note that tensorization requires user to specify :code:`offset_factor`,
with this information, TVM has knowledge of whether the data is aligned
between the start address of the original data structure
and the offset being passed to tensorize,
so that it has chance to optimize with vectorized loading.
We set the factor to 1 for simplification.

Buffers are also declared for inputs and outputs, though this is not required,
we benefit from the extra information provided by buffers. For example, we pass
:code:`bb.strides[0]` as an argument to the external function :code:`gemv_update`.
For now :code:`bb.strides[0] == l`,
but later we will see how they can differ with more complicated schedules.

Note that we use :code:`te.var("s1")` as the first stride dimension for :code:`B`.
If the strides can be inferred
- in this case, TVM knows tensor B is compact thus the strides are :code:`[L, 1]` -
such placeholder can be put to let TVM automatically bind the inferred value for us.


.. GENERATED FROM PYTHON SOURCE LINES 149-153

.. code-block:: default

    gemv = intrin_gemv(factor, L)
    s[C].tensorize(yi, gemv)
    print(tvm.lower(s, [A, B, C], simple_mode=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    @main = primfn(A_1: handle, B_1: handle, C_1: handle) -> ()
      attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
      buffers = {A: Buffer(A_2: Pointer(float32), float32, [1024, 64], []),
                 B: Buffer(B_2: Pointer(float32), float32, [512, 64], []),
                 C: Buffer(C_2: Pointer(float32), float32, [1024, 512], [])}
      buffer_map = {A_1: A, B_1: B, C_1: C} {
      for (i: int32, 0, 1024) {
        for (j.outer: int32, 0, 32) {
          @tir.call_extern("gemv_update", @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), C_2, ((i*512) + (j.outer*16)), 16, 2, dtype=handle), @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), A_2, (i*64), 64, 1, dtype=handle), @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), B_2, (j.outer*1024), 1024, 1, dtype=handle), 16, 64, 64, dtype=int32)
        }
      }
    }






.. GENERATED FROM PYTHON SOURCE LINES 154-159

By tensorizing over :code:`yi`, the inner most two loops are
now replaced by the intrinsic function we defined before.
In order to build and run the module, let's define the external function :code:`gemv_update`,
it is a naive implementation of GEMV, just for demonstration.


.. GENERATED FROM PYTHON SOURCE LINES 159-179

.. code-block:: default

    def gemv_impl():
        cc_code = """
          extern "C" int gemv_update(float *cc, float *aa, float *bb, int m, int l, int stride) {
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < l; ++j) {
                    cc[i] += aa[j] * bb[i * stride + j];
                }
            }
            return 0;
          }
        """
        from tvm.contrib import utils, clang

        temp = utils.tempdir()
        ll_path = temp.relpath("temp.ll")
        # Create LLVM ir from c source code
        ll_code = clang.create_llvm(cc_code, output=ll_path)
        return ll_code









.. GENERATED FROM PYTHON SOURCE LINES 180-183

Now we leverage the pragma attribute :code:`import_llvm` to import llvm asm inline.
The importing needs to happen before the tensorized GEMV being executed.


.. GENERATED FROM PYTHON SOURCE LINES 183-186

.. code-block:: default

    s[C].pragma(x, "import_llvm", gemv_impl())
    print(tvm.lower(s, [A, B, C], simple_mode=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    @main = primfn(A_1: handle, B_1: handle, C_1: handle) -> ()
      attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
      buffers = {A: Buffer(A_2: Pointer(float32), float32, [1024, 64], []),
                 B: Buffer(B_2: Pointer(float32), float32, [512, 64], []),
                 C: Buffer(C_2: Pointer(float32), float32, [1024, 512], [])}
      buffer_map = {A_1: A, B_1: B, C_1: C} {
      attr [IterVar(i: int32, (nullptr), "DataPar", "")] "pragma_import_llvm" = "; ModuleID = '/tmp/tmplfsaskzy/input0.cc'\nsource_filename = \"/tmp/tmplfsaskzy/input0.cc\"\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n; Function Attrs: noinline nounwind optnone uwtable\ndefine dso_local i32 @gemv_update(float*, float*, float*, i32, i32, i32) #0 {\n  %7 = alloca float*, align 8\n  %8 = alloca float*, align 8\n  %9 = alloca float*, align 8\n  %10 = alloca i32, align 4\n  %11 = alloca i32, align 4\n  %12 = alloca i32, align 4\n  %13 = alloca i32, align 4\n  %14 = alloca i32, align 4\n  store float* %0, float** %7, align 8\n  store float* %1, float** %8, align 8\n  store float* %2, float** %9, align 8\n  store i32 %3, i32* %10, align 4\n  store i32 %4, i32* %11, align 4\n  store i32 %5, i32* %12, align 4\n  store i32 0, i32* %13, align 4\n  br label %15\n\n15:                                               ; preds = %50, %6\n  %16 = load i32, i32* %13, align 4\n  %17 = load i32, i32* %10, align 4\n  %18 = icmp slt i32 %16, %17\n  br i1 %18, label %19, label %53\n\n19:                                               ; preds = %15\n  store i32 0, i32* %14, align 4\n  br label %20\n\n20:                                               ; preds = %46, %19\n  %21 = load i32, i32* %14, align 4\n  %22 = load i32, i32* %11, align 4\n  %23 = icmp slt i32 %21, %22\n  br i1 %23, label %24, label %49\n\n24:                                               ; preds = %20\n  %25 = load float*, float** %8, align 8\n  %26 = load i32, i32* %14, align 4\n  %27 = sext i32 %26 to i64\n  %28 = getelementptr inbounds float, float* %25, i64 %27\n  %29 = load float, float* %28, align 4\n  %30 = load float*, float** %9, align 8\n  %31 = load i32, i32* %13, align 4\n  %32 = load i32, i32* %12, align 4\n  %33 = mul nsw i32 %31, %32\n  %34 = load i32, i32* %14, align 4\n  %35 = add nsw i32 %33, %34\n  %36 = sext i32 %35 to i64\n  %37 = getelementptr inbounds float, float* %30, i64 %36\n  %38 = load float, float* %37, align 4\n  %39 = fmul float %29, %38\n  %40 = load float*, float** %7, align 8\n  %41 = load i32, i32* %13, align 4\n  %42 = sext i32 %41 to i64\n  %43 = getelementptr inbounds float, float* %40, i64 %42\n  %44 = load float, float* %43, align 4\n  %45 = fadd float %44, %39\n  store float %45, float* %43, align 4\n  br label %46\n\n46:                                               ; preds = %24\n  %47 = load i32, i32* %14, align 4\n  %48 = add nsw i32 %47, 1\n  store i32 %48, i32* %14, align 4\n  br label %20\n\n49:                                               ; preds = %20\n  br label %50\n\n50:                                               ; preds = %49\n  %51 = load i32, i32* %13, align 4\n  %52 = add nsw i32 %51, 1\n  store i32 %52, i32* %13, align 4\n  br label %15\n\n53:                                               ; preds = %15\n  ret i32 0\n}\n\nattributes #0 = { noinline nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n\n!llvm.module.flags = !{!0}\n!llvm.ident = !{!1}\n\n!0 = !{i32 1, !\"wchar_size\", i32 4}\n!1 = !{!\"clang version 9.0.0-2~ubuntu18.04.2 (tags/RELEASE_900/final)\"}\n";
      for (i, 0, 1024) {
        for (j.outer: int32, 0, 32) {
          @tir.call_extern("gemv_update", @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), C_2, ((i*512) + (j.outer*16)), 16, 2, dtype=handle), @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), A_2, (i*64), 64, 1, dtype=handle), @tir.tvm_access_ptr(@tir.type_annotation(, dtype=float32), B_2, (j.outer*1024), 1024, 1, dtype=handle), 16, 64, 64, dtype=int32)
        }
      }
    }






.. GENERATED FROM PYTHON SOURCE LINES 187-190

Finally we compare the tensorize version with that :code:`numpy.dot` produces,
ensure our implementation is correct.


.. GENERATED FROM PYTHON SOURCE LINES 190-202

.. code-block:: default

    func = tvm.build(s, [A, B, C], target="llvm", name="gemv")

    from tvm.topi.utils import get_const_tuple

    dtype = A.dtype
    dev = tvm.device("cpu", 0)
    a = np.random.uniform(size=get_const_tuple(A.shape)).astype(dtype)
    b = np.random.uniform(size=get_const_tuple(B.shape)).astype(dtype)
    c = tvm.nd.array(np.zeros(get_const_tuple(C.shape), dtype=dtype), dev)
    func(tvm.nd.array(a, dev), tvm.nd.array(b, dev), c)
    tvm.testing.assert_allclose(c.numpy(), np.dot(a, b.T), rtol=1e-3)








.. GENERATED FROM PYTHON SOURCE LINES 203-212

Reduce-update for Tensorize
---------------------------
So far you have learned the basic idea of tensorize,
now let's move one step forward to a more complicated case.

Assume our accelerator could only multiply a vector by a square matrix,
in which the vector size needs to be no larger than 16.
Given such hardware constrain, now we need to split the reduce axis as following,


.. GENERATED FROM PYTHON SOURCE LINES 212-215

.. code-block:: default

    zo, zi = s[C].split(z, factor=factor)
    s[C].reorder(x, yo, zo, yi, zi)








.. GENERATED FROM PYTHON SOURCE LINES 216-221

However, since the tensorize intrinsic now only covers a part of the reduce axis,
instead of using one "body" function, TVM requires a :code:`reduce_reset` function,
which will be invoked before the reduce for-loop, and a :code:`reduce_update` function,
which defines the "update" computing strategy.


.. GENERATED FROM PYTHON SOURCE LINES 221-289

.. code-block:: default

    def gemv_impl():
        cc_code = """
          extern "C" int gemv_update(float *cc, float *aa, float *bb, int m, int l, int stride) {
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < l; ++j) {
                    cc[i] += aa[j] * bb[i * stride + j];
                }
            }
            return 0;
          }
          extern "C" int gemv_reset(float *cc, int m) {
            for (int i = 0; i < m; ++i) {
                cc[i] = 0.0;
            }
            return 0;
          }
        """
        from tvm.contrib import utils, clang

        temp = utils.tempdir()
        ll_path = temp.relpath("temp.ll")
        # Create LLVM ir from c source code
        ll_code = clang.create_llvm(cc_code, output=ll_path)
        return ll_code


    def intrin_gemv(m, l):
        a = te.placeholder((l,), name="a")
        b = te.placeholder((m, l), name="b")
        k = te.reduce_axis((0, l), name="k")
        c = te.compute((m,), lambda i: te.sum(a[k] * b[i, k], axis=k), name="c")
        Ab = tvm.tir.decl_buffer(a.shape, a.dtype, name="A", offset_factor=1, strides=[1])
        Bb = tvm.tir.decl_buffer(b.shape, b.dtype, name="B", offset_factor=1, strides=[te.var("s1"), 1])
        Cb = tvm.tir.decl_buffer(c.shape, c.dtype, name="C", offset_factor=1, strides=[1])

        def intrin_func(ins, outs):
            aa, bb = ins
            cc = outs[0]

            def _body():
                ib = tvm.tir.ir_builder.create()
                ib.emit(
                    tvm.tir.call_extern(
                        "int32",
                        "gemv_update",
                        cc.access_ptr("w"),
                        aa.access_ptr("r"),
                        bb.access_ptr("r"),
                        m,
                        l,
                        bb.strides[0],
                    )
                )
                return ib.get()

            def _reduce_reset():
                ib = tvm.tir.ir_builder.create()
                ib.emit(tvm.tir.call_extern("int32", "gemv_reset", cc.access_ptr("w"), m))
                return ib.get()

            def _reduce_update():
                return _body()

            return _body(), _reduce_reset(), _reduce_update()

        return te.decl_tensor_intrin(c.op, intrin_func, binds={a: Ab, b: Bb, c: Cb})









.. GENERATED FROM PYTHON SOURCE LINES 290-302

Note that :code:`intrin_func` now returns a triplet:
:code:`(body, reduce_reset, reduce_update)`.
If tensorization includes all the reduce axes, function :code:`body()` will be invoked,
otherwise :code:`reduce_reset()` and :code:`reduce_update()` together will be used.
In our example :code:`body()` and :code:`reduce_update()`
share the same implementation,
while in other cases, hardware may have different instructions for these two functions.
Moreover, we can see now :code:`bb.strides[0]` is different from :code:`l`
due to the tiling.

Tensorize for squared GEMV, build and check the results,


.. GENERATED FROM PYTHON SOURCE LINES 302-313

.. code-block:: default

    gemv = intrin_gemv(factor, factor)
    s[C].tensorize(yi, gemv)
    s[C].pragma(yo, "import_llvm", gemv_impl())

    func = tvm.build(s, [A, B, C], target="llvm", name="gemv")
    a = np.random.uniform(size=get_const_tuple(A.shape)).astype(dtype)
    b = np.random.uniform(size=get_const_tuple(B.shape)).astype(dtype)
    c = tvm.nd.array(np.zeros(get_const_tuple(C.shape), dtype=dtype), dev)
    func(tvm.nd.array(a, dev), tvm.nd.array(b, dev), c)
    tvm.testing.assert_allclose(c.numpy(), np.dot(a, b.T), rtol=1e-3)








.. GENERATED FROM PYTHON SOURCE LINES 314-325

Summary
-------
This tutorial demonstrates the usage of tensorize intrinsic in TVM.
Tensorize provides a way for users to get fully optimized schedule via micro-kernels.
For example, INT8 quantization on Intel CPUs uses tensorization
to invoke AVX instruction directly.
It also enables TVM to compile to ASICs -
checkout :ref:`vta-index` for details.
We also demonstrates how to use inline assembly importing,
which helps users inject asm easily into the schedule.



.. _sphx_glr_download_how_to_work_with_schedules_tensorize.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tensorize.py <tensorize.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tensorize.ipynb <tensorize.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
