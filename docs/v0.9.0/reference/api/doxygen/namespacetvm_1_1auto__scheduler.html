<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::auto_scheduler Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1auto__scheduler.html">auto_scheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::auto_scheduler Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AccessAnalyzer.html">AccessAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1AccessAnalyzerNode.html" title="Static analyzer for a ComputeDAG. ">AccessAnalyzerNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1AccessAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AccessAnalyzerNode.html">AccessAnalyzerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static analyzer for a <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a>.  <a href="classtvm_1_1auto__scheduler_1_1AccessAnalyzerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AnnotationStep.html">AnnotationStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1AnnotationStepNode.html" title="Annotation step that corresponds to vectorize, parallel, unroll and thread binding. (i.e. te::Stage::vectorize, te::Stage::parallel, te::Stage::vectorize, te::Stage::bind) ">AnnotationStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1AnnotationStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AnnotationStepNode.html">AnnotationStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation step that corresponds to vectorize, parallel, unroll and thread binding. (i.e. <a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a>, <a class="el" href="classtvm_1_1te_1_1Stage.html#a60a6be10a1a96cb594c1399efabafef3" title="Parallelize iteration. ">te::Stage::parallel</a>, <a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a>, <a class="el" href="classtvm_1_1te_1_1Stage.html#aa9ace0034447b461610ebc1c2de69a26" title="Bind the IterVar to thread index. ">te::Stage::bind</a>)  <a href="classtvm_1_1auto__scheduler_1_1AnnotationStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AttachMap.html">AttachMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1AttachMapNode.html" title="stores the compute_at relation between stages This stores a bi-directional mapping from stages and it...">AttachMapNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1AttachMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1AttachMapNode.html">AttachMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the compute_at relation between stages This stores a bi-directional mapping from stages and iter:  <a href="classtvm_1_1auto__scheduler_1_1AttachMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1BuildResult.html">BuildResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1BuildResultNode.html" title="Store the result of a build. ">BuildResultNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1BuildResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1BuildResultNode.html">BuildResultNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the result of a build.  <a href="classtvm_1_1auto__scheduler_1_1BuildResultNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CacheReadStep.html">CacheReadStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1CacheReadStepNode.html" title="Cache read step that corresponds to te::Schedule::cache_read. ">CacheReadStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1CacheReadStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CacheReadStepNode.html">CacheReadStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache read step that corresponds to <a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b" title="create a cache read of original tensor for readers. This will mutate the body of the readers...">te::Schedule::cache_read</a>.  <a href="classtvm_1_1auto__scheduler_1_1CacheReadStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CacheWriteStep.html">CacheWriteStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1CacheWriteStepNode.html" title="Cache write step that corresponds to te::Schedule::cache_write. ">CacheWriteStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1CacheWriteStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CacheWriteStepNode.html">CacheWriteStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache write step that corresponds to <a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71" title="Create a cache write tensor for producing tensor. The the tensor will take over body of original tens...">te::Schedule::cache_write</a>.  <a href="classtvm_1_1auto__scheduler_1_1CacheWriteStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeAtStep.html">ComputeAtStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeAtStepNode.html" title="Compute at step that corresponds to te::Stage::compute_at. ">ComputeAtStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeAtStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeAtStepNode.html">ComputeAtStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute at step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a071545484de7a894c01ccf0e77183730" title="specify the schedule to be computed at the parent schedule&#39;s scope. ">te::Stage::compute_at</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeAtStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAGNode.html" title="The auto-scheduler&#39;s computational graph and related program analyses. ">ComputeDAGNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAGNode.html">ComputeDAGNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The auto-scheduler's computational graph and related program analyses.  <a href="classtvm_1_1auto__scheduler_1_1ComputeDAGNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeInlineStep.html">ComputeInlineStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeInlineStepNode.html" title="Compute inline step that corresponds to te::Stage::compute_inline. ">ComputeInlineStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeInlineStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeInlineStepNode.html">ComputeInlineStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inline step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a1c58b35e37561739440b322c29d30c3b" title="Compute the function inline. ">te::Stage::compute_inline</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeInlineStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeRootStep.html">ComputeRootStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeRootStepNode.html" title="Compute root step that corresponds to te::Stage::compute_root. ">ComputeRootStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeRootStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeRootStepNode.html">ComputeRootStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute root step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a95b58b2d2ec034ecd0bdb99f95c0b0ba" title="Compute the function at group root. ">te::Stage::compute_root</a>.  <a href="classtvm_1_1auto__scheduler_1_1ComputeRootStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CostModel.html">CostModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1CostModelNode.html" title="The base class for cost model. ">CostModelNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1CostModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1CostModelNode.html">CostModelNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for cost model.  <a href="classtvm_1_1auto__scheduler_1_1CostModelNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FollowFusedSplitStep.html">FollowFusedSplitStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1FollowFusedSplitStepNode.html" title="Similar to FollowSplitStep, but uses split factors from multiple steps. ">FollowFusedSplitStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1FollowFusedSplitStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FollowFusedSplitStepNode.html">FollowFusedSplitStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classtvm_1_1auto__scheduler_1_1FollowSplitStep.html" title="Managed reference to FollowSplitStepNode. ">FollowSplitStep</a>, but uses split factors from multiple steps.  <a href="classtvm_1_1auto__scheduler_1_1FollowFusedSplitStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FollowSplitStep.html">FollowSplitStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1FollowSplitStepNode.html" title="Similar to SplitStepNode, but uses split factors from another step (i.e. Follow another split step) ...">FollowSplitStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1FollowSplitStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FollowSplitStepNode.html">FollowSplitStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classtvm_1_1auto__scheduler_1_1SplitStepNode.html" title="Split step that corresponds to te::Stage::split with additional support of multiple-level of factors...">SplitStepNode</a>, but uses split factors from another step (i.e. Follow another split step)  <a href="classtvm_1_1auto__scheduler_1_1FollowSplitStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FuseStep.html">FuseStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1FuseStepNode.html" title="Fuse step that corresponds to te::Stage::fuse. ">FuseStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1FuseStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1FuseStepNode.html">FuseStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a5658065d9cbbee620bbd107d30c4ae72" title="Fuse the inner outer domain to the target. ">te::Stage::fuse</a>.  <a href="classtvm_1_1auto__scheduler_1_1FuseStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1HardwareParams.html">HardwareParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1HardwareParamsNode.html" title="The parameters of target hardware used to guide the SearchPolicy. ">HardwareParamsNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1HardwareParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1HardwareParamsNode.html">HardwareParamsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parameters of target hardware used to guide the <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html" title="Managed reference to SearchPolicyNode. ">SearchPolicy</a>.  <a href="classtvm_1_1auto__scheduler_1_1HardwareParamsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1IteratorNode.html" title="An iterator of a for-loop Similar to tvm::IterVar in include/tvm/tir/expr.h ">IteratorNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1Iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1IteratorNode.html">IteratorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator of a for-loop Similar to tvm::IterVar in <code><a class="el" href="tir_2expr_8h.html" title="TIR expressions. ">include/tvm/tir/expr.h</a></code>  <a href="classtvm_1_1auto__scheduler_1_1IteratorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalBuilder.html">LocalBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1LocalBuilderNode.html" title="LocalBuilder use local CPU cores to build programs in parallel. ">LocalBuilderNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1LocalBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalBuilderNode.html">LocalBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalBuilder.html" title="Managed reference to LocalBuilderNode. ">LocalBuilder</a> use local CPU cores to build programs in parallel.  <a href="classtvm_1_1auto__scheduler_1_1LocalBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalRunner.html">LocalRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1LocalRunnerNode.html" title="LocalRunner that uses local CPU/GPU to measure the time cost of programs. ">LocalRunnerNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1LocalRunner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalRunnerNode.html">LocalRunnerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1auto__scheduler_1_1LocalRunner.html" title="Managed reference to LocalRunnerNode. ">LocalRunner</a> that uses local CPU/GPU to measure the time cost of programs.  <a href="classtvm_1_1auto__scheduler_1_1LocalRunnerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureCallback.html">MeasureCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureCallbackNode.html" title="Bass class of measurement callbacks. ">MeasureCallbackNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1MeasureCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureCallbackNode.html">MeasureCallbackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bass class of measurement callbacks.  <a href="classtvm_1_1auto__scheduler_1_1MeasureCallbackNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInput.html">MeasureInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html" title="Store the input of a measurement. ">MeasureInputNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1MeasureInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html">MeasureInputNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the input of a measurement.  <a href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResult.html">MeasureResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html" title="Store the results of a measurement. ">MeasureResultNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1MeasureResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html">MeasureResultNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the results of a measurement.  <a href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PragmaStep.html">PragmaStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1PragmaStepNode.html" title="Pragma step that corresponds to te::Stage::pragma. ">PragmaStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1PragmaStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PragmaStepNode.html">PragmaStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pragma step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a7045099f180e5cdcf9b1959b280a2d35" title="Annotate the iteration with pragma. ">te::Stage::pragma</a>.  <a href="classtvm_1_1auto__scheduler_1_1PragmaStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PreloadMeasuredStates.html">PreloadMeasuredStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1PreloadMeasuredStatesNode.html" title="Preload measured states from a log file. This can resume the state of the search policy. ">PreloadMeasuredStatesNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1PreloadMeasuredStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PreloadMeasuredStatesNode.html">PreloadMeasuredStatesNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preload measured states from a log file. This can resume the state of the search policy.  <a href="classtvm_1_1auto__scheduler_1_1PreloadMeasuredStatesNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramBuilder.html">ProgramBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramBuilderNode.html" title="ProgramBuilder that builds the programs. ">ProgramBuilderNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ProgramBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramBuilderNode.html">ProgramBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramBuilder.html" title="Managed reference to ProgramBuilderNode. ">ProgramBuilder</a> that builds the programs.  <a href="classtvm_1_1auto__scheduler_1_1ProgramBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramMeasurer.html">ProgramMeasurer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramMeasurerNode.html" title="Measurer that measures the time costs of tvm programs This class combines ProgramBuilder and ProgramR...">ProgramMeasurerNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ProgramMeasurer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramMeasurerNode.html">ProgramMeasurerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measurer that measures the time costs of tvm programs This class combines <a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramBuilder.html" title="Managed reference to ProgramBuilderNode. ">ProgramBuilder</a> and <a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramRunner.html" title="Managed reference to ProgramRunnerNode. ">ProgramRunner</a>, and provides a simpler API.  <a href="classtvm_1_1auto__scheduler_1_1ProgramMeasurerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramRunner.html">ProgramRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramRunnerNode.html" title="ProgramRunner that runs the built programs and measure the time cost. ">ProgramRunnerNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ProgramRunner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramRunnerNode.html">ProgramRunnerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1auto__scheduler_1_1ProgramRunner.html" title="Managed reference to ProgramRunnerNode. ">ProgramRunner</a> that runs the built programs and measure the time cost.  <a href="classtvm_1_1auto__scheduler_1_1ProgramRunnerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedMeasureCallback.html">PythonBasedMeasureCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedMeasureCallbackNode.html" title="A wrapper for measure callback defined by python code This class will call functions defined in the p...">PythonBasedMeasureCallbackNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1PythonBasedMeasureCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedMeasureCallbackNode.html">PythonBasedMeasureCallbackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for measure callback defined by python code This class will call functions defined in the python.  <a href="classtvm_1_1auto__scheduler_1_1PythonBasedMeasureCallbackNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedModel.html">PythonBasedModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedModelNode.html" title="A wrapper for cost model defined by python code This class will call functions defined in the python...">PythonBasedModelNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1PythonBasedModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1PythonBasedModelNode.html">PythonBasedModelNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for cost model defined by python code This class will call functions defined in the python.  <a href="classtvm_1_1auto__scheduler_1_1PythonBasedModelNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RandomModel.html">RandomModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1RandomModelNode.html" title="The cost model returning random value for all predictions. ">RandomModelNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1RandomModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RandomModelNode.html">RandomModelNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost model returning random value for all predictions.  <a href="classtvm_1_1auto__scheduler_1_1RandomModelNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RecordReader.html">RecordReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1RecordReaderNode.html" title="Log reader to load step logs from a file. ">RecordReaderNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1RecordReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RecordReaderNode.html">RecordReaderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log reader to load step logs from a file.  <a href="classtvm_1_1auto__scheduler_1_1RecordReaderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RecordToFile.html">RecordToFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1RecordToFileNode.html" title="Callback for logging the input and results of measurements to file. ">RecordToFileNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1RecordToFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RecordToFileNode.html">RecordToFileNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for logging the input and results of measurements to file.  <a href="classtvm_1_1auto__scheduler_1_1RecordToFileNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ReorderStep.html">ReorderStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1ReorderStepNode.html" title="Reorder step that corresponds to te::Stage::reorder. ">ReorderStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1ReorderStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1ReorderStepNode.html">ReorderStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#ad96cd240a92df9cafae89cdf2a7e302e" title="Reorder the iteration. ">te::Stage::reorder</a>.  <a href="classtvm_1_1auto__scheduler_1_1ReorderStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RfactorStep.html">RfactorStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1RfactorStepNode.html" title="Reduction factor step that corresponds to te::Schedule::rfactor. ">RfactorStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1RfactorStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RfactorStepNode.html">RfactorStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction factor step that corresponds to <a class="el" href="classtvm_1_1te_1_1Schedule.html#a34ae85add41bbed0140726d024d08862" title="Factor a reduction axis in tensor&#39;s schedule to be an explicit axis. This will create a new stage tha...">te::Schedule::rfactor</a>.  <a href="classtvm_1_1auto__scheduler_1_1RfactorStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RPCRunner.html">RPCRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1RPCRunnerNode.html" title="RPCRunner that uses RPC call to measures the time cost of programs on remote devices. Or sometime we may need to use RPC even in local running to insulate the thread environment. (e.g. running CUDA programs) ">RPCRunnerNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1RPCRunner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1RPCRunnerNode.html">RPCRunnerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1auto__scheduler_1_1RPCRunner.html" title="Managed reference to RPCRunnerNode. ">RPCRunner</a> that uses RPC call to measures the time cost of programs on remote devices. Or sometime we may need to use RPC even in local running to insulate the thread environment. (e.g. running CUDA programs)  <a href="classtvm_1_1auto__scheduler_1_1RPCRunnerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchCallback.html">SearchCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchCallbackNode.html" title="Callback function to be called by the search process. This interface allows to do extra initializatio...">SearchCallbackNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1SearchCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchCallbackNode.html">SearchCallbackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to be called by the search process. This interface allows to do extra initializations before schedule search or extra check during/after the schedule search.  <a href="classtvm_1_1auto__scheduler_1_1SearchCallbackNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html">SearchPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicyNode.html" title="The base class of search policies. ">SearchPolicyNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1auto__scheduler_1_1SearchPolicyKey.html">SearchPolicyKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute keys of ops used for <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html" title="Managed reference to SearchPolicyNode. ">SearchPolicy</a>.  <a href="structtvm_1_1auto__scheduler_1_1SearchPolicyKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicyNode.html">SearchPolicyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of search policies.  <a href="classtvm_1_1auto__scheduler_1_1SearchPolicyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTask.html">SearchTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTaskNode.html" title="The computation information and hardware parameters for a specific schedule search task...">SearchTaskNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1SearchTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTaskNode.html">SearchTaskNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation information and hardware parameters for a specific schedule search task.  <a href="classtvm_1_1auto__scheduler_1_1SearchTaskNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SplitStep.html">SplitStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1SplitStepNode.html" title="Split step that corresponds to te::Stage::split with additional support of multiple-level of factors...">SplitStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1SplitStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1SplitStepNode.html">SplitStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#a5a7cd562be59b68a187ad97085a3425d" title="Split the parent by factor, generate. ">te::Stage::split</a> with additional support of multiple-level of factors.  <a href="classtvm_1_1auto__scheduler_1_1SplitStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1Stage.html">Stage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StageNode.html" title="A op stage in the compute declaration. Similar to te::Stage in include/tvm/te/schedule.h. ">StageNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1Stage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1auto__scheduler_1_1StageAttributes.html">StageAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage-level attributes.  <a href="structtvm_1_1auto__scheduler_1_1StageAttributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1StageNode.html">StageNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A op stage in the compute declaration. Similar to <a class="el" href="classtvm_1_1te_1_1Stage.html" title="Stage, contains scheduling for a stage of computation. ">te::Stage</a> in <code><a class="el" href="te_2schedule_8h.html" title="Define a schedule. ">include/tvm/te/schedule.h</a></code>.  <a href="classtvm_1_1auto__scheduler_1_1StageNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1State.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state in the search process. It consists of the current loop structure and a list of transformation steps used to construct it. Each <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a> corresponds to a specific schedule for its <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a>.  <a href="classtvm_1_1auto__scheduler_1_1StateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StepNode.html" title="The base class of transformation steps. Each step has its corresponding tvm.te schedule primitives...">StepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1Step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1StepNode.html">StepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of transformation steps. Each step has its corresponding <a class="el" href="namespacetvm_1_1te.html" title="Tensor expression language DSL. ">tvm.te</a> schedule primitives.  <a href="classtvm_1_1auto__scheduler_1_1StepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1StorageAlignStep.html">StorageAlignStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StorageAlignStepNode.html" title="Storage align step that corresponds to te::Stage::storage_align. ">StorageAlignStepNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1StorageAlignStep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1StorageAlignStepNode.html">StorageAlignStepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage align step that corresponds to <a class="el" href="classtvm_1_1te_1_1Stage.html#aa73e3a269d84c3b4f0a1994371d67bab" title="Set alignment requirement for specific dimension. ">te::Stage::storage_align</a>.  <a href="classtvm_1_1auto__scheduler_1_1StorageAlignStepNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1TuningOptions.html">TuningOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1TuningOptionsNode.html" title="Tuning and measurement options. ">TuningOptionsNode</a>.  <a href="classtvm_1_1auto__scheduler_1_1TuningOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1TuningOptionsNode.html">TuningOptionsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning and measurement options.  <a href="classtvm_1_1auto__scheduler_1_1TuningOptionsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afc2e977e1bb9b11fc3b78758d997eb60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#afc2e977e1bb9b11fc3b78758d997eb60">StageKey</a> = int</td></tr>
<tr class="memdesc:afc2e977e1bb9b11fc3b78758d997eb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use stage_id to represent a stage.  <a href="#afc2e977e1bb9b11fc3b78758d997eb60">More...</a><br /></td></tr>
<tr class="separator:afc2e977e1bb9b11fc3b78758d997eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f416515f3dd42f5db1c636573ec5cc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a5f416515f3dd42f5db1c636573ec5cc5">IterKey</a> = std::pair&lt; int, int &gt;</td></tr>
<tr class="memdesc:a5f416515f3dd42f5db1c636573ec5cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use stage_id and iter_id to represent a iterator.  <a href="#a5f416515f3dd42f5db1c636573ec5cc5">More...</a><br /></td></tr>
<tr class="separator:a5f416515f3dd42f5db1c636573ec5cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f12e558fc4b8fbb990e7e204c06beeb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1te_1_1Stage.html">tvm::te::Stage</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">tir::IterVar</a> &gt;, <a class="el" href="structtvm_1_1runtime_1_1ObjectHash.html">ObjectHash</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectEqual.html">ObjectEqual</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a></td></tr>
<tr class="separator:a8f12e558fc4b8fbb990e7e204c06beeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3e9480be0119338696abbe9c80193b9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9e">LayoutRewriteOption</a> : int { <a class="el" href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9eaa6dd7ceb983e075b3efc829b61add2ac">LayoutRewriteOption::NoRewrite</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9ead1b2f8d911ee3e5ccac3575f6037cdd3">LayoutRewriteOption::InsertTransformStage</a> = 1, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9eabe8f9c447aade4de06bdb3332885303d">LayoutRewriteOption::RewriteForPreTransformed</a> = 2
 }<tr class="memdesc:a3e9480be0119338696abbe9c80193b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for applying layout rewrite. This is an optimization to rewrite the layout of input tensors according to the schedule we get.  <a href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3e9480be0119338696abbe9c80193b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6533a065c0157391331e89a0e95f35a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#af6533a065c0157391331e89a0e95f35a">StageKind</a> : int { <a class="el" href="namespacetvm_1_1auto__scheduler.html#af6533a065c0157391331e89a0e95f35aad8f4940d9b6d718087e3e6306ea80d4b">StageKind::kPlaceholder</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#af6533a065c0157391331e89a0e95f35aa2ab5a8274f707e48941d2905af48f19a">StageKind::kCompute</a> = 1
 }<tr class="memdesc:af6533a065c0157391331e89a0e95f35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a stage.  <a href="namespacetvm_1_1auto__scheduler.html#af6533a065c0157391331e89a0e95f35a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af6533a065c0157391331e89a0e95f35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75208ecc6a00ca7f86af04b3cc5657f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657f">ComputeAtKind</a> : int { <a class="el" href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657fa88085f89c2abf0eb8bdbf5e603964099">ComputeAtKind::kRoot</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657fa65de1fd3169eecfb4618d2c8e71e631b">ComputeAtKind::kInlined</a> = 1, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657fa8db9b1354688d96ec52c71f2b290165c">ComputeAtKind::kIter</a> = 2
 }<tr class="memdesc:ab75208ecc6a00ca7f86af04b3cc5657f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of compute location.  <a href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab75208ecc6a00ca7f86af04b3cc5657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2b9ff22c8ef2f009aef57f80926b9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9a">MeasureErrorNO</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aafcd1af9ec66cb99f2d106d7fdc865c8b">MeasureErrorNO::kNoError</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aa5d00c14ab3efe3c4b637681a1a745dea">MeasureErrorNO::kInstantiationError</a> = 1, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aad601e3eae241641fc8a9c020051a770c">MeasureErrorNO::kCompileHostError</a> = 2, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aabcffabf5eba02ae1c81e490a408be6ab">MeasureErrorNO::kCompileDeviceError</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aa449637aebb9f8cd8177cf6056a1d2796">MeasureErrorNO::kRuntimeDeviceError</a> = 4, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aae7a1c6ec122aa09811b685552f341d78">MeasureErrorNO::kWrongAnswerError</a> = 5, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aae5d47b814c59b540393c56dfe4848aad">MeasureErrorNO::kBuildTimeoutError</a> = 6, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aab94ae3ccd84f5ba95151375a2c4db28f">MeasureErrorNO::kRunTimeoutError</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9aa4366541ea8a34268abc8b24f19fcefdd">MeasureErrorNO::kUnknownError</a> = 8
<br />
 }<tr class="memdesc:acd2b9ff22c8ef2f009aef57f80926b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error code of one measurement.  <a href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acd2b9ff22c8ef2f009aef57f80926b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369a062b966070cea45c763bd9d2196d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196d">IteratorKind</a> : int { <a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196da83fe4465949392cd595c66cd0992bf4f">IteratorKind::kSpatial</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196da53db07df806f5847ee19a1230183a61b">IteratorKind::kReduction</a> = 1, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196dafce56956341de0de0ec7359c1a84e390">IteratorKind::kMixed</a> = 2, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196da1f0d5fe7d41b5fec009974b34c8ba95e">IteratorKind::kSpecial</a> = 3
 }<tr class="memdesc:a369a062b966070cea45c763bd9d2196d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an iterator.  <a href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a369a062b966070cea45c763bd9d2196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81bc395fc88957fbd33bf041adbe0ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">IteratorAnnotation</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0eca35c3ace1970663a16e5c65baa5941b13">IteratorAnnotation::kNone</a> = 0, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecaafba8a0eee03433f7776c850096cc256">IteratorAnnotation::kUnroll</a> = 1, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0eca4fb69c050a3bd280581e1e4e9e9f3834">IteratorAnnotation::kVectorize</a> = 2, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0eca6fb3551e3657204372d76d2d9b83a3b9">IteratorAnnotation::kParallel</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecafea25ca87d842383b3626fe55954040a">IteratorAnnotation::kVThread</a> = 4, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0eca2db4e4a9a6b82da1e2eb54137e9072a9">IteratorAnnotation::kBlockX</a> = 5, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecac9fa17d1e40906bb1610988efe560b5a">IteratorAnnotation::kThreadX</a> = 6, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecaecfed74a5317c3bc957238e58b75e8b3">IteratorAnnotation::kBlockY</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecac796bccb40d48042c4afee68e1625168">IteratorAnnotation::kThreadY</a> = 8, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecae97bcca1374f4389153e87bed5361440">IteratorAnnotation::kBlockZ</a> = 9, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ecaedadd74840df80bf250991162ebb06fc">IteratorAnnotation::kThreadZ</a> = 10, 
<a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0eca061f6dc7a73b68cfbb0fed0249e60a0c">IteratorAnnotation::kTensorize</a> = 11
<br />
 }<tr class="memdesc:ad81bc395fc88957fbd33bf041adbe0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an iterator's annotation.  <a href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad81bc395fc88957fbd33bf041adbe0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d6d14e885abf0c3b91e6b3cf542c2de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a1d6d14e885abf0c3b91e6b3cf542c2de">AutoSchedule</a> (<a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html">SearchPolicy</a> search_policy, <a class="el" href="classtvm_1_1auto__scheduler_1_1TuningOptions.html">TuningOptions</a> tuning_options)</td></tr>
<tr class="memdesc:a1d6d14e885abf0c3b91e6b3cf542c2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run schedule search for a given compute declaration.  <a href="#a1d6d14e885abf0c3b91e6b3cf542c2de">More...</a><br /></td></tr>
<tr class="separator:a1d6d14e885abf0c3b91e6b3cf542c2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17f33579675323a67964d6653562b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#af17f33579675323a67964d6653562b58">GetShapeFromRewrittenLayout</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> rewritten_layout, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; axis_names)</td></tr>
<tr class="memdesc:af17f33579675323a67964d6653562b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orginal shape from a rewritten layout string.  <a href="#af17f33579675323a67964d6653562b58">More...</a><br /></td></tr>
<tr class="separator:af17f33579675323a67964d6653562b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309309fa1674314212c4af67b3fb12d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a4309309fa1674314212c4af67b3fb12d">GetPerStoreFeature</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, int cache_line_size, int max_n_bufs, std::vector&lt; float &gt; *<a class="el" href="namespacetvm.html#a0da40d3e210aa3b38a17982a7b7866b8">ret</a>, bool log_scale=true)</td></tr>
<tr class="memdesc:a4309309fa1674314212c4af67b3fb12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-store features from a TIR PrimFunc.  <a href="#a4309309fa1674314212c4af67b3fb12d">More...</a><br /></td></tr>
<tr class="separator:a4309309fa1674314212c4af67b3fb12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57f2c52229ce568b9325e384cfa4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#adb57f2c52229ce568b9325e384cfa4a7">GetPerStoreFeatureName</a> (int max_n_bufs, std::vector&lt; std::string &gt; *<a class="el" href="namespacetvm.html#a0da40d3e210aa3b38a17982a7b7866b8">ret</a>)</td></tr>
<tr class="separator:adb57f2c52229ce568b9325e384cfa4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caf6f7db48d16245bd1b5ab75f07062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a0caf6f7db48d16245bd1b5ab75f07062">GetPerStoreFeaturesFromStates</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> &gt; &amp;states, const <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTask.html">SearchTask</a> &amp;task, int skip_first_n_feature_extraction, int max_n_bufs, std::vector&lt; std::vector&lt; float &gt; &gt; *features)</td></tr>
<tr class="memdesc:a0caf6f7db48d16245bd1b5ab75f07062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-store feature from states of the same task.  <a href="#a0caf6f7db48d16245bd1b5ab75f07062">More...</a><br /></td></tr>
<tr class="separator:a0caf6f7db48d16245bd1b5ab75f07062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fcbdbb3bf6298c8f29c1ee490c55a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a77fcbdbb3bf6298c8f29c1ee490c55a1">GetPerStoreFeaturesFromStates</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> &gt; &amp;states, const std::vector&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTask.html">SearchTask</a> &gt; &amp;tasks, int skip_first_n_feature_extraction, int max_n_bufs, std::vector&lt; std::vector&lt; float &gt; &gt; *features)</td></tr>
<tr class="memdesc:a77fcbdbb3bf6298c8f29c1ee490c55a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-store feature from states of different tasks.  <a href="#a77fcbdbb3bf6298c8f29c1ee490c55a1">More...</a><br /></td></tr>
<tr class="separator:a77fcbdbb3bf6298c8f29c1ee490c55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedebb15c2a239e4b42ea61395fd0e99f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#aedebb15c2a239e4b42ea61395fd0e99f">GetPerStoreFeaturesFromFile</a> (const std::string &amp;filename, int max_lines, int max_n_bufs, std::vector&lt; std::vector&lt; float &gt; &gt; *features, std::vector&lt; float &gt; *normalized_throughputs, std::vector&lt; int &gt; *task_ids)</td></tr>
<tr class="memdesc:aedebb15c2a239e4b42ea61395fd0e99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-store features from a log file.  <a href="#aedebb15c2a239e4b42ea61395fd0e99f">More...</a><br /></td></tr>
<tr class="separator:aedebb15c2a239e4b42ea61395fd0e99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae920a4ab4de59f66465f96854a38adb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ae920a4ab4de59f66465f96854a38adb2">GetPerStoreFeaturesFromMeasurePairs</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInput.html">MeasureInput</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResult.html">MeasureResult</a> &gt; &amp;results, int skip_first_n_feature_extraction, int max_n_bufs, std::vector&lt; std::vector&lt; float &gt; &gt; *features, std::vector&lt; float &gt; *normalized_throughputs, std::vector&lt; int &gt; *task_ids)</td></tr>
<tr class="memdesc:ae920a4ab4de59f66465f96854a38adb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get per-store features from measurement input/result pairs.  <a href="#ae920a4ab4de59f66465f96854a38adb2">More...</a><br /></td></tr>
<tr class="separator:ae920a4ab4de59f66465f96854a38adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a8aa311bb0c0e5b28509107b9064d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a374a8aa311bb0c0e5b28509107b9064d">WriteMeasureRecords</a> (std::ostream *os, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInput.html">MeasureInput</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResult.html">MeasureResult</a> &gt; &amp;results, const std::string log_version=<a class="el" href="namespacetvm_1_1auto__scheduler.html#a04029f3b293fba232218203167b2ef63">AUTO_SCHEDULER_LOG_VERSION</a>)</td></tr>
<tr class="memdesc:a374a8aa311bb0c0e5b28509107b9064d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append measure records to an output stream.  <a href="#a374a8aa311bb0c0e5b28509107b9064d">More...</a><br /></td></tr>
<tr class="separator:a374a8aa311bb0c0e5b28509107b9064d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d254ece2b7462cda8b0871749810841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a2d254ece2b7462cda8b0871749810841">ReadMeasureRecord</a> (const std::string &amp;str, <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html">MeasureInputNode</a> *inp, <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html">MeasureResultNode</a> *res, std::string *log_version)</td></tr>
<tr class="memdesc:a2d254ece2b7462cda8b0871749810841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one measure record from a string.  <a href="#a2d254ece2b7462cda8b0871749810841">More...</a><br /></td></tr>
<tr class="separator:a2d254ece2b7462cda8b0871749810841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af721042ba0b561f387dbcc5d2fe3b5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#af721042ba0b561f387dbcc5d2fe3b5b0">UpdateStageToAxesMap</a> (const <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &amp;stage, <a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *stage_to_axes)</td></tr>
<tr class="memdesc:af721042ba0b561f387dbcc5d2fe3b5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current stage IterVar information to StageToAxesMap.  <a href="#af721042ba0b561f387dbcc5d2fe3b5b0">More...</a><br /></td></tr>
<tr class="separator:af721042ba0b561f387dbcc5d2fe3b5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab09151bf58d2cb261e1254f22261741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#aab09151bf58d2cb261e1254f22261741">StepReadFromRecord</a> (dmlc::JSONReader *reader)</td></tr>
<tr class="memdesc:aab09151bf58d2cb261e1254f22261741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a step record from JSONReader and create the corresponding step.  <a href="#aab09151bf58d2cb261e1254f22261741">More...</a><br /></td></tr>
<tr class="separator:aab09151bf58d2cb261e1254f22261741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6909bc5a99d1cc8372201e9392717832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a6909bc5a99d1cc8372201e9392717832">StepApplyToState</a> (const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;step, <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> *state, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a6909bc5a99d1cc8372201e9392717832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a general step to a <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a> with runtime dynamic dispatching.  <a href="#a6909bc5a99d1cc8372201e9392717832">More...</a><br /></td></tr>
<tr class="separator:a6909bc5a99d1cc8372201e9392717832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58f7548a94b92f801b2b9a6f65bd785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ac58f7548a94b92f801b2b9a6f65bd785">StepApplyToSchedule</a> (const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;step, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &gt; *stages, <a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *stage_to_axes, <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a> *schedule, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &gt; &amp;transform_steps)</td></tr>
<tr class="memdesc:ac58f7548a94b92f801b2b9a6f65bd785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a general step to tvm.schedule with runtime dynamic dispatching.  <a href="#ac58f7548a94b92f801b2b9a6f65bd785">More...</a><br /></td></tr>
<tr class="separator:ac58f7548a94b92f801b2b9a6f65bd785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f759d9d2fcc4759578a84e06a509a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a3f759d9d2fcc4759578a84e06a509a07">StepPrintAsPythonAPI</a> (const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;step, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &gt; *stages, <a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *stage_to_axes, <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a> *schedule, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &gt; &amp;transform_steps)</td></tr>
<tr class="memdesc:a3f759d9d2fcc4759578a84e06a509a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a general step as equivalent python schedule API with runtime dynamic dispatching.  <a href="#a3f759d9d2fcc4759578a84e06a509a07">More...</a><br /></td></tr>
<tr class="separator:a3f759d9d2fcc4759578a84e06a509a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a04029f3b293fba232218203167b2ef63"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a04029f3b293fba232218203167b2ef63">AUTO_SCHEDULER_LOG_VERSION</a> = &quot;v0.6&quot;</td></tr>
<tr class="separator:a04029f3b293fba232218203167b2ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eade4c9463a2502919ec5d2fdbd5b64"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a8eade4c9463a2502919ec5d2fdbd5b64">IteratorAnnotationString</a> []</td></tr>
<tr class="separator:a8eade4c9463a2502919ec5d2fdbd5b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5f416515f3dd42f5db1c636573ec5cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f416515f3dd42f5db1c636573ec5cc5">&#9670;&nbsp;</a></span>IterKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1auto__scheduler.html#a5f416515f3dd42f5db1c636573ec5cc5">tvm::auto_scheduler::IterKey</a> = typedef std::pair&lt;int, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use stage_id and iter_id to represent a iterator. </p>

</div>
</div>
<a id="afc2e977e1bb9b11fc3b78758d997eb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2e977e1bb9b11fc3b78758d997eb60">&#9670;&nbsp;</a></span>StageKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1auto__scheduler.html#afc2e977e1bb9b11fc3b78758d997eb60">tvm::auto_scheduler::StageKey</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use stage_id to represent a stage. </p>

</div>
</div>
<a id="a8f12e558fc4b8fbb990e7e204c06beeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f12e558fc4b8fbb990e7e204c06beeb">&#9670;&nbsp;</a></span>StageToAxesMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1te_1_1Stage.html">tvm::te::Stage</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1IterVar.html">tir::IterVar</a>&gt;, <a class="el" href="structtvm_1_1runtime_1_1ObjectHash.html">ObjectHash</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectEqual.html">ObjectEqual</a>&gt; <a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">tvm::auto_scheduler::StageToAxesMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab75208ecc6a00ca7f86af04b3cc5657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75208ecc6a00ca7f86af04b3cc5657f">&#9670;&nbsp;</a></span>ComputeAtKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#ab75208ecc6a00ca7f86af04b3cc5657f">tvm::auto_scheduler::ComputeAtKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of compute location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab75208ecc6a00ca7f86af04b3cc5657fa88085f89c2abf0eb8bdbf5e603964099"></a>kRoot&#160;</td><td class="fielddoc"><p>Compute at root. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab75208ecc6a00ca7f86af04b3cc5657fa65de1fd3169eecfb4618d2c8e71e631b"></a>kInlined&#160;</td><td class="fielddoc"><p>Compute inlined. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab75208ecc6a00ca7f86af04b3cc5657fa8db9b1354688d96ec52c71f2b290165c"></a>kIter&#160;</td><td class="fielddoc"><p>Compute at some iterator. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad81bc395fc88957fbd33bf041adbe0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81bc395fc88957fbd33bf041adbe0ec">&#9670;&nbsp;</a></span>IteratorAnnotation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">tvm::auto_scheduler::IteratorAnnotation</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of an iterator's annotation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0eca35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>This iterator has no annotation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecaafba8a0eee03433f7776c850096cc256"></a>kUnroll&#160;</td><td class="fielddoc"><p>This iterator has been unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0eca4fb69c050a3bd280581e1e4e9e9f3834"></a>kVectorize&#160;</td><td class="fielddoc"><p>This iterator has been vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0eca6fb3551e3657204372d76d2d9b83a3b9"></a>kParallel&#160;</td><td class="fielddoc"><p>This iterator has been paralleld. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecafea25ca87d842383b3626fe55954040a"></a>kVThread&#160;</td><td class="fielddoc"><p>This iterator has been bind to vthread. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0eca2db4e4a9a6b82da1e2eb54137e9072a9"></a>kBlockX&#160;</td><td class="fielddoc"><p>This iterator has been bind to blockIdx.x. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecac9fa17d1e40906bb1610988efe560b5a"></a>kThreadX&#160;</td><td class="fielddoc"><p>This iterator has been bind to threadIdx.x. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecaecfed74a5317c3bc957238e58b75e8b3"></a>kBlockY&#160;</td><td class="fielddoc"><p>This iterator has been bind to blockIdx.y. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecac796bccb40d48042c4afee68e1625168"></a>kThreadY&#160;</td><td class="fielddoc"><p>This iterator has been bind to threadIdx.y. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecae97bcca1374f4389153e87bed5361440"></a>kBlockZ&#160;</td><td class="fielddoc"><p>This iterator has been bind to blockIdx.y. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0ecaedadd74840df80bf250991162ebb06fc"></a>kThreadZ&#160;</td><td class="fielddoc"><p>This iterator has been bind to threadIdx.y. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81bc395fc88957fbd33bf041adbe0eca061f6dc7a73b68cfbb0fed0249e60a0c"></a>kTensorize&#160;</td><td class="fielddoc"><p>This iterator has been mapped with a tensorize intrinsic. </p>
</td></tr>
</table>

</div>
</div>
<a id="a369a062b966070cea45c763bd9d2196d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369a062b966070cea45c763bd9d2196d">&#9670;&nbsp;</a></span>IteratorKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#a369a062b966070cea45c763bd9d2196d">tvm::auto_scheduler::IteratorKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of an iterator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a369a062b966070cea45c763bd9d2196da83fe4465949392cd595c66cd0992bf4f"></a>kSpatial&#160;</td><td class="fielddoc"><p>Spatial iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a369a062b966070cea45c763bd9d2196da53db07df806f5847ee19a1230183a61b"></a>kReduction&#160;</td><td class="fielddoc"><p>Reduction iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a369a062b966070cea45c763bd9d2196dafce56956341de0de0ec7359c1a84e390"></a>kMixed&#160;</td><td class="fielddoc"><p>Fused spatial and reduction iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a369a062b966070cea45c763bd9d2196da1f0d5fe7d41b5fec009974b34c8ba95e"></a>kSpecial&#160;</td><td class="fielddoc"><p>Special iterator. (e.g. virtual root iterator) </p>
</td></tr>
</table>

</div>
</div>
<a id="a3e9480be0119338696abbe9c80193b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9480be0119338696abbe9c80193b9e">&#9670;&nbsp;</a></span>LayoutRewriteOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#a3e9480be0119338696abbe9c80193b9e">tvm::auto_scheduler::LayoutRewriteOption</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Options for applying layout rewrite. This is an optimization to rewrite the layout of input tensors according to the schedule we get. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3e9480be0119338696abbe9c80193b9eaa6dd7ceb983e075b3efc829b61add2ac"></a>NoRewrite&#160;</td><td class="fielddoc"><p>Do not perform layout rewrite. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e9480be0119338696abbe9c80193b9ead1b2f8d911ee3e5ccac3575f6037cdd3"></a>InsertTransformStage&#160;</td><td class="fielddoc"><p>Insert layout transformation stages for input placeholders in the compute DAG. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e9480be0119338696abbe9c80193b9eabe8f9c447aade4de06bdb3332885303d"></a>RewriteForPreTransformed&#160;</td><td class="fielddoc"><p>Do not insert layout transformation stages and assume the input placeholders are pre-transformed. </p>
<dl class="section note"><dt>Note</dt><dd>The lowered function with this option does not accept the origial input shapes, so this option must be used along with <code>AutoSchedulerLayoutRewrite</code> pass in Relay. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="acd2b9ff22c8ef2f009aef57f80926b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2b9ff22c8ef2f009aef57f80926b9a">&#9670;&nbsp;</a></span>MeasureErrorNO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#acd2b9ff22c8ef2f009aef57f80926b9a">tvm::auto_scheduler::MeasureErrorNO</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The error code of one measurement. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aafcd1af9ec66cb99f2d106d7fdc865c8b"></a>kNoError&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aa5d00c14ab3efe3c4b637681a1a745dea"></a>kInstantiationError&#160;</td><td class="fielddoc"><p>Errors happen when apply transform steps from init state. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aad601e3eae241641fc8a9c020051a770c"></a>kCompileHostError&#160;</td><td class="fielddoc"><p>Errors happen when compiling code on host. (when build module) </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aabcffabf5eba02ae1c81e490a408be6ab"></a>kCompileDeviceError&#160;</td><td class="fielddoc"><p>Errors happen when compiling code on device. (when load module) </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aa449637aebb9f8cd8177cf6056a1d2796"></a>kRuntimeDeviceError&#160;</td><td class="fielddoc"><p>Errors happen when run program on device. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aae7a1c6ec122aa09811b685552f341d78"></a>kWrongAnswerError&#160;</td><td class="fielddoc"><p>Answer is wrong when compared to a reference output. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aae5d47b814c59b540393c56dfe4848aad"></a>kBuildTimeoutError&#160;</td><td class="fielddoc"><p>Timeout during compilation. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aab94ae3ccd84f5ba95151375a2c4db28f"></a>kRunTimeoutError&#160;</td><td class="fielddoc"><p>Timeout during run. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2b9ff22c8ef2f009aef57f80926b9aa4366541ea8a34268abc8b24f19fcefdd"></a>kUnknownError&#160;</td><td class="fielddoc"><p>Unknown error. </p>
</td></tr>
</table>

</div>
</div>
<a id="af6533a065c0157391331e89a0e95f35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6533a065c0157391331e89a0e95f35a">&#9670;&nbsp;</a></span>StageKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1auto__scheduler.html#af6533a065c0157391331e89a0e95f35a">tvm::auto_scheduler::StageKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of a stage. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af6533a065c0157391331e89a0e95f35aad8f4940d9b6d718087e3e6306ea80d4b"></a>kPlaceholder&#160;</td><td class="fielddoc"><p>A placeholder stage. </p>
</td></tr>
<tr><td class="fieldname"><a id="af6533a065c0157391331e89a0e95f35aa2ab5a8274f707e48941d2905af48f19a"></a>kCompute&#160;</td><td class="fielddoc"><p>A compute stage. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1d6d14e885abf0c3b91e6b3cf542c2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6d14e885abf0c3b91e6b3cf542c2de">&#9670;&nbsp;</a></span>AutoSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt; &gt; tvm::auto_scheduler::AutoSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1SearchPolicy.html">SearchPolicy</a>&#160;</td>
          <td class="paramname"><em>search_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1TuningOptions.html">TuningOptions</a>&#160;</td>
          <td class="paramname"><em>tuning_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run schedule search for a given compute declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_policy</td><td>The search policy. </td></tr>
    <tr><td class="paramname">tuning_options</td><td>Tuning and measurement options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>te::schedule</code> and an Array of <code><a class="el" href="classtvm_1_1te_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">te::Tensor</a></code> to be used in <code>tvm.lower</code> or <code><a class="el" href="namespacetvm.html#ab5392acd55c76e34323a71a4052f7bb2" title="Build a device and host module for a specific target from an IRModule. ">tvm.build</a></code>. </dd></dl>

</div>
</div>
<a id="a4309309fa1674314212c4af67b3fb12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4309309fa1674314212c4af67b3fb12d">&#9670;&nbsp;</a></span>GetPerStoreFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache_line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log_scale</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get per-store features from a TIR PrimFunc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The input lowered TIR PrimFunc </td></tr>
    <tr><td class="paramname">cache_line_size</td><td>The size of cache line in bytes </td></tr>
    <tr><td class="paramname">max_n_bufs</td><td>The maximum number of extracted buffers for one statement </td></tr>
    <tr><td class="paramname">ret</td><td>The returned feature vector </td></tr>
    <tr><td class="paramname">log_scale</td><td>Should the outputs be scaled by log2(1+x). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb57f2c52229ce568b9325e384cfa4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb57f2c52229ce568b9325e384cfa4a7">&#9670;&nbsp;</a></span>GetPerStoreFeatureName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeatureName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedebb15c2a239e4b42ea61395fd0e99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedebb15c2a239e4b42ea61395fd0e99f">&#9670;&nbsp;</a></span>GetPerStoreFeaturesFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeaturesFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; *&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>normalized_throughputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>task_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get per-store features from a log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of log file </td></tr>
    <tr><td class="paramname">max_lines</td><td>Only read the first n lines of the file </td></tr>
    <tr><td class="paramname">max_n_bufs</td><td>The maximum number of extracted buffers for one statement </td></tr>
    <tr><td class="paramname">features</td><td>The returned feature vector. The innermost vector contains the feature vectors for all BufferStoreNode statements </td></tr>
    <tr><td class="paramname">normalized_throughputs</td><td>The normalized throughputs for all states </td></tr>
    <tr><td class="paramname">task_ids</td><td>The task ids for all states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae920a4ab4de59f66465f96854a38adb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae920a4ab4de59f66465f96854a38adb2">&#9670;&nbsp;</a></span>GetPerStoreFeaturesFromMeasurePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeaturesFromMeasurePairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInput.html">MeasureInput</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResult.html">MeasureResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_first_n_feature_extraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; *&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>normalized_throughputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>task_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get per-store features from measurement input/result pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>The measurement inputs </td></tr>
    <tr><td class="paramname">results</td><td>The measurement results </td></tr>
    <tr><td class="paramname">skip_first_n_feature_extraction</td><td>Skip feature extraction for the first n measurement pairs </td></tr>
    <tr><td class="paramname">max_n_bufs</td><td>The maximum number of extracted buffers for one statement </td></tr>
    <tr><td class="paramname">features</td><td>The returned feature vector. The innermost vector contains the feature vectors for all BufferStoreNode statements </td></tr>
    <tr><td class="paramname">normalized_throughputs</td><td>The normalized throughputs for all states </td></tr>
    <tr><td class="paramname">task_ids</td><td>The task ids for all states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0caf6f7db48d16245bd1b5ab75f07062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caf6f7db48d16245bd1b5ab75f07062">&#9670;&nbsp;</a></span>GetPerStoreFeaturesFromStates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeaturesFromStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTask.html">SearchTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_first_n_feature_extraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; *&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get per-store feature from states of the same task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>The input states </td></tr>
    <tr><td class="paramname">task</td><td>The same search task for all states </td></tr>
    <tr><td class="paramname">skip_first_n_feature_extraction</td><td>Skip feature extraction for the first n states </td></tr>
    <tr><td class="paramname">max_n_bufs</td><td>The maximum number of extracted buffers for one statement </td></tr>
    <tr><td class="paramname">features</td><td>The returned feature vector. The innermost vector contains the feature vectors for all BufferStoreNode statements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77fcbdbb3bf6298c8f29c1ee490c55a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fcbdbb3bf6298c8f29c1ee490c55a1">&#9670;&nbsp;</a></span>GetPerStoreFeaturesFromStates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::GetPerStoreFeaturesFromStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1SearchTask.html">SearchTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_first_n_feature_extraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; *&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get per-store feature from states of different tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>The input states </td></tr>
    <tr><td class="paramname">tasks</td><td>The search tasks corresponding to the input states </td></tr>
    <tr><td class="paramname">skip_first_n_feature_extraction</td><td>Skip feature extraction for the first n states </td></tr>
    <tr><td class="paramname">max_n_bufs</td><td>The maximum number of extracted buffers for one statement </td></tr>
    <tr><td class="paramname">features</td><td>The returned feature vector. The innermost vector contains the feature vectors for all BufferStoreNode statements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af17f33579675323a67964d6653562b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17f33579675323a67964d6653562b58">&#9670;&nbsp;</a></span>GetShapeFromRewrittenLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::auto_scheduler::GetShapeFromRewrittenLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>rewritten_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the orginal shape from a rewritten layout string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rewritten_layout</td><td>The layout after auto-scheduler's layout rewrite. </td></tr>
    <tr><td class="paramname">axis_names</td><td>Specifiy the names of axes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shape The original shape. </dd></dl>

</div>
</div>
<a id="a2d254ece2b7462cda8b0871749810841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d254ece2b7462cda8b0871749810841">&#9670;&nbsp;</a></span>ReadMeasureRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::ReadMeasureRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html">MeasureInputNode</a> *&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html">MeasureResultNode</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>log_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one measure record from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The record string to be parsed. </td></tr>
    <tr><td class="paramname">inp</td><td>A pointer to a <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInputNode.html" title="Store the input of a measurement. ">MeasureInputNode</a> used to store the return value. </td></tr>
    <tr><td class="paramname">res</td><td>A pointer to a <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResultNode.html" title="Store the results of a measurement. ">MeasureResultNode</a> used to store the return value. </td></tr>
    <tr><td class="paramname">log_version</td><td>A pointer to a string used to store the log version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac58f7548a94b92f801b2b9a6f65bd785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58f7548a94b92f801b2b9a6f65bd785">&#9670;&nbsp;</a></span>StepApplyToSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::StepApplyToSchedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &gt; *&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *&#160;</td>
          <td class="paramname"><em>stage_to_axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a> *&#160;</td>
          <td class="paramname"><em>schedule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a general step to tvm.schedule with runtime dynamic dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>The step to be applied to tvm.schedule. </td></tr>
    <tr><td class="paramname">stages</td><td>The list of current stages </td></tr>
    <tr><td class="paramname">stage_to_axes</td><td>A map that maps stage ot all its iterators. </td></tr>
    <tr><td class="paramname">schedule</td><td>A mutable point to the current schedule </td></tr>
    <tr><td class="paramname">transform_steps</td><td>An array of all history transform steps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6909bc5a99d1cc8372201e9392717832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6909bc5a99d1cc8372201e9392717832">&#9670;&nbsp;</a></span>StepApplyToState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::StepApplyToState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a general step to a <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a> with runtime dynamic dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>The step to be applied to <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>. </td></tr>
    <tr><td class="paramname">state</td><td>A mutable pointer to state, which will be updated. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f759d9d2fcc4759578a84e06a509a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f759d9d2fcc4759578a84e06a509a07">&#9670;&nbsp;</a></span>StepPrintAsPythonAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::auto_scheduler::StepPrintAsPythonAPI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &gt; *&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *&#160;</td>
          <td class="paramname"><em>stage_to_axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a> *&#160;</td>
          <td class="paramname"><em>schedule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a general step as equivalent python schedule API with runtime dynamic dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>The step to be printed as python API. </td></tr>
    <tr><td class="paramname">stages</td><td>The list of current stages </td></tr>
    <tr><td class="paramname">stage_to_axes</td><td>A map that maps stage ot all its iterators. </td></tr>
    <tr><td class="paramname">schedule</td><td>A mutable point to the current schedule </td></tr>
    <tr><td class="paramname">transform_steps</td><td>An array of all history transform steps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Python schedule code. </dd></dl>

</div>
</div>
<a id="aab09151bf58d2cb261e1254f22261741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab09151bf58d2cb261e1254f22261741">&#9670;&nbsp;</a></span>StepReadFromRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Step.html">Step</a> tvm::auto_scheduler::StepReadFromRecord </td>
          <td>(</td>
          <td class="paramtype">dmlc::JSONReader *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a step record from JSONReader and create the corresponding step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The input JSONReader. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af721042ba0b561f387dbcc5d2fe3b5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af721042ba0b561f387dbcc5d2fe3b5b0">&#9670;&nbsp;</a></span>UpdateStageToAxesMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::UpdateStageToAxesMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Stage.html">te::Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1auto__scheduler.html#a8f12e558fc4b8fbb990e7e204c06beeb">StageToAxesMap</a> *&#160;</td>
          <td class="paramname"><em>stage_to_axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the current stage IterVar information to StageToAxesMap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>The stage to be updated. </td></tr>
    <tr><td class="paramname">stage_to_axes</td><td>The map to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374a8aa311bb0c0e5b28509107b9064d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374a8aa311bb0c0e5b28509107b9064d">&#9670;&nbsp;</a></span>WriteMeasureRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::WriteMeasureRecords </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureInput.html">MeasureInput</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1MeasureResult.html">MeasureResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>log_version</em> = <code><a class="el" href="namespacetvm_1_1auto__scheduler.html#a04029f3b293fba232218203167b2ef63">AUTO_SCHEDULER_LOG_VERSION</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append measure records to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>A pointer to a output stream. </td></tr>
    <tr><td class="paramname">inputs</td><td>The MeasureInputs to be written. </td></tr>
    <tr><td class="paramname">results</td><td>The MeasureResults to be written. </td></tr>
    <tr><td class="paramname">log_version</td><td>The log version for the given record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a04029f3b293fba232218203167b2ef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04029f3b293fba232218203167b2ef63">&#9670;&nbsp;</a></span>AUTO_SCHEDULER_LOG_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string tvm::auto_scheduler::AUTO_SCHEDULER_LOG_VERSION = &quot;v0.6&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8eade4c9463a2502919ec5d2fdbd5b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eade4c9463a2502919ec5d2fdbd5b64">&#9670;&nbsp;</a></span>IteratorAnnotationString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::auto_scheduler::IteratorAnnotationString[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
