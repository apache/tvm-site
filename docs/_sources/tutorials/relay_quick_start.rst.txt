.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_tutorials_relay_quick_start.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_relay_quick_start.py:


.. _tutorial-relay-quick-start:

Quick Start Tutorial for Compiling Deep Learning Models
=======================================================
**Author**: `Yao Wang <https://github.com/kevinthesun>`_, `Truman Tian <https://github.com/SiNZeRo>`_

This example shows how to build a neural network with Relay python frontend and
generates a runtime library for Nvidia GPU with TVM.
Notice that you need to build TVM with cuda and llvm enabled.

Overview for Supported Hardware Backend of TVM
----------------------------------------------
The image below shows hardware backend currently supported by TVM:

.. image:: https://github.com/dmlc/web-data/raw/master/tvm/tutorial/tvm_support_list.png
     :align: center

In this tutorial, we'll choose cuda and llvm as target backends.
To begin with, let's import Relay and TVM.


.. code-block:: default


    import numpy as np

    from tvm import relay
    from tvm.relay import testing
    import tvm
    from tvm import te
    from tvm.contrib import graph_runtime







Define Neural Network in Relay
------------------------------
First, let's define a neural network with relay python frontend.
For simplicity, we'll use pre-defined resnet-18 network in Relay.
Parameters are initialized with Xavier initializer.
Relay also supports other model formats such as MXNet, CoreML, ONNX and
Tensorflow.

In this tutorial, we assume we will do inference on our device
and the batch size is set to be 1. Input images are RGB color
images of size 224 * 224. We can call the :any:`tvm.relay.TupleWrapper.astext()`
to show the network structure.


.. code-block:: default


    batch_size = 1
    num_class = 1000
    image_shape = (3, 224, 224)
    data_shape = (batch_size,) + image_shape
    out_shape = (batch_size, num_class)

    mod, params = relay.testing.resnet.get_workload(
        num_layers=18, batch_size=batch_size, image_shape=image_shape)

    # set show_meta_data=True if you want to show meta data
    print(mod.astext(show_meta_data=False))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    v0.0.4
    def @main(%data: Tensor[(1, 3, 224, 224), float32], %bn_data_gamma: Tensor[(3), float32], %bn_data_beta: Tensor[(3), float32], %bn_data_moving_mean: Tensor[(3), float32], %bn_data_moving_var: Tensor[(3), float32], %conv0_weight: Tensor[(64, 3, 7, 7), float32], %bn0_gamma: Tensor[(64), float32], %bn0_beta: Tensor[(64), float32], %bn0_moving_mean: Tensor[(64), float32], %bn0_moving_var: Tensor[(64), float32], %stage1_unit1_bn1_gamma: Tensor[(64), float32], %stage1_unit1_bn1_beta: Tensor[(64), float32], %stage1_unit1_bn1_moving_mean: Tensor[(64), float32], %stage1_unit1_bn1_moving_var: Tensor[(64), float32], %stage1_unit1_conv1_weight: Tensor[(64, 64, 3, 3), float32], %stage1_unit1_bn2_gamma: Tensor[(64), float32], %stage1_unit1_bn2_beta: Tensor[(64), float32], %stage1_unit1_bn2_moving_mean: Tensor[(64), float32], %stage1_unit1_bn2_moving_var: Tensor[(64), float32], %stage1_unit1_conv2_weight: Tensor[(64, 64, 3, 3), float32], %stage1_unit1_sc_weight: Tensor[(64, 64, 1, 1), float32], %stage1_unit2_bn1_gamma: Tensor[(64), float32], %stage1_unit2_bn1_beta: Tensor[(64), float32], %stage1_unit2_bn1_moving_mean: Tensor[(64), float32], %stage1_unit2_bn1_moving_var: Tensor[(64), float32], %stage1_unit2_conv1_weight: Tensor[(64, 64, 3, 3), float32], %stage1_unit2_bn2_gamma: Tensor[(64), float32], %stage1_unit2_bn2_beta: Tensor[(64), float32], %stage1_unit2_bn2_moving_mean: Tensor[(64), float32], %stage1_unit2_bn2_moving_var: Tensor[(64), float32], %stage1_unit2_conv2_weight: Tensor[(64, 64, 3, 3), float32], %stage2_unit1_bn1_gamma: Tensor[(64), float32], %stage2_unit1_bn1_beta: Tensor[(64), float32], %stage2_unit1_bn1_moving_mean: Tensor[(64), float32], %stage2_unit1_bn1_moving_var: Tensor[(64), float32], %stage2_unit1_conv1_weight: Tensor[(128, 64, 3, 3), float32], %stage2_unit1_bn2_gamma: Tensor[(128), float32], %stage2_unit1_bn2_beta: Tensor[(128), float32], %stage2_unit1_bn2_moving_mean: Tensor[(128), float32], %stage2_unit1_bn2_moving_var: Tensor[(128), float32], %stage2_unit1_conv2_weight: Tensor[(128, 128, 3, 3), float32], %stage2_unit1_sc_weight: Tensor[(128, 64, 1, 1), float32], %stage2_unit2_bn1_gamma: Tensor[(128), float32], %stage2_unit2_bn1_beta: Tensor[(128), float32], %stage2_unit2_bn1_moving_mean: Tensor[(128), float32], %stage2_unit2_bn1_moving_var: Tensor[(128), float32], %stage2_unit2_conv1_weight: Tensor[(128, 128, 3, 3), float32], %stage2_unit2_bn2_gamma: Tensor[(128), float32], %stage2_unit2_bn2_beta: Tensor[(128), float32], %stage2_unit2_bn2_moving_mean: Tensor[(128), float32], %stage2_unit2_bn2_moving_var: Tensor[(128), float32], %stage2_unit2_conv2_weight: Tensor[(128, 128, 3, 3), float32], %stage3_unit1_bn1_gamma: Tensor[(128), float32], %stage3_unit1_bn1_beta: Tensor[(128), float32], %stage3_unit1_bn1_moving_mean: Tensor[(128), float32], %stage3_unit1_bn1_moving_var: Tensor[(128), float32], %stage3_unit1_conv1_weight: Tensor[(256, 128, 3, 3), float32], %stage3_unit1_bn2_gamma: Tensor[(256), float32], %stage3_unit1_bn2_beta: Tensor[(256), float32], %stage3_unit1_bn2_moving_mean: Tensor[(256), float32], %stage3_unit1_bn2_moving_var: Tensor[(256), float32], %stage3_unit1_conv2_weight: Tensor[(256, 256, 3, 3), float32], %stage3_unit1_sc_weight: Tensor[(256, 128, 1, 1), float32], %stage3_unit2_bn1_gamma: Tensor[(256), float32], %stage3_unit2_bn1_beta: Tensor[(256), float32], %stage3_unit2_bn1_moving_mean: Tensor[(256), float32], %stage3_unit2_bn1_moving_var: Tensor[(256), float32], %stage3_unit2_conv1_weight: Tensor[(256, 256, 3, 3), float32], %stage3_unit2_bn2_gamma: Tensor[(256), float32], %stage3_unit2_bn2_beta: Tensor[(256), float32], %stage3_unit2_bn2_moving_mean: Tensor[(256), float32], %stage3_unit2_bn2_moving_var: Tensor[(256), float32], %stage3_unit2_conv2_weight: Tensor[(256, 256, 3, 3), float32], %stage4_unit1_bn1_gamma: Tensor[(256), float32], %stage4_unit1_bn1_beta: Tensor[(256), float32], %stage4_unit1_bn1_moving_mean: Tensor[(256), float32], %stage4_unit1_bn1_moving_var: Tensor[(256), float32], %stage4_unit1_conv1_weight: Tensor[(512, 256, 3, 3), float32], %stage4_unit1_bn2_gamma: Tensor[(512), float32], %stage4_unit1_bn2_beta: Tensor[(512), float32], %stage4_unit1_bn2_moving_mean: Tensor[(512), float32], %stage4_unit1_bn2_moving_var: Tensor[(512), float32], %stage4_unit1_conv2_weight: Tensor[(512, 512, 3, 3), float32], %stage4_unit1_sc_weight: Tensor[(512, 256, 1, 1), float32], %stage4_unit2_bn1_gamma: Tensor[(512), float32], %stage4_unit2_bn1_beta: Tensor[(512), float32], %stage4_unit2_bn1_moving_mean: Tensor[(512), float32], %stage4_unit2_bn1_moving_var: Tensor[(512), float32], %stage4_unit2_conv1_weight: Tensor[(512, 512, 3, 3), float32], %stage4_unit2_bn2_gamma: Tensor[(512), float32], %stage4_unit2_bn2_beta: Tensor[(512), float32], %stage4_unit2_bn2_moving_mean: Tensor[(512), float32], %stage4_unit2_bn2_moving_var: Tensor[(512), float32], %stage4_unit2_conv2_weight: Tensor[(512, 512, 3, 3), float32], %bn1_gamma: Tensor[(512), float32], %bn1_beta: Tensor[(512), float32], %bn1_moving_mean: Tensor[(512), float32], %bn1_moving_var: Tensor[(512), float32], %fc1_weight: Tensor[(1000, 512), float32], %fc1_bias: Tensor[(1000), float32]) -> Tensor[(1, 1000), float32] {
      %0 = nn.batch_norm(%data, %bn_data_gamma, %bn_data_beta, %bn_data_moving_mean, %bn_data_moving_var, epsilon=2e-05f, scale=False) /* ty=(Tensor[(1, 3, 224, 224), float32], Tensor[(3), float32], Tensor[(3), float32]) */;
      %1 = %0.0;
      %2 = nn.conv2d(%1, %conv0_weight, strides=[2, 2], padding=[3, 3, 3, 3], channels=64, kernel_size=[7, 7]) /* ty=Tensor[(1, 64, 112, 112), float32] */;
      %3 = nn.batch_norm(%2, %bn0_gamma, %bn0_beta, %bn0_moving_mean, %bn0_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 112, 112), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %4 = %3.0;
      %5 = nn.relu(%4) /* ty=Tensor[(1, 64, 112, 112), float32] */;
      %6 = nn.max_pool2d(%5, pool_size=[3, 3], strides=[2, 2], padding=[1, 1, 1, 1]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %7 = nn.batch_norm(%6, %stage1_unit1_bn1_gamma, %stage1_unit1_bn1_beta, %stage1_unit1_bn1_moving_mean, %stage1_unit1_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 56, 56), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %8 = %7.0;
      %9 = nn.relu(%8) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %10 = nn.conv2d(%9, %stage1_unit1_conv1_weight, padding=[1, 1, 1, 1], channels=64, kernel_size=[3, 3]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %11 = nn.batch_norm(%10, %stage1_unit1_bn2_gamma, %stage1_unit1_bn2_beta, %stage1_unit1_bn2_moving_mean, %stage1_unit1_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 56, 56), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %12 = %11.0;
      %13 = nn.relu(%12) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %14 = nn.conv2d(%13, %stage1_unit1_conv2_weight, padding=[1, 1, 1, 1], channels=64, kernel_size=[3, 3]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %15 = nn.conv2d(%9, %stage1_unit1_sc_weight, padding=[0, 0, 0, 0], channels=64, kernel_size=[1, 1]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %16 = add(%14, %15) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %17 = nn.batch_norm(%16, %stage1_unit2_bn1_gamma, %stage1_unit2_bn1_beta, %stage1_unit2_bn1_moving_mean, %stage1_unit2_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 56, 56), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %18 = %17.0;
      %19 = nn.relu(%18) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %20 = nn.conv2d(%19, %stage1_unit2_conv1_weight, padding=[1, 1, 1, 1], channels=64, kernel_size=[3, 3]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %21 = nn.batch_norm(%20, %stage1_unit2_bn2_gamma, %stage1_unit2_bn2_beta, %stage1_unit2_bn2_moving_mean, %stage1_unit2_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 56, 56), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %22 = %21.0;
      %23 = nn.relu(%22) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %24 = nn.conv2d(%23, %stage1_unit2_conv2_weight, padding=[1, 1, 1, 1], channels=64, kernel_size=[3, 3]) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %25 = add(%24, %16) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %26 = nn.batch_norm(%25, %stage2_unit1_bn1_gamma, %stage2_unit1_bn1_beta, %stage2_unit1_bn1_moving_mean, %stage2_unit1_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 64, 56, 56), float32], Tensor[(64), float32], Tensor[(64), float32]) */;
      %27 = %26.0;
      %28 = nn.relu(%27) /* ty=Tensor[(1, 64, 56, 56), float32] */;
      %29 = nn.conv2d(%28, %stage2_unit1_conv1_weight, strides=[2, 2], padding=[1, 1, 1, 1], channels=128, kernel_size=[3, 3]) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %30 = nn.batch_norm(%29, %stage2_unit1_bn2_gamma, %stage2_unit1_bn2_beta, %stage2_unit1_bn2_moving_mean, %stage2_unit1_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 128, 28, 28), float32], Tensor[(128), float32], Tensor[(128), float32]) */;
      %31 = %30.0;
      %32 = nn.relu(%31) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %33 = nn.conv2d(%32, %stage2_unit1_conv2_weight, padding=[1, 1, 1, 1], channels=128, kernel_size=[3, 3]) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %34 = nn.conv2d(%28, %stage2_unit1_sc_weight, strides=[2, 2], padding=[0, 0, 0, 0], channels=128, kernel_size=[1, 1]) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %35 = add(%33, %34) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %36 = nn.batch_norm(%35, %stage2_unit2_bn1_gamma, %stage2_unit2_bn1_beta, %stage2_unit2_bn1_moving_mean, %stage2_unit2_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 128, 28, 28), float32], Tensor[(128), float32], Tensor[(128), float32]) */;
      %37 = %36.0;
      %38 = nn.relu(%37) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %39 = nn.conv2d(%38, %stage2_unit2_conv1_weight, padding=[1, 1, 1, 1], channels=128, kernel_size=[3, 3]) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %40 = nn.batch_norm(%39, %stage2_unit2_bn2_gamma, %stage2_unit2_bn2_beta, %stage2_unit2_bn2_moving_mean, %stage2_unit2_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 128, 28, 28), float32], Tensor[(128), float32], Tensor[(128), float32]) */;
      %41 = %40.0;
      %42 = nn.relu(%41) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %43 = nn.conv2d(%42, %stage2_unit2_conv2_weight, padding=[1, 1, 1, 1], channels=128, kernel_size=[3, 3]) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %44 = add(%43, %35) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %45 = nn.batch_norm(%44, %stage3_unit1_bn1_gamma, %stage3_unit1_bn1_beta, %stage3_unit1_bn1_moving_mean, %stage3_unit1_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 128, 28, 28), float32], Tensor[(128), float32], Tensor[(128), float32]) */;
      %46 = %45.0;
      %47 = nn.relu(%46) /* ty=Tensor[(1, 128, 28, 28), float32] */;
      %48 = nn.conv2d(%47, %stage3_unit1_conv1_weight, strides=[2, 2], padding=[1, 1, 1, 1], channels=256, kernel_size=[3, 3]) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %49 = nn.batch_norm(%48, %stage3_unit1_bn2_gamma, %stage3_unit1_bn2_beta, %stage3_unit1_bn2_moving_mean, %stage3_unit1_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 256, 14, 14), float32], Tensor[(256), float32], Tensor[(256), float32]) */;
      %50 = %49.0;
      %51 = nn.relu(%50) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %52 = nn.conv2d(%51, %stage3_unit1_conv2_weight, padding=[1, 1, 1, 1], channels=256, kernel_size=[3, 3]) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %53 = nn.conv2d(%47, %stage3_unit1_sc_weight, strides=[2, 2], padding=[0, 0, 0, 0], channels=256, kernel_size=[1, 1]) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %54 = add(%52, %53) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %55 = nn.batch_norm(%54, %stage3_unit2_bn1_gamma, %stage3_unit2_bn1_beta, %stage3_unit2_bn1_moving_mean, %stage3_unit2_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 256, 14, 14), float32], Tensor[(256), float32], Tensor[(256), float32]) */;
      %56 = %55.0;
      %57 = nn.relu(%56) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %58 = nn.conv2d(%57, %stage3_unit2_conv1_weight, padding=[1, 1, 1, 1], channels=256, kernel_size=[3, 3]) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %59 = nn.batch_norm(%58, %stage3_unit2_bn2_gamma, %stage3_unit2_bn2_beta, %stage3_unit2_bn2_moving_mean, %stage3_unit2_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 256, 14, 14), float32], Tensor[(256), float32], Tensor[(256), float32]) */;
      %60 = %59.0;
      %61 = nn.relu(%60) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %62 = nn.conv2d(%61, %stage3_unit2_conv2_weight, padding=[1, 1, 1, 1], channels=256, kernel_size=[3, 3]) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %63 = add(%62, %54) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %64 = nn.batch_norm(%63, %stage4_unit1_bn1_gamma, %stage4_unit1_bn1_beta, %stage4_unit1_bn1_moving_mean, %stage4_unit1_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 256, 14, 14), float32], Tensor[(256), float32], Tensor[(256), float32]) */;
      %65 = %64.0;
      %66 = nn.relu(%65) /* ty=Tensor[(1, 256, 14, 14), float32] */;
      %67 = nn.conv2d(%66, %stage4_unit1_conv1_weight, strides=[2, 2], padding=[1, 1, 1, 1], channels=512, kernel_size=[3, 3]) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %68 = nn.batch_norm(%67, %stage4_unit1_bn2_gamma, %stage4_unit1_bn2_beta, %stage4_unit1_bn2_moving_mean, %stage4_unit1_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 512, 7, 7), float32], Tensor[(512), float32], Tensor[(512), float32]) */;
      %69 = %68.0;
      %70 = nn.relu(%69) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %71 = nn.conv2d(%70, %stage4_unit1_conv2_weight, padding=[1, 1, 1, 1], channels=512, kernel_size=[3, 3]) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %72 = nn.conv2d(%66, %stage4_unit1_sc_weight, strides=[2, 2], padding=[0, 0, 0, 0], channels=512, kernel_size=[1, 1]) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %73 = add(%71, %72) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %74 = nn.batch_norm(%73, %stage4_unit2_bn1_gamma, %stage4_unit2_bn1_beta, %stage4_unit2_bn1_moving_mean, %stage4_unit2_bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 512, 7, 7), float32], Tensor[(512), float32], Tensor[(512), float32]) */;
      %75 = %74.0;
      %76 = nn.relu(%75) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %77 = nn.conv2d(%76, %stage4_unit2_conv1_weight, padding=[1, 1, 1, 1], channels=512, kernel_size=[3, 3]) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %78 = nn.batch_norm(%77, %stage4_unit2_bn2_gamma, %stage4_unit2_bn2_beta, %stage4_unit2_bn2_moving_mean, %stage4_unit2_bn2_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 512, 7, 7), float32], Tensor[(512), float32], Tensor[(512), float32]) */;
      %79 = %78.0;
      %80 = nn.relu(%79) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %81 = nn.conv2d(%80, %stage4_unit2_conv2_weight, padding=[1, 1, 1, 1], channels=512, kernel_size=[3, 3]) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %82 = add(%81, %73) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %83 = nn.batch_norm(%82, %bn1_gamma, %bn1_beta, %bn1_moving_mean, %bn1_moving_var, epsilon=2e-05f) /* ty=(Tensor[(1, 512, 7, 7), float32], Tensor[(512), float32], Tensor[(512), float32]) */;
      %84 = %83.0;
      %85 = nn.relu(%84) /* ty=Tensor[(1, 512, 7, 7), float32] */;
      %86 = nn.global_avg_pool2d(%85) /* ty=Tensor[(1, 512, 1, 1), float32] */;
      %87 = nn.batch_flatten(%86) /* ty=Tensor[(1, 512), float32] */;
      %88 = nn.dense(%87, %fc1_weight, units=1000) /* ty=Tensor[(1, 1000), float32] */;
      %89 = nn.bias_add(%88, %fc1_bias, axis=-1) /* ty=Tensor[(1, 1000), float32] */;
      nn.softmax(%89) /* ty=Tensor[(1, 1000), float32] */
    }




Compilation
-----------
Next step is to compile the model using the Relay/TVM pipeline.
Users can specify the optimization level of the compilation.
Currently this value can be 0 to 3. The optimization passes include
operator fusion, pre-computation, layout transformation and so on.

:py:func:`relay.build` returns three components: the execution graph in
json format, the TVM module library of compiled functions specifically
for this graph on the target hardware, and the parameter blobs of
the model. During the compilation, Relay does the graph-level
optimization while TVM does the tensor-level optimization, resulting
in an optimized runtime module for model serving.

We'll first compile for Nvidia GPU. Behind the scene, :py:func:`relay.build`
first does a number of graph-level optimizations, e.g. pruning, fusing, etc.,
then registers the operators (i.e. the nodes of the optimized graphs) to
TVM implementations to generate a `tvm.module`.
To generate the module library, TVM will first transfer the high level IR
into the lower intrinsic IR of the specified target backend, which is CUDA
in this example. Then the machine code will be generated as the module library.


.. code-block:: default


    opt_level = 3
    target = tvm.target.cuda()
    with relay.build_config(opt_level=opt_level):
        graph, lib, params = relay.build(mod, target, params=params)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ...1%, 0.01 MB, 41 KB/s, 0 seconds passed    ...3%, 0.02 MB, 82 KB/s, 0 seconds passed    ...5%, 0.02 MB, 123 KB/s, 0 seconds passed    ...7%, 0.03 MB, 164 KB/s, 0 seconds passed    ...9%, 0.04 MB, 206 KB/s, 0 seconds passed    ...11%, 0.05 MB, 246 KB/s, 0 seconds passed    ...13%, 0.05 MB, 287 KB/s, 0 seconds passed    ...15%, 0.06 MB, 327 KB/s, 0 seconds passed    ...17%, 0.07 MB, 367 KB/s, 0 seconds passed    ...19%, 0.08 MB, 407 KB/s, 0 seconds passed    ...21%, 0.09 MB, 447 KB/s, 0 seconds passed    ...23%, 0.09 MB, 488 KB/s, 0 seconds passed    ...25%, 0.10 MB, 527 KB/s, 0 seconds passed    ...27%, 0.11 MB, 567 KB/s, 0 seconds passed    ...29%, 0.12 MB, 607 KB/s, 0 seconds passed    ...31%, 0.12 MB, 647 KB/s, 0 seconds passed    ...33%, 0.13 MB, 686 KB/s, 0 seconds passed    ...35%, 0.14 MB, 725 KB/s, 0 seconds passed    ...37%, 0.15 MB, 765 KB/s, 0 seconds passed    ...39%, 0.16 MB, 804 KB/s, 0 seconds passed    ...41%, 0.16 MB, 843 KB/s, 0 seconds passed    ...43%, 0.17 MB, 882 KB/s, 0 seconds passed    ...45%, 0.18 MB, 921 KB/s, 0 seconds passed    ...47%, 0.19 MB, 961 KB/s, 0 seconds passed    ...49%, 0.20 MB, 999 KB/s, 0 seconds passed    ...51%, 0.20 MB, 1038 KB/s, 0 seconds passed    ...53%, 0.21 MB, 1076 KB/s, 0 seconds passed    ...55%, 0.22 MB, 1115 KB/s, 0 seconds passed    ...57%, 0.23 MB, 1151 KB/s, 0 seconds passed    ...59%, 0.23 MB, 1190 KB/s, 0 seconds passed    ...61%, 0.24 MB, 1228 KB/s, 0 seconds passed    ...63%, 0.25 MB, 1267 KB/s, 0 seconds passed    ...65%, 0.26 MB, 1304 KB/s, 0 seconds passed    ...67%, 0.27 MB, 1342 KB/s, 0 seconds passed    ...69%, 0.27 MB, 1381 KB/s, 0 seconds passed    ...71%, 0.28 MB, 1420 KB/s, 0 seconds passed    ...73%, 0.29 MB, 1454 KB/s, 0 seconds passed    ...75%, 0.30 MB, 1493 KB/s, 0 seconds passed    ...77%, 0.30 MB, 1531 KB/s, 0 seconds passed    ...79%, 0.31 MB, 1570 KB/s, 0 seconds passed    ...81%, 0.32 MB, 1607 KB/s, 0 seconds passed    ...83%, 0.33 MB, 1646 KB/s, 0 seconds passed    ...85%, 0.34 MB, 1682 KB/s, 0 seconds passed    ...87%, 0.34 MB, 1721 KB/s, 0 seconds passed    ...89%, 0.35 MB, 1756 KB/s, 0 seconds passed    ...91%, 0.36 MB, 1794 KB/s, 0 seconds passed    ...93%, 0.37 MB, 1830 KB/s, 0 seconds passed    ...95%, 0.38 MB, 1868 KB/s, 0 seconds passed    ...97%, 0.38 MB, 1906 KB/s, 0 seconds passed    ...99%, 0.39 MB, 1944 KB/s, 0 seconds passed    ...100%, 0.40 MB, 1981 KB/s, 0 seconds passed
    Cannot find config for target=cuda -model=unknown, workload=('conv2d_nchw.cuda', ('TENSOR', (1, 64, 56, 56), 'float32'), ('TENSOR', (64, 64, 3, 3), 'float32'), (1, 1), (1, 1, 1, 1), (1, 1), 'float32'). A fallback configuration is used, which may bring great performance regression.
    Cannot find config for target=cuda -model=unknown, workload=('conv2d_nchw.cuda', ('TENSOR', (1, 128, 28, 28), 'float32'), ('TENSOR', (128, 128, 3, 3), 'float32'), (1, 1), (1, 1, 1, 1), (1, 1), 'float32'). A fallback configuration is used, which may bring great performance regression.
    Cannot find config for target=cuda -model=unknown, workload=('conv2d_nchw.cuda', ('TENSOR', (1, 256, 14, 14), 'float32'), ('TENSOR', (256, 256, 3, 3), 'float32'), (1, 1), (1, 1, 1, 1), (1, 1), 'float32'). A fallback configuration is used, which may bring great performance regression.
    Cannot find config for target=cuda -model=unknown, workload=('conv2d_nchw.cuda', ('TENSOR', (1, 512, 7, 7), 'float32'), ('TENSOR', (512, 512, 3, 3), 'float32'), (1, 1), (1, 1, 1, 1), (1, 1), 'float32'). A fallback configuration is used, which may bring great performance regression.
    Cannot find config for target=cuda -model=unknown, workload=('dense_small_batch.cuda', ('TENSOR', (1, 512), 'float32'), ('TENSOR', (1000, 512), 'float32'), None, 'float32'). A fallback configuration is used, which may bring great performance regression.



Run the generate library
------------------------
Now we can create graph runtime and run the module on Nvidia GPU.


.. code-block:: default


    # create random input
    ctx = tvm.gpu()
    data = np.random.uniform(-1, 1, size=data_shape).astype("float32")
    # create module
    module = graph_runtime.create(graph, lib, ctx)
    # set input and parameters
    module.set_input("data", data)
    module.set_input(**params)
    # run
    module.run()
    # get output
    out = module.get_output(0, tvm.nd.empty(out_shape)).asnumpy()

    # Print first 10 elements of output
    print(out.flatten()[0:10])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.00089283 0.00103331 0.0009094  0.00102275 0.00108751 0.00106737
     0.00106262 0.00095838 0.00110792 0.00113151]



Save and Load Compiled Module
-----------------------------
We can also save the graph, lib and parameters into files and load them
back in deploy environment.


.. code-block:: default


    # save the graph, lib and params into separate files
    from tvm.contrib import util

    temp = util.tempdir()
    path_lib = temp.relpath("deploy_lib.tar")
    lib.export_library(path_lib)
    with open(temp.relpath("deploy_graph.json"), "w") as fo:
        fo.write(graph)
    with open(temp.relpath("deploy_param.params"), "wb") as fo:
        fo.write(relay.save_param_dict(params))
    print(temp.listdir())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ['deploy_lib.tar', 'deploy_param.params', 'deploy_graph.json']




.. code-block:: default


    # load the module back.
    loaded_json = open(temp.relpath("deploy_graph.json")).read()
    loaded_lib = tvm.runtime.load_module(path_lib)
    loaded_params = bytearray(open(temp.relpath("deploy_param.params"), "rb").read())
    input_data = tvm.nd.array(np.random.uniform(size=data_shape).astype("float32"))

    module = graph_runtime.create(loaded_json, loaded_lib, ctx)
    module.load_params(loaded_params)
    module.run(data=input_data)
    out_deploy = module.get_output(0).asnumpy()

    # Print first 10 elements of output
    print(out_deploy.flatten()[0:10])

    # check whether the output from deployed module is consistent with original one
    tvm.testing.assert_allclose(out_deploy, out, atol=1e-3)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.00090713 0.00105705 0.00094459 0.00103146 0.00110017 0.00105846
     0.00104143 0.00095862 0.0010827  0.00111618]




.. _sphx_glr_download_tutorials_relay_quick_start.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: relay_quick_start.py <relay_quick_start.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: relay_quick_start.ipynb <relay_quick_start.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
