<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: include/tvm/relax/transform.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b4c7d8e826c599ba55146c099a14beb5.html">tvm</a></li><li class="navelem"><a class="el" href="dir_039190d3b4246b6bdd648b90e06580e6.html">relax</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">transform.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Relax specific transformation passes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;tvm/ffi/reflection/registry.h&gt;</code><br />
<code>#include &lt;<a class="el" href="ir_2transform_8h_source.html">tvm/ir/transform.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="dataflow__pattern_8h_source.html">tvm/relax/dataflow_pattern.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="relax_2expr_8h_source.html">tvm/relax/expr.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="tir_2function_8h_source.html">tvm/tir/function.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="index__map_8h_source.html">tvm/tir/index_map.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for transform.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="relax_2transform_8h__incl.svg" width="7418" height="1395"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="relax_2transform_8h__dep__incl.svg" width="454" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="relax_2transform_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPatternNode.html">tvm::relax::transform::FusionPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pattern object used as the input of FuseOpsByPattern. For bindings to be fused, it needs to be matched with <code>pattern</code> and the <code>check</code> function needs to return true.  <a href="classtvm_1_1relax_1_1transform_1_1FusionPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPattern.html">tvm::relax::transform::FusionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1PatternCheckContextNode.html">tvm::relax::transform::PatternCheckContextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input of FusionPattern::check.  <a href="classtvm_1_1relax_1_1transform_1_1PatternCheckContextNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1PatternCheckContext.html">tvm::relax::transform::PatternCheckContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm.html">tvm</a></td></tr>
<tr class="memdesc:namespacetvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance counters for profiling via the PAPI library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relax"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html">tvm::relax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html">tvm::relax::transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa3d28b2e48b6d5708052909943dd3282"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">tvm::relax::transform::Pass</a> = <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td></tr>
<tr class="separator:aa3d28b2e48b6d5708052909943dd3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cc1b2a0ef5efdeb2298358dacae905"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a81cc1b2a0ef5efdeb2298358dacae905">tvm::relax::transform::PassInfo</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td></tr>
<tr class="separator:a81cc1b2a0ef5efdeb2298358dacae905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092572e45f7d7f90fd3270677ed9164"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">tvm::relax::transform::PassContext</a> = <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td></tr>
<tr class="separator:a8092572e45f7d7f90fd3270677ed9164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4497453f2323b565eb405e0097fa1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">tvm::relax::transform::Function</a> = <a class="el" href="classtvm_1_1relax_1_1Function.html">tvm::relax::Function</a></td></tr>
<tr class="separator:a2dc4497453f2323b565eb405e0097fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a73fe4f7173374898cc8978103ceaee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">tvm::relax::transform::DataflowBlock</a> = <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">tvm::relax::DataflowBlock</a></td></tr>
<tr class="separator:a0a73fe4f7173374898cc8978103ceaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a06c5d14cf2410201df1a6a912d1182c9"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a06c5d14cf2410201df1a6a912d1182c9">tvm::relax::transform::CreateFunctionPass</a> (std::function&lt; Function(Function, IRModule, PassContext)&gt; pass_func, int opt_level, ffi::String name, tvm::ffi::Array&lt; ffi::String &gt; required, bool traceable=false)</td></tr>
<tr class="memdesc:a06c5d14cf2410201df1a6a912d1182c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function pass.  <a href="namespacetvm_1_1relax_1_1transform.html#a06c5d14cf2410201df1a6a912d1182c9">More...</a><br /></td></tr>
<tr class="separator:a06c5d14cf2410201df1a6a912d1182c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec22c5e6056bd8f5902dc062a9635ad"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#acec22c5e6056bd8f5902dc062a9635ad">tvm::relax::transform::CreateDataflowBlockPass</a> (std::function&lt; DataflowBlock(DataflowBlock, IRModule, PassContext)&gt; pass_func, int opt_level, ffi::String name, tvm::ffi::Array&lt; ffi::String &gt; required, bool traceable=false)</td></tr>
<tr class="memdesc:acec22c5e6056bd8f5902dc062a9635ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dataflowblock pass.  <a href="namespacetvm_1_1relax_1_1transform.html#acec22c5e6056bd8f5902dc062a9635ad">More...</a><br /></td></tr>
<tr class="separator:acec22c5e6056bd8f5902dc062a9635ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6348965f3158c33e75c2fb780558423"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ac6348965f3158c33e75c2fb780558423">tvm::relax::transform::LambdaLift</a> ()</td></tr>
<tr class="memdesc:ac6348965f3158c33e75c2fb780558423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform lambda lifting to lift functions from nested into global.  <a href="namespacetvm_1_1relax_1_1transform.html#ac6348965f3158c33e75c2fb780558423">More...</a><br /></td></tr>
<tr class="separator:ac6348965f3158c33e75c2fb780558423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2bed29c2df4141beece380481ddaa"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#af3d2bed29c2df4141beece380481ddaa">tvm::relax::transform::ToNonDataflow</a> ()</td></tr>
<tr class="memdesc:af3d2bed29c2df4141beece380481ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all dataflow structure to non-dataflow version.  <a href="namespacetvm_1_1relax_1_1transform.html#af3d2bed29c2df4141beece380481ddaa">More...</a><br /></td></tr>
<tr class="separator:af3d2bed29c2df4141beece380481ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a792aa8a2b0aa28064b41215bc7d4e93a">tvm::relax::transform::RemovePurityChecking</a> ()</td></tr>
<tr class="memdesc:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate force_pure on all pure functions in the module and unwrap all pure override ops into the normal versions.  <a href="namespacetvm_1_1relax_1_1transform.html#a792aa8a2b0aa28064b41215bc7d4e93a">More...</a><br /></td></tr>
<tr class="separator:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811e8bbe0369530605d02e332bed5dc"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a1811e8bbe0369530605d02e332bed5dc">tvm::relax::transform::CallTIRRewrite</a> ()</td></tr>
<tr class="memdesc:a1811e8bbe0369530605d02e332bed5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform explicit tensor allocation for call_tir and call_dps_packed.  <a href="namespacetvm_1_1relax_1_1transform.html#a1811e8bbe0369530605d02e332bed5dc">More...</a><br /></td></tr>
<tr class="separator:a1811e8bbe0369530605d02e332bed5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39386a8c6dad83320670e691e7a60c0"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ab39386a8c6dad83320670e691e7a60c0">tvm::relax::transform::RewriteDataflowReshape</a> ()</td></tr>
<tr class="memdesc:ab39386a8c6dad83320670e691e7a60c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all reshape-like call_tir whose corresponding binding vars are DataflowVars to relax.reshape operator calls. The relax.reshape calls will be lowered an external builtin function call in a subsequent pass, where the external builtin function does a CreateView operation at runtime, instead of doing real data copy. Here "reshape-like" includes reshape, expand_dims, flatten, etc.  <a href="namespacetvm_1_1relax_1_1transform.html#ab39386a8c6dad83320670e691e7a60c0">More...</a><br /></td></tr>
<tr class="separator:ab39386a8c6dad83320670e691e7a60c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9e9338ca42710bcfb51652793efb9b"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aef9e9338ca42710bcfb51652793efb9b">tvm::relax::transform::StaticPlanBlockMemory</a> ()</td></tr>
<tr class="memdesc:aef9e9338ca42710bcfb51652793efb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static memory planning pass on <a class="el" href="classtvm_1_1relax_1_1BindingBlock.html">BindingBlock</a> level. The pass will reuse allocated memory to its best effort, in order to reduce the total amount of allocated memory size.  <a href="namespacetvm_1_1relax_1_1transform.html#aef9e9338ca42710bcfb51652793efb9b">More...</a><br /></td></tr>
<tr class="separator:aef9e9338ca42710bcfb51652793efb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca6a56c220e2984deb346caeba5d871"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a6ca6a56c220e2984deb346caeba5d871">tvm::relax::transform::AttachGlobalSymbol</a> ()</td></tr>
<tr class="memdesc:a6ca6a56c220e2984deb346caeba5d871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach global_symbol to Relax functions and TIR Primfuncs for codegen.  <a href="namespacetvm_1_1relax_1_1transform.html#a6ca6a56c220e2984deb346caeba5d871">More...</a><br /></td></tr>
<tr class="separator:a6ca6a56c220e2984deb346caeba5d871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2d5ba892a16b980a687f0dcb4ad84e17">tvm::relax::transform::Normalize</a> ()</td></tr>
<tr class="memdesc:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform Relax IR to normal form: transform AST to A-normal form, and fill the struct_info_ of expressions.  <a href="namespacetvm_1_1relax_1_1transform.html#a2d5ba892a16b980a687f0dcb4ad84e17">More...</a><br /></td></tr>
<tr class="separator:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8193d3d2f8c7ae4a62dd4b47cc5adeeb">tvm::relax::transform::NormalizeGlobalVar</a> ()</td></tr>
<tr class="memdesc:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly rename the <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> in an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to ensure these properties:  <a href="namespacetvm_1_1relax_1_1transform.html#a8193d3d2f8c7ae4a62dd4b47cc5adeeb">More...</a><br /></td></tr>
<tr class="separator:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa697394f51af1181825cc5223746f18c"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa697394f51af1181825cc5223746f18c">tvm::relax::transform::CanonicalizeBindings</a> ()</td></tr>
<tr class="memdesc:aa697394f51af1181825cc5223746f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a Relax module by folding var bindings and match shape nodes, as well as tuple indices. Best used alongside constant folding and eliminating unused bindings.  <a href="namespacetvm_1_1relax_1_1transform.html#aa697394f51af1181825cc5223746f18c">More...</a><br /></td></tr>
<tr class="separator:aa697394f51af1181825cc5223746f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265e8a2dd2e30c5e577085a7629f4cd"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ae265e8a2dd2e30c5e577085a7629f4cd">tvm::relax::transform::EliminateCommonSubexpr</a> (bool call_only=false)</td></tr>
<tr class="separator:ae265e8a2dd2e30c5e577085a7629f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aceba6fd7c94691d71c1cdaa010b572"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a1aceba6fd7c94691d71c1cdaa010b572">tvm::relax::transform::BindParams</a> (ffi::String func_name, ffi::Map&lt; Any, ObjectRef &gt; params)</td></tr>
<tr class="memdesc:a1aceba6fd7c94691d71c1cdaa010b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind params of function of the module to constant tensors.  <a href="namespacetvm_1_1relax_1_1transform.html#a1aceba6fd7c94691d71c1cdaa010b572">More...</a><br /></td></tr>
<tr class="separator:a1aceba6fd7c94691d71c1cdaa010b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec8a5cf3c44631bee60f30e71c897a"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a4aec8a5cf3c44631bee60f30e71c897a">tvm::relax::transform::BindSymbolicVars</a> (ffi::Map&lt; ffi::Variant&lt; tir::Var, ffi::String &gt;, PrimExpr &gt; binding_map, ffi::Optional&lt; ffi::String &gt; func_name=std::nullopt)</td></tr>
<tr class="memdesc:a4aec8a5cf3c44631bee60f30e71c897a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind symbolic vars to constant shape values.  <a href="namespacetvm_1_1relax_1_1transform.html#a4aec8a5cf3c44631bee60f30e71c897a">More...</a><br /></td></tr>
<tr class="separator:a4aec8a5cf3c44631bee60f30e71c897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa26d9a1b7b6b9b7bc575ad8edccb7ca7">tvm::relax::transform::FoldConstant</a> ()</td></tr>
<tr class="memdesc:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions within dataflow blocks.  <a href="namespacetvm_1_1relax_1_1transform.html#aa26d9a1b7b6b9b7bc575ad8edccb7ca7">More...</a><br /></td></tr>
<tr class="separator:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853600623bebe13a85ac5865c8fddade"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a853600623bebe13a85ac5865c8fddade">tvm::relax::transform::LegalizeOps</a> (ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Function &gt;&gt; cmap, bool enable_warning=false)</td></tr>
<tr class="memdesc:a853600623bebe13a85ac5865c8fddade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize high-level operator calls in Relax functions to call_tir with corresponding low-level TIR PrimFuncs.  <a href="namespacetvm_1_1relax_1_1transform.html#a853600623bebe13a85ac5865c8fddade">More...</a><br /></td></tr>
<tr class="separator:a853600623bebe13a85ac5865c8fddade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032567f2efa23079fc71029d4cb13ca0"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a032567f2efa23079fc71029d4cb13ca0">tvm::relax::transform::RealizeVDevice</a> ()</td></tr>
<tr class="memdesc:a032567f2efa23079fc71029d4cb13ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate virtual device information.  <a href="namespacetvm_1_1relax_1_1transform.html#a032567f2efa23079fc71029d4cb13ca0">More...</a><br /></td></tr>
<tr class="separator:a032567f2efa23079fc71029d4cb13ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a7dc74fad940d4c416f4095f4aef6e8f3">tvm::relax::transform::AttachAttrLayoutFreeBuffers</a> ()</td></tr>
<tr class="memdesc:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach layout free buffers to the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>.  <a href="namespacetvm_1_1relax_1_1transform.html#a7dc74fad940d4c416f4095f4aef6e8f3">More...</a><br /></td></tr>
<tr class="separator:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a2b8f167c50e9749fe05e0552aca7"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a658a2b8f167c50e9749fe05e0552aca7">tvm::relax::transform::SplitLayoutRewritePreproc</a> ()</td></tr>
<tr class="memdesc:a658a2b8f167c50e9749fe05e0552aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the layout rewrite preproc block to a separate <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>.  <a href="namespacetvm_1_1relax_1_1transform.html#a658a2b8f167c50e9749fe05e0552aca7">More...</a><br /></td></tr>
<tr class="separator:a658a2b8f167c50e9749fe05e0552aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313133cbc2c030cc7602d22efb7a3ca1"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a313133cbc2c030cc7602d22efb7a3ca1">tvm::relax::transform::LiftTransformParams</a> (ffi::Variant&lt; Bool, ffi::Array&lt; ffi::String &gt;&gt; shared_transform=Bool(false))</td></tr>
<tr class="memdesc:a313133cbc2c030cc7602d22efb7a3ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift transformation of the parameters of a function.  <a href="namespacetvm_1_1relax_1_1transform.html#a313133cbc2c030cc7602d22efb7a3ca1">More...</a><br /></td></tr>
<tr class="separator:a313133cbc2c030cc7602d22efb7a3ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb38ac5d686a9e6feaec6290b92d374e"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aeb38ac5d686a9e6feaec6290b92d374e">tvm::relax::transform::UpdateVDevice</a> (VDevice new_vdevice, int64_t index)</td></tr>
<tr class="memdesc:aeb38ac5d686a9e6feaec6290b92d374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update virtual device.  <a href="namespacetvm_1_1relax_1_1transform.html#aeb38ac5d686a9e6feaec6290b92d374e">More...</a><br /></td></tr>
<tr class="separator:aeb38ac5d686a9e6feaec6290b92d374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9578408fcfdc920ca97d54ae699c431f"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a9578408fcfdc920ca97d54ae699c431f">tvm::relax::transform::ExpandTupleArguments</a> ()</td></tr>
<tr class="memdesc:a9578408fcfdc920ca97d54ae699c431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand tuple arguments to internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a9578408fcfdc920ca97d54ae699c431f">More...</a><br /></td></tr>
<tr class="separator:a9578408fcfdc920ca97d54ae699c431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a5f8f0e642926291c0554eff604a79"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a33a5f8f0e642926291c0554eff604a79">tvm::relax::transform::RemoveUnusedParameters</a> ()</td></tr>
<tr class="memdesc:a33a5f8f0e642926291c0554eff604a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused parameters to internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a33a5f8f0e642926291c0554eff604a79">More...</a><br /></td></tr>
<tr class="separator:a33a5f8f0e642926291c0554eff604a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a3eef153bbae5089e940ba27e598cf"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a93a3eef153bbae5089e940ba27e598cf">tvm::relax::transform::RemoveUnusedOutputs</a> ()</td></tr>
<tr class="memdesc:a93a3eef153bbae5089e940ba27e598cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused outputs from internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a93a3eef153bbae5089e940ba27e598cf">More...</a><br /></td></tr>
<tr class="separator:a93a3eef153bbae5089e940ba27e598cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739adf2cff75a2e14b305f6fbefa982b"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a739adf2cff75a2e14b305f6fbefa982b">tvm::relax::transform::AnnotateTIROpPattern</a> ()</td></tr>
<tr class="memdesc:a739adf2cff75a2e14b305f6fbefa982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind for TIR functions, which is used in FuseOps.  <a href="namespacetvm_1_1relax_1_1transform.html#a739adf2cff75a2e14b305f6fbefa982b">More...</a><br /></td></tr>
<tr class="separator:a739adf2cff75a2e14b305f6fbefa982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7155cec2bad0e8e64bd78d1459843b88"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a7155cec2bad0e8e64bd78d1459843b88">tvm::relax::transform::FuseOps</a> (int fuse_opt_level=-1)</td></tr>
<tr class="memdesc:a7155cec2bad0e8e64bd78d1459843b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass groups bindings in a dataflow block of Relax functions and generates a new grouped Relax function for each group, according to the fusion algorithm described in the pass implementation. By grouping bindings into new Relax functions, we substitute the bindings in the function being manipulated into function calls to the new grouped function.  <a href="namespacetvm_1_1relax_1_1transform.html#a7155cec2bad0e8e64bd78d1459843b88">More...</a><br /></td></tr>
<tr class="separator:a7155cec2bad0e8e64bd78d1459843b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056853e1c1b4313b0834dba050ac0bce"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a056853e1c1b4313b0834dba050ac0bce">tvm::relax::transform::Gradient</a> (ffi::String func_name, ffi::Optional&lt; ffi::Array&lt; Var &gt;&gt; require_grads=std::nullopt, int target_index=0)</td></tr>
<tr class="memdesc:a056853e1c1b4313b0834dba050ac0bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-mode automatic differentiation.  <a href="namespacetvm_1_1relax_1_1transform.html#a056853e1c1b4313b0834dba050ac0bce">More...</a><br /></td></tr>
<tr class="separator:a056853e1c1b4313b0834dba050ac0bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b24c5daa0796d778e803b320bf6766"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a12b24c5daa0796d778e803b320bf6766">tvm::relax::transform::FuseOpsByPattern</a> (const tvm::ffi::Array&lt; FusionPattern &gt; &amp;patterns, bool bind_constants=true, bool annotate_codegen=false, const tvm::ffi::Array&lt; ffi::String &gt; &amp;entry_function_names={})</td></tr>
<tr class="memdesc:a12b24c5daa0796d778e803b320bf6766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply pattern matching to each function in the given module, and group matched expressions into a new function. The end result is similar to FuseOps, but fusion is driven completely by the provided patterns.  <a href="namespacetvm_1_1relax_1_1transform.html#a12b24c5daa0796d778e803b320bf6766">More...</a><br /></td></tr>
<tr class="separator:a12b24c5daa0796d778e803b320bf6766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a27562367f610b894144546ae0cda8"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a07a27562367f610b894144546ae0cda8">tvm::relax::transform::MergeCompositeFunctions</a> ()</td></tr>
<tr class="memdesc:a07a27562367f610b894144546ae0cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group one or multiple composite functions created by FuseOpsByPattern into a new function. The new function will be annotated with kCodegen and GlobalSymbol attributes, and it is intented to be offloaded to an external backend.  <a href="namespacetvm_1_1relax_1_1transform.html#a07a27562367f610b894144546ae0cda8">More...</a><br /></td></tr>
<tr class="separator:a07a27562367f610b894144546ae0cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a3feb81c5b5d9b4b907f3e2c72b0ac2d3">tvm::relax::transform::FuseTIR</a> ()</td></tr>
<tr class="memdesc:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse relax sub-function into a larger TIR function if possible. this pass works together with FuseOps to perform operator fusion.  <a href="namespacetvm_1_1relax_1_1transform.html#a3feb81c5b5d9b4b907f3e2c72b0ac2d3">More...</a><br /></td></tr>
<tr class="separator:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a84533ab0e8770e7f6b2c0ca677e42c56">tvm::relax::transform::RunCodegen</a> (ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&gt; target_options, ffi::Array&lt; ffi::String &gt; entry_functions)</td></tr>
<tr class="memdesc:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run codegen.  <a href="namespacetvm_1_1relax_1_1transform.html#a84533ab0e8770e7f6b2c0ca677e42c56">More...</a><br /></td></tr>
<tr class="separator:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8366d2c1a552e747c49df617f512bb"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ada8366d2c1a552e747c49df617f512bb">tvm::relax::transform::DecomposeOpsForInference</a> (ffi::Optional&lt; ffi::String &gt; func_name)</td></tr>
<tr class="memdesc:ada8366d2c1a552e747c49df617f512bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose composite operators during inference. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well.  <a href="namespacetvm_1_1relax_1_1transform.html#ada8366d2c1a552e747c49df617f512bb">More...</a><br /></td></tr>
<tr class="separator:ada8366d2c1a552e747c49df617f512bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767be7f56b59f7feed45292854ed934"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ab767be7f56b59f7feed45292854ed934">tvm::relax::transform::DecomposeOpsForTraining</a> (ffi::Optional&lt; ffi::String &gt; func_name)</td></tr>
<tr class="memdesc:ab767be7f56b59f7feed45292854ed934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose composite operators during training. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well.  <a href="namespacetvm_1_1relax_1_1transform.html#ab767be7f56b59f7feed45292854ed934">More...</a><br /></td></tr>
<tr class="separator:ab767be7f56b59f7feed45292854ed934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8acc5693cd6ed43a8053b905e3b886"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aef8acc5693cd6ed43a8053b905e3b886">tvm::relax::transform::AlterOpImpl</a> (const ffi::Map&lt; ffi::String, tir::PrimFunc &gt; &amp;op_impl_map, const ffi::Map&lt; ffi::String, ffi::Array&lt; tir::IndexMap &gt;&gt; &amp;op_buffer_transforms, const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; IntImm &gt;&gt;&gt;&gt; &amp;axis_separators, const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; IntImm &gt;&gt;&gt;&gt; &amp;input_axis_separators)</td></tr>
<tr class="memdesc:aef8acc5693cd6ed43a8053b905e3b886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pass which replaces PrimFuncs which have matching kOperatorName attribute in <code>op_impl_map</code>, with replacement PrimFunc that could possibly have different layouts on i/o buffers. The layout transformations on i/o buffers is present in the <code>op_buffer_transforms</code>. The pass inserts the layout transformations in the call sites of PrimFuncs being replaced to transform i/o buffers into expected layout.  <a href="namespacetvm_1_1relax_1_1transform.html#aef8acc5693cd6ed43a8053b905e3b886">More...</a><br /></td></tr>
<tr class="separator:aef8acc5693cd6ed43a8053b905e3b886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8de8208a1d4efb9ea263bf599474af"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a4d8de8208a1d4efb9ea263bf599474af">tvm::relax::transform::ConvertLayout</a> (ffi::Map&lt; ffi::String, ffi::Array&lt; ffi::String &gt;&gt; desired_layouts)</td></tr>
<tr class="memdesc:a4d8de8208a1d4efb9ea263bf599474af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layout conversion pass.  <a href="namespacetvm_1_1relax_1_1transform.html#a4d8de8208a1d4efb9ea263bf599474af">More...</a><br /></td></tr>
<tr class="separator:a4d8de8208a1d4efb9ea263bf599474af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf34717bb1990ef17ddb03db00360ddc"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#adf34717bb1990ef17ddb03db00360ddc">tvm::relax::transform::ConvertToDataflow</a> (int min_size=2)</td></tr>
<tr class="memdesc:adf34717bb1990ef17ddb03db00360ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass that converts consecutive dataflow operations inside binding blocks into dataflow blocks.  <a href="namespacetvm_1_1relax_1_1transform.html#adf34717bb1990ef17ddb03db00360ddc">More...</a><br /></td></tr>
<tr class="separator:adf34717bb1990ef17ddb03db00360ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#afc435a69f08a8e5eee5c2bce0dfd6992">tvm::relax::transform::DeadCodeElimination</a> (ffi::Array&lt; ffi::String &gt; entry_functions={})</td></tr>
<tr class="memdesc:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead code elimination.  <a href="namespacetvm_1_1relax_1_1transform.html#afc435a69f08a8e5eee5c2bce0dfd6992">More...</a><br /></td></tr>
<tr class="separator:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f82e9471203ddc307c67bc858a28d8"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a11f82e9471203ddc307c67bc858a28d8">tvm::relax::transform::DataflowUseInplaceCalls</a> ()</td></tr>
<tr class="memdesc:a11f82e9471203ddc307c67bc858a28d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that changes calls to operators that can be done in-place (generally, these are elementwise operations) in dataflow blocks into in-place implementations. Supported operators will be replaced by calls to <code>call_tir_inplace</code> that invoke in-place PrimFunc implementations of those operators (which are based on the legalizations of those operators).  <a href="namespacetvm_1_1relax_1_1transform.html#a11f82e9471203ddc307c67bc858a28d8">More...</a><br /></td></tr>
<tr class="separator:a11f82e9471203ddc307c67bc858a28d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0363e13a19a156462cab6f097559c"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a13b0363e13a19a156462cab6f097559c">tvm::relax::transform::ToMixedPrecision</a> (const DataType &amp;out_dtype, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; fp16_input_names=std::nullopt)</td></tr>
<tr class="memdesc:a13b0363e13a19a156462cab6f097559c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic mixed precision pass. Currently the pass assumes the input module to be fp32 only, and will automatically cast fp32 to fp16 for certain ops.  <a href="namespacetvm_1_1relax_1_1transform.html#a13b0363e13a19a156462cab6f097559c">More...</a><br /></td></tr>
<tr class="separator:a13b0363e13a19a156462cab6f097559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ad769f00c33bd5eac4fa5e608ce92b87b">tvm::relax::transform::RewriteCUDAGraph</a> ()</td></tr>
<tr class="memdesc:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a Relax module for executing with CUDA graph. This pass identifies the regions that can be executed with CUDA graph and lifts them into new functions for runtime graph capturing.  <a href="namespacetvm_1_1relax_1_1transform.html#ad769f00c33bd5eac4fa5e608ce92b87b">More...</a><br /></td></tr>
<tr class="separator:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47edcc1f5a163d830f6a428663d82875"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a47edcc1f5a163d830f6a428663d82875">tvm::relax::transform::FewShotTuning</a> (int valid_count, bool benchmark)</td></tr>
<tr class="memdesc:a47edcc1f5a163d830f6a428663d82875"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pass is designed for few shot tuning for static shape PrimFuncs. It examines all the blocks within the PrimFunc and conducts loop fusion, splitting, and other transformations based on MetaSchedule schedule rules but directly samples from the search space instead of using the tuning algorithm. User can specify the number of valid counts to try and whether to use runner for benchmarking.  <a href="namespacetvm_1_1relax_1_1transform.html#a47edcc1f5a163d830f6a428663d82875">More...</a><br /></td></tr>
<tr class="separator:a47edcc1f5a163d830f6a428663d82875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Relax specific transformation passes. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
