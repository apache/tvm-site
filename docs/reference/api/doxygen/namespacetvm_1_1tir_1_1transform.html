<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac51a104ab4d2c60a4f6ed0e827efab18">VerifySSA</a> ()</td></tr>
<tr class="memdesc:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifySSA.  <a href="namespacetvm_1_1tir_1_1transform.html#ac51a104ab4d2c60a4f6ed0e827efab18">More...</a><br /></td></tr>
<tr class="separator:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d0b0ed966cf019d5e607bc90f284af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a32d0b0ed966cf019d5e607bc90f284af">VerifyMemory</a> ()</td></tr>
<tr class="memdesc:a32d0b0ed966cf019d5e607bc90f284af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifyMemory.  <a href="namespacetvm_1_1tir_1_1transform.html#a32d0b0ed966cf019d5e607bc90f284af">More...</a><br /></td></tr>
<tr class="separator:a32d0b0ed966cf019d5e607bc90f284af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a059926c2ea81dcf437eff35f05e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a70a059926c2ea81dcf437eff35f05e3e">VerifyGPUCode</a> (Map&lt; String, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; constraints)</td></tr>
<tr class="memdesc:a70a059926c2ea81dcf437eff35f05e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifyGPUCode.  <a href="namespacetvm_1_1tir_1_1transform.html#a70a059926c2ea81dcf437eff35f05e3e">More...</a><br /></td></tr>
<tr class="separator:a70a059926c2ea81dcf437eff35f05e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6989866d1d471ce19bd5fa45f4871a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6989866d1d471ce19bd5fa45f4871a20">VerifyVTCMLimit</a> (Optional&lt; <a class="el" href="classtvm_1_1Target.html">Target</a> &gt; target=std::nullopt)</td></tr>
<tr class="memdesc:a6989866d1d471ce19bd5fa45f4871a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to checks if the size of the allocated vtcm memory satisfies the limit.  <a href="namespacetvm_1_1tir_1_1transform.html#a6989866d1d471ce19bd5fa45f4871a20">More...</a><br /></td></tr>
<tr class="separator:a6989866d1d471ce19bd5fa45f4871a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea27d24b6e7852652d258268d8537b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aea27d24b6e7852652d258268d8537b66">OOBChecker</a> ()</td></tr>
<tr class="memdesc:aea27d24b6e7852652d258268d8537b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically check TIR code for out of bounds array access.  <a href="namespacetvm_1_1tir_1_1transform.html#aea27d24b6e7852652d258268d8537b66">More...</a><br /></td></tr>
<tr class="separator:aea27d24b6e7852652d258268d8537b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6d6301148b32e20b9926b383855ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a51c6d6301148b32e20b9926b383855ce">CreatePrimFuncPass</a> (std::function&lt; <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1transform_1_1PassContext.html">PassContext</a>)&gt; pass_func, int opt_level, String name, tvm::Array&lt; String &gt; required, bool traceable=false)</td></tr>
<tr class="separator:a51c6d6301148b32e20b9926b383855ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b0910c03b6f2d462448fa2725c1f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a17b0910c03b6f2d462448fa2725c1f5e">LoopPartition</a> ()</td></tr>
<tr class="memdesc:a17b0910c03b6f2d462448fa2725c1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition loops in the stmt.  <a href="namespacetvm_1_1tir_1_1transform.html#a17b0910c03b6f2d462448fa2725c1f5e">More...</a><br /></td></tr>
<tr class="separator:a17b0910c03b6f2d462448fa2725c1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cecb50a8b8fc8021f6a87bc27587da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af3cecb50a8b8fc8021f6a87bc27587da">VectorizeLoop</a> (bool enable_vectorize=true)</td></tr>
<tr class="memdesc:af3cecb50a8b8fc8021f6a87bc27587da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower vectorization loops.  <a href="namespacetvm_1_1tir_1_1transform.html#af3cecb50a8b8fc8021f6a87bc27587da">More...</a><br /></td></tr>
<tr class="separator:af3cecb50a8b8fc8021f6a87bc27587da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ade618ab7572f92bd37f69049966c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a37ade618ab7572f92bd37f69049966c7">InjectVirtualThread</a> ()</td></tr>
<tr class="memdesc:a37ade618ab7572f92bd37f69049966c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject virtual thread loops.  <a href="namespacetvm_1_1tir_1_1transform.html#a37ade618ab7572f92bd37f69049966c7">More...</a><br /></td></tr>
<tr class="separator:a37ade618ab7572f92bd37f69049966c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f70a1b3cfc63c52b462fba772b8370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a55f70a1b3cfc63c52b462fba772b8370">InjectDoubleBuffer</a> ()</td></tr>
<tr class="memdesc:a55f70a1b3cfc63c52b462fba772b8370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject double buffer statements.  <a href="namespacetvm_1_1tir_1_1transform.html#a55f70a1b3cfc63c52b462fba772b8370">More...</a><br /></td></tr>
<tr class="separator:a55f70a1b3cfc63c52b462fba772b8370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87b271e2c20e0ad901697f33c01d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#abe87b271e2c20e0ad901697f33c01d2c">StorageRewrite</a> ()</td></tr>
<tr class="memdesc:abe87b271e2c20e0ad901697f33c01d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible.  <a href="namespacetvm_1_1tir_1_1transform.html#abe87b271e2c20e0ad901697f33c01d2c">More...</a><br /></td></tr>
<tr class="separator:abe87b271e2c20e0ad901697f33c01d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f279e91071fa96a1edb24fa004ea6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ab2f279e91071fa96a1edb24fa004ea6a">UnrollLoop</a> ()</td></tr>
<tr class="memdesc:ab2f279e91071fa96a1edb24fa004ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard.  <a href="namespacetvm_1_1tir_1_1transform.html#ab2f279e91071fa96a1edb24fa004ea6a">More...</a><br /></td></tr>
<tr class="separator:ab2f279e91071fa96a1edb24fa004ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad1159425e29be796562b2ec629b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8aad1159425e29be796562b2ec629b10">RemoveNoOp</a> ()</td></tr>
<tr class="memdesc:a8aad1159425e29be796562b2ec629b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a>.  <a href="namespacetvm_1_1tir_1_1transform.html#a8aad1159425e29be796562b2ec629b10">More...</a><br /></td></tr>
<tr class="separator:a8aad1159425e29be796562b2ec629b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe43327c4454dd05b6e925577443f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4fe43327c4454dd05b6e925577443f49">RewriteUnsafeSelect</a> ()</td></tr>
<tr class="memdesc:a4fe43327c4454dd05b6e925577443f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and rewrite unsafe select that contains memory access.  <a href="namespacetvm_1_1tir_1_1transform.html#a4fe43327c4454dd05b6e925577443f49">More...</a><br /></td></tr>
<tr class="separator:a4fe43327c4454dd05b6e925577443f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817801e8c9488f712804d2d0b821acf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a817801e8c9488f712804d2d0b821acf0">Simplify</a> ()</td></tr>
<tr class="memdesc:a817801e8c9488f712804d2d0b821acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run arithmetic simplifications on the statements and expressions.  <a href="namespacetvm_1_1tir_1_1transform.html#a817801e8c9488f712804d2d0b821acf0">More...</a><br /></td></tr>
<tr class="separator:a817801e8c9488f712804d2d0b821acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c4595056a7a397a88cce0d06975409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a78c4595056a7a397a88cce0d06975409">ConvertSSA</a> ()</td></tr>
<tr class="memdesc:a78c4595056a7a397a88cce0d06975409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to be SSA form.  <a href="namespacetvm_1_1tir_1_1transform.html#a78c4595056a7a397a88cce0d06975409">More...</a><br /></td></tr>
<tr class="separator:a78c4595056a7a397a88cce0d06975409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c492c5e21f3cd636bc27493153dcbbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8c492c5e21f3cd636bc27493153dcbbe">InstrumentBoundCheckers</a> ()</td></tr>
<tr class="memdesc:a8c492c5e21f3cd636bc27493153dcbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruments bound checkers.  <a href="namespacetvm_1_1tir_1_1transform.html#a8c492c5e21f3cd636bc27493153dcbbe">More...</a><br /></td></tr>
<tr class="separator:a8c492c5e21f3cd636bc27493153dcbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be3df8947fea34192c61bfed1c6eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a38be3df8947fea34192c61bfed1c6eec">MakePackedAPI</a> ()</td></tr>
<tr class="memdesc:a38be3df8947fea34192c61bfed1c6eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to a low-level version that can be used as an API function.  <a href="namespacetvm_1_1tir_1_1transform.html#a38be3df8947fea34192c61bfed1c6eec">More...</a><br /></td></tr>
<tr class="separator:a38be3df8947fea34192c61bfed1c6eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903620176fa71b005fd7c58656d7139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1903620176fa71b005fd7c58656d7139">MakeUnpackedAPI</a> ()</td></tr>
<tr class="memdesc:a1903620176fa71b005fd7c58656d7139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to a C signature that can be used to call the operator directly.  <a href="namespacetvm_1_1tir_1_1transform.html#a1903620176fa71b005fd7c58656d7139">More...</a><br /></td></tr>
<tr class="separator:a1903620176fa71b005fd7c58656d7139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b5de58d543c6786325d87eaad83692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a25b5de58d543c6786325d87eaad83692">RemapThreadAxis</a> (Map&lt; String, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt; axis_map)</td></tr>
<tr class="memdesc:a25b5de58d543c6786325d87eaad83692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the thread axis.  <a href="namespacetvm_1_1tir_1_1transform.html#a25b5de58d543c6786325d87eaad83692">More...</a><br /></td></tr>
<tr class="separator:a25b5de58d543c6786325d87eaad83692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">LowerCustomDatatypes</a> ()</td></tr>
<tr class="memdesc:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower custom datatypes.  <a href="namespacetvm_1_1tir_1_1transform.html#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">More...</a><br /></td></tr>
<tr class="separator:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6648d0a1c613e7e0f5e231059c3c22c6">DecorateDeviceScope</a> ()</td></tr>
<tr class="memdesc:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate all the function's body as device function.  <a href="namespacetvm_1_1tir_1_1transform.html#a6648d0a1c613e7e0f5e231059c3c22c6">More...</a><br /></td></tr>
<tr class="separator:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad2c07d48e6f8e179adcbe4a171a817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8ad2c07d48e6f8e179adcbe4a171a817">AnnotateDeviceRegions</a> ()</td></tr>
<tr class="memdesc:a8ad2c07d48e6f8e179adcbe4a171a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate locations that should be run on the device.  <a href="namespacetvm_1_1tir_1_1transform.html#a8ad2c07d48e6f8e179adcbe4a171a817">More...</a><br /></td></tr>
<tr class="separator:a8ad2c07d48e6f8e179adcbe4a171a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5dffb2a177bfd7548be4d974cba71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4ec5dffb2a177bfd7548be4d974cba71">SplitHostDevice</a> ()</td></tr>
<tr class="memdesc:a4ec5dffb2a177bfd7548be4d974cba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the function into a host function and device functions.  <a href="namespacetvm_1_1tir_1_1transform.html#a4ec5dffb2a177bfd7548be4d974cba71">More...</a><br /></td></tr>
<tr class="separator:a4ec5dffb2a177bfd7548be4d974cba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a9e2aa46d96c38e34602ee64390516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aa8a9e2aa46d96c38e34602ee64390516">LowerDeviceKernelLaunch</a> ()</td></tr>
<tr class="memdesc:aa8a9e2aa46d96c38e34602ee64390516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross-device function calls.  <a href="namespacetvm_1_1tir_1_1transform.html#aa8a9e2aa46d96c38e34602ee64390516">More...</a><br /></td></tr>
<tr class="separator:aa8a9e2aa46d96c38e34602ee64390516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdd5910b00af823071dcdddd21cd2d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6fdd5910b00af823071dcdddd21cd2d3">SkipAssert</a> ()</td></tr>
<tr class="memdesc:a6fdd5910b00af823071dcdddd21cd2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip assert stmt.  <a href="namespacetvm_1_1tir_1_1transform.html#a6fdd5910b00af823071dcdddd21cd2d3">More...</a><br /></td></tr>
<tr class="separator:a6fdd5910b00af823071dcdddd21cd2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0010cbc20ee308819046d77ad58b62cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0010cbc20ee308819046d77ad58b62cf">ThreadSync</a> (String storage_scope)</td></tr>
<tr class="memdesc:a0010cbc20ee308819046d77ad58b62cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert sync between parallel read/write of shared buffers.  <a href="namespacetvm_1_1tir_1_1transform.html#a0010cbc20ee308819046d77ad58b62cf">More...</a><br /></td></tr>
<tr class="separator:a0010cbc20ee308819046d77ad58b62cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d42050efec51126d5b90eb2f60171f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a16d42050efec51126d5b90eb2f60171f">LowerThreadAllreduce</a> ()</td></tr>
<tr class="memdesc:a16d42050efec51126d5b90eb2f60171f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross thread alleduce.  <a href="namespacetvm_1_1tir_1_1transform.html#a16d42050efec51126d5b90eb2f60171f">More...</a><br /></td></tr>
<tr class="separator:a16d42050efec51126d5b90eb2f60171f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae10fc2ab38a0cdfe79cb7f718549f532">InferFragment</a> ()</td></tr>
<tr class="memdesc:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the TensorCore fragment infomation using tensor intrinsics.  <a href="namespacetvm_1_1tir_1_1transform.html#ae10fc2ab38a0cdfe79cb7f718549f532">More...</a><br /></td></tr>
<tr class="separator:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8b8e7806d1a6e21b66123b3a4e255caf">LowerTVMBuiltin</a> ()</td></tr>
<tr class="memdesc:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower builtin intrinsics.  <a href="namespacetvm_1_1tir_1_1transform.html#a8b8e7806d1a6e21b66123b3a4e255caf">More...</a><br /></td></tr>
<tr class="separator:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0979c9d3bf0e64205f16aa00d331c6b5">LowerIntrin</a> ()</td></tr>
<tr class="memdesc:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower the target specific function intrinsics in each of the function.  <a href="namespacetvm_1_1tir_1_1transform.html#a0979c9d3bf0e64205f16aa00d331c6b5">More...</a><br /></td></tr>
<tr class="separator:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a726d95328c4e85c0c717c52aff4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ad5a726d95328c4e85c0c717c52aff4f2">LowerWarpMemory</a> ()</td></tr>
<tr class="memdesc:ad5a726d95328c4e85c0c717c52aff4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower warp memory access to low-level device related function calls.  <a href="namespacetvm_1_1tir_1_1transform.html#ad5a726d95328c4e85c0c717c52aff4f2">More...</a><br /></td></tr>
<tr class="separator:ad5a726d95328c4e85c0c717c52aff4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a53b7a3b7552ad5fa7b49e90470aff02b">LowerDeviceStorageAccessInfo</a> ()</td></tr>
<tr class="memdesc:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower attached storage access information on device.  <a href="namespacetvm_1_1tir_1_1transform.html#a53b7a3b7552ad5fa7b49e90470aff02b">More...</a><br /></td></tr>
<tr class="separator:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a9c2f441a8056f9abe65e72b41b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af00a9c2f441a8056f9abe65e72b41b36">CombineContextCall</a> ()</td></tr>
<tr class="memdesc:af00a9c2f441a8056f9abe65e72b41b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine context calls in the host function.  <a href="namespacetvm_1_1tir_1_1transform.html#af00a9c2f441a8056f9abe65e72b41b36">More...</a><br /></td></tr>
<tr class="separator:af00a9c2f441a8056f9abe65e72b41b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97b7253e13e662adc5f9ad3367746a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aa97b7253e13e662adc5f9ad3367746a8">NarrowDataType</a> (int target_bits)</td></tr>
<tr class="memdesc:aa97b7253e13e662adc5f9ad3367746a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow down <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> datatype in stmt to target_bits.  <a href="namespacetvm_1_1tir_1_1transform.html#aa97b7253e13e662adc5f9ad3367746a8">More...</a><br /></td></tr>
<tr class="separator:aa97b7253e13e662adc5f9ad3367746a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712a319ce047094a15aaf327d9be6ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a712a319ce047094a15aaf327d9be6ae3">ForceNarrowIndexToInt32</a> ()</td></tr>
<tr class="memdesc:a712a319ce047094a15aaf327d9be6ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force to narrow down indexing expressions and integer buffers to int32 dtype.  <a href="namespacetvm_1_1tir_1_1transform.html#a712a319ce047094a15aaf327d9be6ae3">More...</a><br /></td></tr>
<tr class="separator:a712a319ce047094a15aaf327d9be6ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1062396b86491bde128ecfdf92c2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1b1062396b86491bde128ecfdf92c2a6">BF16ComputeLegalize</a> ()</td></tr>
<tr class="memdesc:a1b1062396b86491bde128ecfdf92c2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize bf16 compute Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> a cast to fp32 before Ops, then add a cast back to bf16.  <a href="namespacetvm_1_1tir_1_1transform.html#a1b1062396b86491bde128ecfdf92c2a6">More...</a><br /></td></tr>
<tr class="separator:a1b1062396b86491bde128ecfdf92c2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993797f3733c2cf23729d50ab9c02ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4993797f3733c2cf23729d50ab9c02ee">FP8ComputeLegalize</a> (String promote_dtype_str=&quot;float16&quot;)</td></tr>
<tr class="memdesc:a4993797f3733c2cf23729d50ab9c02ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize fp8 compute Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> a cast to fp16/fp32 before Ops, then add a cast back to fp8.  <a href="namespacetvm_1_1tir_1_1transform.html#a4993797f3733c2cf23729d50ab9c02ee">More...</a><br /></td></tr>
<tr class="separator:a4993797f3733c2cf23729d50ab9c02ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b3ae44e21d755a8f01676f86b81930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae3b3ae44e21d755a8f01676f86b81930">BF16StorageLegalize</a> ()</td></tr>
<tr class="memdesc:ae3b3ae44e21d755a8f01676f86b81930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize bf16 storage types to u16.  <a href="namespacetvm_1_1tir_1_1transform.html#ae3b3ae44e21d755a8f01676f86b81930">More...</a><br /></td></tr>
<tr class="separator:ae3b3ae44e21d755a8f01676f86b81930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e5d2c86754e19989125064122da0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5c3e5d2c86754e19989125064122da0e">FP8StorageLegalize</a> ()</td></tr>
<tr class="memdesc:a5c3e5d2c86754e19989125064122da0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize fp8 storage types to u8.  <a href="namespacetvm_1_1tir_1_1transform.html#a5c3e5d2c86754e19989125064122da0e">More...</a><br /></td></tr>
<tr class="separator:a5c3e5d2c86754e19989125064122da0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e91b6027a8dd2cc8faeb0dff3cdd3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5e91b6027a8dd2cc8faeb0dff3cdd3b7">InlinePrivateFunctions</a> ()</td></tr>
<tr class="memdesc:a5e91b6027a8dd2cc8faeb0dff3cdd3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline calls to private functions.  <a href="namespacetvm_1_1tir_1_1transform.html#a5e91b6027a8dd2cc8faeb0dff3cdd3b7">More...</a><br /></td></tr>
<tr class="separator:a5e91b6027a8dd2cc8faeb0dff3cdd3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36268b8988766d94b09daaa433a2e1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a36268b8988766d94b09daaa433a2e1aa">PointerValueTypeRewrite</a> ()</td></tr>
<tr class="memdesc:a36268b8988766d94b09daaa433a2e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible.  <a href="namespacetvm_1_1tir_1_1transform.html#a36268b8988766d94b09daaa433a2e1aa">More...</a><br /></td></tr>
<tr class="separator:a36268b8988766d94b09daaa433a2e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2b8fdd84785388630e2d52a6e3cc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#acd2b8fdd84785388630e2d52a6e3cc54">HoistIfThenElse</a> ()</td></tr>
<tr class="memdesc:acd2b8fdd84785388630e2d52a6e3cc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariant <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> nodes to outside the elligible loops.  <a href="namespacetvm_1_1tir_1_1transform.html#acd2b8fdd84785388630e2d52a6e3cc54">More...</a><br /></td></tr>
<tr class="separator:acd2b8fdd84785388630e2d52a6e3cc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd207977177c1d1dc097445cc44339b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aabd207977177c1d1dc097445cc44339b">HoistExpression</a> ()</td></tr>
<tr class="memdesc:aabd207977177c1d1dc097445cc44339b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariant expressions nodes to outside the elligible loops.  <a href="namespacetvm_1_1tir_1_1transform.html#aabd207977177c1d1dc097445cc44339b">More...</a><br /></td></tr>
<tr class="separator:aabd207977177c1d1dc097445cc44339b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641a33aa6ac3ec146be1196a091af5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a641a33aa6ac3ec146be1196a091af5d5">LowerCrossThreadReduction</a> ()</td></tr>
<tr class="memdesc:a641a33aa6ac3ec146be1196a091af5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross-thread reduction from thread bindings to intrinsic function calls.  <a href="namespacetvm_1_1tir_1_1transform.html#a641a33aa6ac3ec146be1196a091af5d5">More...</a><br /></td></tr>
<tr class="separator:a641a33aa6ac3ec146be1196a091af5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aeaa9c663bdf10c5c596d81f8d5b6f1ed">LowerInitBlock</a> ()</td></tr>
<tr class="memdesc:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower block init stmt into <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> stmts.  <a href="namespacetvm_1_1tir_1_1transform.html#aeaa9c663bdf10c5c596d81f8d5b6f1ed">More...</a><br /></td></tr>
<tr class="separator:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5ffa51908f8a4c9f7eb4321d8b92c234">PlanAndUpdateBufferAllocationLocation</a> ()</td></tr>
<tr class="memdesc:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the buffer allocation to the exact position (usually is the lca of buffer access). This pass will inject opaque block with alloc_buffers at the allocation site.  <a href="namespacetvm_1_1tir_1_1transform.html#a5ffa51908f8a4c9f7eb4321d8b92c234">More...</a><br /></td></tr>
<tr class="separator:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f476f006bd24ef62f7c170aded18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae14f476f006bd24ef62f7c170aded18d">ConvertBlocksToOpaque</a> ()</td></tr>
<tr class="memdesc:ae14f476f006bd24ef62f7c170aded18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all the block vars with the PrimExprs they are bound to, indicated by the corresponding iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode.">BlockRealize</a>, for opaque blocks by removing all . the iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode.">BlockRealize</a> and iter_vars in <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode.">Block</a>.  <a href="namespacetvm_1_1tir_1_1transform.html#ae14f476f006bd24ef62f7c170aded18d">More...</a><br /></td></tr>
<tr class="separator:ae14f476f006bd24ef62f7c170aded18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7d03731a2d7b7dbe05e0a0c9f6c11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aec7d03731a2d7b7dbe05e0a0c9f6c11a">LiftThreadBinding</a> ()</td></tr>
<tr class="memdesc:aec7d03731a2d7b7dbe05e0a0c9f6c11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift the same thread bindings to their LCA loops.  <a href="namespacetvm_1_1tir_1_1transform.html#aec7d03731a2d7b7dbe05e0a0c9f6c11a">More...</a><br /></td></tr>
<tr class="separator:aec7d03731a2d7b7dbe05e0a0c9f6c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2ad780d6302432ead7f8b5fbffc275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1e2ad780d6302432ead7f8b5fbffc275">CompactBufferAllocation</a> (bool is_strict=true)</td></tr>
<tr class="memdesc:a1e2ad780d6302432ead7f8b5fbffc275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the buffer access region by removing the buffer regions that are not accessed, i.e. narrowing the buffer shape and adjust the access region if necessary.  <a href="namespacetvm_1_1tir_1_1transform.html#a1e2ad780d6302432ead7f8b5fbffc275">More...</a><br /></td></tr>
<tr class="separator:a1e2ad780d6302432ead7f8b5fbffc275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7277fb8101861053cc697a9d3aba1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aaf7277fb8101861053cc697a9d3aba1e">LowerMatchBuffer</a> ()</td></tr>
<tr class="memdesc:aaf7277fb8101861053cc697a9d3aba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove match buffers inside the block. Also, it will validate the binding.  <a href="namespacetvm_1_1tir_1_1transform.html#aaf7277fb8101861053cc697a9d3aba1e">More...</a><br /></td></tr>
<tr class="separator:aaf7277fb8101861053cc697a9d3aba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec81cfa53b10279a2e0ea388fadf0aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#afec81cfa53b10279a2e0ea388fadf0aa">InjectPermutedLayout</a> ()</td></tr>
<tr class="memdesc:afec81cfa53b10279a2e0ea388fadf0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject permuted layout for shared memory.  <a href="namespacetvm_1_1tir_1_1transform.html#afec81cfa53b10279a2e0ea388fadf0aa">More...</a><br /></td></tr>
<tr class="separator:afec81cfa53b10279a2e0ea388fadf0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1956116a1d54ea3f33c68b35792f720e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1956116a1d54ea3f33c68b35792f720e">TransformMmaBufferLayout</a> ()</td></tr>
<tr class="memdesc:a1956116a1d54ea3f33c68b35792f720e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform Mma scope (m16n8k8.matrixA/B/C) to local scope with layout transformation.  <a href="namespacetvm_1_1tir_1_1transform.html#a1956116a1d54ea3f33c68b35792f720e">More...</a><br /></td></tr>
<tr class="separator:a1956116a1d54ea3f33c68b35792f720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c80e759e67633f417edf99e2cc9f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5a0c80e759e67633f417edf99e2cc9f4">LowerOpaqueBlock</a> ()</td></tr>
<tr class="memdesc:a5a0c80e759e67633f417edf99e2cc9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the block to ensure that the TIR can not be scheduled again.  <a href="namespacetvm_1_1tir_1_1transform.html#a5a0c80e759e67633f417edf99e2cc9f4">More...</a><br /></td></tr>
<tr class="separator:a5a0c80e759e67633f417edf99e2cc9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf607d0e759472ac47845b7206f276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a3acf607d0e759472ac47845b7206f276">FlattenBuffer</a> ()</td></tr>
<tr class="memdesc:a3acf607d0e759472ac47845b7206f276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the multi-dimensional <a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode.">BufferLoad</a> and <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode.">BufferStore</a> to single dimensional BufferLoad/BufferStore for the TIR not contains opaque block.  <a href="namespacetvm_1_1tir_1_1transform.html#a3acf607d0e759472ac47845b7206f276">More...</a><br /></td></tr>
<tr class="separator:a3acf607d0e759472ac47845b7206f276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ede8aa0409b3812b88c83a6e55e32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a12ede8aa0409b3812b88c83a6e55e32c">LowerVtcmAlloc</a> ()</td></tr>
<tr class="separator:a12ede8aa0409b3812b88c83a6e55e32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f0ca4f873cb6220bba4504e347705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af77f0ca4f873cb6220bba4504e347705">LowerAsyncDMA</a> ()</td></tr>
<tr class="memdesc:af77f0ca4f873cb6220bba4504e347705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower Async TIR primitives to DMA copy and wait builtins.  <a href="namespacetvm_1_1tir_1_1transform.html#af77f0ca4f873cb6220bba4504e347705">More...</a><br /></td></tr>
<tr class="separator:af77f0ca4f873cb6220bba4504e347705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c5b1caff09436701fb9b9e7f672571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a82c5b1caff09436701fb9b9e7f672571">CommonSubexprElimTIR</a> (bool enable_cse_tir=true, bool identify_equiv_terms=false)</td></tr>
<tr class="memdesc:a82c5b1caff09436701fb9b9e7f672571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a Common Subexpression Elimination (CSE) for TIR which introduces let-in bindings for duplicated sub-expressions.  <a href="namespacetvm_1_1tir_1_1transform.html#a82c5b1caff09436701fb9b9e7f672571">More...</a><br /></td></tr>
<tr class="separator:a82c5b1caff09436701fb9b9e7f672571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b45a049536f7786b7821a5c1c32f0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8b45a049536f7786b7821a5c1c32f0b3">UnifyThreadBinding</a> ()</td></tr>
<tr class="memdesc:a8b45a049536f7786b7821a5c1c32f0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify all the thread bindings for "blockIdx.x/y/z", "threadIdx.x/y/z", and "vthread.x/y/z". Before the unification, two vars that are bound to a thread axis (e.g., "threadIdx.x") use different IterVars and variables in their AttrStmts. After the unification, we use a consolidated <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> and a variable for them.  <a href="namespacetvm_1_1tir_1_1transform.html#a8b45a049536f7786b7821a5c1c32f0b3">More...</a><br /></td></tr>
<tr class="separator:a8b45a049536f7786b7821a5c1c32f0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d85d35f717a306c4e602eee7ed9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4b0d85d35f717a306c4e602eee7ed9aa">MergeSharedMemoryAllocations</a> ()</td></tr>
<tr class="separator:a4b0d85d35f717a306c4e602eee7ed9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106e04ba8c560e24a4b6c8c414184ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a106e04ba8c560e24a4b6c8c414184ec4">ConvertForLoopsToSerial</a> ()</td></tr>
<tr class="memdesc:a106e04ba8c560e24a4b6c8c414184ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass is post-scheduling pass to convert all Parallel <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loops to Serial ones. This is run to attain lesser memory and/or executor/backend does not support parallel launch of <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loops.  <a href="namespacetvm_1_1tir_1_1transform.html#a106e04ba8c560e24a4b6c8c414184ec4">More...</a><br /></td></tr>
<tr class="separator:a106e04ba8c560e24a4b6c8c414184ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44076eb1085d664877596a8b8587d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aca44076eb1085d664877596a8b8587d4">UnifiedStaticMemoryPlanner</a> ()</td></tr>
<tr class="memdesc:aca44076eb1085d664877596a8b8587d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the unified static memory planner pass that will plan for memory intra- and inter- PrimFuncs together. The pass requires all the function to be PrimFuncs including the main.  <a href="namespacetvm_1_1tir_1_1transform.html#aca44076eb1085d664877596a8b8587d4">More...</a><br /></td></tr>
<tr class="separator:aca44076eb1085d664877596a8b8587d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1b90f3ff7f983452fb3a4f7181043ae8">InjectSoftwarePipeline</a> ()</td></tr>
<tr class="memdesc:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass transforms annotated loops into pipelined ones where producers and consumers are overlapped with the information provided in loop annotations, which enables optimization techniques like prefetching and pipeline parallelism.  <a href="namespacetvm_1_1tir_1_1transform.html#a1b90f3ff7f983452fb3a4f7181043ae8">More...</a><br /></td></tr>
<tr class="separator:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d8ff162a7043149cfc55f5ea8ba7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#abf2d8ff162a7043149cfc55f5ea8ba7f">BindParams</a> (const Array&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">runtime::NDArray</a> &gt; &amp;constants)</td></tr>
<tr class="separator:abf2d8ff162a7043149cfc55f5ea8ba7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148d43765be86c3778bd32a112698fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac148d43765be86c3778bd32a112698fd">ExtractPrimFuncConstants</a> ()</td></tr>
<tr class="memdesc:ac148d43765be86c3778bd32a112698fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to collect tir non-scalar constants into module's 'Constants' attribute.  <a href="namespacetvm_1_1tir_1_1transform.html#ac148d43765be86c3778bd32a112698fd">More...</a><br /></td></tr>
<tr class="separator:ac148d43765be86c3778bd32a112698fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47710621db083ca74f38702fdd66a316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a47710621db083ca74f38702fdd66a316">LowerAutoCopy</a> ()</td></tr>
<tr class="memdesc:a47710621db083ca74f38702fdd66a316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically do memory optimizations for auto copy blocks.  <a href="namespacetvm_1_1tir_1_1transform.html#a47710621db083ca74f38702fdd66a316">More...</a><br /></td></tr>
<tr class="separator:a47710621db083ca74f38702fdd66a316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c670c9efcd740f2f168b62e624c8c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5c670c9efcd740f2f168b62e624c8c57">RenormalizeSplitPattern</a> ()</td></tr>
<tr class="memdesc:a5c670c9efcd740f2f168b62e624c8c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize the split pattern from floordiv(floormod()) to floormod(floordiv())  <a href="namespacetvm_1_1tir_1_1transform.html#a5c670c9efcd740f2f168b62e624c8c57">More...</a><br /></td></tr>
<tr class="separator:a5c670c9efcd740f2f168b62e624c8c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae976049e464f05cbd3ddfdbfcf8cd1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae976049e464f05cbd3ddfdbfcf8cd1d6">BindTarget</a> (<a class="el" href="classtvm_1_1Target.html">Target</a> target)</td></tr>
<tr class="memdesc:ae976049e464f05cbd3ddfdbfcf8cd1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> with a given target.  <a href="namespacetvm_1_1tir_1_1transform.html#ae976049e464f05cbd3ddfdbfcf8cd1d6">More...</a><br /></td></tr>
<tr class="separator:ae976049e464f05cbd3ddfdbfcf8cd1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776c657ccb30ff327c5dd0d6940a836a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a776c657ccb30ff327c5dd0d6940a836a">AnnotateEntryFunc</a> ()</td></tr>
<tr class="memdesc:a776c657ccb30ff327c5dd0d6940a836a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> as the entry point if it is only function in <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>.  <a href="namespacetvm_1_1tir_1_1transform.html#a776c657ccb30ff327c5dd0d6940a836a">More...</a><br /></td></tr>
<tr class="separator:a776c657ccb30ff327c5dd0d6940a836a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb48ea18790d4bf27e6809780ca275f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aeeb48ea18790d4bf27e6809780ca275f">Filter</a> (ffi::TypedFunction&lt; bool(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>)&gt; fcond)</td></tr>
<tr class="memdesc:aeeb48ea18790d4bf27e6809780ca275f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter PrimFuncs with a given condition.  <a href="namespacetvm_1_1tir_1_1transform.html#aeeb48ea18790d4bf27e6809780ca275f">More...</a><br /></td></tr>
<tr class="separator:aeeb48ea18790d4bf27e6809780ca275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac804d5f6bd95449af8d09f26b804db4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac804d5f6bd95449af8d09f26b804db4a">InjectPTXAsyncCopy</a> ()</td></tr>
<tr class="memdesc:ac804d5f6bd95449af8d09f26b804db4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to rewrite global to shared memory copy on CUDA with asyncronous copy.  <a href="namespacetvm_1_1tir_1_1transform.html#ac804d5f6bd95449af8d09f26b804db4a">More...</a><br /></td></tr>
<tr class="separator:ac804d5f6bd95449af8d09f26b804db4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28008376f9c4ba325c3c7e1a3b0d0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac28008376f9c4ba325c3c7e1a3b0d0bf">InjectPTXLDG32</a> (bool enable_ptx_ldg32=true)</td></tr>
<tr class="memdesc:ac28008376f9c4ba325c3c7e1a3b0d0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to rewrite global to local memory copy on CUDA with ldg32 instruction.  <a href="namespacetvm_1_1tir_1_1transform.html#ac28008376f9c4ba325c3c7e1a3b0d0bf">More...</a><br /></td></tr>
<tr class="separator:ac28008376f9c4ba325c3c7e1a3b0d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889dbda25befe68a8e8999f3e8ea8dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a889dbda25befe68a8e8999f3e8ea8dc4">RemoveWeightLayoutRewriteBlock</a> (bool skip_ndarray_rewrite=false)</td></tr>
<tr class="memdesc:a889dbda25befe68a8e8999f3e8ea8dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the weight layout rewrite block.  <a href="namespacetvm_1_1tir_1_1transform.html#a889dbda25befe68a8e8999f3e8ea8dc4">More...</a><br /></td></tr>
<tr class="separator:a889dbda25befe68a8e8999f3e8ea8dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cdafede0174363f10db49d9a61fbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af2cdafede0174363f10db49d9a61fbe3">ManifestSharedMemoryLocalStage</a> ()</td></tr>
<tr class="memdesc:af2cdafede0174363f10db49d9a61fbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> the explicit local stage for the shared memory access on GPU.  <a href="namespacetvm_1_1tir_1_1transform.html#af2cdafede0174363f10db49d9a61fbe3">More...</a><br /></td></tr>
<tr class="separator:af2cdafede0174363f10db49d9a61fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac039d4db9a6821d8a3e0b0191e7e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a2ac039d4db9a6821d8a3e0b0191e7e20">InstrumentProfileIntrinsics</a> ()</td></tr>
<tr class="memdesc:a2ac039d4db9a6821d8a3e0b0191e7e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert intrinsic calls to instrument function and loop level profiling.  <a href="namespacetvm_1_1tir_1_1transform.html#a2ac039d4db9a6821d8a3e0b0191e7e20">More...</a><br /></td></tr>
<tr class="separator:a2ac039d4db9a6821d8a3e0b0191e7e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cf9500914b9a0782156d039a606b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aac1cf9500914b9a0782156d039a606b6">DefaultGPUSchedule</a> ()</td></tr>
<tr class="memdesc:aac1cf9500914b9a0782156d039a606b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pass sets default thread bindings for PrimFuncs, including symbolic shape functions, allowing their build and execution on GPU devices. It examines all the blocks within the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> and conducts loop fusion, splitting, and reordering operations based on the loop extent and target information, such as the maximum thread block number and maximum thread per block.  <a href="namespacetvm_1_1tir_1_1transform.html#aac1cf9500914b9a0782156d039a606b6">More...</a><br /></td></tr>
<tr class="separator:aac1cf9500914b9a0782156d039a606b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910f290dff4206785d60732ff5021ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a910f290dff4206785d60732ff5021ac0">UseAssumeToReduceBranches</a> ()</td></tr>
<tr class="memdesc:a910f290dff4206785d60732ff5021ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass analyzes primfunc &amp; eliminates branch introdued due to layout specific padding. It leverages from the buffer assumptions and use the information to eliminate the branch.  <a href="namespacetvm_1_1tir_1_1transform.html#a910f290dff4206785d60732ff5021ac0">More...</a><br /></td></tr>
<tr class="separator:a910f290dff4206785d60732ff5021ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8ad2c07d48e6f8e179adcbe4a171a817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad2c07d48e6f8e179adcbe4a171a817">&#9670;&nbsp;</a></span>AnnotateDeviceRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::AnnotateDeviceRegions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate locations that should be run on the device. </p>
<p>Insert <code><a class="el" href="classtvm_1_1tir_1_1AttrStmt.html" title="Managed reference to AttrStmtNode.">AttrStmt</a></code> nodes specifying a target on which regions within the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> should be executed. Only modifies functions that have a <code><a class="el" href="namespacetvm_1_1attr.html#a580ae92d00e34f0a8f0d40395b8d972c" title="Compilation target of the function.">tvm::attr::kTarget</a></code> attribute, and where that target defines a host.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a776c657ccb30ff327c5dd0d6940a836a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776c657ccb30ff327c5dd0d6940a836a">&#9670;&nbsp;</a></span>AnnotateEntryFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::AnnotateEntryFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> as the entry point if it is only function in <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1b1062396b86491bde128ecfdf92c2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1062396b86491bde128ecfdf92c2a6">&#9670;&nbsp;</a></span>BF16ComputeLegalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BF16ComputeLegalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize bf16 compute Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> a cast to fp32 before Ops, then add a cast back to bf16. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae3b3ae44e21d755a8f01676f86b81930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b3ae44e21d755a8f01676f86b81930">&#9670;&nbsp;</a></span>BF16StorageLegalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BF16StorageLegalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize bf16 storage types to u16. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="abf2d8ff162a7043149cfc55f5ea8ba7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d8ff162a7043149cfc55f5ea8ba7f">&#9670;&nbsp;</a></span>BindParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BindParams </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">runtime::NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae976049e464f05cbd3ddfdbfcf8cd1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae976049e464f05cbd3ddfdbfcf8cd1d6">&#9670;&nbsp;</a></span>BindTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BindTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Target.html">Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> with a given target. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="af00a9c2f441a8056f9abe65e72b41b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a9c2f441a8056f9abe65e72b41b36">&#9670;&nbsp;</a></span>CombineContextCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CombineContextCall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine context calls in the host function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a82c5b1caff09436701fb9b9e7f672571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c5b1caff09436701fb9b9e7f672571">&#9670;&nbsp;</a></span>CommonSubexprElimTIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CommonSubexprElimTIR </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_cse_tir</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>identify_equiv_terms</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a Common Subexpression Elimination (CSE) for TIR which introduces let-in bindings for duplicated sub-expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_cse_tir</td><td>Whether common subexpression elimination is enabled. </td></tr>
    <tr><td class="paramname">identify_equiv_terms</td><td>Whether equivalent terms should be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1e2ad780d6302432ead7f8b5fbffc275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2ad780d6302432ead7f8b5fbffc275">&#9670;&nbsp;</a></span>CompactBufferAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CompactBufferAllocation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_strict</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compact the buffer access region by removing the buffer regions that are not accessed, i.e. narrowing the buffer shape and adjust the access region if necessary. </p>
<p>Before narrowing, <code>B</code> is a <code>[16, 16]</code> buffer, but only a skinny vector <code>B[i, 0:16]</code> is accessed.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i in range(0, 16):</div>
<div class="line">    with T.block():</div>
<div class="line">        B = T.alloc_buffer(16, 16)</div>
<div class="line">        for j in range(0, 16):</div>
<div class="line">            B[i, j] = A[i, j] + 1</div>
<div class="line">        for j in range(0, 16):</div>
<div class="line">            C[i, j] = B[i, j] + 1</div>
</div><!-- fragment --><p>This pass narrows the buffer shape and adjust its accessed region accordingly. In this particular case, because only a <code>1 * 16</code> vector of <code>B</code> is accessed, the pass narrows <code>B</code> to shape <code>[1, 16]</code>, and changes the access to <code>B[i, j]</code> to <code>B[0, j]</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i in range(0, 16):</div>
<div class="line">    with T.block():</div>
<div class="line">        B = T.alloc_buffer(1, 16)</div>
<div class="line">        for j in range(0, 16):</div>
<div class="line">            B[0, j] = A[i, j] + 1</div>
<div class="line">        for j in range(0, 16):</div>
<div class="line">            C[i, j] = B[0, j] + 1</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_strict</td><td>ensure the compacted shape always smaller than the original shape. otherwise it allows to grow the shape to match actual accessed buffer regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae14f476f006bd24ef62f7c170aded18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14f476f006bd24ef62f7c170aded18d">&#9670;&nbsp;</a></span>ConvertBlocksToOpaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ConvertBlocksToOpaque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all the block vars with the PrimExprs they are bound to, indicated by the corresponding iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode.">BlockRealize</a>, for opaque blocks by removing all . the iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode.">BlockRealize</a> and iter_vars in <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode.">Block</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a106e04ba8c560e24a4b6c8c414184ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106e04ba8c560e24a4b6c8c414184ec4">&#9670;&nbsp;</a></span>ConvertForLoopsToSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ConvertForLoopsToSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass is post-scheduling pass to convert all Parallel <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loops to Serial ones. This is run to attain lesser memory and/or executor/backend does not support parallel launch of <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a78c4595056a7a397a88cce0d06975409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c4595056a7a397a88cce0d06975409">&#9670;&nbsp;</a></span>ConvertSSA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ConvertSSA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to be SSA form. </p>
<p>This pass handles cases where the same <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">tir::Var</a> appears in multiple functions within the same module. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, after extracting a fragment from one function into another, where the same <code><a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">tir::Var</a></code> may be defined both as within the body of the original function, and as a parameter within the hoisted function.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a51c6d6301148b32e20b9926b383855ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6d6301148b32e20b9926b383855ce">&#9670;&nbsp;</a></span>CreatePrimFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CreatePrimFuncPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1transform_1_1PassContext.html">PassContext</a>)&gt;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tvm::Array&lt; String &gt;&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6648d0a1c613e7e0f5e231059c3c22c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6648d0a1c613e7e0f5e231059c3c22c6">&#9670;&nbsp;</a></span>DecorateDeviceScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::DecorateDeviceScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate all the function's body as device function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aac1cf9500914b9a0782156d039a606b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1cf9500914b9a0782156d039a606b6">&#9670;&nbsp;</a></span>DefaultGPUSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::DefaultGPUSchedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pass sets default thread bindings for PrimFuncs, including symbolic shape functions, allowing their build and execution on GPU devices. It examines all the blocks within the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> and conducts loop fusion, splitting, and reordering operations based on the loop extent and target information, such as the maximum thread block number and maximum thread per block. </p>
<dl class="section note"><dt>Note</dt><dd>The primary objective of this pass is not to optimize performance, but rather to generate a valid GPU kernel for unscheduled or symbolic shape PrimFuncs. The pass is currently only working for CUDA targets. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="ac148d43765be86c3778bd32a112698fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148d43765be86c3778bd32a112698fd">&#9670;&nbsp;</a></span>ExtractPrimFuncConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ExtractPrimFuncConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass to collect tir non-scalar constants into module's 'Constants' attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aeeb48ea18790d4bf27e6809780ca275f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb48ea18790d4bf27e6809780ca275f">&#9670;&nbsp;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::Filter </td>
          <td>(</td>
          <td class="paramtype">ffi::TypedFunction&lt; bool(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>)&gt;&#160;</td>
          <td class="paramname"><em>fcond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter PrimFuncs with a given condition. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a3acf607d0e759472ac47845b7206f276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acf607d0e759472ac47845b7206f276">&#9670;&nbsp;</a></span>FlattenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::FlattenBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the multi-dimensional <a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode.">BufferLoad</a> and <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode.">BufferStore</a> to single dimensional BufferLoad/BufferStore for the TIR not contains opaque block. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a712a319ce047094a15aaf327d9be6ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712a319ce047094a15aaf327d9be6ae3">&#9670;&nbsp;</a></span>ForceNarrowIndexToInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ForceNarrowIndexToInt32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force to narrow down indexing expressions and integer buffers to int32 dtype. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This pass should not be used in default cases. </dd></dl>

</div>
</div>
<a id="a4993797f3733c2cf23729d50ab9c02ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993797f3733c2cf23729d50ab9c02ee">&#9670;&nbsp;</a></span>FP8ComputeLegalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::FP8ComputeLegalize </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>promote_dtype_str</em> = <code>&quot;float16&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize fp8 compute Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> a cast to fp16/fp32 before Ops, then add a cast back to fp8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">promote_dtype_str</td><td>The data type used for type promotion, defaults to float16 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be run after BindTarget, as it relies on target attributes for PrimFuncs </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5c3e5d2c86754e19989125064122da0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3e5d2c86754e19989125064122da0e">&#9670;&nbsp;</a></span>FP8StorageLegalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::FP8StorageLegalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize fp8 storage types to u8. </p>
<dl class="section note"><dt>Note</dt><dd>Must be run after BindTarget, as it relies on target attributes for PrimFuncs </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aabd207977177c1d1dc097445cc44339b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd207977177c1d1dc097445cc44339b">&#9670;&nbsp;</a></span>HoistExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::HoistExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariant expressions nodes to outside the elligible loops. </p>
<p>Can hoist conditionals used in <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> statements and expressions, bindings of variables in <a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode.">Let</a> statements and expressions, or boolean expressions, configurable to enable/disable each hoistable type.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="acd2b8fdd84785388630e2d52a6e3cc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2b8fdd84785388630e2d52a6e3cc54">&#9670;&nbsp;</a></span>HoistIfThenElse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::HoistIfThenElse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariant <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> nodes to outside the elligible loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae10fc2ab38a0cdfe79cb7f718549f532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10fc2ab38a0cdfe79cb7f718549f532">&#9670;&nbsp;</a></span>InferFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InferFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the TensorCore fragment infomation using tensor intrinsics. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a55f70a1b3cfc63c52b462fba772b8370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f70a1b3cfc63c52b462fba772b8370">&#9670;&nbsp;</a></span>InjectDoubleBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectDoubleBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject double buffer statements. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="afec81cfa53b10279a2e0ea388fadf0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec81cfa53b10279a2e0ea388fadf0aa">&#9670;&nbsp;</a></span>InjectPermutedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectPermutedLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject permuted layout for shared memory. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ac804d5f6bd95449af8d09f26b804db4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac804d5f6bd95449af8d09f26b804db4a">&#9670;&nbsp;</a></span>InjectPTXAsyncCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectPTXAsyncCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass to rewrite global to shared memory copy on CUDA with asyncronous copy. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ac28008376f9c4ba325c3c7e1a3b0d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28008376f9c4ba325c3c7e1a3b0d0bf">&#9670;&nbsp;</a></span>InjectPTXLDG32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectPTXLDG32 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_ptx_ldg32</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass to rewrite global to local memory copy on CUDA with ldg32 instruction. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1b90f3ff7f983452fb3a4f7181043ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b90f3ff7f983452fb3a4f7181043ae8">&#9670;&nbsp;</a></span>InjectSoftwarePipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectSoftwarePipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass transforms annotated loops into pipelined ones where producers and consumers are overlapped with the information provided in loop annotations, which enables optimization techniques like prefetching and pipeline parallelism. </p>
<p>The pipeline scope consists of the direct children of the annotated loop (ignoring <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode.">BlockRealize</a>, <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode.">Block</a>, <a class="el" href="classtvm_1_1tir_1_1SeqStmt.html" title="Sequence statement.">SeqStmt</a>), and the number of children is denoted by <code>n</code> in the documentation.</p>
<p>The following annotations are used to guide the loop transformation:</p>
<p>1) Loop annotation <code>software_pipeline_stage</code> defines the pipeline stage. An array of <code>n</code> integers, and each element should be in range [0, max_stage], where max_stage is the maximum (inclusive) stage. 2) Loop annotation <code>software_pipeline_order</code> defines the pipeline order. An array of <code>n</code> integers, a permutation of [0, 1, ..., num_components - 1]; 3) <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode.">Block</a> annotation <code>double_buffer_scope</code> controls certain buffer sizes to allow decoupling of read/write dependency. It's an integer index of the write regions of the block.</p>
<p>Every annotated loop is transformed into a loop with three blocks as its direct children:</p>
<p>1) Prologue block, where components whose stage is less than <code>max_stage</code> is executed;</p>
<p>2) Body block, where all the components are executed;</p>
<p>3) Epilogue block, where only components whose stage is greater than 0 will be executed. The execution order is controlled by the annotation <code>software_pipeline_order</code>, and thus could be different than the original order.</p>
<p>Note: <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> nested software pipelines, the inner software pipeline will be generated first, which may affect the number of the direct children of the outer loop. In this case, the annotations for the outer software pipeline should include the result of the inner software pipeline, which is the three blocks as discussed above. Example:</p>
<p>Before this pass, the TIR is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@T.prim_func</span></div>
<div class="line"><span class="keyword">def </span>before_transform(A: T.Buffer((16, 16), <span class="stringliteral">&quot;float32&quot;</span>), C: T.Buffer((16, 16), <span class="stringliteral">&quot;float32&quot;</span>)) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    <span class="keywordflow">for</span> tx <span class="keywordflow">in</span> T.thread_binding(0, 16, thread=<span class="stringliteral">&quot;threadIdx.x&quot;</span>):</div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> T.serial(0, 16,</div>
<div class="line">                          annotations={<span class="stringliteral">&quot;software_pipeline_stage&quot;</span>: [0, 1],</div>
<div class="line">                                       <span class="stringliteral">&quot;software_pipeline_order&quot;</span>: [0, 1]}</div>
<div class="line">                         ):</div>
<div class="line">            <span class="keyword">with</span> T.block():</div>
<div class="line">                T.reads(A[tx, i])</div>
<div class="line">                T.writes(C[tx, i])</div>
<div class="line">                B = T.alloc_buffer((16, 1), dtype=<span class="stringliteral">&quot;float32&quot;</span>, scope=<span class="stringliteral">&quot;shared&quot;</span>)</div>
<div class="line">                <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;B&quot;</span>):</div>
<div class="line">                    T.reads(A[tx, i])</div>
<div class="line">                    T.writes(B[tx, 0])</div>
<div class="line">                    B[tx, 0] = A[tx, i] * T.float32(2)</div>
<div class="line">                <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;C&quot;</span>):</div>
<div class="line">                    T.reads(B[tx, 0])</div>
<div class="line">                    T.writes(C[tx, i])</div>
<div class="line">                    C[tx, i] = B[tx, 0] + T.float32(1)</div>
</div><!-- fragment --><p>The TIR above annotates the loop as a two-stage pipeline with no reordering. After applying this pass, the TIR is transformed into:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@T.prim_func</span></div>
<div class="line"><span class="keyword">def </span>after_transform(A: T.Buffer((16, 16), <span class="stringliteral">&quot;float32&quot;</span>), C: T.Buffer((16, 16), <span class="stringliteral">&quot;float32&quot;</span>)) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    <span class="keywordflow">for</span> tx <span class="keywordflow">in</span> T.thread_binding(0, 16, thread=<span class="stringliteral">&quot;threadIdx.x&quot;</span>):</div>
<div class="line">        <span class="keyword">with</span> T.block():</div>
<div class="line">            T.reads([A[tx, 0:16]])</div>
<div class="line">            T.writes([C[tx, 0:16]])</div>
<div class="line">            B = T.alloc_buffer([2, 16, 1], dtype=<span class="stringliteral">&quot;float32&quot;</span>, scope=<span class="stringliteral">&quot;shared&quot;</span>)</div>
<div class="line">            <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;prologue&quot;</span>):</div>
<div class="line">                T.reads([A[tx, 0]])</div>
<div class="line">                T.writes([B[0, tx, 0]])</div>
<div class="line">                B[0, tx, 0] = A[tx, 0] * T.float32(2)</div>
<div class="line">            <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;body&quot;</span>):</div>
<div class="line">                T.reads([A[tx, 1:16], B[0:2, tx, 0]])</div>
<div class="line">                T.writes([B[0:2, tx, 0], C[tx, 0:15]])</div>
<div class="line">                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> T.serial(0, 15):</div>
<div class="line">                    <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;B&quot;</span>):</div>
<div class="line">                        T.reads([A[tx, i + 1]])</div>
<div class="line">                        T.writes([B[(i + 1) % 2, tx, 0]])</div>
<div class="line">                        B[(i + 1) % 2, tx, 0] = A[tx, i + 1] * T.float32(2)</div>
<div class="line">                    <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;C&quot;</span>):</div>
<div class="line">                        T.reads([B[i % 2, tx, 0]])</div>
<div class="line">                        T.writes([C[tx, i]])</div>
<div class="line">                        C[tx, i] = B[i % 2, tx, 0] + T.float32(1)</div>
<div class="line">            <span class="keyword">with</span> T.block(<span class="stringliteral">&quot;epilogue&quot;</span>):</div>
<div class="line">                T.reads([B[1, tx, 0]])</div>
<div class="line">                T.writes([C[tx, 15]])</div>
<div class="line">                C[tx, 15] = B[1, tx, 0] + T.float32(1)</div>
</div><!-- fragment --><p>The original loop has two blocks, B and C, as its direct children. The loop annotations indicate that block B has stage == 0, order == 0, block C has stage == 1, order == 1. Therefore, block B should be executed in advance of block C by one iteration. The order 0 and 1 specifies the order of block B and C inside the body block inside the result TIR.</p>
<dl class="section return"><dt>Returns</dt><dd>The IR transform pass. </dd></dl>

</div>
</div>
<a id="a37ade618ab7572f92bd37f69049966c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ade618ab7572f92bd37f69049966c7">&#9670;&nbsp;</a></span>InjectVirtualThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectVirtualThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject virtual thread loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5e91b6027a8dd2cc8faeb0dff3cdd3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e91b6027a8dd2cc8faeb0dff3cdd3b7">&#9670;&nbsp;</a></span>InlinePrivateFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InlinePrivateFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline calls to private functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8c492c5e21f3cd636bc27493153dcbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c492c5e21f3cd636bc27493153dcbbe">&#9670;&nbsp;</a></span>InstrumentBoundCheckers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InstrumentBoundCheckers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruments bound checkers. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a2ac039d4db9a6821d8a3e0b0191e7e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac039d4db9a6821d8a3e0b0191e7e20">&#9670;&nbsp;</a></span>InstrumentProfileIntrinsics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InstrumentProfileIntrinsics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert intrinsic calls to instrument function and loop level profiling. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aec7d03731a2d7b7dbe05e0a0c9f6c11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7d03731a2d7b7dbe05e0a0c9f6c11a">&#9670;&nbsp;</a></span>LiftThreadBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LiftThreadBinding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift the same thread bindings to their LCA loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a17b0910c03b6f2d462448fa2725c1f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b0910c03b6f2d462448fa2725c1f5e">&#9670;&nbsp;</a></span>LoopPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LoopPartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partition loops in the stmt. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="af77f0ca4f873cb6220bba4504e347705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77f0ca4f873cb6220bba4504e347705">&#9670;&nbsp;</a></span>LowerAsyncDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerAsyncDMA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower Async TIR primitives to DMA copy and wait builtins. </p>

</div>
</div>
<a id="a47710621db083ca74f38702fdd66a316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47710621db083ca74f38702fdd66a316">&#9670;&nbsp;</a></span>LowerAutoCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerAutoCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically do memory optimizations for auto copy blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a641a33aa6ac3ec146be1196a091af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a33aa6ac3ec146be1196a091af5d5">&#9670;&nbsp;</a></span>LowerCrossThreadReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerCrossThreadReduction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross-thread reduction from thread bindings to intrinsic function calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0d6b2682a93ca4136ed4fa6d8fa7bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">&#9670;&nbsp;</a></span>LowerCustomDatatypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerCustomDatatypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower custom datatypes. </p>
<p>See tvm::datatypes::Registry for more information on adding custom datatypes.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aa8a9e2aa46d96c38e34602ee64390516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a9e2aa46d96c38e34602ee64390516">&#9670;&nbsp;</a></span>LowerDeviceKernelLaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerDeviceKernelLaunch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross-device function calls. </p>
<p>Prior to this pass, host to device calls are represented as subroutine calls, with environment parameters (e.g. env_thread) specified internally. The device function is an internal function, without a <code><a class="el" href="namespacetvm_1_1attr.html#a7737d03caeeaeac61531ace9a91f7d74" title="Global linker symbol of the function in generated code.">tvm::attr::kGlobalSymbol</a></code> attribute.</p>
<p>After this pass, host to device calls are represented as tvm_call_packed built-in. The device function is an externally-exposed function, with a non-empty <code><a class="el" href="namespacetvm_1_1attr.html#a7737d03caeeaeac61531ace9a91f7d74" title="Global linker symbol of the function in generated code.">tvm::attr::kGlobalSymbol</a></code> attribute.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a53b7a3b7552ad5fa7b49e90470aff02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b7a3b7552ad5fa7b49e90470aff02b">&#9670;&nbsp;</a></span>LowerDeviceStorageAccessInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerDeviceStorageAccessInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower attached storage access information on device. </p>
<dl class="section note"><dt>Note</dt><dd>Run this pass after all storage access analysis finish.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aeaa9c663bdf10c5c596d81f8d5b6f1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa9c663bdf10c5c596d81f8d5b6f1ed">&#9670;&nbsp;</a></span>LowerInitBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerInitBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower block init stmt into <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> stmts. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0979c9d3bf0e64205f16aa00d331c6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0979c9d3bf0e64205f16aa00d331c6b5">&#9670;&nbsp;</a></span>LowerIntrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerIntrin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower the target specific function intrinsics in each of the function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aaf7277fb8101861053cc697a9d3aba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7277fb8101861053cc697a9d3aba1e">&#9670;&nbsp;</a></span>LowerMatchBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerMatchBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove match buffers inside the block. Also, it will validate the binding. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5a0c80e759e67633f417edf99e2cc9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0c80e759e67633f417edf99e2cc9f4">&#9670;&nbsp;</a></span>LowerOpaqueBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerOpaqueBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the block to ensure that the TIR can not be scheduled again. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a16d42050efec51126d5b90eb2f60171f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d42050efec51126d5b90eb2f60171f">&#9670;&nbsp;</a></span>LowerThreadAllreduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerThreadAllreduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross thread alleduce. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8b8e7806d1a6e21b66123b3a4e255caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8e7806d1a6e21b66123b3a4e255caf">&#9670;&nbsp;</a></span>LowerTVMBuiltin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerTVMBuiltin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower builtin intrinsics. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a12ede8aa0409b3812b88c83a6e55e32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ede8aa0409b3812b88c83a6e55e32c">&#9670;&nbsp;</a></span>LowerVtcmAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerVtcmAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a726d95328c4e85c0c717c52aff4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a726d95328c4e85c0c717c52aff4f2">&#9670;&nbsp;</a></span>LowerWarpMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerWarpMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower warp memory access to low-level device related function calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a38be3df8947fea34192c61bfed1c6eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38be3df8947fea34192c61bfed1c6eec">&#9670;&nbsp;</a></span>MakePackedAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MakePackedAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to a low-level version that can be used as an API function. </p>
<p>The main task of this function is to create code to :</p><ul>
<li>Map the values in the api_args to <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">Var</a> that is required by body.</li>
<li>Insert assertions to check type/value of the passed arguments.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The function signature have two cases</dd></dl>
<p>let num_packed_args = len(api_args);</p>
<p>if num_packed_args is zero: f()</p>
<p>if num_packed_args is not zero: f(void *, TVMFFIAny* packed_args, int num_packed_args, api_arg_k, api_arg_k+1, ... api_arg_n, TVMFFIAny* out_ret_val)</p>
<p>where n == len(api_args), k == num_packed_args</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1903620176fa71b005fd7c58656d7139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903620176fa71b005fd7c58656d7139">&#9670;&nbsp;</a></span>MakeUnpackedAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MakeUnpackedAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to a C signature that can be used to call the operator directly. </p>
<p>The main task of this function is to create code that maps the values in the api_args to <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">Var</a> that is required by body</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="af2cdafede0174363f10db49d9a61fbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cdafede0174363f10db49d9a61fbe3">&#9670;&nbsp;</a></span>ManifestSharedMemoryLocalStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ManifestSharedMemoryLocalStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode.">Add</a> the explicit local stage for the shared memory access on GPU. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a4b0d85d35f717a306c4e602eee7ed9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d85d35f717a306c4e602eee7ed9aa">&#9670;&nbsp;</a></span>MergeSharedMemoryAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MergeSharedMemoryAllocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pass to merge multiple TIR-level shared memory allocations into one </p>

</div>
</div>
<a id="aa97b7253e13e662adc5f9ad3367746a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97b7253e13e662adc5f9ad3367746a8">&#9670;&nbsp;</a></span>NarrowDataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::NarrowDataType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow down <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> datatype in stmt to target_bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_bits</td><td>The target bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Run this pass after storage flatten. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aea27d24b6e7852652d258268d8537b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea27d24b6e7852652d258268d8537b66">&#9670;&nbsp;</a></span>OOBChecker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::OOBChecker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically check TIR code for out of bounds array access. </p>
<p>This analysis is conservative: it will only raise errors if it can prove that out of bounds access occurs. Cases that are uncertain do not raise errors.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5ffa51908f8a4c9f7eb4321d8b92c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffa51908f8a4c9f7eb4321d8b92c234">&#9670;&nbsp;</a></span>PlanAndUpdateBufferAllocationLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::PlanAndUpdateBufferAllocationLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate the buffer allocation to the exact position (usually is the lca of buffer access). This pass will inject opaque block with alloc_buffers at the allocation site. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a36268b8988766d94b09daaa433a2e1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36268b8988766d94b09daaa433a2e1aa">&#9670;&nbsp;</a></span>PointerValueTypeRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::PointerValueTypeRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a25b5de58d543c6786325d87eaad83692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b5de58d543c6786325d87eaad83692">&#9670;&nbsp;</a></span>RemapThreadAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RemapThreadAxis </td>
          <td>(</td>
          <td class="paramtype">Map&lt; String, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap the thread axis. </p>
<p>This can be used to get equivalent program which uses threadIdx.y in place of threadIdx.x by passing {"threadIdx.x": thread_axis("threadIdx.y")}</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8aad1159425e29be796562b2ec629b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aad1159425e29be796562b2ec629b10">&#9670;&nbsp;</a></span>RemoveNoOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RemoveNoOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a889dbda25befe68a8e8999f3e8ea8dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889dbda25befe68a8e8999f3e8ea8dc4">&#9670;&nbsp;</a></span>RemoveWeightLayoutRewriteBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RemoveWeightLayoutRewriteBlock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_ndarray_rewrite</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the weight layout rewrite block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skip_ndarray_rewrite</td><td>If True, exact rewrite of NDArray, according to the given index map, will be skipped. Only the shape of the NDArray is transformed correctly, and the content of the destination array will be filled with random values.</td></tr>
  </table>
  </dd>
</dl>
<p>When this pass is called many times during MetaSchedule tuning, the raw data of NDArray, before and after rewrite, does not matter. Since NDArray layout rewrite, using <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a>'s MapNDArray, is currently slow, skipping the exact rewrite is sometimes necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5c670c9efcd740f2f168b62e624c8c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c670c9efcd740f2f168b62e624c8c57">&#9670;&nbsp;</a></span>RenormalizeSplitPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RenormalizeSplitPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize the split pattern from floordiv(floormod()) to floormod(floordiv()) </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a4fe43327c4454dd05b6e925577443f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe43327c4454dd05b6e925577443f49">&#9670;&nbsp;</a></span>RewriteUnsafeSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RewriteUnsafeSelect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and rewrite unsafe select that contains memory access. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a817801e8c9488f712804d2d0b821acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817801e8c9488f712804d2d0b821acf0">&#9670;&nbsp;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::Simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run arithmetic simplifications on the statements and expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a6fdd5910b00af823071dcdddd21cd2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdd5910b00af823071dcdddd21cd2d3">&#9670;&nbsp;</a></span>SkipAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::SkipAssert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>skip assert stmt. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a4ec5dffb2a177bfd7548be4d974cba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5dffb2a177bfd7548be4d974cba71">&#9670;&nbsp;</a></span>SplitHostDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::SplitHostDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the function into a host function and device functions. </p>
<p>The resulting host-side function will keep the same <code><a class="el" href="namespacetvm_1_1attr.html#a580ae92d00e34f0a8f0d40395b8d972c" title="Compilation target of the function.">tvm::attr::kTarget</a></code> attribute (e.g. <code>T.target("cuda", host=T.target("llvm"))</code>). This ensures that <code>MakePackedAPI</code> knows which device type should be used for the input buffers.</p>
<p>The resulting device-side function will have the host stripped from its target attribute (e.g. <code>T.target("cuda")</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="abe87b271e2c20e0ad901697f33c01d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe87b271e2c20e0ad901697f33c01d2c">&#9670;&nbsp;</a></span>StorageRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::StorageRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0010cbc20ee308819046d77ad58b62cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0010cbc20ee308819046d77ad58b62cf">&#9670;&nbsp;</a></span>ThreadSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ThreadSync </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>storage_scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert sync between parallel read/write of shared buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage_scope</td><td>The storage scope considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1956116a1d54ea3f33c68b35792f720e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1956116a1d54ea3f33c68b35792f720e">&#9670;&nbsp;</a></span>TransformMmaBufferLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::TransformMmaBufferLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform Mma scope (m16n8k8.matrixA/B/C) to local scope with layout transformation. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aca44076eb1085d664877596a8b8587d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca44076eb1085d664877596a8b8587d4">&#9670;&nbsp;</a></span>UnifiedStaticMemoryPlanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnifiedStaticMemoryPlanner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the unified static memory planner pass that will plan for memory intra- and inter- PrimFuncs together. The pass requires all the function to be PrimFuncs including the main. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8b45a049536f7786b7821a5c1c32f0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b45a049536f7786b7821a5c1c32f0b3">&#9670;&nbsp;</a></span>UnifyThreadBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnifyThreadBinding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unify all the thread bindings for "blockIdx.x/y/z", "threadIdx.x/y/z", and "vthread.x/y/z". Before the unification, two vars that are bound to a thread axis (e.g., "threadIdx.x") use different IterVars and variables in their AttrStmts. After the unification, we use a consolidated <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> and a variable for them. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>vthread</code> is a legacy behavior that will be deprecated, though thread bindings of <code>vthread</code> are still also unified in this pass. Please use <code>vthread.x</code>, <code>vthread.y</code> and <code>vthread.z</code> instead. </dd></dl>

</div>
</div>
<a id="ab2f279e91071fa96a1edb24fa004ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f279e91071fa96a1edb24fa004ea6a">&#9670;&nbsp;</a></span>UnrollLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnrollLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a910f290dff4206785d60732ff5021ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910f290dff4206785d60732ff5021ac0">&#9670;&nbsp;</a></span>UseAssumeToReduceBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UseAssumeToReduceBranches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass analyzes primfunc &amp; eliminates branch introdued due to layout specific padding. It leverages from the buffer assumptions and use the information to eliminate the branch. </p>
<dl class="section note"><dt>Note</dt><dd>This creates more opportunity to vectorize the code. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="af3cecb50a8b8fc8021f6a87bc27587da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cecb50a8b8fc8021f6a87bc27587da">&#9670;&nbsp;</a></span>VectorizeLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VectorizeLoop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_vectorize</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower vectorization loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_vectorize</td><td>Whether vectorization is enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a70a059926c2ea81dcf437eff35f05e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a059926c2ea81dcf437eff35f05e3e">&#9670;&nbsp;</a></span>VerifyGPUCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype">Map&lt; String, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifyGPUCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#a53dfcb6ef7e178a83fda0bbb5dddcb39" title="Verify the correctness of a GPU code It will check the whether the amount of memory usage or the numb...">tvm::tir::VerifyGPUCode</a> </dd></dl>

</div>
</div>
<a id="a32d0b0ed966cf019d5e607bc90f284af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d0b0ed966cf019d5e607bc90f284af">&#9670;&nbsp;</a></span>VerifyMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifyMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifyMemory. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27" title="Verify if memory accesses are legal for a specific target device type.">tvm::tir::VerifyMemory</a> </dd></dl>

</div>
</div>
<a id="ac51a104ab4d2c60a4f6ed0e827efab18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51a104ab4d2c60a4f6ed0e827efab18">&#9670;&nbsp;</a></span>VerifySSA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifySSA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifySSA. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826" title="Verifies whether the IR stmt or Expr is in SSA form. That is: each Var is defined and assigned once(i...">tvm::tir::VerifySSA</a> </dd></dl>

</div>
</div>
<a id="a6989866d1d471ce19bd5fa45f4871a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6989866d1d471ce19bd5fa45f4871a20">&#9670;&nbsp;</a></span>VerifyVTCMLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifyVTCMLimit </td>
          <td>(</td>
          <td class="paramtype">Optional&lt; <a class="el" href="classtvm_1_1Target.html">Target</a> &gt;&#160;</td>
          <td class="paramname"><em>target</em> = <code>std::nullopt</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass to checks if the size of the allocated vtcm memory satisfies the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target whose VTCM limit should be used for any functions not already annotated with <code><a class="el" href="namespacetvm_1_1attr.html#a580ae92d00e34f0a8f0d40395b8d972c" title="Compilation target of the function.">tvm::attr::kTarget</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#a2f0f177b771c1c6c8a4097f540ed903c" title="Calculate the allocated memory per scope in bytes needed inside the TIR PrimFunc.">tvm::tir::CalculateAllocatedBytes</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
