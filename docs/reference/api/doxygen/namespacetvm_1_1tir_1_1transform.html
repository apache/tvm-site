<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac51a104ab4d2c60a4f6ed0e827efab18">VerifySSA</a> ()</td></tr>
<tr class="memdesc:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifySSA.  <a href="#ac51a104ab4d2c60a4f6ed0e827efab18">More...</a><br /></td></tr>
<tr class="separator:ac51a104ab4d2c60a4f6ed0e827efab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d0b0ed966cf019d5e607bc90f284af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a32d0b0ed966cf019d5e607bc90f284af">VerifyMemory</a> ()</td></tr>
<tr class="memdesc:a32d0b0ed966cf019d5e607bc90f284af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifyMemory.  <a href="#a32d0b0ed966cf019d5e607bc90f284af">More...</a><br /></td></tr>
<tr class="separator:a32d0b0ed966cf019d5e607bc90f284af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a059926c2ea81dcf437eff35f05e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a70a059926c2ea81dcf437eff35f05e3e">VerifyGPUCode</a> (<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; constraints)</td></tr>
<tr class="memdesc:a70a059926c2ea81dcf437eff35f05e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass variant of VerifyGPUCode.  <a href="#a70a059926c2ea81dcf437eff35f05e3e">More...</a><br /></td></tr>
<tr class="separator:a70a059926c2ea81dcf437eff35f05e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1492ac3cab5f661e4fb05d26a19200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6b1492ac3cab5f661e4fb05d26a19200">CreatePrimFuncPass</a> (const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1transform_1_1PassContext.html">PassContext</a>)&gt; &amp;pass_func, int opt_level, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> name, <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; required)</td></tr>
<tr class="separator:a6b1492ac3cab5f661e4fb05d26a19200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aa23d8985679d2e09685729c644f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a20aa23d8985679d2e09685729c644f0f">InjectPrefetch</a> ()</td></tr>
<tr class="memdesc:a20aa23d8985679d2e09685729c644f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject prefetch instructions into stmt.  <a href="#a20aa23d8985679d2e09685729c644f0f">More...</a><br /></td></tr>
<tr class="separator:a20aa23d8985679d2e09685729c644f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d3e1efecdff97e7bcf0e6a5406e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a778d3e1efecdff97e7bcf0e6a5406e61">StorageFlatten</a> (int cache_line_size, bool create_bound_attribute=false)</td></tr>
<tr class="memdesc:a778d3e1efecdff97e7bcf0e6a5406e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the multi-dimensional read/write to single dimensional Load/Store.  <a href="#a778d3e1efecdff97e7bcf0e6a5406e61">More...</a><br /></td></tr>
<tr class="separator:a778d3e1efecdff97e7bcf0e6a5406e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70d9af70526908167101609baaf4142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae70d9af70526908167101609baaf4142">InjectCopyIntrin</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> pragma_key, <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> fintrin)</td></tr>
<tr class="memdesc:ae70d9af70526908167101609baaf4142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject copy intrinsics with optional pad.  <a href="#ae70d9af70526908167101609baaf4142">More...</a><br /></td></tr>
<tr class="separator:ae70d9af70526908167101609baaf4142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa234deedbe456bf561a1b90f2ed94206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aa234deedbe456bf561a1b90f2ed94206">CoProcSync</a> ()</td></tr>
<tr class="memdesc:aa234deedbe456bf561a1b90f2ed94206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and insert sync points to co-processor.  <a href="#aa234deedbe456bf561a1b90f2ed94206">More...</a><br /></td></tr>
<tr class="separator:aa234deedbe456bf561a1b90f2ed94206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6050dba3ac8efbb922ce0477198ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1a6050dba3ac8efbb922ce0477198ab3">LiftAttrScope</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> attr_key)</td></tr>
<tr class="memdesc:a1a6050dba3ac8efbb922ce0477198ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift common attrs with attr_key to outer scope.  <a href="#a1a6050dba3ac8efbb922ce0477198ab3">More...</a><br /></td></tr>
<tr class="separator:a1a6050dba3ac8efbb922ce0477198ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b0910c03b6f2d462448fa2725c1f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a17b0910c03b6f2d462448fa2725c1f5e">LoopPartition</a> ()</td></tr>
<tr class="memdesc:a17b0910c03b6f2d462448fa2725c1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition loops in the stmt.  <a href="#a17b0910c03b6f2d462448fa2725c1f5e">More...</a><br /></td></tr>
<tr class="separator:a17b0910c03b6f2d462448fa2725c1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cecb50a8b8fc8021f6a87bc27587da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af3cecb50a8b8fc8021f6a87bc27587da">VectorizeLoop</a> (bool enable_vectorize=true)</td></tr>
<tr class="memdesc:af3cecb50a8b8fc8021f6a87bc27587da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower vectorization loops.  <a href="#af3cecb50a8b8fc8021f6a87bc27587da">More...</a><br /></td></tr>
<tr class="separator:af3cecb50a8b8fc8021f6a87bc27587da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ade618ab7572f92bd37f69049966c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a37ade618ab7572f92bd37f69049966c7">InjectVirtualThread</a> ()</td></tr>
<tr class="memdesc:a37ade618ab7572f92bd37f69049966c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject virtual thread loops.  <a href="#a37ade618ab7572f92bd37f69049966c7">More...</a><br /></td></tr>
<tr class="separator:a37ade618ab7572f92bd37f69049966c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f70a1b3cfc63c52b462fba772b8370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a55f70a1b3cfc63c52b462fba772b8370">InjectDoubleBuffer</a> ()</td></tr>
<tr class="memdesc:a55f70a1b3cfc63c52b462fba772b8370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject double buffer statements.  <a href="#a55f70a1b3cfc63c52b462fba772b8370">More...</a><br /></td></tr>
<tr class="separator:a55f70a1b3cfc63c52b462fba772b8370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87b271e2c20e0ad901697f33c01d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#abe87b271e2c20e0ad901697f33c01d2c">StorageRewrite</a> ()</td></tr>
<tr class="memdesc:abe87b271e2c20e0ad901697f33c01d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible.  <a href="#abe87b271e2c20e0ad901697f33c01d2c">More...</a><br /></td></tr>
<tr class="separator:abe87b271e2c20e0ad901697f33c01d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f279e91071fa96a1edb24fa004ea6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ab2f279e91071fa96a1edb24fa004ea6a">UnrollLoop</a> ()</td></tr>
<tr class="memdesc:ab2f279e91071fa96a1edb24fa004ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard.  <a href="#ab2f279e91071fa96a1edb24fa004ea6a">More...</a><br /></td></tr>
<tr class="separator:ab2f279e91071fa96a1edb24fa004ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad1159425e29be796562b2ec629b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8aad1159425e29be796562b2ec629b10">RemoveNoOp</a> ()</td></tr>
<tr class="memdesc:a8aad1159425e29be796562b2ec629b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="#a8aad1159425e29be796562b2ec629b10">More...</a><br /></td></tr>
<tr class="separator:a8aad1159425e29be796562b2ec629b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe43327c4454dd05b6e925577443f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4fe43327c4454dd05b6e925577443f49">RewriteUnsafeSelect</a> ()</td></tr>
<tr class="memdesc:a4fe43327c4454dd05b6e925577443f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and rewrite unsafe select that contains memory access.  <a href="#a4fe43327c4454dd05b6e925577443f49">More...</a><br /></td></tr>
<tr class="separator:a4fe43327c4454dd05b6e925577443f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817801e8c9488f712804d2d0b821acf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a817801e8c9488f712804d2d0b821acf0">Simplify</a> ()</td></tr>
<tr class="memdesc:a817801e8c9488f712804d2d0b821acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run arithmetic simplifications on the statements and expressions.  <a href="#a817801e8c9488f712804d2d0b821acf0">More...</a><br /></td></tr>
<tr class="separator:a817801e8c9488f712804d2d0b821acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c492c5e21f3cd636bc27493153dcbbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8c492c5e21f3cd636bc27493153dcbbe">InstrumentBoundCheckers</a> ()</td></tr>
<tr class="memdesc:a8c492c5e21f3cd636bc27493153dcbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruments bound checkers.  <a href="#a8c492c5e21f3cd636bc27493153dcbbe">More...</a><br /></td></tr>
<tr class="separator:a8c492c5e21f3cd636bc27493153dcbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf9c953f28d23408872beef5aa33af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#abaf9c953f28d23408872beef5aa33af7">MakePackedAPI</a> (int num_unpacked_args)</td></tr>
<tr class="memdesc:abaf9c953f28d23408872beef5aa33af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to a low-level version that can be used as an API function.  <a href="#abaf9c953f28d23408872beef5aa33af7">More...</a><br /></td></tr>
<tr class="separator:abaf9c953f28d23408872beef5aa33af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903620176fa71b005fd7c58656d7139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1903620176fa71b005fd7c58656d7139">MakeUnpackedAPI</a> ()</td></tr>
<tr class="memdesc:a1903620176fa71b005fd7c58656d7139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to a C signature that can be used to call the operator directly.  <a href="#a1903620176fa71b005fd7c58656d7139">More...</a><br /></td></tr>
<tr class="separator:a1903620176fa71b005fd7c58656d7139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b5de58d543c6786325d87eaad83692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a25b5de58d543c6786325d87eaad83692">RemapThreadAxis</a> (<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt; axis_map)</td></tr>
<tr class="memdesc:a25b5de58d543c6786325d87eaad83692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the thread axis.  <a href="#a25b5de58d543c6786325d87eaad83692">More...</a><br /></td></tr>
<tr class="separator:a25b5de58d543c6786325d87eaad83692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">LowerCustomDatatypes</a> ()</td></tr>
<tr class="memdesc:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower custom datatypes.  <a href="#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">More...</a><br /></td></tr>
<tr class="separator:a0d6b2682a93ca4136ed4fa6d8fa7bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6648d0a1c613e7e0f5e231059c3c22c6">DecorateDeviceScope</a> ()</td></tr>
<tr class="memdesc:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate all the function's body as device function.  <a href="#a6648d0a1c613e7e0f5e231059c3c22c6">More...</a><br /></td></tr>
<tr class="separator:a6648d0a1c613e7e0f5e231059c3c22c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5dffb2a177bfd7548be4d974cba71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a4ec5dffb2a177bfd7548be4d974cba71">SplitHostDevice</a> ()</td></tr>
<tr class="memdesc:a4ec5dffb2a177bfd7548be4d974cba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the function into a host function and device functions.  <a href="#a4ec5dffb2a177bfd7548be4d974cba71">More...</a><br /></td></tr>
<tr class="separator:a4ec5dffb2a177bfd7548be4d974cba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdd5910b00af823071dcdddd21cd2d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a6fdd5910b00af823071dcdddd21cd2d3">SkipAssert</a> ()</td></tr>
<tr class="memdesc:a6fdd5910b00af823071dcdddd21cd2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip assert stmt.  <a href="#a6fdd5910b00af823071dcdddd21cd2d3">More...</a><br /></td></tr>
<tr class="separator:a6fdd5910b00af823071dcdddd21cd2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0010cbc20ee308819046d77ad58b62cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0010cbc20ee308819046d77ad58b62cf">ThreadSync</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> storage_scope)</td></tr>
<tr class="memdesc:a0010cbc20ee308819046d77ad58b62cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert sync between parallel read/write of shared buffers.  <a href="#a0010cbc20ee308819046d77ad58b62cf">More...</a><br /></td></tr>
<tr class="separator:a0010cbc20ee308819046d77ad58b62cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d42050efec51126d5b90eb2f60171f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a16d42050efec51126d5b90eb2f60171f">LowerThreadAllreduce</a> ()</td></tr>
<tr class="memdesc:a16d42050efec51126d5b90eb2f60171f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross thread alleduce.  <a href="#a16d42050efec51126d5b90eb2f60171f">More...</a><br /></td></tr>
<tr class="separator:a16d42050efec51126d5b90eb2f60171f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae10fc2ab38a0cdfe79cb7f718549f532">InferFragment</a> ()</td></tr>
<tr class="memdesc:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the TensorCore fragment infomation using tensor intrinsics.  <a href="#ae10fc2ab38a0cdfe79cb7f718549f532">More...</a><br /></td></tr>
<tr class="separator:ae10fc2ab38a0cdfe79cb7f718549f532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8b8e7806d1a6e21b66123b3a4e255caf">LowerTVMBuiltin</a> ()</td></tr>
<tr class="memdesc:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower builtin intrinsics.  <a href="#a8b8e7806d1a6e21b66123b3a4e255caf">More...</a><br /></td></tr>
<tr class="separator:a8b8e7806d1a6e21b66123b3a4e255caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a0979c9d3bf0e64205f16aa00d331c6b5">LowerIntrin</a> ()</td></tr>
<tr class="memdesc:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower the target specific function intrinsics in each of the function.  <a href="#a0979c9d3bf0e64205f16aa00d331c6b5">More...</a><br /></td></tr>
<tr class="separator:a0979c9d3bf0e64205f16aa00d331c6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a726d95328c4e85c0c717c52aff4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ad5a726d95328c4e85c0c717c52aff4f2">LowerWarpMemory</a> ()</td></tr>
<tr class="memdesc:ad5a726d95328c4e85c0c717c52aff4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower warp memory access to low-level device related function calls.  <a href="#ad5a726d95328c4e85c0c717c52aff4f2">More...</a><br /></td></tr>
<tr class="separator:ad5a726d95328c4e85c0c717c52aff4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a53b7a3b7552ad5fa7b49e90470aff02b">LowerDeviceStorageAccessInfo</a> ()</td></tr>
<tr class="memdesc:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower attached storage access information on device.  <a href="#a53b7a3b7552ad5fa7b49e90470aff02b">More...</a><br /></td></tr>
<tr class="separator:a53b7a3b7552ad5fa7b49e90470aff02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a9c2f441a8056f9abe65e72b41b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#af00a9c2f441a8056f9abe65e72b41b36">CombineContextCall</a> ()</td></tr>
<tr class="memdesc:af00a9c2f441a8056f9abe65e72b41b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine context calls in the host function.  <a href="#af00a9c2f441a8056f9abe65e72b41b36">More...</a><br /></td></tr>
<tr class="separator:af00a9c2f441a8056f9abe65e72b41b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97b7253e13e662adc5f9ad3367746a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aa97b7253e13e662adc5f9ad3367746a8">NarrowDataType</a> (int target_bits)</td></tr>
<tr class="memdesc:aa97b7253e13e662adc5f9ad3367746a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow down <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> datatype in stmt to target_bits.  <a href="#aa97b7253e13e662adc5f9ad3367746a8">More...</a><br /></td></tr>
<tr class="separator:aa97b7253e13e662adc5f9ad3367746a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d253fffbff469622fa63c52dff89352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a2d253fffbff469622fa63c52dff89352">BF16Legalize</a> ()</td></tr>
<tr class="memdesc:a2d253fffbff469622fa63c52dff89352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize bf16 typed Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode. ">Add</a> a cast to fp32 before Ops, then add a cast back to bf16.  <a href="#a2d253fffbff469622fa63c52dff89352">More...</a><br /></td></tr>
<tr class="separator:a2d253fffbff469622fa63c52dff89352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36268b8988766d94b09daaa433a2e1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a36268b8988766d94b09daaa433a2e1aa">PointerValueTypeRewrite</a> ()</td></tr>
<tr class="memdesc:a36268b8988766d94b09daaa433a2e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible.  <a href="#a36268b8988766d94b09daaa433a2e1aa">More...</a><br /></td></tr>
<tr class="separator:a36268b8988766d94b09daaa433a2e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2b8fdd84785388630e2d52a6e3cc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#acd2b8fdd84785388630e2d52a6e3cc54">HoistIfThenElse</a> ()</td></tr>
<tr class="memdesc:acd2b8fdd84785388630e2d52a6e3cc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariant <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> nodes to outside the elligible loops.  <a href="#acd2b8fdd84785388630e2d52a6e3cc54">More...</a><br /></td></tr>
<tr class="separator:acd2b8fdd84785388630e2d52a6e3cc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641a33aa6ac3ec146be1196a091af5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a641a33aa6ac3ec146be1196a091af5d5">LowerCrossThreadReduction</a> ()</td></tr>
<tr class="memdesc:a641a33aa6ac3ec146be1196a091af5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross-thread reduction from thread bindings to intrinsic function calls.  <a href="#a641a33aa6ac3ec146be1196a091af5d5">More...</a><br /></td></tr>
<tr class="separator:a641a33aa6ac3ec146be1196a091af5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aeaa9c663bdf10c5c596d81f8d5b6f1ed">LowerInitBlock</a> ()</td></tr>
<tr class="memdesc:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower block init stmt into <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> stmts.  <a href="#aeaa9c663bdf10c5c596d81f8d5b6f1ed">More...</a><br /></td></tr>
<tr class="separator:aeaa9c663bdf10c5c596d81f8d5b6f1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5ffa51908f8a4c9f7eb4321d8b92c234">PlanAndUpdateBufferAllocationLocation</a> ()</td></tr>
<tr class="memdesc:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the buffer allocation to the exact position (usually is the lca of buffer access). This pass will inject opaque block with alloc_buffers at the allocation site.  <a href="#a5ffa51908f8a4c9f7eb4321d8b92c234">More...</a><br /></td></tr>
<tr class="separator:a5ffa51908f8a4c9f7eb4321d8b92c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f476f006bd24ef62f7c170aded18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ae14f476f006bd24ef62f7c170aded18d">ConvertBlocksToOpaque</a> ()</td></tr>
<tr class="memdesc:ae14f476f006bd24ef62f7c170aded18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all the block vars with the PrimExprs they are bound to, indicated by the corresponding iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode. ">BlockRealize</a>, for opaque blocks by removing all . the iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode. ">BlockRealize</a> and iter_vars in <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a>.  <a href="#ae14f476f006bd24ef62f7c170aded18d">More...</a><br /></td></tr>
<tr class="separator:ae14f476f006bd24ef62f7c170aded18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dbf3a491d01da405c1ce6d5944ee85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac6dbf3a491d01da405c1ce6d5944ee85">CompactBufferAllocation</a> ()</td></tr>
<tr class="memdesc:ac6dbf3a491d01da405c1ce6d5944ee85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the buffer access region by removing the buffer regions that are not accessed, i.e. narrowing the buffer shape and adjust the access region if necessary.  <a href="#ac6dbf3a491d01da405c1ce6d5944ee85">More...</a><br /></td></tr>
<tr class="separator:ac6dbf3a491d01da405c1ce6d5944ee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84aad38c2cacfae333c8970ece933d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#acc84aad38c2cacfae333c8970ece933d">LegalizePackedCalls</a> ()</td></tr>
<tr class="separator:acc84aad38c2cacfae333c8970ece933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7277fb8101861053cc697a9d3aba1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aaf7277fb8101861053cc697a9d3aba1e">LowerMatchBuffer</a> ()</td></tr>
<tr class="memdesc:aaf7277fb8101861053cc697a9d3aba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove match buffers inside the block. Also, it will validate the binding.  <a href="#aaf7277fb8101861053cc697a9d3aba1e">More...</a><br /></td></tr>
<tr class="separator:aaf7277fb8101861053cc697a9d3aba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf607d0e759472ac47845b7206f276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a3acf607d0e759472ac47845b7206f276">FlattenBuffer</a> ()</td></tr>
<tr class="memdesc:a3acf607d0e759472ac47845b7206f276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the multi-dimensional <a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode. ">BufferLoad</a> and <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> to single dimensional Load/Store. Also remove <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a> to ensure that the flattened TIR can not be scheduled again.  <a href="#a3acf607d0e759472ac47845b7206f276">More...</a><br /></td></tr>
<tr class="separator:a3acf607d0e759472ac47845b7206f276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19311e5b5ae82ad85ec3fdd7ea4556e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ab19311e5b5ae82ad85ec3fdd7ea4556e">TextureFlatten</a> ()</td></tr>
<tr class="separator:ab19311e5b5ae82ad85ec3fdd7ea4556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6c3059742090f9549f4dad01ba7c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5c6c3059742090f9549f4dad01ba7c8d">CommonSubexprElimTIR</a> (bool enable_cse_tir=true)</td></tr>
<tr class="memdesc:a5c6c3059742090f9549f4dad01ba7c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a Common Subexpression Elimination (CSE) for TIR which introduces let-in bindings for duplicated sub-expressions.  <a href="#a5c6c3059742090f9549f4dad01ba7c8d">More...</a><br /></td></tr>
<tr class="separator:a5c6c3059742090f9549f4dad01ba7c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b45a049536f7786b7821a5c1c32f0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a8b45a049536f7786b7821a5c1c32f0b3">UnifyThreadBinding</a> ()</td></tr>
<tr class="memdesc:a8b45a049536f7786b7821a5c1c32f0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify all the thread bindings for "blockIdx.x/y/z", "threadIdx.x/y/z", and "vthread.x/y/z". Before the unification, two vars that are bound to a thread axis (e.g., "threadIdx.x") use different IterVars and variables in their AttrStmts. After the unification, we use a consolidated <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> and a variable for them.  <a href="#a8b45a049536f7786b7821a5c1c32f0b3">More...</a><br /></td></tr>
<tr class="separator:a8b45a049536f7786b7821a5c1c32f0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070137dbab05c63d4af6b77c25868a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a070137dbab05c63d4af6b77c25868a66">MergeDynamicSharedMemoryAllocations</a> ()</td></tr>
<tr class="separator:a070137dbab05c63d4af6b77c25868a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106e04ba8c560e24a4b6c8c414184ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a106e04ba8c560e24a4b6c8c414184ec4">ConvertForLoopsToSerial</a> ()</td></tr>
<tr class="memdesc:a106e04ba8c560e24a4b6c8c414184ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass is post-scheduling pass to convert all Parallel <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loops to Serial ones. This is run to attain lesser memory and/or executor/backend does not support parallel launch of <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loops.  <a href="#a106e04ba8c560e24a4b6c8c414184ec4">More...</a><br /></td></tr>
<tr class="separator:a106e04ba8c560e24a4b6c8c414184ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44076eb1085d664877596a8b8587d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#aca44076eb1085d664877596a8b8587d4">UnifiedStaticMemoryPlanner</a> ()</td></tr>
<tr class="memdesc:aca44076eb1085d664877596a8b8587d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the unified static memory planner pass that will plan for memory intra- and inter- PrimFuncs together. The pass requires all the function to be PrimFuncs including the main.  <a href="#aca44076eb1085d664877596a8b8587d4">More...</a><br /></td></tr>
<tr class="separator:aca44076eb1085d664877596a8b8587d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a1b90f3ff7f983452fb3a4f7181043ae8">InjectSoftwarePipeline</a> ()</td></tr>
<tr class="memdesc:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass transforms annotated loops into pipelined ones where producers and consumers are overlapped with the information provided in loop annotations, which enables optimization techniques like prefetching and pipeline parallelism.  <a href="#a1b90f3ff7f983452fb3a4f7181043ae8">More...</a><br /></td></tr>
<tr class="separator:a1b90f3ff7f983452fb3a4f7181043ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d8ff162a7043149cfc55f5ea8ba7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#abf2d8ff162a7043149cfc55f5ea8ba7f">BindParams</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">runtime::NDArray</a> &gt; &amp;constants)</td></tr>
<tr class="separator:abf2d8ff162a7043149cfc55f5ea8ba7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148d43765be86c3778bd32a112698fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#ac148d43765be86c3778bd32a112698fd">ExtractPrimFuncConstants</a> ()</td></tr>
<tr class="memdesc:ac148d43765be86c3778bd32a112698fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to collect tir non-scalar constants into module's 'Constants' attribute.  <a href="#ac148d43765be86c3778bd32a112698fd">More...</a><br /></td></tr>
<tr class="separator:ac148d43765be86c3778bd32a112698fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c670c9efcd740f2f168b62e624c8c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html#a5c670c9efcd740f2f168b62e624c8c57">RenormalizeSplitPattern</a> ()</td></tr>
<tr class="memdesc:a5c670c9efcd740f2f168b62e624c8c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize the split pattern from floordiv(floormod()) to floormod(floordiv())  <a href="#a5c670c9efcd740f2f168b62e624c8c57">More...</a><br /></td></tr>
<tr class="separator:a5c670c9efcd740f2f168b62e624c8c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d253fffbff469622fa63c52dff89352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d253fffbff469622fa63c52dff89352">&#9670;&nbsp;</a></span>BF16Legalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BF16Legalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize bf16 typed Ops. <a class="el" href="classtvm_1_1tir_1_1Add.html" title="Managed reference to AddNode. ">Add</a> a cast to fp32 before Ops, then add a cast back to bf16. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="abf2d8ff162a7043149cfc55f5ea8ba7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d8ff162a7043149cfc55f5ea8ba7f">&#9670;&nbsp;</a></span>BindParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::BindParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">runtime::NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af00a9c2f441a8056f9abe65e72b41b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a9c2f441a8056f9abe65e72b41b36">&#9670;&nbsp;</a></span>CombineContextCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CombineContextCall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine context calls in the host function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5c6c3059742090f9549f4dad01ba7c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6c3059742090f9549f4dad01ba7c8d">&#9670;&nbsp;</a></span>CommonSubexprElimTIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CommonSubexprElimTIR </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_cse_tir</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a Common Subexpression Elimination (CSE) for TIR which introduces let-in bindings for duplicated sub-expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_cse_tir</td><td>Whether common subexpression elimination is enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ac6dbf3a491d01da405c1ce6d5944ee85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dbf3a491d01da405c1ce6d5944ee85">&#9670;&nbsp;</a></span>CompactBufferAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CompactBufferAllocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compact the buffer access region by removing the buffer regions that are not accessed, i.e. narrowing the buffer shape and adjust the access region if necessary. </p>
<p>Before narrowing, <code>B</code> is a <code>[16, 16]</code> buffer, but only a skinny vector <code>B[i, 0:16]</code> is accessed.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i in range(0, 16):</div><div class="line">    with T.block():</div><div class="line">        B = T.alloc_buffer(16, 16)</div><div class="line">        for j in range(0, 16):</div><div class="line">            B[i, j] = A[i, j] + 1</div><div class="line">        for j in range(0, 16):</div><div class="line">            C[i, j] = B[i, j] + 1</div></div><!-- fragment --><p>This pass narrows the buffer shape and adjust its accessed region accordingly. In this particular case, because only a <code>1 * 16</code> vector of <code>B</code> is accessed, the pass narrows <code>B</code> to shape <code>[1, 16]</code>, and changes the access to <code>B[i, j]</code> to <code>B[0, j]</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i in range(0, 16):</div><div class="line">    with T.block():</div><div class="line">        B = T.alloc_buffer(1, 16)</div><div class="line">        for j in range(0, 16):</div><div class="line">            B[0, j] = A[i, j] + 1</div><div class="line">        for j in range(0, 16):</div><div class="line">            C[i, j] = B[0, j] + 1</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae14f476f006bd24ef62f7c170aded18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14f476f006bd24ef62f7c170aded18d">&#9670;&nbsp;</a></span>ConvertBlocksToOpaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ConvertBlocksToOpaque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all the block vars with the PrimExprs they are bound to, indicated by the corresponding iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode. ">BlockRealize</a>, for opaque blocks by removing all . the iter_values in <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode. ">BlockRealize</a> and iter_vars in <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a106e04ba8c560e24a4b6c8c414184ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106e04ba8c560e24a4b6c8c414184ec4">&#9670;&nbsp;</a></span>ConvertForLoopsToSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ConvertForLoopsToSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass is post-scheduling pass to convert all Parallel <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loops to Serial ones. This is run to attain lesser memory and/or executor/backend does not support parallel launch of <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aa234deedbe456bf561a1b90f2ed94206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa234deedbe456bf561a1b90f2ed94206">&#9670;&nbsp;</a></span>CoProcSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CoProcSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and insert sync points to co-processor. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a6b1492ac3cab5f661e4fb05d26a19200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1492ac3cab5f661e4fb05d26a19200">&#9670;&nbsp;</a></span>CreatePrimFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::CreatePrimFuncPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>(<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1transform_1_1PassContext.html">PassContext</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6648d0a1c613e7e0f5e231059c3c22c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6648d0a1c613e7e0f5e231059c3c22c6">&#9670;&nbsp;</a></span>DecorateDeviceScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::DecorateDeviceScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate all the function's body as device function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ac148d43765be86c3778bd32a112698fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148d43765be86c3778bd32a112698fd">&#9670;&nbsp;</a></span>ExtractPrimFuncConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ExtractPrimFuncConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass to collect tir non-scalar constants into module's 'Constants' attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a3acf607d0e759472ac47845b7206f276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acf607d0e759472ac47845b7206f276">&#9670;&nbsp;</a></span>FlattenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::FlattenBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the multi-dimensional <a class="el" href="classtvm_1_1tir_1_1BufferLoad.html" title="Managed reference to BufferLoadNode. ">BufferLoad</a> and <a class="el" href="classtvm_1_1tir_1_1BufferStore.html" title="Managed reference to BufferStoreNode. ">BufferStore</a> to single dimensional Load/Store. Also remove <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a> to ensure that the flattened TIR can not be scheduled again. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="acd2b8fdd84785388630e2d52a6e3cc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2b8fdd84785388630e2d52a6e3cc54">&#9670;&nbsp;</a></span>HoistIfThenElse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::HoistIfThenElse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariant <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> nodes to outside the elligible loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae10fc2ab38a0cdfe79cb7f718549f532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10fc2ab38a0cdfe79cb7f718549f532">&#9670;&nbsp;</a></span>InferFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InferFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the TensorCore fragment infomation using tensor intrinsics. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ae70d9af70526908167101609baaf4142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70d9af70526908167101609baaf4142">&#9670;&nbsp;</a></span>InjectCopyIntrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectCopyIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>pragma_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a>&#160;</td>
          <td class="paramname"><em>fintrin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject copy intrinsics with optional pad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pragma_key</td><td>The pragma key for hint of copy. </td></tr>
    <tr><td class="paramname">fintrin</td><td>The function with signature</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a> fintrin(<a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> src, <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> dst, Array&lt;Expr&gt; pad_before, Array&lt;Expr&gt; pad_after, Expr pad_value) </p><dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a55f70a1b3cfc63c52b462fba772b8370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f70a1b3cfc63c52b462fba772b8370">&#9670;&nbsp;</a></span>InjectDoubleBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectDoubleBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject double buffer statements. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a20aa23d8985679d2e09685729c644f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aa23d8985679d2e09685729c644f0f">&#9670;&nbsp;</a></span>InjectPrefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectPrefetch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject prefetch instructions into stmt. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1b90f3ff7f983452fb3a4f7181043ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b90f3ff7f983452fb3a4f7181043ae8">&#9670;&nbsp;</a></span>InjectSoftwarePipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectSoftwarePipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass transforms annotated loops into pipelined ones where producers and consumers are overlapped with the information provided in loop annotations, which enables optimization techniques like prefetching and pipeline parallelism. </p>
<p>The pipeline scope consists of the direct children of the annotated loop (ignoring <a class="el" href="classtvm_1_1tir_1_1BlockRealize.html" title="Managed reference to BlockRealizeNode. ">BlockRealize</a>, <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a>, <a class="el" href="classtvm_1_1tir_1_1SeqStmt.html" title="Sequence statement. ">SeqStmt</a>), and the number of children is denoted by <code>n</code> in the documentation.</p>
<p>The following annotations are used to guide the loop transformation:</p>
<p>1) Loop annotation <code>software_pipeline_stage</code> defines the pipeline stage. An array of <code>n</code> integers, and each element should be in range [0, max_stage], where max_stage is the maximum (inclusive) stage. 2) Loop annotation <code>software_pipeline_order</code> defines the pipeline order. An array of <code>n</code> integers, a permutation of [0, 1, ..., num_components - 1]; 3) <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a> annotation <code>double_buffer_scope</code> controls certain buffer sizes to allow decoupling of read/write dependency. It's an integer index of the write regions of the block.</p>
<p>Every annotated loop is transformed into a loop with three blocks as its direct children:</p>
<p>1) Prologue block, where components whose stage is less than <code>max_stage</code> is executed;</p>
<p>2) Body block, where all the components are executed;</p>
<p>3) Epilogue block, where only components whose stage is greater than 0 will be executed. The execution order is controlled by the annotation <code>software_pipeline_order</code>, and thus could be different than the original order.</p>
<p>Note: <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> nested software pipelines, the inner software pipeline will be generated first, which may affect the number of the direct children of the outer loop. In this case, the annotations for the outer software pipeline should include the result of the inner software pipeline, which is the three blocks as discussed above. Example:</p>
<p>Before this pass, the TIR is:</p>
<div class="fragment"><div class="line">@T.prim_func</div><div class="line"><span class="keyword">def </span>before_transform(A: T.Buffer[(16, 16), <span class="stringliteral">&quot;float32&quot;</span>], C: T.Buffer[(16, 16), <span class="stringliteral">&quot;float32&quot;</span>]) -&gt; <span class="keywordtype">None</span>:</div><div class="line">    <span class="keywordflow">for</span> tx <span class="keywordflow">in</span> T.thread_binding(0, 16, thread=<span class="stringliteral">&quot;threadIdx.x&quot;</span>):</div><div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> T.serial(0, 16,</div><div class="line">                          annotations={<span class="stringliteral">&quot;software_pipeline_stage&quot;</span>: [0, 1],</div><div class="line">                                       <span class="stringliteral">&quot;software_pipeline_order&quot;</span>: [0, 1]}</div><div class="line">                         ):</div><div class="line">            with T.block():</div><div class="line">                T.reads(A[tx, i])</div><div class="line">                T.writes(C[tx, i])</div><div class="line">                B = T.alloc_buffer((16, 1), dtype=<span class="stringliteral">&quot;float32&quot;</span>, scope=<span class="stringliteral">&quot;shared&quot;</span>)</div><div class="line">                with T.block(<span class="stringliteral">&quot;B&quot;</span>):</div><div class="line">                    T.reads(A[tx, i])</div><div class="line">                    T.writes(B[tx, 0])</div><div class="line">                    B[tx, 0] = A[tx, i] * T.float32(2)</div><div class="line">                with T.block(<span class="stringliteral">&quot;C&quot;</span>):</div><div class="line">                    T.reads(B[tx, 0])</div><div class="line">                    T.writes(C[tx, i])</div><div class="line">                    C[tx, i] = B[tx, 0] + T.float32(1)</div></div><!-- fragment --><p>The TIR above annotates the loop as a two-stage pipeline with no reordering. After applying this pass, the TIR is transformed into:</p>
<div class="fragment"><div class="line">@T.prim_func</div><div class="line"><span class="keyword">def </span>after_transform(A: T.Buffer[(16, 16), <span class="stringliteral">&quot;float32&quot;</span>], C: T.Buffer[(16, 16), <span class="stringliteral">&quot;float32&quot;</span>]) -&gt; <span class="keywordtype">None</span>:</div><div class="line">    <span class="keywordflow">for</span> tx <span class="keywordflow">in</span> T.thread_binding(0, 16, thread=<span class="stringliteral">&quot;threadIdx.x&quot;</span>):</div><div class="line">        with T.block():</div><div class="line">            T.reads([A[tx, 0:16]])</div><div class="line">            T.writes([C[tx, 0:16]])</div><div class="line">            B = T.alloc_buffer([2, 16, 1], dtype=<span class="stringliteral">&quot;float32&quot;</span>, scope=<span class="stringliteral">&quot;shared&quot;</span>)</div><div class="line">            with T.block(<span class="stringliteral">&quot;prologue&quot;</span>):</div><div class="line">                T.reads([A[tx, 0]])</div><div class="line">                T.writes([B[0, tx, 0]])</div><div class="line">                B[0, tx, 0] = A[tx, 0] * T.float32(2)</div><div class="line">            with T.block(<span class="stringliteral">&quot;body&quot;</span>):</div><div class="line">                T.reads([A[tx, 1:16], B[0:2, tx, 0]])</div><div class="line">                T.writes([B[0:2, tx, 0], C[tx, 0:15]])</div><div class="line">                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> T.serial(0, 15):</div><div class="line">                    with T.block(<span class="stringliteral">&quot;B&quot;</span>):</div><div class="line">                        T.reads([A[tx, i + 1]])</div><div class="line">                        T.writes([B[(i + 1) % 2, tx, 0]])</div><div class="line">                        B[(i + 1) % 2, tx, 0] = A[tx, i + 1] * T.float32(2)</div><div class="line">                    with T.block(<span class="stringliteral">&quot;C&quot;</span>):</div><div class="line">                        T.reads([B[i % 2, tx, 0]])</div><div class="line">                        T.writes([C[tx, i]])</div><div class="line">                        C[tx, i] = B[i % 2, tx, 0] + T.float32(1)</div><div class="line">            with T.block(<span class="stringliteral">&quot;epilogue&quot;</span>):</div><div class="line">                T.reads([B[1, tx, 0]])</div><div class="line">                T.writes([C[tx, 15]])</div><div class="line">                C[tx, 15] = B[1, tx, 0] + T.float32(1)</div></div><!-- fragment --><p>The original loop has two blocks, B and C, as its direct children. The loop annotations indicate that block B has stage == 0, order == 0, block C has stage == 1, order == 1. Therefore, block B should be executed in advance of block C by one iteration. The order 0 and 1 specifies the order of block B and C inside the body block inside the result TIR.</p>
<dl class="section return"><dt>Returns</dt><dd>The IR transform pass. </dd></dl>

</div>
</div>
<a id="a37ade618ab7572f92bd37f69049966c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ade618ab7572f92bd37f69049966c7">&#9670;&nbsp;</a></span>InjectVirtualThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InjectVirtualThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject virtual thread loops. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8c492c5e21f3cd636bc27493153dcbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c492c5e21f3cd636bc27493153dcbbe">&#9670;&nbsp;</a></span>InstrumentBoundCheckers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::InstrumentBoundCheckers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruments bound checkers. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="acc84aad38c2cacfae333c8970ece933d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc84aad38c2cacfae333c8970ece933d">&#9670;&nbsp;</a></span>LegalizePackedCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LegalizePackedCalls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This pass legalizes packed calls by wrapping their arguments into TVMValues </p>

</div>
</div>
<a id="a1a6050dba3ac8efbb922ce0477198ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6050dba3ac8efbb922ce0477198ab3">&#9670;&nbsp;</a></span>LiftAttrScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LiftAttrScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>attr_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift common attrs with attr_key to outer scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>The attribute key to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a17b0910c03b6f2d462448fa2725c1f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b0910c03b6f2d462448fa2725c1f5e">&#9670;&nbsp;</a></span>LoopPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LoopPartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partition loops in the stmt. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a641a33aa6ac3ec146be1196a091af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a33aa6ac3ec146be1196a091af5d5">&#9670;&nbsp;</a></span>LowerCrossThreadReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerCrossThreadReduction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross-thread reduction from thread bindings to intrinsic function calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0d6b2682a93ca4136ed4fa6d8fa7bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6b2682a93ca4136ed4fa6d8fa7bc2f">&#9670;&nbsp;</a></span>LowerCustomDatatypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerCustomDatatypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower custom datatypes. </p>
<p>See tvm::datatypes::Registry for more information on adding custom datatypes.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a53b7a3b7552ad5fa7b49e90470aff02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b7a3b7552ad5fa7b49e90470aff02b">&#9670;&nbsp;</a></span>LowerDeviceStorageAccessInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerDeviceStorageAccessInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower attached storage access information on device. </p>
<dl class="section note"><dt>Note</dt><dd>Run this pass after all storage access analysis finish.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aeaa9c663bdf10c5c596d81f8d5b6f1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa9c663bdf10c5c596d81f8d5b6f1ed">&#9670;&nbsp;</a></span>LowerInitBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerInitBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower block init stmt into <a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> stmts. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0979c9d3bf0e64205f16aa00d331c6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0979c9d3bf0e64205f16aa00d331c6b5">&#9670;&nbsp;</a></span>LowerIntrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerIntrin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower the target specific function intrinsics in each of the function. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aaf7277fb8101861053cc697a9d3aba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7277fb8101861053cc697a9d3aba1e">&#9670;&nbsp;</a></span>LowerMatchBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerMatchBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove match buffers inside the block. Also, it will validate the binding. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a16d42050efec51126d5b90eb2f60171f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d42050efec51126d5b90eb2f60171f">&#9670;&nbsp;</a></span>LowerThreadAllreduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerThreadAllreduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross thread alleduce. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8b8e7806d1a6e21b66123b3a4e255caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8e7806d1a6e21b66123b3a4e255caf">&#9670;&nbsp;</a></span>LowerTVMBuiltin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerTVMBuiltin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower builtin intrinsics. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ad5a726d95328c4e85c0c717c52aff4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a726d95328c4e85c0c717c52aff4f2">&#9670;&nbsp;</a></span>LowerWarpMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::LowerWarpMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower warp memory access to low-level device related function calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="abaf9c953f28d23408872beef5aa33af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf9c953f28d23408872beef5aa33af7">&#9670;&nbsp;</a></span>MakePackedAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MakePackedAPI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_unpacked_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to a low-level version that can be used as an API function. </p>
<p>The main task of this function is to create code to :</p><ul>
<li>Map the values in the api_args to <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> that is required by body.</li>
<li>Insert assertions to check type/value of the passed arguments.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_unpacked_args</td><td>Number of arguments that are processed in plain form instead of packed form.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function signature have two cases</dd></dl>
<p>let num_packed_args = len(api_args) - num_unpacked_args;</p>
<p>if num_packed_args is zero: f(api_arg_0, api_arg_1, .., api_arg_n) where n == len(api_args)</p>
<p>if num_packed_args is not zero: f(TVMArg* packed_args, int* packed_arg_type_ids, int num_packed_args, api_arg_k, api_arg_k+1, ... api_arg_n, TVMValue* out_ret_val, int* out_ret_tcode)</p>
<p>where n == len(api_args), k == num_packed_args</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1903620176fa71b005fd7c58656d7139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903620176fa71b005fd7c58656d7139">&#9670;&nbsp;</a></span>MakeUnpackedAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MakeUnpackedAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the high-level <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> to a C signature that can be used to call the operator directly. </p>
<p>The main task of this function is to create code that maps the values in the api_args to <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> that is required by body</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a070137dbab05c63d4af6b77c25868a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070137dbab05c63d4af6b77c25868a66">&#9670;&nbsp;</a></span>MergeDynamicSharedMemoryAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::MergeDynamicSharedMemoryAllocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pass to merge multiple TIR-level dynamic shared memory allocations into one </p>

</div>
</div>
<a id="aa97b7253e13e662adc5f9ad3367746a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97b7253e13e662adc5f9ad3367746a8">&#9670;&nbsp;</a></span>NarrowDataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::NarrowDataType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow down <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> datatype in stmt to target_bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_bits</td><td>The target bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Run this pass after storage flatten. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5ffa51908f8a4c9f7eb4321d8b92c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffa51908f8a4c9f7eb4321d8b92c234">&#9670;&nbsp;</a></span>PlanAndUpdateBufferAllocationLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::PlanAndUpdateBufferAllocationLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate the buffer allocation to the exact position (usually is the lca of buffer access). This pass will inject opaque block with alloc_buffers at the allocation site. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a36268b8988766d94b09daaa433a2e1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36268b8988766d94b09daaa433a2e1aa">&#9670;&nbsp;</a></span>PointerValueTypeRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::PointerValueTypeRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a25b5de58d543c6786325d87eaad83692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b5de58d543c6786325d87eaad83692">&#9670;&nbsp;</a></span>RemapThreadAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RemapThreadAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap the thread axis. </p>
<p>This can be used to get equivalent program which uses threadIdx.y in place of threadIdx.x by passing {"threadIdx.x": thread_axis("threadIdx.y")}</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8aad1159425e29be796562b2ec629b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aad1159425e29be796562b2ec629b10">&#9670;&nbsp;</a></span>RemoveNoOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RemoveNoOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5c670c9efcd740f2f168b62e624c8c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c670c9efcd740f2f168b62e624c8c57">&#9670;&nbsp;</a></span>RenormalizeSplitPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RenormalizeSplitPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize the split pattern from floordiv(floormod()) to floormod(floordiv()) </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a4fe43327c4454dd05b6e925577443f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe43327c4454dd05b6e925577443f49">&#9670;&nbsp;</a></span>RewriteUnsafeSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::RewriteUnsafeSelect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and rewrite unsafe select that contains memory access. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a817801e8c9488f712804d2d0b821acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817801e8c9488f712804d2d0b821acf0">&#9670;&nbsp;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::Simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run arithmetic simplifications on the statements and expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a6fdd5910b00af823071dcdddd21cd2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdd5910b00af823071dcdddd21cd2d3">&#9670;&nbsp;</a></span>SkipAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::SkipAssert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>skip assert stmt. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a4ec5dffb2a177bfd7548be4d974cba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5dffb2a177bfd7548be4d974cba71">&#9670;&nbsp;</a></span>SplitHostDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::SplitHostDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the function into a host function and device functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a778d3e1efecdff97e7bcf0e6a5406e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778d3e1efecdff97e7bcf0e6a5406e61">&#9670;&nbsp;</a></span>StorageFlatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::StorageFlatten </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache_line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_bound_attribute</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the multi-dimensional read/write to single dimensional Load/Store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_line_size</td><td>The size of CPU cache line. </td></tr>
    <tr><td class="paramname">create_bound_attribute</td><td>Whether to create bound attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass </dd></dl>

</div>
</div>
<a id="abe87b271e2c20e0ad901697f33c01d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe87b271e2c20e0ad901697f33c01d2c">&#9670;&nbsp;</a></span>StorageRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::StorageRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab19311e5b5ae82ad85ec3fdd7ea4556e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19311e5b5ae82ad85ec3fdd7ea4556e">&#9670;&nbsp;</a></span>TextureFlatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::TextureFlatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0010cbc20ee308819046d77ad58b62cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0010cbc20ee308819046d77ad58b62cf">&#9670;&nbsp;</a></span>ThreadSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::ThreadSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>storage_scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert sync between parallel read/write of shared buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage_scope</td><td>The storage scope considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aca44076eb1085d664877596a8b8587d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca44076eb1085d664877596a8b8587d4">&#9670;&nbsp;</a></span>UnifiedStaticMemoryPlanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnifiedStaticMemoryPlanner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the unified static memory planner pass that will plan for memory intra- and inter- PrimFuncs together. The pass requires all the function to be PrimFuncs including the main. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8b45a049536f7786b7821a5c1c32f0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b45a049536f7786b7821a5c1c32f0b3">&#9670;&nbsp;</a></span>UnifyThreadBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnifyThreadBinding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unify all the thread bindings for "blockIdx.x/y/z", "threadIdx.x/y/z", and "vthread.x/y/z". Before the unification, two vars that are bound to a thread axis (e.g., "threadIdx.x") use different IterVars and variables in their AttrStmts. After the unification, we use a consolidated <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> and a variable for them. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>vthread</code> is a legacy behavior that will be deprecated, though thread bindings of <code>vthread</code> are still also unified in this pass. Please use <code>vthread.x</code>, <code>vthread.y</code> and <code>vthread.z</code> instead. </dd></dl>

</div>
</div>
<a id="ab2f279e91071fa96a1edb24fa004ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f279e91071fa96a1edb24fa004ea6a">&#9670;&nbsp;</a></span>UnrollLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::UnrollLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="af3cecb50a8b8fc8021f6a87bc27587da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cecb50a8b8fc8021f6a87bc27587da">&#9670;&nbsp;</a></span>VectorizeLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VectorizeLoop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_vectorize</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower vectorization loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_vectorize</td><td>Whether vectorization is enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a70a059926c2ea81dcf437eff35f05e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a059926c2ea81dcf437eff35f05e3e">&#9670;&nbsp;</a></span>VerifyGPUCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifyGPUCode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#a53dfcb6ef7e178a83fda0bbb5dddcb39" title="Verify the correctness of a GPU code It will check the whether the amount of memory usage or the numb...">tvm::tir::VerifyGPUCode</a> </dd></dl>

</div>
</div>
<a id="a32d0b0ed966cf019d5e607bc90f284af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d0b0ed966cf019d5e607bc90f284af">&#9670;&nbsp;</a></span>VerifyMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifyMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifyMemory. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27" title="Verify if memory accesses are legal for a specific target device type. ">tvm::tir::VerifyMemory</a> </dd></dl>

</div>
</div>
<a id="ac51a104ab4d2c60a4f6ed0e827efab18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51a104ab4d2c60a4f6ed0e827efab18">&#9670;&nbsp;</a></span>VerifySSA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1transform_1_1Pass.html">Pass</a> tvm::tir::transform::VerifySSA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass variant of VerifySSA. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826" title="Verifies whether the IR stmt or Expr is in SSA form. That is: each Var is defined and assigned once(i...">tvm::tir::VerifySSA</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
