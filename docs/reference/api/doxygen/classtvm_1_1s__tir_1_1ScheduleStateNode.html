<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::s_tir::ScheduleStateNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1s__tir.html">s_tir</a></li><li class="navelem"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html">ScheduleStateNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classtvm_1_1s__tir_1_1ScheduleStateNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::s_tir::ScheduleStateNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The state of scheduling, which exposes a <code>Replace</code> method as the primary interface for all the scheduling primitives to manipulate the TensorIR.  
 <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="state_8h_source.html">state.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::s_tir::ScheduleStateNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1s__tir_1_1ScheduleStateNode__inherit__graph.svg" width="234" height="434"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::s_tir::ScheduleStateNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1s__tir_1_1ScheduleStateNode__coll__graph.svg" width="336" height="678"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedf8e64d6bb387ccb09fb5b23554716f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#aedf8e64d6bb387ccb09fb5b23554716f">Replace</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">tir::StmtSRef</a> &amp;src_sref, const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;tgt_stmt, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a>, <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &gt; &amp;block_sref_reuse)</td></tr>
<tr class="memdesc:aedf8e64d6bb387ccb09fb5b23554716f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the part of the AST, as being pointed to by <code>src_sref</code>, with a specific statement <code>tgt_stmt</code>, and maintain the sref tree accordingly. Replace will try to perform copy on write as much as possible when the <a class="el" href="classtvm_1_1s__tir_1_1ScheduleState.html" title="Managed reference to ScheduleStateNode.">ScheduleState</a> holds the only copy to the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> and IR nodes.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#aedf8e64d6bb387ccb09fb5b23554716f">More...</a><br /></td></tr>
<tr class="separator:aedf8e64d6bb387ccb09fb5b23554716f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eb8af7c4184bbf37760f63c0dcb274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a44eb8af7c4184bbf37760f63c0dcb274">DebugVerify</a> () const</td></tr>
<tr class="memdesc:a44eb8af7c4184bbf37760f63c0dcb274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the verification according to the <code>debug_mask</code> bitmask. 1) If the bitmask <code>kVerifySRefTree</code> is on, verify the correctness of the sref tree. 2) If the bitmask <code>kVerifyCachedFlags</code> is on, verify the correctness of <code>affine_binding</code>, <code>region_cover</code> and <code>stage_pipeline</code>  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a44eb8af7c4184bbf37760f63c0dcb274">More...</a><br /></td></tr>
<tr class="separator:a44eb8af7c4184bbf37760f63c0dcb274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd998b4065f83f264175729b65cf07b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#abfd998b4065f83f264175729b65cf07b">TVM_FFI_DECLARE_OBJECT_INFO_FINAL</a> (&quot;s_tir.ScheduleState&quot;, ScheduleStateNode, Object)</td></tr>
<tr class="separator:abfd998b4065f83f264175729b65cf07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ea96dfcc048198a291e040411ec86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html">SBlockInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a439ea96dfcc048198a291e040411ec86">GetSBlockInfo</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;block_sref) const</td></tr>
<tr class="memdesc:a439ea96dfcc048198a291e040411ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a> correpsonding to the block sref.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a439ea96dfcc048198a291e040411ec86">More...</a><br /></td></tr>
<tr class="separator:a439ea96dfcc048198a291e040411ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85c989ae79ff88cb0380b1c1517df6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#ac85c989ae79ff88cb0380b1c1517df6a">UpdateScopeSBlockInfo</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:ac85c989ae79ff88cb0380b1c1517df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate the <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a> recursively under stmt. If stmt is a SBlock itself, we will not reset its affine binding flag unless it doesn't have block vars, since the affine flag depends on the outer scope of stmt.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#ac85c989ae79ff88cb0380b1c1517df6a">More...</a><br /></td></tr>
<tr class="separator:ac85c989ae79ff88cb0380b1c1517df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404d1985beb148706729551cdf886933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1SBlockScope.html">SBlockScope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a404d1985beb148706729551cdf886933">GetSBlockScope</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;scope_root) const</td></tr>
<tr class="memdesc:a404d1985beb148706729551cdf886933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SBlockScope correpsonding to the sref of scope root block.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a404d1985beb148706729551cdf886933">More...</a><br /></td></tr>
<tr class="separator:a404d1985beb148706729551cdf886933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd8848e865b7047f56e334e901adc72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a3dd8848e865b7047f56e334e901adc72">IsAffineBlockBinding</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;block_sref) const</td></tr>
<tr class="memdesc:a3dd8848e865b7047f56e334e901adc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a cached flag indicating if the specific block has quasi-affine bindings.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a3dd8848e865b7047f56e334e901adc72">More...</a><br /></td></tr>
<tr class="separator:a3dd8848e865b7047f56e334e901adc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d8d5357eb18cb759f7eab287b9b1e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#af0d8d5357eb18cb759f7eab287b9b1e9">IsRegionCoveredConsumer</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;consumer_block_sref) const</td></tr>
<tr class="memdesc:af0d8d5357eb18cb759f7eab287b9b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a cached flag indicating if each of the specific consumer block's read region is fully produced by its producers.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#af0d8d5357eb18cb759f7eab287b9b1e9">More...</a><br /></td></tr>
<tr class="separator:af0d8d5357eb18cb759f7eab287b9b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be418be6ba9286b628800861962832e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a4be418be6ba9286b628800861962832e">IsStagePipeline</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;scope_root) const</td></tr>
<tr class="memdesc:a4be418be6ba9286b628800861962832e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a cached flag indicating if a block scope is an equivalence of a stage pipeline.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a4be418be6ba9286b628800861962832e">More...</a><br /></td></tr>
<tr class="separator:a4be418be6ba9286b628800861962832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a149333500fc437a361031d9ba26d0665"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a149333500fc437a361031d9ba26d0665">RegisterReflection</a> ()</td></tr>
<tr class="separator:a149333500fc437a361031d9ba26d0665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2ccdf186a36ec64934bdc2aa39770a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a2ccdf186a36ec64934bdc2aa39770a61">mod</a></td></tr>
<tr class="memdesc:a2ccdf186a36ec64934bdc2aa39770a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AST of the module being scheduled.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a2ccdf186a36ec64934bdc2aa39770a61">More...</a><br /></td></tr>
<tr class="separator:a2ccdf186a36ec64934bdc2aa39770a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f7a585bb8700310702867113c2f23"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>, <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html">SBlockInfo</a>, ObjectPtrHash, ObjectPtrEqual &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a469f7a585bb8700310702867113c2f23">block_info</a></td></tr>
<tr class="memdesc:a469f7a585bb8700310702867113c2f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from a block sref to its correpsonding <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a>, tracking the dependency inside the block scope, and storing necessary information flags for scheduling.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a469f7a585bb8700310702867113c2f23">More...</a><br /></td></tr>
<tr class="separator:a469f7a585bb8700310702867113c2f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeed4aa57a07dae1d146c487ccbf7df9"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#aeeed4aa57a07dae1d146c487ccbf7df9">stmt2ref</a></td></tr>
<tr class="memdesc:aeeed4aa57a07dae1d146c487ccbf7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse mapping from block/for-loop to their corresponding srefs.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#aeeed4aa57a07dae1d146c487ccbf7df9">More...</a><br /></td></tr>
<tr class="separator:aeeed4aa57a07dae1d146c487ccbf7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc563e357652a4fa0e7e764e11e91d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a5fc563e357652a4fa0e7e764e11e91d0">debug_mask</a></td></tr>
<tr class="memdesc:a5fc563e357652a4fa0e7e764e11e91d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do extra correctness checking after the class creation and each time after calling the Replace method.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a5fc563e357652a4fa0e7e764e11e91d0">More...</a><br /></td></tr>
<tr class="separator:a5fc563e357652a4fa0e7e764e11e91d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c085a1632f3e1e3b991c4d45456880f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a7c085a1632f3e1e3b991c4d45456880f">enable_check</a></td></tr>
<tr class="memdesc:a7c085a1632f3e1e3b991c4d45456880f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to enable prequisite checks for schedule primitives.  <a href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a7c085a1632f3e1e3b991c4d45456880f">More...</a><br /></td></tr>
<tr class="separator:a7c085a1632f3e1e3b991c4d45456880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4607d29bec37b28f48287407b32686a8"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html#a4607d29bec37b28f48287407b32686a8">_type_mutable</a> = true</td></tr>
<tr class="separator:a4607d29bec37b28f48287407b32686a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The state of scheduling, which exposes a <code>Replace</code> method as the primary interface for all the scheduling primitives to manipulate the TensorIR. </p>
<p>The data structure contains the following information 1) The AST being scheduled (mod) 2) The sref tree of schedulable statements (indicated by the srefs) 3) The dependency information of each block scope (block_info) 4) A reverse mapping from the AST nodes to that in the sref tree (stmt2ref) 5) A debug flag, if set, extra checking is enabled (debug_mask) 6) A check flag, if set, enable prequisite check for schedule primitives (enable_check) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a44eb8af7c4184bbf37760f63c0dcb274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eb8af7c4184bbf37760f63c0dcb274">&#9670;&nbsp;</a></span>DebugVerify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::s_tir::ScheduleStateNode::DebugVerify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger the verification according to the <code>debug_mask</code> bitmask. 1) If the bitmask <code>kVerifySRefTree</code> is on, verify the correctness of the sref tree. 2) If the bitmask <code>kVerifyCachedFlags</code> is on, verify the correctness of <code>affine_binding</code>, <code>region_cover</code> and <code>stage_pipeline</code> </p>

</div>
</div>
<a id="a439ea96dfcc048198a291e040411ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ea96dfcc048198a291e040411ec86">&#9670;&nbsp;</a></span>GetSBlockInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html">SBlockInfo</a> tvm::s_tir::ScheduleStateNode::GetSBlockInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>block_sref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a> correpsonding to the block sref. </p>

</div>
</div>
<a id="a404d1985beb148706729551cdf886933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404d1985beb148706729551cdf886933">&#9670;&nbsp;</a></span>GetSBlockScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1SBlockScope.html">SBlockScope</a> tvm::s_tir::ScheduleStateNode::GetSBlockScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the SBlockScope correpsonding to the sref of scope root block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope_root</td><td>The block sref to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding SBlockScope </dd></dl>

</div>
</div>
<a id="a3dd8848e865b7047f56e334e901adc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd8848e865b7047f56e334e901adc72">&#9670;&nbsp;</a></span>IsAffineBlockBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::s_tir::ScheduleStateNode::IsAffineBlockBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>block_sref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a cached flag indicating if the specific block has quasi-affine bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_sref</td><td>The block sref to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean flag indicating if the block has quasi-affine bindings </dd></dl>

</div>
</div>
<a id="af0d8d5357eb18cb759f7eab287b9b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d8d5357eb18cb759f7eab287b9b1e9">&#9670;&nbsp;</a></span>IsRegionCoveredConsumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::s_tir::ScheduleStateNode::IsRegionCoveredConsumer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer_block_sref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a cached flag indicating if each of the specific consumer block's read region is fully produced by its producers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer_block_sref</td><td>The specific consumer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean flag indicating if the block has quasi-affine bindings </dd></dl>

</div>
</div>
<a id="a4be418be6ba9286b628800861962832e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be418be6ba9286b628800861962832e">&#9670;&nbsp;</a></span>IsStagePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::s_tir::ScheduleStateNode::IsStagePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a cached flag indicating if a block scope is an equivalence of a stage pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope_root</td><td>The block sref to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding SBlockScope </dd></dl>

</div>
</div>
<a id="a149333500fc437a361031d9ba26d0665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149333500fc437a361031d9ba26d0665">&#9670;&nbsp;</a></span>RegisterReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tvm::s_tir::ScheduleStateNode::RegisterReflection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf8e64d6bb387ccb09fb5b23554716f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf8e64d6bb387ccb09fb5b23554716f">&#9670;&nbsp;</a></span>Replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::s_tir::ScheduleStateNode::Replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">tir::StmtSRef</a> &amp;&#160;</td>
          <td class="paramname"><em>src_sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>tgt_stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a>, <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sref_reuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the part of the AST, as being pointed to by <code>src_sref</code>, with a specific statement <code>tgt_stmt</code>, and maintain the sref tree accordingly. Replace will try to perform copy on write as much as possible when the <a class="el" href="classtvm_1_1s__tir_1_1ScheduleState.html" title="Managed reference to ScheduleStateNode.">ScheduleState</a> holds the only copy to the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> and IR nodes. </p>
<p>Only 3 types of replacements are allowed: from <code>src_sref-&gt;stmt</code> to <code>tgt_stmt</code>. 1) SBlock -&gt; SBlock 2) Loop -&gt; Loop 3) Loop -&gt; SBlockRealize</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_sref</td><td>The sref to the statement to be replaced </td></tr>
    <tr><td class="paramname">tgt_stmt</td><td>The statement to be replaced in </td></tr>
    <tr><td class="paramname">block_sref_reuse</td><td>Maps an old block (to be replaced in the subtree under <code>src_sref-&gt;stmt</code>) to a new block (replaced to, in the subtree under <code>tgt_stmt</code>), and enforces reuse of srefs between them (rather than create new srefs) i.e. after being replaced, the sref that points to the old block will point to the new one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The reuse of loop srefs are detected automatically according to the reuse of loop vars. </dd></dl>

</div>
</div>
<a id="abfd998b4065f83f264175729b65cf07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd998b4065f83f264175729b65cf07b">&#9670;&nbsp;</a></span>TVM_FFI_DECLARE_OBJECT_INFO_FINAL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::s_tir::ScheduleStateNode::TVM_FFI_DECLARE_OBJECT_INFO_FINAL </td>
          <td>(</td>
          <td class="paramtype">&quot;s_tir.ScheduleState&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleStateNode.html">ScheduleStateNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Object&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85c989ae79ff88cb0380b1c1517df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85c989ae79ff88cb0380b1c1517df6a">&#9670;&nbsp;</a></span>UpdateScopeSBlockInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::s_tir::ScheduleStateNode::UpdateScopeSBlockInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate the <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a> recursively under stmt. If stmt is a SBlock itself, we will not reset its affine binding flag unless it doesn't have block vars, since the affine flag depends on the outer scope of stmt. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4607d29bec37b28f48287407b32686a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4607d29bec37b28f48287407b32686a8">&#9670;&nbsp;</a></span>_type_mutable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool tvm::s_tir::ScheduleStateNode::_type_mutable = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a469f7a585bb8700310702867113c2f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f7a585bb8700310702867113c2f23">&#9670;&nbsp;</a></span>block_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>, <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html">SBlockInfo</a>, ObjectPtrHash, ObjectPtrEqual&gt; tvm::s_tir::ScheduleStateNode::block_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from a block sref to its correpsonding <a class="el" href="structtvm_1_1s__tir_1_1SBlockInfo.html" title="The information about a TensorIR block, it contains two categories of information 1) Info on the bloc...">SBlockInfo</a>, tracking the dependency inside the block scope, and storing necessary information flags for scheduling. </p>

</div>
</div>
<a id="a5fc563e357652a4fa0e7e764e11e91d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc563e357652a4fa0e7e764e11e91d0">&#9670;&nbsp;</a></span>debug_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::s_tir::ScheduleStateNode::debug_mask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do extra correctness checking after the class creation and each time after calling the Replace method. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1s__tir.html#a4bc9a20893458a914d48dbf732567ad9" title="The bitmask of the debug flag in the ScheduleStateNode.">ScheduleDebugMask</a> </dd></dl>

</div>
</div>
<a id="a7c085a1632f3e1e3b991c4d45456880f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c085a1632f3e1e3b991c4d45456880f">&#9670;&nbsp;</a></span>enable_check</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::s_tir::ScheduleStateNode::enable_check</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to enable prequisite checks for schedule primitives. </p>

</div>
</div>
<a id="a2ccdf186a36ec64934bdc2aa39770a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccdf186a36ec64934bdc2aa39770a61">&#9670;&nbsp;</a></span>mod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a> tvm::s_tir::ScheduleStateNode::mod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The AST of the module being scheduled. </p>

</div>
</div>
<a id="aeeed4aa57a07dae1d146c487ccbf7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeed4aa57a07dae1d146c487ccbf7df9">&#9670;&nbsp;</a></span>stmt2ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a>*, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&gt; tvm::s_tir::ScheduleStateNode::stmt2ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reverse mapping from block/for-loop to their corresponding srefs. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/s_tir/schedule/<a class="el" href="state_8h_source.html">state.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
