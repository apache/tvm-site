<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::runtime Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1runtime.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::runtime Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1cuda__ipc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1cuda__ipc.html">cuda_ipc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1memory"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1memory.html">memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1profiling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1profiling.html">profiling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1symbol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1symbol.html">symbol</a></td></tr>
<tr class="memdesc:namespacetvm_1_1runtime_1_1symbol"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for constant symbols <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1threading"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1threading.html">threading</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1vm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1vm.html">vm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime primitive data type.  <a href="classtvm_1_1runtime_1_1DataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DeviceAPI.html">DeviceAPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TVM Runtime Device API, abstracts the device specific interface for memory management.  <a href="classtvm_1_1runtime_1_1DeviceAPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DiscoWorker.html">DiscoWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker in Disco. It takes a channel to communication with the controler. The worker can be run in a separate thread or process as long as the channel supports bi-directional communication in-between.  <a href="classtvm_1_1runtime_1_1DiscoWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ThreadLocalDiscoWorker.html">ThreadLocalDiscoWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A threadlocal wrapper of <a class="el" href="classtvm_1_1runtime_1_1DiscoWorker.html" title="A worker in Disco. It takes a channel to communication with the controler. The worker can be run in a...">DiscoWorker</a>.  <a href="structtvm_1_1runtime_1_1ThreadLocalDiscoWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DRefObj.html">DRefObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that exists on all workers.  <a href="classtvm_1_1runtime_1_1DRefObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DRef.html">DRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1runtime_1_1DRefObj.html" title="An object that exists on all workers.">DRefObj</a>.  <a href="classtvm_1_1runtime_1_1DRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SessionObj.html">SessionObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Disco interactive session. It allows users to interact with the Disco command queue with various ffi::Function calling convention.  <a href="classtvm_1_1runtime_1_1SessionObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Session.html">Session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1runtime_1_1SessionObj.html" title="A Disco interactive session. It allows users to interact with the Disco command queue with various ff...">SessionObj</a>.  <a href="classtvm_1_1runtime_1_1Session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DiscoChannel.html">DiscoChannel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bi-directional channel for controler-worker communication. This channel is primarily used to transfer control messages but not data.  <a href="classtvm_1_1runtime_1_1DiscoChannel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1WorkerZeroData.html">WorkerZeroData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special communication channel between controler and worker-0, assuming they are always collocated in the same process.  <a href="classtvm_1_1runtime_1_1WorkerZeroData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1NVTXScopedRange.html">NVTXScopedRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to create a NVTX range. No-op if TVM is not built against NVTX.  <a href="classtvm_1_1runtime_1_1NVTXScopedRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TimerNode.html">TimerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all implementations.  <a href="classtvm_1_1runtime_1_1TimerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Timer.html" title="Timer for a specific device.">Timer</a> for a specific device.  <a href="classtvm_1_1runtime_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a>. The array is backed by reference counted blocks.  <a href="classtvm_1_1runtime_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a953860c249ea5d75326dc8f2928491ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a953860c249ea5d75326dc8f2928491ea">tvm_index_t</a> = ffi::Shape::index_type</td></tr>
<tr class="separator:a953860c249ea5d75326dc8f2928491ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc84b8d3a671ceb4f490cad57283d732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adc84b8d3a671ceb4f490cad57283d732">IntTuple</a> = ffi::Shape</td></tr>
<tr class="separator:adc84b8d3a671ceb4f490cad57283d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7ddcf5d6725600b62b7783e4ac507e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adc7ddcf5d6725600b62b7783e4ac507e">IntTupleObj</a> = ffi::ShapeObj</td></tr>
<tr class="separator:adc7ddcf5d6725600b62b7783e4ac507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a237ec21eda9c03c495db5ce0da0f849d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a237ec21eda9c03c495db5ce0da0f849d">TVMDeviceExtType</a> { <a class="el" href="namespacetvm_1_1runtime.html#a237ec21eda9c03c495db5ce0da0f849da988c9df9b3f4e94e793e3e6dce05bb9c">TVMDeviceExtType_End</a> = 36
 }</td></tr>
<tr class="memdesc:a237ec21eda9c03c495db5ce0da0f849d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension device types in TVM.  <a href="namespacetvm_1_1runtime.html#a237ec21eda9c03c495db5ce0da0f849d">More...</a><br /></td></tr>
<tr class="separator:a237ec21eda9c03c495db5ce0da0f849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">DeviceAttrKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb">kExist</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4">kMaxThreadsPerBlock</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da">kWarpSize</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264">kMaxSharedMemoryPerBlock</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b">kComputeVersion</a> = 4
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca">kDeviceName</a> = 5
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630">kMaxClockRate</a> = 6
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd">kMultiProcessorCount</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991">kMaxThreadDimensions</a> = 8
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357">kMaxRegistersPerBlock</a> = 9
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201">kGcnArch</a> = 10
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337">kApiVersion</a> = 11
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9">kDriverVersion</a> = 12
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afebd0fa20dbcf8f5fe6b31f7bdfb7496">kL2CacheSizeBytes</a> = 13
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aaefa5c35ec7a4ef2fab9d26949b3de12">kTotalGlobalMemory</a> = 14
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ab5557051e97fe70b60484ce6589f91de">kAvailableGlobalMemory</a> = 15
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a72d56bdb4e70760379da4a19d6477735">kImagePitchAlignment</a> = 16
<br />
 }</td></tr>
<tr class="memdesc:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="mdescLeft">&#160;</td><td class="mdescRight">the query type into GetAttr  <a href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">More...</a><br /></td></tr>
<tr class="separator:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebb65e06d120de112c54fdcd10c27d7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa1dc5fbfa16754d1e628d66381725617">kSum</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7a4eef5c699751ff1b31a7fcc194b28a88">kProd</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7a8fbc2f6c44a6d70550df79903eb57d48">kMin</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa0b1ac8aae6b1cfbbe89085c642b3b4b">kMax</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa22c1525680159c49e69ff9c43d1d01b">kAvg</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a9ebb65e06d120de112c54fdcd10c27d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible kinds of reduction operations.  <a href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">More...</a><br /></td></tr>
<tr class="separator:a9ebb65e06d120de112c54fdcd10c27d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba6565e739bed4d5078c2ff998deae8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aff48289104dbc943d0354379e43f7e5f">kShutDown</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8ad6aaaf2cb07d224d5aed793c09a777ef">kKillReg</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8abd597f33da21ed3ec14131295daab521">kGetGlobalFunc</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aeab0582e669357bc410678d34b50178f">kCallPacked</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8ac4e6997e9ed12a3933fa5ab71fc364ef">kSyncWorker</a> = 4
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8a3bc0e63927f289f5a8956e0c2c791cea">kCopyFromWorker0</a> = 5
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8affb0ed964f1001fecda2ea2e8ac90bea">kCopyToWorker0</a> = 6
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aa9e0e3dadb4ecfc65792001a864b868a">kDebugGetFromRemote</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8a08f61e83ccd56e0950d9b9b36d6f1a15">kDebugSetRegister</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a4ba6565e739bed4d5078c2ff998deae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">All possible kinds of Disco commands.  <a href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">More...</a><br /></td></tr>
<tr class="separator:a4ba6565e739bed4d5078c2ff998deae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc320dbf7396f349bb015aec34a3b3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3f">TypeIndex</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3faf5474ebdbaaa19e977334eefa4bbd611">kRuntimeModule</a> = TVMFFITypeIndex::kTVMFFIModule
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa784a020f84753e81d49cd6212ca97457">kRuntimeTensor</a> = TVMFFITypeIndex::kTVMFFITensor
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa88cf741bfe2461e6b9a718b4ceb13c61">kRuntimeShape</a> = TVMFFITypeIndex::kTVMFFIShape
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fabd14026b3a03064fa001caf5db19a1e9">kCustomStaticIndex</a> = TVMFFITypeIndex::kTVMFFIDynObjectBegin - 16
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa64c2fe96f9710738e921eba9a0647043">kRuntimePackedFunc</a> = kCustomStaticIndex + 1
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa149e3537240d5889283fb48769bbb856">kRuntimeDiscoDRef</a> = kCustomStaticIndex + 2
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fabc94c22e14c33b9be181f00c0be9620b">kRuntimeRPCObjectRef</a> = kCustomStaticIndex + 3
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fabcee6d9c2e81240077eaf3ee3775e36f">kRuntimeString</a>
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa2a1e3d7c7627236861336275102881e1">kRuntimeMap</a>
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3faa89514ac36216daf735627790247c945">kRuntimeArray</a>
, <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3fa548302094bc9afb6bb14dc2a283c1014">kStaticIndexEnd</a>
<br />
 }</td></tr>
<tr class="memdesc:abfc320dbf7396f349bb015aec34a3b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the list of type index.  <a href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3f">More...</a><br /></td></tr>
<tr class="separator:abfc320dbf7396f349bb015aec34a3b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad01a53416152b68029d67190c3709d25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">GetVectorBytes</a> (<a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype)</td></tr>
<tr class="memdesc:ad01a53416152b68029d67190c3709d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes needed in a vector.  <a href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">More...</a><br /></td></tr>
<tr class="separator:ad01a53416152b68029d67190c3709d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">TypeMatch</a> (DLDataType t, int code, int bits, int lanes=1)</td></tr>
<tr class="memdesc:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether type matches the given spec.  <a href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">More...</a><br /></td></tr>
<tr class="separator:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee574cee6755b0c2f1aa664c6967686f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">TypeEqual</a> (DLDataType lhs, DLDataType rhs)</td></tr>
<tr class="memdesc:aee574cee6755b0c2f1aa664c6967686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two types are equal .  <a href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">More...</a><br /></td></tr>
<tr class="separator:aee574cee6755b0c2f1aa664c6967686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d447b7bdac52d26bca3422fe098f6f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59d447b7bdac52d26bca3422fe098f6f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;dtype)</td></tr>
<tr class="separator:a59d447b7bdac52d26bca3422fe098f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1fa64a5babbd1f199e4c14f1d90ed5dc">DLDeviceType2Str</a> (int type)</td></tr>
<tr class="memdesc:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of DLDeviceType.  <a href="namespacetvm_1_1runtime.html#a1fa64a5babbd1f199e4c14f1d90ed5dc">More...</a><br /></td></tr>
<tr class="separator:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f13cd8047078f88d142fe53337ba6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa5f13cd8047078f88d142fe53337ba6f">IsRPCSessionDevice</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:aa5f13cd8047078f88d142fe53337ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a Device is owned by an RPC session.  <a href="namespacetvm_1_1runtime.html#aa5f13cd8047078f88d142fe53337ba6f">More...</a><br /></td></tr>
<tr class="separator:aa5f13cd8047078f88d142fe53337ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d284249899038cca33c40d97eefa1e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8d284249899038cca33c40d97eefa1e3">GetRPCSessionIndex</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:a8d284249899038cca33c40d97eefa1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RPCSessTable index of the RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> that owns this device.  <a href="namespacetvm_1_1runtime.html#a8d284249899038cca33c40d97eefa1e3">More...</a><br /></td></tr>
<tr class="separator:a8d284249899038cca33c40d97eefa1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32398517b6b915361c5716f8e32c16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af32398517b6b915361c5716f8e32c16f">RemoveRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:af32398517b6b915361c5716f8e32c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation.  <a href="namespacetvm_1_1runtime.html#af32398517b6b915361c5716f8e32c16f">More...</a><br /></td></tr>
<tr class="separator:af32398517b6b915361c5716f8e32c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b70cf1ffccb2b7737d26cccb4103d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a06b70cf1ffccb2b7737d26cccb4103d8">operator&lt;&lt;</a> (std::ostream &amp;os, DLDevice dev)</td></tr>
<tr class="separator:a06b70cf1ffccb2b7737d26cccb4103d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa93f6c733bf54ca19d642a5ae2ec94be">AddRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev, int session_table_index)</td></tr>
<tr class="memdesc:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote.  <a href="namespacetvm_1_1runtime.html#aa93f6c733bf54ca19d642a5ae2ec94be">More...</a><br /></td></tr>
<tr class="separator:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3467a4ef36085dc8262601478a70869a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a3467a4ef36085dc8262601478a70869a">ReduceKind2String</a> (<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> kind)</td></tr>
<tr class="memdesc:a3467a4ef36085dc8262601478a70869a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>ReduceKind</code> to string.  <a href="namespacetvm_1_1runtime.html#a3467a4ef36085dc8262601478a70869a">More...</a><br /></td></tr>
<tr class="separator:a3467a4ef36085dc8262601478a70869a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c22d3ea92d51e43bb2916f72d32354"><td class="memItemLeft" align="right" valign="top">ffi::Module&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a25c22d3ea92d51e43bb2916f72d32354">LoadVMModule</a> (std::string path, Optional&lt; <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> &gt; device)</td></tr>
<tr class="memdesc:a25c22d3ea92d51e43bb2916f72d32354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a runtime Module, then create and initialize a RelaxVM.  <a href="namespacetvm_1_1runtime.html#a25c22d3ea92d51e43bb2916f72d32354">More...</a><br /></td></tr>
<tr class="separator:a25c22d3ea92d51e43bb2916f72d32354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c601b4310b125cc2d8502e0673ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aba8c601b4310b125cc2d8502e0673ff9">DiscoEmptyTensor</a> (ffi::Shape shape, <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype, Optional&lt; <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> &gt; device)</td></tr>
<tr class="memdesc:aba8c601b4310b125cc2d8502e0673ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialized empty <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a>.  <a href="namespacetvm_1_1runtime.html#aba8c601b4310b125cc2d8502e0673ff9">More...</a><br /></td></tr>
<tr class="separator:aba8c601b4310b125cc2d8502e0673ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1da94a59b5e1aabd4b25e924f03a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abc1da94a59b5e1aabd4b25e924f03a3b">AllReduce</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> send, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> reduce_kind, bool in_group, <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> recv)</td></tr>
<tr class="memdesc:abc1da94a59b5e1aabd4b25e924f03a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an allreduce operation using the underlying communication library.  <a href="namespacetvm_1_1runtime.html#abc1da94a59b5e1aabd4b25e924f03a3b">More...</a><br /></td></tr>
<tr class="separator:abc1da94a59b5e1aabd4b25e924f03a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96852bde59aaae38b18eac0af0f2e2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a96852bde59aaae38b18eac0af0f2e2a4">AllGather</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> send, bool in_group, <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> recv)</td></tr>
<tr class="memdesc:a96852bde59aaae38b18eac0af0f2e2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an allgather operation using the underlying communication library.  <a href="namespacetvm_1_1runtime.html#a96852bde59aaae38b18eac0af0f2e2a4">More...</a><br /></td></tr>
<tr class="separator:a96852bde59aaae38b18eac0af0f2e2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae652e519d320f656c0106492239f25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aae652e519d320f656c0106492239f25e">BroadcastFromWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> send, bool in_group, <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> recv)</td></tr>
<tr class="memdesc:aae652e519d320f656c0106492239f25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a broadcast operation from worker-0.  <a href="namespacetvm_1_1runtime.html#aae652e519d320f656c0106492239f25e">More...</a><br /></td></tr>
<tr class="separator:aae652e519d320f656c0106492239f25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da16f59a809d09353bed2d49318d8bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4da16f59a809d09353bed2d49318d8bf">ScatterFromWorker0</a> (Optional&lt; <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> &gt; send, bool in_group, <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> recv)</td></tr>
<tr class="memdesc:a4da16f59a809d09353bed2d49318d8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a scatter operation from worker-0, chunking the given buffer into equal parts.  <a href="namespacetvm_1_1runtime.html#a4da16f59a809d09353bed2d49318d8bf">More...</a><br /></td></tr>
<tr class="separator:a4da16f59a809d09353bed2d49318d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc0c96a9b7920852cc71d8ae437d7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afdc0c96a9b7920852cc71d8ae437d7a3">GatherToWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> send, bool in_group, Optional&lt; <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> &gt; recv)</td></tr>
<tr class="memdesc:afdc0c96a9b7920852cc71d8ae437d7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a gather operation to worker-0.  <a href="namespacetvm_1_1runtime.html#afdc0c96a9b7920852cc71d8ae437d7a3">More...</a><br /></td></tr>
<tr class="separator:afdc0c96a9b7920852cc71d8ae437d7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f43bb654214a0e4233ea57a891a1070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2f43bb654214a0e4233ea57a891a1070">RecvFromWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> buffer)</td></tr>
<tr class="memdesc:a2f43bb654214a0e4233ea57a891a1070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a buffer from worker-0. No-op if the current worker is worker-0.  <a href="namespacetvm_1_1runtime.html#a2f43bb654214a0e4233ea57a891a1070">More...</a><br /></td></tr>
<tr class="separator:a2f43bb654214a0e4233ea57a891a1070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c688aa578b4f81d2c296326911d79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a30c688aa578b4f81d2c296326911d79f">SendToNextGroup</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> buffer)</td></tr>
<tr class="memdesc:a30c688aa578b4f81d2c296326911d79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a buffer to the corresponding worker in the next group. An error is thrown if the worker is already in the last group.  <a href="namespacetvm_1_1runtime.html#a30c688aa578b4f81d2c296326911d79f">More...</a><br /></td></tr>
<tr class="separator:a30c688aa578b4f81d2c296326911d79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fe6a7db3d574b8d746328fade5fb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a49fe6a7db3d574b8d746328fade5fb4e">RecvFromPrevGroup</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> buffer)</td></tr>
<tr class="memdesc:a49fe6a7db3d574b8d746328fade5fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a buffer from the corresponding worker in the previous group. An error is thrown if the worker is already in the first group.  <a href="namespacetvm_1_1runtime.html#a49fe6a7db3d574b8d746328fade5fb4e">More...</a><br /></td></tr>
<tr class="separator:a49fe6a7db3d574b8d746328fade5fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c09a342e05638d11892c8656087bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a04c09a342e05638d11892c8656087bf4">SendToWorker</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> buffer, int receiver_id)</td></tr>
<tr class="memdesc:a04c09a342e05638d11892c8656087bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a buffer to the target receiver worker (globally across all groups).  <a href="namespacetvm_1_1runtime.html#a04c09a342e05638d11892c8656087bf4">More...</a><br /></td></tr>
<tr class="separator:a04c09a342e05638d11892c8656087bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe6730e5a6f87015b9c1f512a7a3d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aebe6730e5a6f87015b9c1f512a7a3d0c">RecvFromWorker</a> (<a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> buffer, int sender_id)</td></tr>
<tr class="memdesc:aebe6730e5a6f87015b9c1f512a7a3d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a buffer from the target sender worker (globally across all groups).  <a href="namespacetvm_1_1runtime.html#aebe6730e5a6f87015b9c1f512a7a3d0c">More...</a><br /></td></tr>
<tr class="separator:aebe6730e5a6f87015b9c1f512a7a3d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11d7c335ce64b50b3e6cee085d55c8fc">WorkerId</a> ()</td></tr>
<tr class="memdesc:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local worker id.  <a href="namespacetvm_1_1runtime.html#a11d7c335ce64b50b3e6cee085d55c8fc">More...</a><br /></td></tr>
<tr class="separator:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f369b9882f8ec57826acd5f86c4404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a65f369b9882f8ec57826acd5f86c4404">SyncWorker</a> ()</td></tr>
<tr class="memdesc:a65f369b9882f8ec57826acd5f86c4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the worker thread. Waiting until the worker completes all its tasks. As a specific example, on a CUDA worker, it blocks until all kernels are launched and cudaStreamSynchronize is complete.  <a href="namespacetvm_1_1runtime.html#a65f369b9882f8ec57826acd5f86c4404">More...</a><br /></td></tr>
<tr class="separator:a65f369b9882f8ec57826acd5f86c4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3703032b26941b2dc4a6660d7dcc14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0c3703032b26941b2dc4a6660d7dcc14">DiscoAction2String</a> (<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a> action)</td></tr>
<tr class="memdesc:a0c3703032b26941b2dc4a6660d7dcc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the enum class <code>DiscoAction</code> to string.  <a href="namespacetvm_1_1runtime.html#a0c3703032b26941b2dc4a6660d7dcc14">More...</a><br /></td></tr>
<tr class="separator:a0c3703032b26941b2dc4a6660d7dcc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ae6d933eb1e7414afa9a9a62d22cd2522">RuntimeEnabled</a> (const String &amp;target)</td></tr>
<tr class="memdesc:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if runtime module is enabled for target.  <a href="namespacetvm_1_1runtime.html#ae6d933eb1e7414afa9a9a62d22cd2522">More...</a><br /></td></tr>
<tr class="separator:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab69f2cbb94a9c579ee870ca7f186cf10">DefaultTimer</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timer if one does not exist for the device.  <a href="namespacetvm_1_1runtime.html#ab69f2cbb94a9c579ee870ca7f186cf10">More...</a><br /></td></tr>
<tr class="separator:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">SaveDLTensor</a> (dmlc::Stream *strm, const DLTensor *tensor)</td></tr>
<tr class="memdesc:a8fb37910dcd9bb6899e6a3a47f006514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a DLTensor to stream.  <a href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">More...</a><br /></td></tr>
<tr class="separator:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80916ee2a125355bc25dbd5a60c39164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a80916ee2a125355bc25dbd5a60c39164">GetPreferredHostDevice</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device)</td></tr>
<tr class="memdesc:a80916ee2a125355bc25dbd5a60c39164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the preferred host device from the input device.  <a href="namespacetvm_1_1runtime.html#a80916ee2a125355bc25dbd5a60c39164">More...</a><br /></td></tr>
<tr class="separator:a80916ee2a125355bc25dbd5a60c39164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0ec7f78231f4bf6c16188f87d98283a1">parallel_for_with_threading_backend</a> (T flambda, int64_t begin, int64_t end)</td></tr>
<tr class="separator:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac8a77303649fb143634796b3dc50a286"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">kAllocAlignment</a> = 64</td></tr>
<tr class="memdesc:ac8a77303649fb143634796b3dc50a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to.  <a href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">More...</a><br /></td></tr>
<tr class="separator:ac8a77303649fb143634796b3dc50a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">kTempAllocaAlignment</a> = 64</td></tr>
<tr class="memdesc:a8f5819cabea098a1818cf7cda40fdb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to in temporary allocation.  <a href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">More...</a><br /></td></tr>
<tr class="separator:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">kMaxStackAlloca</a> = 1024</td></tr>
<tr class="memdesc:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size that can be allocated on stack.  <a href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">More...</a><br /></td></tr>
<tr class="separator:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a551bab1e24e2e794f8ccd4446b63a7af">kDefaultWorkspaceAlignment</a> = 1</td></tr>
<tr class="memdesc:a551bab1e24e2e794f8ccd4446b63a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors.  <a href="namespacetvm_1_1runtime.html#a551bab1e24e2e794f8ccd4446b63a7af">More...</a><br /></td></tr>
<tr class="separator:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">kRPCSessMask</a> = 128</td></tr>
<tr class="memdesc:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type bigger than this is RPC device.  <a href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">More...</a><br /></td></tr>
<tr class="separator:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7511f3f3acbee3d3aca5d432e294c1"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aed7511f3f3acbee3d3aca5d432e294c1">kTVMTensorMagic</a> = 0xDD5E40F096B4A13F</td></tr>
<tr class="memdesc:aed7511f3f3acbee3d3aca5d432e294c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> file.  <a href="namespacetvm_1_1runtime.html#aed7511f3f3acbee3d3aca5d432e294c1">More...</a><br /></td></tr>
<tr class="separator:aed7511f3f3acbee3d3aca5d432e294c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc84b8d3a671ceb4f490cad57283d732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc84b8d3a671ceb4f490cad57283d732">&#9670;&nbsp;</a></span>IntTuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#adc84b8d3a671ceb4f490cad57283d732">tvm::runtime::IntTuple</a> = typedef ffi::Shape</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc7ddcf5d6725600b62b7783e4ac507e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7ddcf5d6725600b62b7783e4ac507e">&#9670;&nbsp;</a></span>IntTupleObj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#adc7ddcf5d6725600b62b7783e4ac507e">tvm::runtime::IntTupleObj</a> = typedef ffi::ShapeObj</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a953860c249ea5d75326dc8f2928491ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953860c249ea5d75326dc8f2928491ea">&#9670;&nbsp;</a></span>tvm_index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#a953860c249ea5d75326dc8f2928491ea">tvm::runtime::tvm_index_t</a> = typedef ffi::Shape::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a46fef1ca0ccc05473e9bb0a8c6b66619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fef1ca0ccc05473e9bb0a8c6b66619">&#9670;&nbsp;</a></span>DeviceAttrKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">tvm::runtime::DeviceAttrKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the query type into GetAttr </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb"></a>kExist&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4"></a>kMaxThreadsPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da"></a>kWarpSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264"></a>kMaxSharedMemoryPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b"></a>kComputeVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca"></a>kDeviceName&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630"></a>kMaxClockRate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd"></a>kMultiProcessorCount&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991"></a>kMaxThreadDimensions&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357"></a>kMaxRegistersPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201"></a>kGcnArch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337"></a>kApiVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9"></a>kDriverVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619afebd0fa20dbcf8f5fe6b31f7bdfb7496"></a>kL2CacheSizeBytes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619aaefa5c35ec7a4ef2fab9d26949b3de12"></a>kTotalGlobalMemory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ab5557051e97fe70b60484ce6589f91de"></a>kAvailableGlobalMemory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a72d56bdb4e70760379da4a19d6477735"></a>kImagePitchAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4ba6565e739bed4d5078c2ff998deae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba6565e739bed4d5078c2ff998deae8">&#9670;&nbsp;</a></span>DiscoAction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">tvm::runtime::DiscoAction</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All possible kinds of Disco commands. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aff48289104dbc943d0354379e43f7e5f"></a>kShutDown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8ad6aaaf2cb07d224d5aed793c09a777ef"></a>kKillReg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8abd597f33da21ed3ec14131295daab521"></a>kGetGlobalFunc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aeab0582e669357bc410678d34b50178f"></a>kCallPacked&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8ac4e6997e9ed12a3933fa5ab71fc364ef"></a>kSyncWorker&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8a3bc0e63927f289f5a8956e0c2c791cea"></a>kCopyFromWorker0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8affb0ed964f1001fecda2ea2e8ac90bea"></a>kCopyToWorker0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aa9e0e3dadb4ecfc65792001a864b868a"></a>kDebugGetFromRemote&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8a08f61e83ccd56e0950d9b9b36d6f1a15"></a>kDebugSetRegister&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9ebb65e06d120de112c54fdcd10c27d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebb65e06d120de112c54fdcd10c27d7">&#9670;&nbsp;</a></span>ReduceKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">tvm::runtime::ReduceKind</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible kinds of reduction operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa1dc5fbfa16754d1e628d66381725617"></a>kSum&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7a4eef5c699751ff1b31a7fcc194b28a88"></a>kProd&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7a8fbc2f6c44a6d70550df79903eb57d48"></a>kMin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa0b1ac8aae6b1cfbbe89085c642b3b4b"></a>kMax&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa22c1525680159c49e69ff9c43d1d01b"></a>kAvg&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a237ec21eda9c03c495db5ce0da0f849d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ec21eda9c03c495db5ce0da0f849d">&#9670;&nbsp;</a></span>TVMDeviceExtType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a237ec21eda9c03c495db5ce0da0f849d">tvm::runtime::TVMDeviceExtType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extension device types in TVM. </p>
<p>Additional enumerators to supplement those provided by DLPack's <code>DLDeviceType</code> enumeration.</p>
<p>MAINTAINERS NOTE #1: We need to ensure that the two devices are identified by the same integer. Currently this requires manual verification. Discussed here: <a href="https://github.com/dmlc/dlpack/issues/111">https://github.com/dmlc/dlpack/issues/111</a> As of DLPack v0.7, the highest-valued enumerator in <code>DLDeviceType</code> is kDLHexagon = 16.</p>
<p>MAINTAINERS NOTE #2: As of DLPack v0.7, the definition for <code>DLDeviceType</code> specifies an underlying storage type of <code>int32_t</code>. That guarantees a variable of type <code>DLDeviceType</code> is capable of holding any integers provided by <em>either</em> of these enumerations.</p>
<p>However, the <code>int32_t</code> specification only applies when the header file is compiled as C++, and this header file is also meant to work as C code. So the unspecified storage type could be a latent bug when compiled as C. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a237ec21eda9c03c495db5ce0da0f849da988c9df9b3f4e94e793e3e6dce05bb9c"></a>TVMDeviceExtType_End&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abfc320dbf7396f349bb015aec34a3b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc320dbf7396f349bb015aec34a3b3f">&#9670;&nbsp;</a></span>TypeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#abfc320dbf7396f349bb015aec34a3b3f">tvm::runtime::TypeIndex</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace for the list of type index. </p>
<dl class="section note"><dt>Note</dt><dd>Use struct so that we have to use TypeIndex::ENumName to refer to the constant, but still able to use enum. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3faf5474ebdbaaa19e977334eefa4bbd611"></a>kRuntimeModule&#160;</td><td class="fielddoc"><p>runtime::Module. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa784a020f84753e81d49cd6212ca97457"></a>kRuntimeTensor&#160;</td><td class="fielddoc"><p><a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">runtime::Tensor</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa88cf741bfe2461e6b9a718b4ceb13c61"></a>kRuntimeShape&#160;</td><td class="fielddoc"><p>runtime::Shape. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fabd14026b3a03064fa001caf5db19a1e9"></a>kCustomStaticIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa64c2fe96f9710738e921eba9a0647043"></a>kRuntimePackedFunc&#160;</td><td class="fielddoc"><p>ffi::Function. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa149e3537240d5889283fb48769bbb856"></a>kRuntimeDiscoDRef&#160;</td><td class="fielddoc"><p><a class="el" href="classtvm_1_1runtime_1_1DRef.html" title="Managed reference to DRefObj.">runtime::DRef</a> for disco distributed runtime </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fabc94c22e14c33b9be181f00c0be9620b"></a>kRuntimeRPCObjectRef&#160;</td><td class="fielddoc"><p>runtime::RPCObjectRef </p>
</td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fabcee6d9c2e81240077eaf3ee3775e36f"></a>kRuntimeString&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa2a1e3d7c7627236861336275102881e1"></a>kRuntimeMap&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3faa89514ac36216daf735627790247c945"></a>kRuntimeArray&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abfc320dbf7396f349bb015aec34a3b3fa548302094bc9afb6bb14dc2a283c1014"></a>kStaticIndexEnd&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa93f6c733bf54ca19d642a5ae2ec94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f6c733bf54ca19d642a5ae2ec94be">&#9670;&nbsp;</a></span>AddRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::AddRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_table_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device without any RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC server. </td></tr>
    <tr><td class="paramname">session_table_index</td><td>Numeric index of the RPC session in the session table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device with RPC session mask added, valid on the RPC client. </dd></dl>

</div>
</div>
<a id="a96852bde59aaae38b18eac0af0f2e2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96852bde59aaae38b18eac0af0f2e2a4">&#9670;&nbsp;</a></span>AllGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AllGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an allgather operation using the underlying communication library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The array send to perform allgather on </td></tr>
    <tr><td class="paramname">in_group</td><td>Whether the allgather operation performs globally or in group as default. </td></tr>
    <tr><td class="paramname">recv</td><td>The array receives the outcome of allgather </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1da94a59b5e1aabd4b25e924f03a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1da94a59b5e1aabd4b25e924f03a3b">&#9670;&nbsp;</a></span>AllReduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AllReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a>&#160;</td>
          <td class="paramname"><em>reduce_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an allreduce operation using the underlying communication library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The array send to perform allreduce on </td></tr>
    <tr><td class="paramname">reduce_kind</td><td>The kind of reduction operation (e.g. sum, avg, min, max) </td></tr>
    <tr><td class="paramname">in_group</td><td>Whether the allreduce operation performs globally or in group as default. </td></tr>
    <tr><td class="paramname">recv</td><td>The array receives the outcome of allreduce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae652e519d320f656c0106492239f25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae652e519d320f656c0106492239f25e">&#9670;&nbsp;</a></span>BroadcastFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::BroadcastFromWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a broadcast operation from worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The buffer to be broadcasted </td></tr>
    <tr><td class="paramname">in_group</td><td>Whether the broadcast operation performs globally or in group as default. </td></tr>
    <tr><td class="paramname">recv</td><td>The buffer receives the broadcasted array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab69f2cbb94a9c579ee870ca7f186cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f2cbb94a9c579ee870ca7f186cf10">&#9670;&nbsp;</a></span>DefaultTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a> tvm::runtime::DefaultTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default timer if one does not exist for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to time on.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this timer performs synchronization between the device and CPU, which can lead to overhead in the reported results. </p>

</div>
</div>
<a id="a0c3703032b26941b2dc4a6660d7dcc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3703032b26941b2dc4a6660d7dcc14">&#9670;&nbsp;</a></span>DiscoAction2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::DiscoAction2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the enum class <code>DiscoAction</code> to string. </p>

</div>
</div>
<a id="aba8c601b4310b125cc2d8502e0673ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c601b4310b125cc2d8502e0673ff9">&#9670;&nbsp;</a></span>DiscoEmptyTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> tvm::runtime::DiscoEmptyTensor </td>
          <td>(</td>
          <td class="paramtype">ffi::Shape&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional&lt; <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> &gt;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an uninitialized empty <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> </td></tr>
    <tr><td class="paramname">dtype</td><td>The dtype of the <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> </td></tr>
    <tr><td class="paramname">device</td><td>The device the <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> is created on. If None, use the thread local default device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> created </dd></dl>

</div>
</div>
<a id="a1fa64a5babbd1f199e4c14f1d90ed5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa64a5babbd1f199e4c14f1d90ed5dc">&#9670;&nbsp;</a></span>DLDeviceType2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::runtime::DLDeviceType2Str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of DLDeviceType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device name. </dd></dl>

</div>
</div>
<a id="afdc0c96a9b7920852cc71d8ae437d7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc0c96a9b7920852cc71d8ae437d7a3">&#9670;&nbsp;</a></span>GatherToWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::GatherToWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional&lt; <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a gather operation to worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The sending buffer, which must not be None. </td></tr>
    <tr><td class="paramname">in_group</td><td>Whether the gather operation performs globally or in group as default. </td></tr>
    <tr><td class="paramname">recv</td><td>For worker-0, it must be provided, and otherwise, the buffer must be None. The receiving buffer will be divided into equal parts and receive from each worker accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80916ee2a125355bc25dbd5a60c39164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80916ee2a125355bc25dbd5a60c39164">&#9670;&nbsp;</a></span>GetPreferredHostDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::GetPreferredHostDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the preferred host device from the input device. </p>
<ul>
<li>For CUDA and ROCm, CUDAHost and ROCMHost will be returned for pinned memory, since pinned memory reduces copy overhead.</li>
<li>For other devices, CPU is returned as a fallback. </li>
</ul>

</div>
</div>
<a id="a8d284249899038cca33c40d97eefa1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d284249899038cca33c40d97eefa1e3">&#9670;&nbsp;</a></span>GetRPCSessionIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetRPCSessionIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the RPCSessTable index of the RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> that owns this device. </p>
<dl class="section return"><dt>Returns</dt><dd>the table index. </dd></dl>

</div>
</div>
<a id="ad01a53416152b68029d67190c3709d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a53416152b68029d67190c3709d25">&#9670;&nbsp;</a></span>GetVectorBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetVectorBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes needed in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes needed. </dd></dl>

</div>
</div>
<a id="aa5f13cd8047078f88d142fe53337ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f13cd8047078f88d142fe53337ba6f">&#9670;&nbsp;</a></span>IsRPCSessionDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::IsRPCSessionDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a Device is owned by an RPC session. </p>

</div>
</div>
<a id="a25c22d3ea92d51e43bb2916f72d32354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c22d3ea92d51e43bb2916f72d32354">&#9670;&nbsp;</a></span>LoadVMModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Module tvm::runtime::LoadVMModule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional&lt; <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> &gt;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a runtime Module, then create and initialize a RelaxVM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the runtime Module (a DSO file) to be loaded </td></tr>
    <tr><td class="paramname">device</td><td>The default device used to initialize the RelaxVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RelaxVM as a runtime Module </dd></dl>

</div>
</div>
<a id="a59d447b7bdac52d26bca3422fe098f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d447b7bdac52d26bca3422fe098f6f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06b70cf1ffccb2b7737d26cccb4103d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b70cf1ffccb2b7737d26cccb4103d8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ec7f78231f4bf6c16188f87d98283a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec7f78231f4bf6c16188f87d98283a1">&#9670;&nbsp;</a></span>parallel_for_with_threading_backend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::parallel_for_with_threading_backend </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>flambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2workspace_2include_2tvm_2runtime_2threading_backend_8h-example.html#a15">/workspace/include/tvm/runtime/threading_backend.h</a>.</dd>
</dl>

</div>
</div>
<a id="a49fe6a7db3d574b8d746328fade5fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fe6a7db3d574b8d746328fade5fb4e">&#9670;&nbsp;</a></span>RecvFromPrevGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::RecvFromPrevGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a buffer from the corresponding worker in the previous group. An error is thrown if the worker is already in the first group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The receiving buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebe6730e5a6f87015b9c1f512a7a3d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe6730e5a6f87015b9c1f512a7a3d0c">&#9670;&nbsp;</a></span>RecvFromWorker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::RecvFromWorker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sender_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a buffer from the target sender worker (globally across all groups). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The receiving buffer. </td></tr>
    <tr><td class="paramname">sender_id</td><td>The global sender worker id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f43bb654214a0e4233ea57a891a1070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f43bb654214a0e4233ea57a891a1070">&#9670;&nbsp;</a></span>RecvFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::RecvFromWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a buffer from worker-0. No-op if the current worker is worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3467a4ef36085dc8262601478a70869a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3467a4ef36085dc8262601478a70869a">&#9670;&nbsp;</a></span>ReduceKind2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::ReduceKind2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>ReduceKind</code> to string. </p>

</div>
</div>
<a id="af32398517b6b915361c5716f8e32c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32398517b6b915361c5716f8e32c16f">&#9670;&nbsp;</a></span>RemoveRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::RemoveRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device with non-zero RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device without any RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC server. </dd></dl>

</div>
</div>
<a id="ae6d933eb1e7414afa9a9a62d22cd2522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d933eb1e7414afa9a9a62d22cd2522">&#9670;&nbsp;</a></span>RuntimeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::RuntimeEnabled </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if runtime module is enabled for target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target module name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether runtime is enabled. </dd></dl>

</div>
</div>
<a id="a8fb37910dcd9bb6899e6a3a47f006514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb37910dcd9bb6899e6a3a47f006514">&#9670;&nbsp;</a></span>SaveDLTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::SaveDLTensor </td>
          <td>(</td>
          <td class="paramtype">dmlc::Stream *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLTensor *&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a DLTensor to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>The output stream </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da16f59a809d09353bed2d49318d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da16f59a809d09353bed2d49318d8bf">&#9670;&nbsp;</a></span>ScatterFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::ScatterFromWorker0 </td>
          <td>(</td>
          <td class="paramtype">Optional&lt; <a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a scatter operation from worker-0, chunking the given buffer into equal parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>For worker-0, it must be provided, and otherwise, the buffer must be None. The buffer will be divided into equal parts and sent to each worker accordingly. </td></tr>
    <tr><td class="paramname">in_group</td><td>Whether the scatter operation performs globally or in group as default. </td></tr>
    <tr><td class="paramname">recv</td><td>The receiving buffer, which must not be None. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30c688aa578b4f81d2c296326911d79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c688aa578b4f81d2c296326911d79f">&#9670;&nbsp;</a></span>SendToNextGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::SendToNextGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a buffer to the corresponding worker in the next group. An error is thrown if the worker is already in the last group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The sending buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c09a342e05638d11892c8656087bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c09a342e05638d11892c8656087bf4">&#9670;&nbsp;</a></span>SendToWorker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::SendToWorker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>receiver_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a buffer to the target receiver worker (globally across all groups). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The sending buffer. </td></tr>
    <tr><td class="paramname">receiver_id</td><td>The global receiver worker id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65f369b9882f8ec57826acd5f86c4404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f369b9882f8ec57826acd5f86c4404">&#9670;&nbsp;</a></span>SyncWorker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::SyncWorker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the worker thread. Waiting until the worker completes all its tasks. As a specific example, on a CUDA worker, it blocks until all kernels are launched and cudaStreamSynchronize is complete. </p>

</div>
</div>
<a id="aee574cee6755b0c2f1aa664c6967686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee574cee6755b0c2f1aa664c6967686f">&#9670;&nbsp;</a></span>TypeEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeEqual </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two types are equal . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbabb7cfb79bfb6d802f65a9803e4eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbabb7cfb79bfb6d802f65a9803e4eb6">&#9670;&nbsp;</a></span>TypeMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeMatch </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether type matches the given spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type </td></tr>
    <tr><td class="paramname">code</td><td>The type code. </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to be matched. </td></tr>
    <tr><td class="paramname">lanes</td><td>The number of lanes in the type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d7c335ce64b50b3e6cee085d55c8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d7c335ce64b50b3e6cee085d55c8fc">&#9670;&nbsp;</a></span>WorkerId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::WorkerId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local worker id. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac8a77303649fb143634796b3dc50a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a77303649fb143634796b3dc50a286">&#9670;&nbsp;</a></span>kAllocAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kAllocAlignment = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to. </p>

</div>
</div>
<a id="a551bab1e24e2e794f8ccd4446b63a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551bab1e24e2e794f8ccd4446b63a7af">&#9670;&nbsp;</a></span>kDefaultWorkspaceAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kDefaultWorkspaceAlignment = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors. </p>

</div>
</div>
<a id="a2f6f769f6dbbbb24929b7c9f91a48c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6f769f6dbbbb24929b7c9f91a48c90">&#9670;&nbsp;</a></span>kMaxStackAlloca</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kMaxStackAlloca = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size that can be allocated on stack. </p>

</div>
</div>
<a id="a48cbe06e6c95ca6fabc20dd1cbacc2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cbe06e6c95ca6fabc20dd1cbacc2c9">&#9670;&nbsp;</a></span>kRPCSessMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kRPCSessMask = 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device type bigger than this is RPC device. </p>

</div>
</div>
<a id="a8f5819cabea098a1818cf7cda40fdb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5819cabea098a1818cf7cda40fdb1f">&#9670;&nbsp;</a></span>kTempAllocaAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kTempAllocaAlignment = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to in temporary allocation. </p>

</div>
</div>
<a id="aed7511f3f3acbee3d3aca5d432e294c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7511f3f3acbee3d3aca5d432e294c1">&#9670;&nbsp;</a></span>kTVMTensorMagic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t tvm::runtime::kTVMTensorMagic = 0xDD5E40F096B4A13F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magic number for <a class="el" href="classtvm_1_1runtime_1_1Tensor.html" title="Managed Tensor. The array is backed by reference counted blocks.">Tensor</a> file. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
