<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::runtime Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1runtime.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::runtime Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1metadata"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1metadata.html">metadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1micro__rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1micro__rpc.html">micro_rpc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1profiling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1profiling.html">profiling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1symbol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1symbol.html">symbol</a></td></tr>
<tr class="memdesc:namespacetvm_1_1runtime_1_1symbol"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for constant symbols <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1threading"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1threading.html">threading</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1vm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1vm.html">vm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to algebraic data type objects.  <a href="classtvm_1_1runtime_1_1ADT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADTObj.html">ADTObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a structure or enumeration.  <a href="classtvm_1_1runtime_1_1ADTObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a>, container representing a contiguous sequence of ObjectRefs.  <a href="classtvm_1_1runtime_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array node content in array  <a href="classtvm_1_1runtime_1_1ArrayNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to closure.  <a href="classtvm_1_1runtime_1_1Closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ClosureObj.html">ClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a closure. This object is used by both the Relay VM and interpreter.  <a href="classtvm_1_1runtime_1_1ClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime primitive data type.  <a href="classtvm_1_1runtime_1_1DataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DenseMapNode.html">DenseMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of hash map that implements the idea of array-based hash map. Another reference implementation can be found [1].  <a href="classtvm_1_1runtime_1_1DenseMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DeviceAPI.html">DeviceAPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TVM Runtime Device API, abstracts the device specific interface for memory management.  <a href="classtvm_1_1runtime_1_1DeviceAPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1InplaceArrayBase.html">InplaceArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for classes with array like memory layout.  <a href="classtvm_1_1runtime_1_1InplaceArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1IterAdapter.html">IterAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adapter that adapts TIter to return another type.  <a href="classtvm_1_1runtime_1_1IterAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> container of NodeRef-&gt;NodeRef in DSL graph. <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places.  <a href="classtvm_1_1runtime_1_1Map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1MapNode.html">MapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared content of all specializations of hash map.  <a href="classtvm_1_1runtime_1_1MapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM. ">Module</a> container of TVM.  <a href="classtvm_1_1runtime_1_1Module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ModuleNode.html">ModuleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container of module.  <a href="classtvm_1_1runtime_1_1ModuleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a>. The array is backed by reference counted blocks.  <a href="classtvm_1_1runtime_1_1NDArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1NullOptType.html">NullOptType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to represent nullptr for optional.  <a href="structtvm_1_1runtime_1_1NullOptType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjAllocatorBase.html">ObjAllocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of object allocators that implements make. Use curiously recurring template pattern.  <a href="classtvm_1_1runtime_1_1ObjAllocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of all object containers.  <a href="classtvm_1_1runtime_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectEqual.html">ObjectEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-aware <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> hash functor.  <a href="structtvm_1_1runtime_1_1ObjectEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectHash.html">ObjectHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-aware <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> equal functor.  <a href="structtvm_1_1runtime_1_1ObjectHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom smart pointer for <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a>.  <a href="classtvm_1_1runtime_1_1ObjectPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectPtrEqual.html">ObjectPtrEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> equal functor.  <a href="structtvm_1_1runtime_1_1ObjectPtrEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectPtrHash.html">ObjectPtrHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> hash functor.  <a href="structtvm_1_1runtime_1_1ObjectPtrHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all object reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker.html">ObjectTypeChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> traits for runtime type check during FFI conversion.  <a href="structtvm_1_1runtime_1_1ObjectTypeChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4.html">ObjectTypeChecker&lt; Array&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4.html">ObjectTypeChecker&lt; Map&lt; K, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Optional.html" title="Optional container that to represent to a Nullable variant of T. ">Optional</a> container that to represent to a Nullable variant of T.  <a href="classtvm_1_1runtime_1_1Optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">PackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed function is a type-erased function. The arguments are passed by packed format.  <a href="classtvm_1_1runtime_1_1PackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFuncObj.html">PackedFuncObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> container class that backs <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a>.  <a href="classtvm_1_1runtime_1_1PackedFuncObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFuncSubObj.html">PackedFuncSubObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived object class for constructing <a class="el" href="classtvm_1_1runtime_1_1PackedFuncObj.html" title="Object container class that backs PackedFunc. ">PackedFuncObj</a>.  <a href="classtvm_1_1runtime_1_1PackedFuncSubObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter.html">PackedFuncValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> trait to specify special value conversion rules from <a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html" title="A single argument value to PackedFunc. Containing both type_code and TVMValue. ">TVMArgValue</a> and <a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html" title="Return Value container, Unlike TVMArgValue, which only holds reference and do not delete the underlyi...">TVMRetValue</a>.  <a href="structtvm_1_1runtime_1_1PackedFuncValueConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01Optional_3_01T_01_4_01_4.html">PackedFuncValueConverter&lt; Optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01PrimExpr_01_4.html">PackedFuncValueConverter&lt; PrimExpr &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01tvm_1_1Bool_01_4.html">PackedFuncValueConverter&lt; tvm::Bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01tvm_1_1Integer_01_4.html">PackedFuncValueConverter&lt; tvm::Integer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_1_1tvm_1_1runtime_1_1String_01_4.html">PackedFuncValueConverter&lt;::tvm::runtime::String &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Registry.html" title="Registry for global function. ">Registry</a> for global function.  <a href="classtvm_1_1runtime_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ReverseIterAdapter.html">ReverseIterAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adapter that adapts TIter to return another type.  <a href="classtvm_1_1runtime_1_1ReverseIterAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to shape tuple objects.  <a href="classtvm_1_1runtime_1_1ShapeTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ShapeTupleObj.html">ShapeTupleObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a shape tuple.  <a href="classtvm_1_1runtime_1_1ShapeTupleObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1SignaturePrinter.html">SignaturePrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SimpleObjAllocator.html">SimpleObjAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SmallMapNode.html">SmallMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of small-sized hash map.  <a href="classtvm_1_1runtime_1_1SmallMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to string objects.  <a href="classtvm_1_1runtime_1_1String.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1StringObj.html">StringObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing string. It's POD type.  <a href="classtvm_1_1runtime_1_1StringObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Timer.html" title="Timer for a specific device. ">Timer</a> for a specific device.  <a href="classtvm_1_1runtime_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TimerNode.html">TimerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all implementations.  <a href="classtvm_1_1runtime_1_1TimerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgs.html">TVMArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments into TVM functions.  <a href="classtvm_1_1runtime_1_1TVMArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgsSetter.html">TVMArgsSetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html">TVMArgValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single argument value to <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a>. Containing both type_code and <a class="el" href="unionTVMValue.html" title="Union type of values being passed through API and function calls. ">TVMValue</a>.  <a href="classtvm_1_1runtime_1_1TVMArgValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMMovableArgValue__.html">TVMMovableArgValue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal auxiliary struct for <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;. ">TypedPackedFunc</a> to indicate a movable argument.  <a href="classtvm_1_1runtime_1_1TVMMovableArgValue__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMMovableArgValueWithContext__.html">TVMMovableArgValueWithContext_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal auxiliary struct for <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;. ">TypedPackedFunc</a> to indicate a movable argument with additional context information (function name and argument index) for better error reporting.  <a href="classtvm_1_1runtime_1_1TVMMovableArgValueWithContext__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMPODValue__.html">TVMPODValue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal base class to handle conversion to POD values.  <a href="classtvm_1_1runtime_1_1TVMPODValue__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html">TVMRetValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Value container, Unlike <a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html" title="A single argument value to PackedFunc. Containing both type_code and TVMValue. ">TVMArgValue</a>, which only holds reference and do not delete the underlying container during destruction.  <a href="classtvm_1_1runtime_1_1TVMRetValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">TypedPackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please refer to <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#TypedPackedFuncAnchor">TypedPackedFunc&lt;R(Args..)&gt;</a>.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html">TypedPackedFunc&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a> wrapper to provide typed function signature. It is backed by a <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a> internally.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1TypeIndex.html">TypeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the list of type index.  <a href="structtvm_1_1runtime_1_1TypeIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a28022a2dc86007a65b24b8c41e0c7da3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a28022a2dc86007a65b24b8c41e0c7da3">FSig</a> = std::string()</td></tr>
<tr class="memdesc:a28022a2dc86007a65b24b8c41e0c7da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using static function to output <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;. ">TypedPackedFunc</a> signature.  <a href="#a28022a2dc86007a65b24b8c41e0c7da3">More...</a><br /></td></tr>
<tr class="separator:a28022a2dc86007a65b24b8c41e0c7da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">DeviceAttrKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb">kExist</a> = 0, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4">kMaxThreadsPerBlock</a> = 1, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da">kWarpSize</a> = 2, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264">kMaxSharedMemoryPerBlock</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b">kComputeVersion</a> = 4, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca">kDeviceName</a> = 5, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630">kMaxClockRate</a> = 6, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd">kMultiProcessorCount</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991">kMaxThreadDimensions</a> = 8, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357">kMaxRegistersPerBlock</a> = 9, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201">kGcnArch</a> = 10, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337">kApiVersion</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9">kDriverVersion</a> = 12
<br />
 }<tr class="memdesc:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="mdescLeft">&#160;</td><td class="mdescRight">the query type into GetAttr  <a href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af22b89284299c81d0c1802199af446d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af22b89284299c81d0c1802199af446d7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;n)</td></tr>
<tr class="separator:af22b89284299c81d0c1802199af446d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4a8b9d4d20b7993992145f73efa2abf2">Concat</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; lhs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4a8b9d4d20b7993992145f73efa2abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concat two Arrays.  <a href="#a4a8b9d4d20b7993992145f73efa2abf2">More...</a><br /></td></tr>
<tr class="separator:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca61f3e3dd7af5ee94ed7886f638ee5"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5ca61f3e3dd7af5ee94ed7886f638ee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5ca61f3e3dd7af5ee94ed7886f638ee5">make_object</a> ()</td></tr>
<tr class="separator:a5ca61f3e3dd7af5ee94ed7886f638ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4c19389363853e409527badb5b177"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a57b4c19389363853e409527badb5b177"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1MapNode.html">MapNode</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a57b4c19389363853e409527badb5b177">make_object</a> ()=delete</td></tr>
<tr class="separator:a57b4c19389363853e409527badb5b177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff337677f23f7d665960f553fb52ab86"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, K&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, V&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aff337677f23f7d665960f553fb52ab86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aff337677f23f7d665960f553fb52ab86">Merge</a> (<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; lhs, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aff337677f23f7d665960f553fb52ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two Maps.  <a href="#aff337677f23f7d665960f553fb52ab86">More...</a><br /></td></tr>
<tr class="separator:aff337677f23f7d665960f553fb52ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbaf8d9ec6bd68590a23da05d8a2831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a3dbaf8d9ec6bd68590a23da05d8a2831">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a3dbaf8d9ec6bd68590a23da05d8a2831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c069145ecfa5909a77841f60332af4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5c069145ecfa5909a77841f60332af4d">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a5c069145ecfa5909a77841f60332af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9820cf44823ad5098183e9dbd7b867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acc9820cf44823ad5098183e9dbd7b867">operator+</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:acc9820cf44823ad5098183e9dbd7b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935d5423ffab64da49612e80f775a8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a935d5423ffab64da49612e80f775a8ff">operator+</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a935d5423ffab64da49612e80f775a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca259da80169ea60877e17c98a0b472a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aca259da80169ea60877e17c98a0b472a">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:aca259da80169ea60877e17c98a0b472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2865dffa2fddf5eff9d7ed397563ebd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2865dffa2fddf5eff9d7ed397563ebd6">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a2865dffa2fddf5eff9d7ed397563ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5305faaeefd679da62186dab423bdab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad5305faaeefd679da62186dab423bdab">operator&lt;</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad5305faaeefd679da62186dab423bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263e89c942dc4b01075dd01b6882a814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a263e89c942dc4b01075dd01b6882a814">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a263e89c942dc4b01075dd01b6882a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbf6ce2f770d4f348ace3407ee9c500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acbbf6ce2f770d4f348ace3407ee9c500">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:acbbf6ce2f770d4f348ace3407ee9c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77f7b17aece9015b0ef91908f75b5f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab77f7b17aece9015b0ef91908f75b5f4">operator&lt;</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ab77f7b17aece9015b0ef91908f75b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7996be0c57184e8ff9e655d0d055edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af7996be0c57184e8ff9e655d0d055edc">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:af7996be0c57184e8ff9e655d0d055edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e6c8e64cd9db11754355e3250ab4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a031e6c8e64cd9db11754355e3250ab4c">operator&gt;</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a031e6c8e64cd9db11754355e3250ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf23f2e6b19c87ecf3f27a7506ddf4c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abf23f2e6b19c87ecf3f27a7506ddf4c0">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:abf23f2e6b19c87ecf3f27a7506ddf4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001f8f5205170a33ea1b9db314549c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2001f8f5205170a33ea1b9db314549c9">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a2001f8f5205170a33ea1b9db314549c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa52eb43328fdca2972a8312bb1ed6d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afa52eb43328fdca2972a8312bb1ed6d0">operator&gt;</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:afa52eb43328fdca2972a8312bb1ed6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92428efae022d4982b2644f8960d4386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a92428efae022d4982b2644f8960d4386">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a92428efae022d4982b2644f8960d4386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf39dc422f228fae2ec11a426bab28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8daf39dc422f228fae2ec11a426bab28">operator&lt;=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a8daf39dc422f228fae2ec11a426bab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf2e7e67fd12d69c5bce2be881c8296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9cf2e7e67fd12d69c5bce2be881c8296">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a9cf2e7e67fd12d69c5bce2be881c8296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d696c920a17b8c54775705062de75be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1d696c920a17b8c54775705062de75be">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a1d696c920a17b8c54775705062de75be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76c697beb4a77556a869f7cc45f09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2e76c697beb4a77556a869f7cc45f09a">operator&lt;=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a2e76c697beb4a77556a869f7cc45f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944029d40e689e4d2acab53ce36a5c99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a944029d40e689e4d2acab53ce36a5c99">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a944029d40e689e4d2acab53ce36a5c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8694e651078c6df7c5c26898ee9f14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f8694e651078c6df7c5c26898ee9f14">operator&gt;=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a8f8694e651078c6df7c5c26898ee9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7310fb8b9944f41f8f30021d92847eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af7310fb8b9944f41f8f30021d92847eb">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:af7310fb8b9944f41f8f30021d92847eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4bb211393bf9d17b138cad36421c84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afb4bb211393bf9d17b138cad36421c84">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:afb4bb211393bf9d17b138cad36421c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a0ea66d3af9fd1b232e49a960f6f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad83a0ea66d3af9fd1b232e49a960f6f4">operator&gt;=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad83a0ea66d3af9fd1b232e49a960f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04626a0c1e717679d673bc90c6a23f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aba04626a0c1e717679d673bc90c6a23f">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:aba04626a0c1e717679d673bc90c6a23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dae8fb1a2fa349cfb272525294f954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a81dae8fb1a2fa349cfb272525294f954">operator==</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a81dae8fb1a2fa349cfb272525294f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109f107067bdcf493aafafd8896e031"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5109f107067bdcf493aafafd8896e031">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a5109f107067bdcf493aafafd8896e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5995094218eac7fe1f98e1abee852d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5a5995094218eac7fe1f98e1abee852d">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a5a5995094218eac7fe1f98e1abee852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77c2b6d2b8176af69f6e6cccbe736c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac77c2b6d2b8176af69f6e6cccbe736c2">operator==</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ac77c2b6d2b8176af69f6e6cccbe736c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d584f14566754b91a0e7f415b83fbda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a7d584f14566754b91a0e7f415b83fbda">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a7d584f14566754b91a0e7f415b83fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab556e58d616b05ce4ae338f887b17cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab556e58d616b05ce4ae338f887b17cb4">operator!=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ab556e58d616b05ce4ae338f887b17cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504adcfea8e21b2865b56cdfad447918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a504adcfea8e21b2865b56cdfad447918">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a504adcfea8e21b2865b56cdfad447918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a808c040486da95a7fa2f4725b55635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2a808c040486da95a7fa2f4725b55635">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a2a808c040486da95a7fa2f4725b55635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d1999febc0f97ae2e2c9cc12edd280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad4d1999febc0f97ae2e2c9cc12edd280">operator!=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad4d1999febc0f97ae2e2c9cc12edd280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20920d4a09a6c022768b353ec8df2a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2c20920d4a09a6c022768b353ec8df2a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;input)</td></tr>
<tr class="separator:a2c20920d4a09a6c022768b353ec8df2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01a53416152b68029d67190c3709d25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">GetVectorBytes</a> (<a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype)</td></tr>
<tr class="memdesc:ad01a53416152b68029d67190c3709d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes needed in a vector.  <a href="#ad01a53416152b68029d67190c3709d25">More...</a><br /></td></tr>
<tr class="separator:ad01a53416152b68029d67190c3709d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">TypeMatch</a> (DLDataType t, int code, int bits, int lanes=1)</td></tr>
<tr class="memdesc:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether type matches the given spec.  <a href="#adbabb7cfb79bfb6d802f65a9803e4eb6">More...</a><br /></td></tr>
<tr class="separator:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee574cee6755b0c2f1aa664c6967686f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">TypeEqual</a> (DLDataType lhs, DLDataType rhs)</td></tr>
<tr class="memdesc:aee574cee6755b0c2f1aa664c6967686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two types are equal .  <a href="#aee574cee6755b0c2f1aa664c6967686f">More...</a><br /></td></tr>
<tr class="separator:aee574cee6755b0c2f1aa664c6967686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a49d761ea6373557c24c01eaceb07d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a06a49d761ea6373557c24c01eaceb07d">GetCustomTypeName</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a06a49d761ea6373557c24c01eaceb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for getting custom type name from code.  <a href="#a06a49d761ea6373557c24c01eaceb07d">More...</a><br /></td></tr>
<tr class="separator:a06a49d761ea6373557c24c01eaceb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1b8eedadc5a269b2f9614ce69a9932e7">GetCustomTypeRegistered</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for checking whether custom type is registered.  <a href="#a1b8eedadc5a269b2f9614ce69a9932e7">More...</a><br /></td></tr>
<tr class="separator:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d167947285dff3c780bd5d01ace9b9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac6d167947285dff3c780bd5d01ace9b9">ParseCustomDatatype</a> (const std::string &amp;s, const char **scan)</td></tr>
<tr class="memdesc:ac6d167947285dff3c780bd5d01ace9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for parsing string of the form "custom[&lt;typename&gt;]".  <a href="#ac6d167947285dff3c780bd5d01ace9b9">More...</a><br /></td></tr>
<tr class="separator:ac6d167947285dff3c780bd5d01ace9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9303c49b737675bdab034c4032dcc48"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af9303c49b737675bdab034c4032dcc48">DLDataTypeCode2Str</a> (DLDataTypeCode type_code)</td></tr>
<tr class="memdesc:af9303c49b737675bdab034c4032dcc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type code to its name.  <a href="#af9303c49b737675bdab034c4032dcc48">More...</a><br /></td></tr>
<tr class="separator:af9303c49b737675bdab034c4032dcc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277f104e659f71cd8885744700016341"><td class="memItemLeft" align="right" valign="top">DLDataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a277f104e659f71cd8885744700016341">String2DLDataType</a> (std::string s)</td></tr>
<tr class="memdesc:a277f104e659f71cd8885744700016341"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a string to TVM type.  <a href="#a277f104e659f71cd8885744700016341">More...</a><br /></td></tr>
<tr class="separator:a277f104e659f71cd8885744700016341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac360f2d9815036ab1b4d84d9cfb46b4f">DLDataType2String</a> (DLDataType t)</td></tr>
<tr class="memdesc:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a TVM type to string.  <a href="#ac360f2d9815036ab1b4d84d9cfb46b4f">More...</a><br /></td></tr>
<tr class="separator:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed99740d7bb838d96617de83ff2363"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11ed99740d7bb838d96617de83ff2363">operator&lt;&lt;</a> (std::ostream &amp;os, DLDataType t)</td></tr>
<tr class="separator:a11ed99740d7bb838d96617de83ff2363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d447b7bdac52d26bca3422fe098f6f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59d447b7bdac52d26bca3422fe098f6f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;dtype)</td></tr>
<tr class="separator:a59d447b7bdac52d26bca3422fe098f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8593d6430be00492db4b52b3aad542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aec8593d6430be00492db4b52b3aad542">AppendNDArray</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &amp;nd_array, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="memdesc:aec8593d6430be00492db4b52b3aad542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers to describe runtime objects in human-friendly form. For <code>nd_arrays</code> we show their shapes and dtypes, but also their contents if 'small' and on the <code>host_device</code> (mostly so that we can see dynamic shapes as they are computed). For <code>adts</code> we show the <a class="el" href="classtvm_1_1runtime_1_1ADT.html" title="reference to algebraic data type objects. ">ADT</a> fields. For <code>objects</code> we dispatch to one of the above as appropriate.  <a href="#aec8593d6430be00492db4b52b3aad542">More...</a><br /></td></tr>
<tr class="separator:aec8593d6430be00492db4b52b3aad542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c142fe6cc61a977ec7ab0e56a77a201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0c142fe6cc61a977ec7ab0e56a77a201">AppendADT</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a> &amp;adt, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a0c142fe6cc61a977ec7ab0e56a77a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da4311f8b37f76fad2d4da39c35f50f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4da4311f8b37f76fad2d4da39c35f50f">AppendRuntimeObject</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;object, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a4da4311f8b37f76fad2d4da39c35f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4682aef4c22170449389fa455ab434"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5e4682aef4c22170449389fa455ab434">RuntimeObject2String</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;object, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a5e4682aef4c22170449389fa455ab434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9109e4efe269213052ed6a94853c0c00"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9109e4efe269213052ed6a94853c0c00">DeviceName</a> (int type)</td></tr>
<tr class="memdesc:a9109e4efe269213052ed6a94853c0c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of Device API factory.  <a href="#a9109e4efe269213052ed6a94853c0c00">More...</a><br /></td></tr>
<tr class="separator:a9109e4efe269213052ed6a94853c0c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f13cd8047078f88d142fe53337ba6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa5f13cd8047078f88d142fe53337ba6f">IsRPCSessionDevice</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:aa5f13cd8047078f88d142fe53337ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a Device is owned by an RPC session.  <a href="#aa5f13cd8047078f88d142fe53337ba6f">More...</a><br /></td></tr>
<tr class="separator:aa5f13cd8047078f88d142fe53337ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d284249899038cca33c40d97eefa1e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8d284249899038cca33c40d97eefa1e3">GetRPCSessionIndex</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:a8d284249899038cca33c40d97eefa1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RPCSessTable index of the RPC Session that owns this device.  <a href="#a8d284249899038cca33c40d97eefa1e3">More...</a><br /></td></tr>
<tr class="separator:a8d284249899038cca33c40d97eefa1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32398517b6b915361c5716f8e32c16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af32398517b6b915361c5716f8e32c16f">RemoveRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:af32398517b6b915361c5716f8e32c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation.  <a href="#af32398517b6b915361c5716f8e32c16f">More...</a><br /></td></tr>
<tr class="separator:af32398517b6b915361c5716f8e32c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b70cf1ffccb2b7737d26cccb4103d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a06b70cf1ffccb2b7737d26cccb4103d8">operator&lt;&lt;</a> (std::ostream &amp;os, DLDevice dev)</td></tr>
<tr class="separator:a06b70cf1ffccb2b7737d26cccb4103d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa93f6c733bf54ca19d642a5ae2ec94be">AddRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev, int session_table_index)</td></tr>
<tr class="memdesc:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote.  <a href="#aa93f6c733bf54ca19d642a5ae2ec94be">More...</a><br /></td></tr>
<tr class="separator:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af55276b6524dbaf78e3eaba39ee9ce16">make_object</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af55276b6524dbaf78e3eaba39ee9ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an object using default allocator.  <a href="#af55276b6524dbaf78e3eaba39ee9ce16">More...</a><br /></td></tr>
<tr class="separator:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0537c9d197068a02c26cd702ab42f6ff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </td></tr>
<tr class="memitem:a0537c9d197068a02c26cd702ab42f6ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ArrayType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0537c9d197068a02c26cd702ab42f6ff">make_inplace_array_object</a> (size_t num_elems, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a0537c9d197068a02c26cd702ab42f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbea0c23882ae01431ac7fe6506b32a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abbea0c23882ae01431ac7fe6506b32a7">RuntimeEnabled</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:abbea0c23882ae01431ac7fe6506b32a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if runtime module is enabled for target.  <a href="#abbea0c23882ae01431ac7fe6506b32a7">More...</a><br /></td></tr>
<tr class="separator:abbea0c23882ae01431ac7fe6506b32a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">SaveDLTensor</a> (dmlc::Stream *strm, const DLTensor *tensor)</td></tr>
<tr class="memdesc:a8fb37910dcd9bb6899e6a3a47f006514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a DLTensor to stream.  <a href="#a8fb37910dcd9bb6899e6a3a47f006514">More...</a><br /></td></tr>
<tr class="separator:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59940b6d63dd4c5175c0fe875047c1cf">GetDataSize</a> (const DLTensor &amp;arr)</td></tr>
<tr class="memdesc:a59940b6d63dd4c5175c0fe875047c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of data the DLTensor hold, in term of number of bytes  <a href="#a59940b6d63dd4c5175c0fe875047c1cf">More...</a><br /></td></tr>
<tr class="separator:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ed1227b418f5846d43d3234b52391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adb2ed1227b418f5846d43d3234b52391">IsContiguous</a> (const DLTensor &amp;arr)</td></tr>
<tr class="memdesc:adb2ed1227b418f5846d43d3234b52391"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a DLTensor is contiguous.  <a href="#adb2ed1227b418f5846d43d3234b52391">More...</a><br /></td></tr>
<tr class="separator:adb2ed1227b418f5846d43d3234b52391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7050eda88b079f0a962bd413a34ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afdd7050eda88b079f0a962bd413a34ea">TVMArrayHandleToObjectHandle</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle)</td></tr>
<tr class="separator:afdd7050eda88b079f0a962bd413a34ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplParams" colspan="2">template&lt;typename RelayRefType , typename ObjectType &gt; </td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa4a97de4fefd23aa5942c6a545544a05">GetRef</a> (const ObjectType *ptr)</td></tr>
<tr class="memdesc:aa4a97de4fefd23aa5942c6a545544a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference type from a raw object ptr type.  <a href="#aa4a97de4fefd23aa5942c6a545544a05">More...</a><br /></td></tr>
<tr class="separator:aa4a97de4fefd23aa5942c6a545544a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplParams" colspan="2">template&lt;typename SubRef , typename BaseRef &gt; </td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplItemLeft" align="right" valign="top">SubRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a756a222aed384e208f32d35d3412c918">Downcast</a> (BaseRef ref)</td></tr>
<tr class="memdesc:a756a222aed384e208f32d35d3412c918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast a base reference type to a more specific type.  <a href="#a756a222aed384e208f32d35d3412c918">More...</a><br /></td></tr>
<tr class="separator:a756a222aed384e208f32d35d3412c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjectType &gt; </td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46bcf7948293194c5b9c7db91da96381">GetObjectPtr</a> (ObjectType *ptr)</td></tr>
<tr class="memdesc:a46bcf7948293194c5b9c7db91da96381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object ptr type from a raw object ptr.  <a href="#a46bcf7948293194c5b9c7db91da96381">More...</a><br /></td></tr>
<tr class="separator:a46bcf7948293194c5b9c7db91da96381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63300957592e8991c18c54703123ef7"><td class="memTemplParams" colspan="2">template&lt;typename RefType , typename ObjType &gt; </td></tr>
<tr class="memitem:af63300957592e8991c18c54703123ef7"><td class="memTemplItemLeft" align="right" valign="top">RefType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af63300957592e8991c18c54703123ef7">GetRef</a> (const ObjType *ptr)</td></tr>
<tr class="separator:af63300957592e8991c18c54703123ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjType &gt; </td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac2d903012aff56c2bd54ff66f48450c3">GetObjectPtr</a> (ObjType *ptr)</td></tr>
<tr class="separator:ac2d903012aff56c2bd54ff66f48450c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129050a60cebb0bbe18f96b41a36a948"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a129050a60cebb0bbe18f96b41a36a948">ArgTypeCode2Str</a> (int type_code)</td></tr>
<tr class="memdesc:a129050a60cebb0bbe18f96b41a36a948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert argument type code to string.  <a href="#a129050a60cebb0bbe18f96b41a36a948">More...</a><br /></td></tr>
<tr class="separator:a129050a60cebb0bbe18f96b41a36a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab69f2cbb94a9c579ee870ca7f186cf10">DefaultTimer</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timer if one does not exist for the device.  <a href="#ab69f2cbb94a9c579ee870ca7f186cf10">More...</a><br /></td></tr>
<tr class="separator:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">EnvCheckSignals</a> ()</td></tr>
<tr class="memdesc:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if signals have been sent to the process and if so invoke the registered signal handler in the frontend environment.  <a href="#af5edb7ca30cd4affb50eb1fe6e3a1d13">More...</a><br /></td></tr>
<tr class="separator:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac8a77303649fb143634796b3dc50a286"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">kAllocAlignment</a> = 128</td></tr>
<tr class="memdesc:ac8a77303649fb143634796b3dc50a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to.  <a href="#ac8a77303649fb143634796b3dc50a286">More...</a><br /></td></tr>
<tr class="separator:ac8a77303649fb143634796b3dc50a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">kTempAllocaAlignment</a> = 128</td></tr>
<tr class="memdesc:a8f5819cabea098a1818cf7cda40fdb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to in temporary allocation.  <a href="#a8f5819cabea098a1818cf7cda40fdb1f">More...</a><br /></td></tr>
<tr class="separator:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">kMaxStackAlloca</a> = 1024</td></tr>
<tr class="memdesc:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size that can be allocated on stack.  <a href="#a2f6f769f6dbbbb24929b7c9f91a48c90">More...</a><br /></td></tr>
<tr class="separator:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a551bab1e24e2e794f8ccd4446b63a7af">kDefaultWorkspaceAlignment</a> = 1</td></tr>
<tr class="memdesc:a551bab1e24e2e794f8ccd4446b63a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors.  <a href="#a551bab1e24e2e794f8ccd4446b63a7af">More...</a><br /></td></tr>
<tr class="separator:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">kRPCSessMask</a> = 128</td></tr>
<tr class="memdesc:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type bigger than this is RPC device.  <a href="#a48cbe06e6c95ca6fabc20dd1cbacc2c9">More...</a><br /></td></tr>
<tr class="separator:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acf4599f17bfe79ae1fe8afc1af053b43">kTVMNDArrayMagic</a> = 0xDD5E40F096B4A13F</td></tr>
<tr class="memdesc:acf4599f17bfe79ae1fe8afc1af053b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a> file.  <a href="#acf4599f17bfe79ae1fe8afc1af053b43">More...</a><br /></td></tr>
<tr class="separator:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a28022a2dc86007a65b24b8c41e0c7da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28022a2dc86007a65b24b8c41e0c7da3">&#9670;&nbsp;</a></span>FSig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#a28022a2dc86007a65b24b8c41e0c7da3">tvm::runtime::FSig</a> = typedef std::string()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using static function to output <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;. ">TypedPackedFunc</a> signature. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a46fef1ca0ccc05473e9bb0a8c6b66619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fef1ca0ccc05473e9bb0a8c6b66619">&#9670;&nbsp;</a></span>DeviceAttrKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">tvm::runtime::DeviceAttrKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the query type into GetAttr </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb"></a>kExist&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4"></a>kMaxThreadsPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da"></a>kWarpSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264"></a>kMaxSharedMemoryPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b"></a>kComputeVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca"></a>kDeviceName&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630"></a>kMaxClockRate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd"></a>kMultiProcessorCount&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991"></a>kMaxThreadDimensions&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357"></a>kMaxRegistersPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201"></a>kGcnArch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337"></a>kApiVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9"></a>kDriverVersion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa93f6c733bf54ca19d642a5ae2ec94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f6c733bf54ca19d642a5ae2ec94be">&#9670;&nbsp;</a></span>AddRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::AddRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_table_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device without any RPC Session mask, valid on the RPC server. </td></tr>
    <tr><td class="paramname">session_table_index</td><td>Numeric index of the RPC session in the session table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device with RPC session mask added, valid on the RPC client. </dd></dl>

</div>
</div>
<a id="a0c142fe6cc61a977ec7ab0e56a77a201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c142fe6cc61a977ec7ab0e56a77a201">&#9670;&nbsp;</a></span>AppendADT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendADT </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a> &amp;&#160;</td>
          <td class="paramname"><em>adt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec8593d6430be00492db4b52b3aad542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8593d6430be00492db4b52b3aad542">&#9670;&nbsp;</a></span>AppendNDArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendNDArray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>nd_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helpers to describe runtime objects in human-friendly form. For <code>nd_arrays</code> we show their shapes and dtypes, but also their contents if 'small' and on the <code>host_device</code> (mostly so that we can see dynamic shapes as they are computed). For <code>adts</code> we show the <a class="el" href="classtvm_1_1runtime_1_1ADT.html" title="reference to algebraic data type objects. ">ADT</a> fields. For <code>objects</code> we dispatch to one of the above as appropriate. </p>

</div>
</div>
<a id="a4da4311f8b37f76fad2d4da39c35f50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da4311f8b37f76fad2d4da39c35f50f">&#9670;&nbsp;</a></span>AppendRuntimeObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendRuntimeObject </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a129050a60cebb0bbe18f96b41a36a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129050a60cebb0bbe18f96b41a36a948">&#9670;&nbsp;</a></span>ArgTypeCode2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * tvm::runtime::ArgTypeCode2Str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert argument type code to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>The input type code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding string repr. </dd></dl>

</div>
</div>
<a id="a4a8b9d4d20b7993992145f73efa2abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b9d4d20b7993992145f73efa2abf2">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;T&gt; tvm::runtime::Concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concat two Arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>first <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a> to be concatenated. </td></tr>
    <tr><td class="paramname">rhs</td><td>second <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a> to be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a>. Original Arrays are kept unchanged. </dd></dl>

</div>
</div>
<a id="ab69f2cbb94a9c579ee870ca7f186cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f2cbb94a9c579ee870ca7f186cf10">&#9670;&nbsp;</a></span>DefaultTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a> tvm::runtime::DefaultTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default timer if one does not exist for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to time on.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this timer performs synchronization between the device and CPU, which can lead to overhead in the reported results. </p>

</div>
</div>
<a id="a9109e4efe269213052ed6a94853c0c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9109e4efe269213052ed6a94853c0c00">&#9670;&nbsp;</a></span>DeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::runtime::DeviceName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of Device API factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device name. </dd></dl>

</div>
</div>
<a id="ac360f2d9815036ab1b4d84d9cfb46b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac360f2d9815036ab1b4d84d9cfb46b4f">&#9670;&nbsp;</a></span>DLDataType2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::DLDataType2String </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a TVM type to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type in string. </dd></dl>

</div>
</div>
<a id="af9303c49b737675bdab034c4032dcc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9303c49b737675bdab034c4032dcc48">&#9670;&nbsp;</a></span>DLDataTypeCode2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * tvm::runtime::DLDataTypeCode2Str </td>
          <td>(</td>
          <td class="paramtype">DLDataTypeCode&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert type code to its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>The type code . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of type code. </dd></dl>

</div>
</div>
<a id="a756a222aed384e208f32d35d3412c918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a222aed384e208f32d35d3412c918">&#9670;&nbsp;</a></span>Downcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubRef , typename BaseRef &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubRef tvm::runtime::Downcast </td>
          <td>(</td>
          <td class="paramtype">BaseRef&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast a base reference type to a more specific type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The input reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding SubRef. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SubRef</td><td>The target specific reference type. </td></tr>
    <tr><td class="paramname">BaseRef</td><td>the current reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5edb7ca30cd4affb50eb1fe6e3a1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5edb7ca30cd4affb50eb1fe6e3a1d13">&#9670;&nbsp;</a></span>EnvCheckSignals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::EnvCheckSignals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if signals have been sent to the process and if so invoke the registered signal handler in the frontend environment. </p>
<p>When running TVM in another language (Python), the signal handler may not be immediately executed, but instead the signal is marked in the interpreter state (to ensure non-blocking of the signal handler).</p>
<p>This function can be explicitly invoked to check the cached signal and run the related processing if a signal is marked.</p>
<p>On Linux, when siginterrupt() is set, invoke this function whenever a syscall returns EINTR. When it is not set, invoke it between long-running syscalls when you will not immediately return to the frontend. On Windows, the same rules apply, but due to differences in signal processing, these are likely to only make a difference when used with Ctrl+C and socket calls.</p>
<p>Not inserting this function will not cause any correctness issue, but will delay invoking the Python-side signal handler until the function returns to the Python side. This means that the effect of e.g. pressing Ctrl+C or sending signals the process will be delayed until function return. When a C function is blocked on a syscall such as accept(), it needs to be called when EINTR is received. So this function is not needed in most API functions, which can finish quickly in a reasonable, deterministic amount of time.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> check_signal_every_k_iter = 10;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter = 0; iter &lt; very_large_number; ++iter) {</div><div class="line">  <span class="keywordflow">if</span> (iter % check_signal_every_k_iter == 0) {</div><div class="line">    <a class="code" href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">tvm::runtime::EnvCheckSignals</a>();</div><div class="line">  }</div><div class="line">  <span class="comment">// do work here</span></div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function is a nop when no PyErr_CheckSignals is registered.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>function throws an exception when the frontend signal handler indicate an error happens, otherwise it returns normally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06a49d761ea6373557c24c01eaceb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a49d761ea6373557c24c01eaceb07d">&#9670;&nbsp;</a></span>GetCustomTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::GetCustomTypeName </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for getting custom type name from code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Custom type name </dd></dl>

</div>
</div>
<a id="a1b8eedadc5a269b2f9614ce69a9932e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8eedadc5a269b2f9614ce69a9932e7">&#9670;&nbsp;</a></span>GetCustomTypeRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::GetCustomTypeRegistered </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for checking whether custom type is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1Bool.html" title="Boolean constant. ">Bool</a> representing whether type is registered </dd></dl>

</div>
</div>
<a id="a59940b6d63dd4c5175c0fe875047c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59940b6d63dd4c5175c0fe875047c1cf">&#9670;&nbsp;</a></span>GetDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::runtime::GetDataSize </td>
          <td>(</td>
          <td class="paramtype">const DLTensor &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the size of data the DLTensor hold, in term of number of bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input DLTensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of data in the DLTensor. </dd></dl>

</div>
</div>
<a id="a46bcf7948293194c5b9c7db91da96381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bcf7948293194c5b9c7db91da96381">&#9670;&nbsp;</a></span>GetObjectPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object ptr type from a raw object ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BaseType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a id="ac2d903012aff56c2bd54ff66f48450c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d903012aff56c2bd54ff66f48450c3">&#9670;&nbsp;</a></span>GetObjectPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4a97de4fefd23aa5942c6a545544a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a97de4fefd23aa5942c6a545544a05">&#9670;&nbsp;</a></span>GetRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RelayRefType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a> tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference type from a raw object ptr type. </p>
<p>It is always important to get a reference type if we want to return a value as reference or keep the object alive beyond the scope of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RefType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a id="af63300957592e8991c18c54703123ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63300957592e8991c18c54703123ef7">&#9670;&nbsp;</a></span>GetRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RefType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefType tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d284249899038cca33c40d97eefa1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d284249899038cca33c40d97eefa1e3">&#9670;&nbsp;</a></span>GetRPCSessionIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetRPCSessionIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the RPCSessTable index of the RPC Session that owns this device. </p>
<dl class="section return"><dt>Returns</dt><dd>the table index. </dd></dl>

</div>
</div>
<a id="ad01a53416152b68029d67190c3709d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a53416152b68029d67190c3709d25">&#9670;&nbsp;</a></span>GetVectorBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetVectorBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes needed in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes needed. </dd></dl>

</div>
</div>
<a id="adb2ed1227b418f5846d43d3234b52391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2ed1227b418f5846d43d3234b52391">&#9670;&nbsp;</a></span>IsContiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::IsContiguous </td>
          <td>(</td>
          <td class="paramtype">const DLTensor &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a DLTensor is contiguous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The input DLTensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The check result. </dd></dl>

</div>
</div>
<a id="aa5f13cd8047078f88d142fe53337ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f13cd8047078f88d142fe53337ba6f">&#9670;&nbsp;</a></span>IsRPCSessionDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::IsRPCSessionDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a Device is owned by an RPC session. </p>

</div>
</div>
<a id="a0537c9d197068a02c26cd702ab42f6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0537c9d197068a02c26cd702ab42f6ff">&#9670;&nbsp;</a></span>make_inplace_array_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;ArrayType&gt; tvm::runtime::make_inplace_array_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af55276b6524dbaf78e3eaba39ee9ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55276b6524dbaf78e3eaba39ee9ce16">&#9670;&nbsp;</a></span>make_object() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate an object using default allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the node type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> to the allocated object. </dd></dl>

</div>
</div>
<a id="a5ca61f3e3dd7af5ee94ed7886f638ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca61f3e3dd7af5ee94ed7886f638ee5">&#9670;&nbsp;</a></span>make_object() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a>&gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b4c19389363853e409527badb5b177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4c19389363853e409527badb5b177">&#9670;&nbsp;</a></span>make_object() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1MapNode.html">MapNode</a>&gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff337677f23f7d665960f553fb52ab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff337677f23f7d665960f553fb52ab86">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, K&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, V&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;K, V&gt; tvm::runtime::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two Maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> to merge. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> to merge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs. ">Array</a>. Original Maps are kept unchanged. </dd></dl>

</div>
</div>
<a id="a7d584f14566754b91a0e7f415b83fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d584f14566754b91a0e7f415b83fbda">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab556e58d616b05ce4ae338f887b17cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab556e58d616b05ce4ae338f887b17cb4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504adcfea8e21b2865b56cdfad447918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504adcfea8e21b2865b56cdfad447918">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a808c040486da95a7fa2f4725b55635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a808c040486da95a7fa2f4725b55635">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d1999febc0f97ae2e2c9cc12edd280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d1999febc0f97ae2e2c9cc12edd280">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dbaf8d9ec6bd68590a23da05d8a2831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbaf8d9ec6bd68590a23da05d8a2831">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c069145ecfa5909a77841f60332af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c069145ecfa5909a77841f60332af4d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc9820cf44823ad5098183e9dbd7b867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9820cf44823ad5098183e9dbd7b867">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a935d5423ffab64da49612e80f775a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935d5423ffab64da49612e80f775a8ff">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca259da80169ea60877e17c98a0b472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca259da80169ea60877e17c98a0b472a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2865dffa2fddf5eff9d7ed397563ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2865dffa2fddf5eff9d7ed397563ebd6">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5305faaeefd679da62186dab423bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5305faaeefd679da62186dab423bdab">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a263e89c942dc4b01075dd01b6882a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263e89c942dc4b01075dd01b6882a814">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbbf6ce2f770d4f348ace3407ee9c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbf6ce2f770d4f348ace3407ee9c500">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab77f7b17aece9015b0ef91908f75b5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77f7b17aece9015b0ef91908f75b5f4">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af22b89284299c81d0c1802199af446d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22b89284299c81d0c1802199af446d7">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06b70cf1ffccb2b7737d26cccb4103d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b70cf1ffccb2b7737d26cccb4103d8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ed99740d7bb838d96617de83ff2363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ed99740d7bb838d96617de83ff2363">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d447b7bdac52d26bca3422fe098f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d447b7bdac52d26bca3422fe098f6f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c20920d4a09a6c022768b353ec8df2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c20920d4a09a6c022768b353ec8df2a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92428efae022d4982b2644f8960d4386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92428efae022d4982b2644f8960d4386">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8daf39dc422f228fae2ec11a426bab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daf39dc422f228fae2ec11a426bab28">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf2e7e67fd12d69c5bce2be881c8296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf2e7e67fd12d69c5bce2be881c8296">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d696c920a17b8c54775705062de75be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d696c920a17b8c54775705062de75be">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e76c697beb4a77556a869f7cc45f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76c697beb4a77556a869f7cc45f09a">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04626a0c1e717679d673bc90c6a23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04626a0c1e717679d673bc90c6a23f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81dae8fb1a2fa349cfb272525294f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dae8fb1a2fa349cfb272525294f954">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5109f107067bdcf493aafafd8896e031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5109f107067bdcf493aafafd8896e031">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a5995094218eac7fe1f98e1abee852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5995094218eac7fe1f98e1abee852d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac77c2b6d2b8176af69f6e6cccbe736c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77c2b6d2b8176af69f6e6cccbe736c2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7996be0c57184e8ff9e655d0d055edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7996be0c57184e8ff9e655d0d055edc">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a031e6c8e64cd9db11754355e3250ab4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e6c8e64cd9db11754355e3250ab4c">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf23f2e6b19c87ecf3f27a7506ddf4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf23f2e6b19c87ecf3f27a7506ddf4c0">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2001f8f5205170a33ea1b9db314549c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2001f8f5205170a33ea1b9db314549c9">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa52eb43328fdca2972a8312bb1ed6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa52eb43328fdca2972a8312bb1ed6d0">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a944029d40e689e4d2acab53ce36a5c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944029d40e689e4d2acab53ce36a5c99">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f8694e651078c6df7c5c26898ee9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8694e651078c6df7c5c26898ee9f14">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7310fb8b9944f41f8f30021d92847eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7310fb8b9944f41f8f30021d92847eb">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb4bb211393bf9d17b138cad36421c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4bb211393bf9d17b138cad36421c84">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad83a0ea66d3af9fd1b232e49a960f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83a0ea66d3af9fd1b232e49a960f6f4">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6d167947285dff3c780bd5d01ace9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d167947285dff3c780bd5d01ace9b9">&#9670;&nbsp;</a></span>ParseCustomDatatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t tvm::runtime::ParseCustomDatatype </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for parsing string of the form "custom[&lt;typename&gt;]". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="classtvm_1_1runtime_1_1String.html" title="Reference to string objects. ">String</a> to parse </td></tr>
    <tr><td class="paramname">scan</td><td>pointer to parsing pointer, which is scanning across s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type code of custom type parsed </dd></dl>

</div>
</div>
<a id="af32398517b6b915361c5716f8e32c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32398517b6b915361c5716f8e32c16f">&#9670;&nbsp;</a></span>RemoveRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::RemoveRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device with non-zero RPC Session mask, valid on the RPC client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device without any RPC Session mask, valid on the RPC server. </dd></dl>

</div>
</div>
<a id="abbea0c23882ae01431ac7fe6506b32a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbea0c23882ae01431ac7fe6506b32a7">&#9670;&nbsp;</a></span>RuntimeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::RuntimeEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if runtime module is enabled for target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target module name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether runtime is enabled. </dd></dl>

</div>
</div>
<a id="a5e4682aef4c22170449389fa455ab434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4682aef4c22170449389fa455ab434">&#9670;&nbsp;</a></span>RuntimeObject2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::RuntimeObject2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fb37910dcd9bb6899e6a3a47f006514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb37910dcd9bb6899e6a3a47f006514">&#9670;&nbsp;</a></span>SaveDLTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::SaveDLTensor </td>
          <td>(</td>
          <td class="paramtype">dmlc::Stream *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLTensor *&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a DLTensor to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>The output stream </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a277f104e659f71cd8885744700016341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277f104e659f71cd8885744700016341">&#9670;&nbsp;</a></span>String2DLDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DLDataType tvm::runtime::String2DLDataType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a string to TVM type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type. </dd></dl>

</div>
</div>
<a id="afdd7050eda88b079f0a962bd413a34ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd7050eda88b079f0a962bd413a34ea">&#9670;&nbsp;</a></span>TVMArrayHandleToObjectHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a>* tvm::runtime::TVMArrayHandleToObjectHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee574cee6755b0c2f1aa664c6967686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee574cee6755b0c2f1aa664c6967686f">&#9670;&nbsp;</a></span>TypeEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeEqual </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two types are equal . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbabb7cfb79bfb6d802f65a9803e4eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbabb7cfb79bfb6d802f65a9803e4eb6">&#9670;&nbsp;</a></span>TypeMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeMatch </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether type matches the given spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type </td></tr>
    <tr><td class="paramname">code</td><td>The type code. </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to be matched. </td></tr>
    <tr><td class="paramname">lanes</td><td>The number of lanes in the type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac8a77303649fb143634796b3dc50a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a77303649fb143634796b3dc50a286">&#9670;&nbsp;</a></span>kAllocAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kAllocAlignment = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to. </p>

</div>
</div>
<a id="a551bab1e24e2e794f8ccd4446b63a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551bab1e24e2e794f8ccd4446b63a7af">&#9670;&nbsp;</a></span>kDefaultWorkspaceAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kDefaultWorkspaceAlignment = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors. </p>

</div>
</div>
<a id="a2f6f769f6dbbbb24929b7c9f91a48c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6f769f6dbbbb24929b7c9f91a48c90">&#9670;&nbsp;</a></span>kMaxStackAlloca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kMaxStackAlloca = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size that can be allocated on stack. </p>

</div>
</div>
<a id="a48cbe06e6c95ca6fabc20dd1cbacc2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cbe06e6c95ca6fabc20dd1cbacc2c9">&#9670;&nbsp;</a></span>kRPCSessMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kRPCSessMask = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type bigger than this is RPC device. </p>

</div>
</div>
<a id="a8f5819cabea098a1818cf7cda40fdb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5819cabea098a1818cf7cda40fdb1f">&#9670;&nbsp;</a></span>kTempAllocaAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kTempAllocaAlignment = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to in temporary allocation. </p>

</div>
</div>
<a id="acf4599f17bfe79ae1fe8afc1af053b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4599f17bfe79ae1fe8afc1af053b43">&#9670;&nbsp;</a></span>kTVMNDArrayMagic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t tvm::runtime::kTVMNDArrayMagic = 0xDD5E40F096B4A13F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a> file. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
