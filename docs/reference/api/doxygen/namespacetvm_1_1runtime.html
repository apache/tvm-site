<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::runtime Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1runtime.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::runtime Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1contrib"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1contrib.html">contrib</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1cuda__ipc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1cuda__ipc.html">cuda_ipc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1memory"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1memory.html">memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1metadata"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1metadata.html">metadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1micro__rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1micro__rpc.html">micro_rpc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1profiling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1profiling.html">profiling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1relax__vm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1relax__vm.html">relax_vm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1symbol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1symbol.html">symbol</a></td></tr>
<tr class="memdesc:namespacetvm_1_1runtime_1_1symbol"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for constant symbols <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1threading"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1threading.html">threading</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1vm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1vm.html">vm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01PrimExpr_01_4.html">PackedFuncValueConverter&lt; PrimExpr &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01tvm_1_1Integer_01_4.html">PackedFuncValueConverter&lt; tvm::Integer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01tvm_1_1Bool_01_4.html">PackedFuncValueConverter&lt; tvm::Bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADTObj.html">ADTObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a structure or enumeration.  <a href="classtvm_1_1runtime_1_1ADTObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to algebraic data type objects.  <a href="classtvm_1_1runtime_1_1ADT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array node content in array  <a href="classtvm_1_1runtime_1_1ArrayNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1is__valid__iterator.html">is_valid_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for type-checking.  <a href="structtvm_1_1runtime_1_1is__valid__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1is__valid__iterator_3_01Optional_3_01T_01_4_00_01IterType_01_4.html">is_valid_iterator&lt; Optional&lt; T &gt;, IterType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs.">Array</a>, container representing a contiguous sequence of ObjectRefs.  <a href="classtvm_1_1runtime_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectHash.html">ObjectHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-aware <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference.">ObjectRef</a> equal functor.  <a href="structtvm_1_1runtime_1_1ObjectHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectEqual.html">ObjectEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-aware <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference.">ObjectRef</a> hash functor.  <a href="structtvm_1_1runtime_1_1ObjectEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1InplaceArrayBase.html">InplaceArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for classes with array like memory layout.  <a href="classtvm_1_1runtime_1_1InplaceArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1IterAdapter.html">IterAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adapter that adapts TIter to return another type.  <a href="classtvm_1_1runtime_1_1IterAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ReverseIterAdapter.html">ReverseIterAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adapter that adapts TIter to return another type.  <a href="classtvm_1_1runtime_1_1ReverseIterAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ClosureObj.html">ClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a closure. This object is used by both the Relay VM and interpreter.  <a href="classtvm_1_1runtime_1_1ClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to closure.  <a href="classtvm_1_1runtime_1_1Closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1MapNode.html">MapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared content of all specializations of hash map.  <a href="classtvm_1_1runtime_1_1MapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SmallMapNode.html">SmallMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of small-sized hash map.  <a href="classtvm_1_1runtime_1_1SmallMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DenseMapNode.html">DenseMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of hash map that implements the idea of array-based hash map. Another reference implementation can be found [1].  <a href="classtvm_1_1runtime_1_1DenseMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics,...">Map</a> container of NodeRef-&gt;NodeRef in DSL graph. <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics,...">Map</a> implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places.  <a href="classtvm_1_1runtime_1_1Map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1NullOptType.html">NullOptType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to represent nullptr for optional.  <a href="structtvm_1_1runtime_1_1NullOptType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Optional.html" title="Optional container that to represent to a Nullable variant of T.">Optional</a> container that to represent to a Nullable variant of T.  <a href="classtvm_1_1runtime_1_1Optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ShapeTupleObj.html">ShapeTupleObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a shape tuple.  <a href="classtvm_1_1runtime_1_1ShapeTupleObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to shape tuple objects.  <a href="classtvm_1_1runtime_1_1ShapeTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1StringObj.html">StringObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing string. It's POD type.  <a href="classtvm_1_1runtime_1_1StringObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to string objects.  <a href="classtvm_1_1runtime_1_1String.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Variant.html">Variant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime primitive data type.  <a href="classtvm_1_1runtime_1_1DataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DeviceAPI.html">DeviceAPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TVM Runtime Device API, abstracts the device specific interface for memory management.  <a href="classtvm_1_1runtime_1_1DeviceAPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DiscoWorker.html">DiscoWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker in Disco. It takes a channel to communication with the controler. The worker can be run in a separate thread or process as long as the channel supports bi-directional communication in-between.  <a href="classtvm_1_1runtime_1_1DiscoWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DRefObj.html">DRefObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that exists on all workers.  <a href="classtvm_1_1runtime_1_1DRefObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DRef.html">DRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1runtime_1_1DRefObj.html" title="An object that exists on all workers.">DRefObj</a>.  <a href="classtvm_1_1runtime_1_1DRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SessionObj.html">SessionObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Disco interactive session. It allows users to interact with the Disco command queue with various <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format.">PackedFunc</a> calling convention.  <a href="classtvm_1_1runtime_1_1SessionObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Session.html">Session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1runtime_1_1SessionObj.html" title="A Disco interactive session. It allows users to interact with the Disco command queue with various Pa...">SessionObj</a>.  <a href="classtvm_1_1runtime_1_1Session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DiscoChannel.html">DiscoChannel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bi-directional channel for controler-worker communication. This channel is primarily used to transfer control messages but not data.  <a href="classtvm_1_1runtime_1_1DiscoChannel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1WorkerZeroData.html">WorkerZeroData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special communication channel between controler and worker-0, assuming they are always collocated in the same process.  <a href="classtvm_1_1runtime_1_1WorkerZeroData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjAllocatorBase.html">ObjAllocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of object allocators that implements make. Use curiously recurring template pattern.  <a href="classtvm_1_1runtime_1_1ObjAllocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SimpleObjAllocator.html">SimpleObjAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM.">Module</a> container of TVM.  <a href="classtvm_1_1runtime_1_1Module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ModuleNode.html">ModuleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container of module.  <a href="classtvm_1_1runtime_1_1ModuleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a>. The array is backed by reference counted blocks.  <a href="classtvm_1_1runtime_1_1NDArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1NVTXScopedRange.html">NVTXScopedRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to create a NVTX range. No-op if TVM is not built against NVTX.  <a href="classtvm_1_1runtime_1_1NVTXScopedRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1TypeIndex.html">TypeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the list of type index.  <a href="structtvm_1_1runtime_1_1TypeIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of all object containers.  <a href="classtvm_1_1runtime_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom smart pointer for <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers.">Object</a>.  <a href="classtvm_1_1runtime_1_1ObjectPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all object reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectPtrHash.html">ObjectPtrHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference.">ObjectRef</a> hash functor.  <a href="structtvm_1_1runtime_1_1ObjectPtrHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectPtrEqual.html">ObjectPtrEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference.">ObjectRef</a> equal functor.  <a href="structtvm_1_1runtime_1_1ObjectPtrEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">TypedPackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please refer to <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#TypedPackedFuncAnchor">TypedPackedFunc&lt;R(Args..)&gt;</a>.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1SignaturePrinter.html">SignaturePrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFuncObj.html">PackedFuncObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers.">Object</a> container class that backs <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format.">PackedFunc</a>.  <a href="classtvm_1_1runtime_1_1PackedFuncObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFuncSubObj.html">PackedFuncSubObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived object class for constructing <a class="el" href="classtvm_1_1runtime_1_1PackedFuncObj.html" title="Object container class that backs PackedFunc.">PackedFuncObj</a>.  <a href="classtvm_1_1runtime_1_1PackedFuncSubObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">PackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed function is a type-erased function. The arguments are passed by packed format.  <a href="classtvm_1_1runtime_1_1PackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html">TypedPackedFunc&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format.">PackedFunc</a> wrapper to provide typed function signature. It is backed by a <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format.">PackedFunc</a> internally.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgs.html">TVMArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments into TVM functions.  <a href="classtvm_1_1runtime_1_1TVMArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker.html">ObjectTypeChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode.">Type</a> traits for runtime type check during FFI conversion.  <a href="structtvm_1_1runtime_1_1ObjectTypeChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4.html">ObjectTypeChecker&lt; Array&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4.html">ObjectTypeChecker&lt; Map&lt; K, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMPODValue__.html">TVMPODValue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal base class to handle conversion to POD values.  <a href="classtvm_1_1runtime_1_1TVMPODValue__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html">TVMArgValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single argument value to <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format.">PackedFunc</a>. Containing both type_code and <a class="el" href="unionTVMValue.html" title="Union type of values being passed through API and function calls.">TVMValue</a>.  <a href="classtvm_1_1runtime_1_1TVMArgValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMMovableArgValue__.html">TVMMovableArgValue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal auxiliary struct for <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;.">TypedPackedFunc</a> to indicate a movable argument.  <a href="classtvm_1_1runtime_1_1TVMMovableArgValue__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMMovableArgValueWithContext__.html">TVMMovableArgValueWithContext_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal auxiliary struct for <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;.">TypedPackedFunc</a> to indicate a movable argument with additional context information (function name and argument index) for better error reporting.  <a href="classtvm_1_1runtime_1_1TVMMovableArgValueWithContext__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html">TVMRetValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Value container, Unlike <a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html" title="A single argument value to PackedFunc. Containing both type_code and TVMValue.">TVMArgValue</a>, which only holds reference and do not delete the underlying container during destruction.  <a href="classtvm_1_1runtime_1_1TVMRetValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter.html">PackedFuncValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode.">Type</a> trait to specify special value conversion rules from <a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html" title="A single argument value to PackedFunc. Containing both type_code and TVMValue.">TVMArgValue</a> and <a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html" title="Return Value container, Unlike TVMArgValue, which only holds reference and do not delete the underlyi...">TVMRetValue</a>.  <a href="structtvm_1_1runtime_1_1PackedFuncValueConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgsSetter.html">TVMArgsSetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1TVMArgsSetterApply.html">TVMArgsSetterApply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_1_1tvm_1_1runtime_1_1String_01_4.html">PackedFuncValueConverter&lt;::tvm::runtime::String &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01Optional_3_01T_01_4_01_4.html">PackedFuncValueConverter&lt; Optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1PackedFuncValueConverter_3_01Variant_3_01VariantTypes_8_8_8_01_4_01_4.html">PackedFuncValueConverter&lt; Variant&lt; VariantTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TimerNode.html">TimerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all implementations.  <a href="classtvm_1_1runtime_1_1TimerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Timer.html" title="Timer for a specific device.">Timer</a> for a specific device.  <a href="classtvm_1_1runtime_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1WrappedPythonObject.html">WrappedPythonObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that wraps a Python object and preserves its ownership.  <a href="classtvm_1_1runtime_1_1WrappedPythonObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Registry.html" title="Registry for global function.">Registry</a> for global function.  <a href="classtvm_1_1runtime_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4bc1ad60cb099dde44f5b5ee0f1b7216"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4bc1ad60cb099dde44f5b5ee0f1b7216">IntTuple</a> = <a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a></td></tr>
<tr class="separator:a4bc1ad60cb099dde44f5b5ee0f1b7216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05cfd921c5454ad8100de9e0f6c6a3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ae05cfd921c5454ad8100de9e0f6c6a3b">IntTupleObj</a> = <a class="el" href="classtvm_1_1runtime_1_1ShapeTupleObj.html">ShapeTupleObj</a></td></tr>
<tr class="separator:ae05cfd921c5454ad8100de9e0f6c6a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28022a2dc86007a65b24b8c41e0c7da3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a28022a2dc86007a65b24b8c41e0c7da3">FSig</a> = std::string()</td></tr>
<tr class="memdesc:a28022a2dc86007a65b24b8c41e0c7da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using static function to output <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;.">TypedPackedFunc</a> signature.  <a href="namespacetvm_1_1runtime.html#a28022a2dc86007a65b24b8c41e0c7da3">More...</a><br /></td></tr>
<tr class="separator:a28022a2dc86007a65b24b8c41e0c7da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">DeviceAttrKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb">kExist</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4">kMaxThreadsPerBlock</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da">kWarpSize</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264">kMaxSharedMemoryPerBlock</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b">kComputeVersion</a> = 4
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca">kDeviceName</a> = 5
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630">kMaxClockRate</a> = 6
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd">kMultiProcessorCount</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991">kMaxThreadDimensions</a> = 8
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357">kMaxRegistersPerBlock</a> = 9
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201">kGcnArch</a> = 10
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337">kApiVersion</a> = 11
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9">kDriverVersion</a> = 12
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afebd0fa20dbcf8f5fe6b31f7bdfb7496">kL2CacheSizeBytes</a> = 13
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aaefa5c35ec7a4ef2fab9d26949b3de12">kTotalGlobalMemory</a> = 14
, <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ab5557051e97fe70b60484ce6589f91de">kAvailableGlobalMemory</a> = 15
<br />
 }</td></tr>
<tr class="memdesc:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="mdescLeft">&#160;</td><td class="mdescRight">the query type into GetAttr  <a href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">More...</a><br /></td></tr>
<tr class="separator:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebb65e06d120de112c54fdcd10c27d7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa1dc5fbfa16754d1e628d66381725617">kSum</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7a4eef5c699751ff1b31a7fcc194b28a88">kProd</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7a8fbc2f6c44a6d70550df79903eb57d48">kMin</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa0b1ac8aae6b1cfbbe89085c642b3b4b">kMax</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7aa22c1525680159c49e69ff9c43d1d01b">kAvg</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a9ebb65e06d120de112c54fdcd10c27d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible kinds of reduction operations.  <a href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">More...</a><br /></td></tr>
<tr class="separator:a9ebb65e06d120de112c54fdcd10c27d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba6565e739bed4d5078c2ff998deae8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aff48289104dbc943d0354379e43f7e5f">kShutDown</a> = 0
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8ad6aaaf2cb07d224d5aed793c09a777ef">kKillReg</a> = 1
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8abd597f33da21ed3ec14131295daab521">kGetGlobalFunc</a> = 2
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aeab0582e669357bc410678d34b50178f">kCallPacked</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8ac4e6997e9ed12a3933fa5ab71fc364ef">kSyncWorker</a> = 4
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8a3bc0e63927f289f5a8956e0c2c791cea">kCopyFromWorker0</a> = 5
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8affb0ed964f1001fecda2ea2e8ac90bea">kCopyToWorker0</a> = 6
, <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8aa9e0e3dadb4ecfc65792001a864b868a">kDebugGetFromRemote</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8a08f61e83ccd56e0950d9b9b36d6f1a15">kDebugSetRegister</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a4ba6565e739bed4d5078c2ff998deae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">All possible kinds of Disco commands.  <a href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">More...</a><br /></td></tr>
<tr class="separator:a4ba6565e739bed4d5078c2ff998deae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edb2235f96c34eaf0119834d293ca54"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54">ModulePropertyMask</a> : int { <a class="el" href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54abb73d116e7bde220e81a19e98cc62103">kBinarySerializable</a> = 0b001
, <a class="el" href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54a6aa052b038d11007d0df028d29fcda2e">kRunnable</a> = 0b010
, <a class="el" href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54aeac3ca683f62d5793245a4a4a378015c">kDSOExportable</a> = 0b100
 }</td></tr>
<tr class="memdesc:a6edb2235f96c34eaf0119834d293ca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property of runtime module We classify the property of runtime module into the following categories.  <a href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54">More...</a><br /></td></tr>
<tr class="separator:a6edb2235f96c34eaf0119834d293ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af22b89284299c81d0c1802199af446d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af22b89284299c81d0c1802199af446d7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;n)</td></tr>
<tr class="separator:af22b89284299c81d0c1802199af446d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae07357d6856dcdb0b501e7f0e49e1ac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aae07357d6856dcdb0b501e7f0e49e1ac">AsLegacyRepr</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;n)</td></tr>
<tr class="separator:aae07357d6856dcdb0b501e7f0e49e1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4a8b9d4d20b7993992145f73efa2abf2">Concat</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; lhs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4a8b9d4d20b7993992145f73efa2abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concat two Arrays.  <a href="namespacetvm_1_1runtime.html#a4a8b9d4d20b7993992145f73efa2abf2">More...</a><br /></td></tr>
<tr class="separator:a4a8b9d4d20b7993992145f73efa2abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189d7506cfd1acacd3cdfc04d399a03"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3189d7506cfd1acacd3cdfc04d399a03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ArrayNode.html">ArrayNode</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a3189d7506cfd1acacd3cdfc04d399a03">make_object</a> ()</td></tr>
<tr class="separator:a3189d7506cfd1acacd3cdfc04d399a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff337677f23f7d665960f553fb52ab86"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, K&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, V&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aff337677f23f7d665960f553fb52ab86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aff337677f23f7d665960f553fb52ab86">Merge</a> (<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; lhs, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aff337677f23f7d665960f553fb52ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two Maps.  <a href="namespacetvm_1_1runtime.html#aff337677f23f7d665960f553fb52ab86">More...</a><br /></td></tr>
<tr class="separator:aff337677f23f7d665960f553fb52ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88cd3c4604865b859373cb32ff53be5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af88cd3c4604865b859373cb32ff53be5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a> &amp;shape)</td></tr>
<tr class="separator:af88cd3c4604865b859373cb32ff53be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbaf8d9ec6bd68590a23da05d8a2831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a3dbaf8d9ec6bd68590a23da05d8a2831">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a3dbaf8d9ec6bd68590a23da05d8a2831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c069145ecfa5909a77841f60332af4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5c069145ecfa5909a77841f60332af4d">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a5c069145ecfa5909a77841f60332af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9820cf44823ad5098183e9dbd7b867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acc9820cf44823ad5098183e9dbd7b867">operator+</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:acc9820cf44823ad5098183e9dbd7b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935d5423ffab64da49612e80f775a8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a935d5423ffab64da49612e80f775a8ff">operator+</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a935d5423ffab64da49612e80f775a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca259da80169ea60877e17c98a0b472a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aca259da80169ea60877e17c98a0b472a">operator+</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:aca259da80169ea60877e17c98a0b472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2865dffa2fddf5eff9d7ed397563ebd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2865dffa2fddf5eff9d7ed397563ebd6">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a2865dffa2fddf5eff9d7ed397563ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5305faaeefd679da62186dab423bdab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad5305faaeefd679da62186dab423bdab">operator&lt;</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad5305faaeefd679da62186dab423bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263e89c942dc4b01075dd01b6882a814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a263e89c942dc4b01075dd01b6882a814">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a263e89c942dc4b01075dd01b6882a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbf6ce2f770d4f348ace3407ee9c500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acbbf6ce2f770d4f348ace3407ee9c500">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:acbbf6ce2f770d4f348ace3407ee9c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77f7b17aece9015b0ef91908f75b5f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab77f7b17aece9015b0ef91908f75b5f4">operator&lt;</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ab77f7b17aece9015b0ef91908f75b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7996be0c57184e8ff9e655d0d055edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af7996be0c57184e8ff9e655d0d055edc">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:af7996be0c57184e8ff9e655d0d055edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e6c8e64cd9db11754355e3250ab4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a031e6c8e64cd9db11754355e3250ab4c">operator&gt;</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a031e6c8e64cd9db11754355e3250ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf23f2e6b19c87ecf3f27a7506ddf4c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abf23f2e6b19c87ecf3f27a7506ddf4c0">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:abf23f2e6b19c87ecf3f27a7506ddf4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001f8f5205170a33ea1b9db314549c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2001f8f5205170a33ea1b9db314549c9">operator&gt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a2001f8f5205170a33ea1b9db314549c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa52eb43328fdca2972a8312bb1ed6d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afa52eb43328fdca2972a8312bb1ed6d0">operator&gt;</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:afa52eb43328fdca2972a8312bb1ed6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92428efae022d4982b2644f8960d4386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a92428efae022d4982b2644f8960d4386">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a92428efae022d4982b2644f8960d4386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf39dc422f228fae2ec11a426bab28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8daf39dc422f228fae2ec11a426bab28">operator&lt;=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a8daf39dc422f228fae2ec11a426bab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf2e7e67fd12d69c5bce2be881c8296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9cf2e7e67fd12d69c5bce2be881c8296">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a9cf2e7e67fd12d69c5bce2be881c8296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d696c920a17b8c54775705062de75be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1d696c920a17b8c54775705062de75be">operator&lt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a1d696c920a17b8c54775705062de75be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76c697beb4a77556a869f7cc45f09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2e76c697beb4a77556a869f7cc45f09a">operator&lt;=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a2e76c697beb4a77556a869f7cc45f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944029d40e689e4d2acab53ce36a5c99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a944029d40e689e4d2acab53ce36a5c99">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a944029d40e689e4d2acab53ce36a5c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8694e651078c6df7c5c26898ee9f14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f8694e651078c6df7c5c26898ee9f14">operator&gt;=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a8f8694e651078c6df7c5c26898ee9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7310fb8b9944f41f8f30021d92847eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af7310fb8b9944f41f8f30021d92847eb">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:af7310fb8b9944f41f8f30021d92847eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4bb211393bf9d17b138cad36421c84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afb4bb211393bf9d17b138cad36421c84">operator&gt;=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:afb4bb211393bf9d17b138cad36421c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a0ea66d3af9fd1b232e49a960f6f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad83a0ea66d3af9fd1b232e49a960f6f4">operator&gt;=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad83a0ea66d3af9fd1b232e49a960f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04626a0c1e717679d673bc90c6a23f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aba04626a0c1e717679d673bc90c6a23f">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:aba04626a0c1e717679d673bc90c6a23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dae8fb1a2fa349cfb272525294f954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a81dae8fb1a2fa349cfb272525294f954">operator==</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a81dae8fb1a2fa349cfb272525294f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109f107067bdcf493aafafd8896e031"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5109f107067bdcf493aafafd8896e031">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a5109f107067bdcf493aafafd8896e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5995094218eac7fe1f98e1abee852d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5a5995094218eac7fe1f98e1abee852d">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a5a5995094218eac7fe1f98e1abee852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77c2b6d2b8176af69f6e6cccbe736c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac77c2b6d2b8176af69f6e6cccbe736c2">operator==</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ac77c2b6d2b8176af69f6e6cccbe736c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d584f14566754b91a0e7f415b83fbda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a7d584f14566754b91a0e7f415b83fbda">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a7d584f14566754b91a0e7f415b83fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab556e58d616b05ce4ae338f887b17cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab556e58d616b05ce4ae338f887b17cb4">operator!=</a> (const std::string &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ab556e58d616b05ce4ae338f887b17cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504adcfea8e21b2865b56cdfad447918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a504adcfea8e21b2865b56cdfad447918">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:a504adcfea8e21b2865b56cdfad447918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a808c040486da95a7fa2f4725b55635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2a808c040486da95a7fa2f4725b55635">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a2a808c040486da95a7fa2f4725b55635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d1999febc0f97ae2e2c9cc12edd280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad4d1999febc0f97ae2e2c9cc12edd280">operator!=</a> (const char *lhs, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rhs)</td></tr>
<tr class="separator:ad4d1999febc0f97ae2e2c9cc12edd280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20920d4a09a6c022768b353ec8df2a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2c20920d4a09a6c022768b353ec8df2a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;input)</td></tr>
<tr class="separator:a2c20920d4a09a6c022768b353ec8df2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01a53416152b68029d67190c3709d25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">GetVectorBytes</a> (<a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype)</td></tr>
<tr class="memdesc:ad01a53416152b68029d67190c3709d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes needed in a vector.  <a href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">More...</a><br /></td></tr>
<tr class="separator:ad01a53416152b68029d67190c3709d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">TypeMatch</a> (DLDataType t, int code, int bits, int lanes=1)</td></tr>
<tr class="memdesc:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether type matches the given spec.  <a href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">More...</a><br /></td></tr>
<tr class="separator:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee574cee6755b0c2f1aa664c6967686f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">TypeEqual</a> (DLDataType lhs, DLDataType rhs)</td></tr>
<tr class="memdesc:aee574cee6755b0c2f1aa664c6967686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two types are equal .  <a href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">More...</a><br /></td></tr>
<tr class="separator:aee574cee6755b0c2f1aa664c6967686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a49d761ea6373557c24c01eaceb07d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a06a49d761ea6373557c24c01eaceb07d">GetCustomTypeName</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a06a49d761ea6373557c24c01eaceb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for getting custom type name from code.  <a href="namespacetvm_1_1runtime.html#a06a49d761ea6373557c24c01eaceb07d">More...</a><br /></td></tr>
<tr class="separator:a06a49d761ea6373557c24c01eaceb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1b8eedadc5a269b2f9614ce69a9932e7">GetCustomTypeRegistered</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for checking whether custom type is registered.  <a href="namespacetvm_1_1runtime.html#a1b8eedadc5a269b2f9614ce69a9932e7">More...</a><br /></td></tr>
<tr class="separator:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d167947285dff3c780bd5d01ace9b9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac6d167947285dff3c780bd5d01ace9b9">ParseCustomDatatype</a> (const std::string &amp;s, const char **scan)</td></tr>
<tr class="memdesc:ac6d167947285dff3c780bd5d01ace9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for parsing string of the form "custom[&lt;typename&gt;]".  <a href="namespacetvm_1_1runtime.html#ac6d167947285dff3c780bd5d01ace9b9">More...</a><br /></td></tr>
<tr class="separator:ac6d167947285dff3c780bd5d01ace9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9303c49b737675bdab034c4032dcc48"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af9303c49b737675bdab034c4032dcc48">DLDataTypeCode2Str</a> (DLDataTypeCode type_code)</td></tr>
<tr class="memdesc:af9303c49b737675bdab034c4032dcc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type code to its name.  <a href="namespacetvm_1_1runtime.html#af9303c49b737675bdab034c4032dcc48">More...</a><br /></td></tr>
<tr class="separator:af9303c49b737675bdab034c4032dcc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277f104e659f71cd8885744700016341"><td class="memItemLeft" align="right" valign="top">DLDataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a277f104e659f71cd8885744700016341">String2DLDataType</a> (std::string s)</td></tr>
<tr class="memdesc:a277f104e659f71cd8885744700016341"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a string to TVM type.  <a href="namespacetvm_1_1runtime.html#a277f104e659f71cd8885744700016341">More...</a><br /></td></tr>
<tr class="separator:a277f104e659f71cd8885744700016341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac360f2d9815036ab1b4d84d9cfb46b4f">DLDataType2String</a> (DLDataType t)</td></tr>
<tr class="memdesc:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a TVM type to string.  <a href="namespacetvm_1_1runtime.html#ac360f2d9815036ab1b4d84d9cfb46b4f">More...</a><br /></td></tr>
<tr class="separator:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed99740d7bb838d96617de83ff2363"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11ed99740d7bb838d96617de83ff2363">operator&lt;&lt;</a> (std::ostream &amp;os, DLDataType t)</td></tr>
<tr class="separator:a11ed99740d7bb838d96617de83ff2363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d447b7bdac52d26bca3422fe098f6f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59d447b7bdac52d26bca3422fe098f6f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;dtype)</td></tr>
<tr class="separator:a59d447b7bdac52d26bca3422fe098f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8593d6430be00492db4b52b3aad542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aec8593d6430be00492db4b52b3aad542">AppendNDArray</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &amp;nd_array, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="memdesc:aec8593d6430be00492db4b52b3aad542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers to describe runtime objects in human-friendly form. For <code>nd_arrays</code> we show their shapes and dtypes, but also their contents if 'small' and on the <code>host_device</code> (mostly so that we can see dynamic shapes as they are computed). For <code>adts</code> we show the <a class="el" href="classtvm_1_1runtime_1_1ADT.html" title="reference to algebraic data type objects.">ADT</a> fields. For <code>objects</code> we dispatch to one of the above as appropriate.  <a href="namespacetvm_1_1runtime.html#aec8593d6430be00492db4b52b3aad542">More...</a><br /></td></tr>
<tr class="separator:aec8593d6430be00492db4b52b3aad542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c142fe6cc61a977ec7ab0e56a77a201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0c142fe6cc61a977ec7ab0e56a77a201">AppendADT</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a> &amp;adt, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a0c142fe6cc61a977ec7ab0e56a77a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da4311f8b37f76fad2d4da39c35f50f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a4da4311f8b37f76fad2d4da39c35f50f">AppendRuntimeObject</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;object, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a4da4311f8b37f76fad2d4da39c35f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4682aef4c22170449389fa455ab434"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a5e4682aef4c22170449389fa455ab434">RuntimeObject2String</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;object, const DLDevice &amp;host_device, bool show_content=true)</td></tr>
<tr class="separator:a5e4682aef4c22170449389fa455ab434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f13cd8047078f88d142fe53337ba6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa5f13cd8047078f88d142fe53337ba6f">IsRPCSessionDevice</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:aa5f13cd8047078f88d142fe53337ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a Device is owned by an RPC session.  <a href="namespacetvm_1_1runtime.html#aa5f13cd8047078f88d142fe53337ba6f">More...</a><br /></td></tr>
<tr class="separator:aa5f13cd8047078f88d142fe53337ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d284249899038cca33c40d97eefa1e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8d284249899038cca33c40d97eefa1e3">GetRPCSessionIndex</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:a8d284249899038cca33c40d97eefa1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RPCSessTable index of the RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> that owns this device.  <a href="namespacetvm_1_1runtime.html#a8d284249899038cca33c40d97eefa1e3">More...</a><br /></td></tr>
<tr class="separator:a8d284249899038cca33c40d97eefa1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32398517b6b915361c5716f8e32c16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af32398517b6b915361c5716f8e32c16f">RemoveRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:af32398517b6b915361c5716f8e32c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation.  <a href="namespacetvm_1_1runtime.html#af32398517b6b915361c5716f8e32c16f">More...</a><br /></td></tr>
<tr class="separator:af32398517b6b915361c5716f8e32c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e8684776f3f98b6a5a13c9c343904f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac9e8684776f3f98b6a5a13c9c343904f">operator&lt;&lt;</a> (std::ostream &amp;os, DLDevice dev)</td></tr>
<tr class="separator:ac9e8684776f3f98b6a5a13c9c343904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa93f6c733bf54ca19d642a5ae2ec94be">AddRPCSessionMask</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev, int session_table_index)</td></tr>
<tr class="memdesc:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote.  <a href="namespacetvm_1_1runtime.html#aa93f6c733bf54ca19d642a5ae2ec94be">More...</a><br /></td></tr>
<tr class="separator:aa93f6c733bf54ca19d642a5ae2ec94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3467a4ef36085dc8262601478a70869a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a3467a4ef36085dc8262601478a70869a">ReduceKind2String</a> (<a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> kind)</td></tr>
<tr class="memdesc:a3467a4ef36085dc8262601478a70869a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>ReduceKind</code> to string.  <a href="namespacetvm_1_1runtime.html#a3467a4ef36085dc8262601478a70869a">More...</a><br /></td></tr>
<tr class="separator:a3467a4ef36085dc8262601478a70869a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7ff3434b2a2d4365f36d94c1dc830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8be7ff3434b2a2d4365f36d94c1dc830">LoadVMModule</a> (std::string path, <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device)</td></tr>
<tr class="memdesc:a8be7ff3434b2a2d4365f36d94c1dc830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a runtime <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM.">Module</a>, then create and initialize a RelaxVM.  <a href="namespacetvm_1_1runtime.html#a8be7ff3434b2a2d4365f36d94c1dc830">More...</a><br /></td></tr>
<tr class="separator:a8be7ff3434b2a2d4365f36d94c1dc830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7aed6ffaafbb6adb9df67bfaa44cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1a7aed6ffaafbb6adb9df67bfaa44cde">DiscoEmptyNDArray</a> (<a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a> shape, <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype, <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device)</td></tr>
<tr class="memdesc:a1a7aed6ffaafbb6adb9df67bfaa44cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialized empty <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a>.  <a href="namespacetvm_1_1runtime.html#a1a7aed6ffaafbb6adb9df67bfaa44cde">More...</a><br /></td></tr>
<tr class="separator:a1a7aed6ffaafbb6adb9df67bfaa44cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad615c644745d2b1e9097e93274760420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad615c644745d2b1e9097e93274760420">AllReduce</a> (<a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> send, <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a> reduce_kind, <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> recv)</td></tr>
<tr class="memdesc:ad615c644745d2b1e9097e93274760420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an allreduce operation using the underlying communication library.  <a href="namespacetvm_1_1runtime.html#ad615c644745d2b1e9097e93274760420">More...</a><br /></td></tr>
<tr class="separator:ad615c644745d2b1e9097e93274760420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3685684365b05e1d1511461f8ada82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aad3685684365b05e1d1511461f8ada82">AllGather</a> (<a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> send, <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> recv)</td></tr>
<tr class="memdesc:aad3685684365b05e1d1511461f8ada82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an allgather operation using the underlying communication library.  <a href="namespacetvm_1_1runtime.html#aad3685684365b05e1d1511461f8ada82">More...</a><br /></td></tr>
<tr class="separator:aad3685684365b05e1d1511461f8ada82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaecde92a8ed3f84a9e7e870825ad1b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abaecde92a8ed3f84a9e7e870825ad1b8">BroadcastFromWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> send, <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> recv)</td></tr>
<tr class="memdesc:abaecde92a8ed3f84a9e7e870825ad1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a broadcast operation from worker-0.  <a href="namespacetvm_1_1runtime.html#abaecde92a8ed3f84a9e7e870825ad1b8">More...</a><br /></td></tr>
<tr class="separator:abaecde92a8ed3f84a9e7e870825ad1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719149b239ba245285be7cda32013b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a719149b239ba245285be7cda32013b72">ScatterFromWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &gt; send, <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> recv)</td></tr>
<tr class="memdesc:a719149b239ba245285be7cda32013b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a scatter operation from worker-0, chunking the given buffer into equal parts.  <a href="namespacetvm_1_1runtime.html#a719149b239ba245285be7cda32013b72">More...</a><br /></td></tr>
<tr class="separator:a719149b239ba245285be7cda32013b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171cee6bb9e18f52c1f6b534c4ebbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af171cee6bb9e18f52c1f6b534c4ebbd9">GatherToWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> send, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &gt; recv)</td></tr>
<tr class="memdesc:af171cee6bb9e18f52c1f6b534c4ebbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a gather operation to worker-0.  <a href="namespacetvm_1_1runtime.html#af171cee6bb9e18f52c1f6b534c4ebbd9">More...</a><br /></td></tr>
<tr class="separator:af171cee6bb9e18f52c1f6b534c4ebbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b211d99323b4e09a76bdb6b6f133cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab6b211d99323b4e09a76bdb6b6f133cb">RecvFromWorker0</a> (<a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> buffer)</td></tr>
<tr class="memdesc:ab6b211d99323b4e09a76bdb6b6f133cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a buffer from worker-0. No-op if the current worker is worker-0.  <a href="namespacetvm_1_1runtime.html#ab6b211d99323b4e09a76bdb6b6f133cb">More...</a><br /></td></tr>
<tr class="separator:ab6b211d99323b4e09a76bdb6b6f133cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11d7c335ce64b50b3e6cee085d55c8fc">WorkerId</a> ()</td></tr>
<tr class="memdesc:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local worker id.  <a href="namespacetvm_1_1runtime.html#a11d7c335ce64b50b3e6cee085d55c8fc">More...</a><br /></td></tr>
<tr class="separator:a11d7c335ce64b50b3e6cee085d55c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f369b9882f8ec57826acd5f86c4404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a65f369b9882f8ec57826acd5f86c4404">SyncWorker</a> ()</td></tr>
<tr class="memdesc:a65f369b9882f8ec57826acd5f86c4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the worker thread. Waiting until the worker completes all its tasks. As a specific example, on a CUDA worker, it blocks until all kernels are launched and cudaStreamSynchronize is complete.  <a href="namespacetvm_1_1runtime.html#a65f369b9882f8ec57826acd5f86c4404">More...</a><br /></td></tr>
<tr class="separator:a65f369b9882f8ec57826acd5f86c4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3703032b26941b2dc4a6660d7dcc14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0c3703032b26941b2dc4a6660d7dcc14">DiscoAction2String</a> (<a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a> action)</td></tr>
<tr class="memdesc:a0c3703032b26941b2dc4a6660d7dcc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the enum class <code>DiscoAction</code> to string.  <a href="namespacetvm_1_1runtime.html#a0c3703032b26941b2dc4a6660d7dcc14">More...</a><br /></td></tr>
<tr class="separator:a0c3703032b26941b2dc4a6660d7dcc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af55276b6524dbaf78e3eaba39ee9ce16">make_object</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af55276b6524dbaf78e3eaba39ee9ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an object using default allocator.  <a href="namespacetvm_1_1runtime.html#af55276b6524dbaf78e3eaba39ee9ce16">More...</a><br /></td></tr>
<tr class="separator:af55276b6524dbaf78e3eaba39ee9ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0537c9d197068a02c26cd702ab42f6ff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </td></tr>
<tr class="memitem:a0537c9d197068a02c26cd702ab42f6ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ArrayType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0537c9d197068a02c26cd702ab42f6ff">make_inplace_array_object</a> (size_t num_elems, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a0537c9d197068a02c26cd702ab42f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ae6d933eb1e7414afa9a9a62d22cd2522">RuntimeEnabled</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;target)</td></tr>
<tr class="memdesc:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if runtime module is enabled for target.  <a href="namespacetvm_1_1runtime.html#ae6d933eb1e7414afa9a9a62d22cd2522">More...</a><br /></td></tr>
<tr class="separator:ae6d933eb1e7414afa9a9a62d22cd2522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75e2cf6722f7bb4a9dab69e45054d8f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac75e2cf6722f7bb4a9dab69e45054d8f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a> &amp;module)</td></tr>
<tr class="separator:ac75e2cf6722f7bb4a9dab69e45054d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffd1371d92046a4129a4961ef40755c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abffd1371d92046a4129a4961ef40755c">SanitizeName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abffd1371d92046a4129a4961ef40755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize name for output into compiler artifacts.  <a href="namespacetvm_1_1runtime.html#abffd1371d92046a4129a4961ef40755c">More...</a><br /></td></tr>
<tr class="separator:abffd1371d92046a4129a4961ef40755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">SaveDLTensor</a> (dmlc::Stream *strm, const DLTensor *tensor)</td></tr>
<tr class="memdesc:a8fb37910dcd9bb6899e6a3a47f006514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a DLTensor to stream.  <a href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">More...</a><br /></td></tr>
<tr class="separator:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59940b6d63dd4c5175c0fe875047c1cf">GetDataSize</a> (const DLTensor &amp;arr)</td></tr>
<tr class="memdesc:a59940b6d63dd4c5175c0fe875047c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of data the DLTensor hold, in term of number of bytes  <a href="namespacetvm_1_1runtime.html#a59940b6d63dd4c5175c0fe875047c1cf">More...</a><br /></td></tr>
<tr class="separator:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7050eda88b079f0a962bd413a34ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afdd7050eda88b079f0a962bd413a34ea">TVMArrayHandleToObjectHandle</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle)</td></tr>
<tr class="separator:afdd7050eda88b079f0a962bd413a34ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80916ee2a125355bc25dbd5a60c39164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a80916ee2a125355bc25dbd5a60c39164">GetPreferredHostDevice</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device)</td></tr>
<tr class="memdesc:a80916ee2a125355bc25dbd5a60c39164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the preferred host device from the input device.  <a href="namespacetvm_1_1runtime.html#a80916ee2a125355bc25dbd5a60c39164">More...</a><br /></td></tr>
<tr class="separator:a80916ee2a125355bc25dbd5a60c39164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplParams" colspan="2">template&lt;typename RelayRefType , typename ObjectType &gt; </td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa4a97de4fefd23aa5942c6a545544a05">GetRef</a> (const ObjectType *ptr)</td></tr>
<tr class="memdesc:aa4a97de4fefd23aa5942c6a545544a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference type from a raw object ptr type.  <a href="namespacetvm_1_1runtime.html#aa4a97de4fefd23aa5942c6a545544a05">More...</a><br /></td></tr>
<tr class="separator:aa4a97de4fefd23aa5942c6a545544a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplParams" colspan="2">template&lt;typename SubRef , typename BaseRef &gt; </td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplItemLeft" align="right" valign="top">SubRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a756a222aed384e208f32d35d3412c918">Downcast</a> (BaseRef ref)</td></tr>
<tr class="memdesc:a756a222aed384e208f32d35d3412c918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast a base reference type to a more specific type.  <a href="namespacetvm_1_1runtime.html#a756a222aed384e208f32d35d3412c918">More...</a><br /></td></tr>
<tr class="separator:a756a222aed384e208f32d35d3412c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjectType &gt; </td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46bcf7948293194c5b9c7db91da96381">GetObjectPtr</a> (ObjectType *ptr)</td></tr>
<tr class="memdesc:a46bcf7948293194c5b9c7db91da96381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object ptr type from a raw object ptr.  <a href="namespacetvm_1_1runtime.html#a46bcf7948293194c5b9c7db91da96381">More...</a><br /></td></tr>
<tr class="separator:a46bcf7948293194c5b9c7db91da96381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63300957592e8991c18c54703123ef7"><td class="memTemplParams" colspan="2">template&lt;typename RefType , typename ObjType &gt; </td></tr>
<tr class="memitem:af63300957592e8991c18c54703123ef7"><td class="memTemplItemLeft" align="right" valign="top">RefType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af63300957592e8991c18c54703123ef7">GetRef</a> (const ObjType *ptr)</td></tr>
<tr class="separator:af63300957592e8991c18c54703123ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjType &gt; </td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac2d903012aff56c2bd54ff66f48450c3">GetObjectPtr</a> (ObjType *ptr)</td></tr>
<tr class="separator:ac2d903012aff56c2bd54ff66f48450c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129050a60cebb0bbe18f96b41a36a948"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a129050a60cebb0bbe18f96b41a36a948">ArgTypeCode2Str</a> (int type_code)</td></tr>
<tr class="memdesc:a129050a60cebb0bbe18f96b41a36a948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert argument type code to string.  <a href="namespacetvm_1_1runtime.html#a129050a60cebb0bbe18f96b41a36a948">More...</a><br /></td></tr>
<tr class="separator:a129050a60cebb0bbe18f96b41a36a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1fa64a5babbd1f199e4c14f1d90ed5dc">DLDeviceType2Str</a> (int type)</td></tr>
<tr class="memdesc:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of DLDeviceType.  <a href="namespacetvm_1_1runtime.html#a1fa64a5babbd1f199e4c14f1d90ed5dc">More...</a><br /></td></tr>
<tr class="separator:a1fa64a5babbd1f199e4c14f1d90ed5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80885b3cfaabbee3d448c4d0fabec29f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a80885b3cfaabbee3d448c4d0fabec29f"><td class="memTemplItemLeft" align="right" valign="top">void TVM_ALWAYS_INLINE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a80885b3cfaabbee3d448c4d0fabec29f">PackArgs</a> (<a class="el" href="unionTVMValue.html">TVMValue</a> *values, int *type_codes, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a80885b3cfaabbee3d448c4d0fabec29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ab69f2cbb94a9c579ee870ca7f186cf10">DefaultTimer</a> (<a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> dev)</td></tr>
<tr class="memdesc:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timer if one does not exist for the device.  <a href="namespacetvm_1_1runtime.html#ab69f2cbb94a9c579ee870ca7f186cf10">More...</a><br /></td></tr>
<tr class="separator:ab69f2cbb94a9c579ee870ca7f186cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">EnvCheckSignals</a> ()</td></tr>
<tr class="memdesc:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if signals have been sent to the process and if so invoke the registered signal handler in the frontend environment.  <a href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">More...</a><br /></td></tr>
<tr class="separator:af5edb7ca30cd4affb50eb1fe6e3a1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0ec7f78231f4bf6c16188f87d98283a1">parallel_for_with_threading_backend</a> (T flambda, int64_t begin, int64_t end)</td></tr>
<tr class="separator:a0ec7f78231f4bf6c16188f87d98283a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afbd2b4816e4fde19ac51ed38463fb43c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IterType &gt; </td></tr>
<tr class="memitem:afbd2b4816e4fde19ac51ed38463fb43c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afbd2b4816e4fde19ac51ed38463fb43c">is_valid_iterator_v</a> = <a class="el" href="structtvm_1_1runtime_1_1is__valid__iterator.html">is_valid_iterator</a>&lt;T, IterType&gt;::value</td></tr>
<tr class="separator:afbd2b4816e4fde19ac51ed38463fb43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046f48c6c26b7e59951fd144cf89ce7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a046f48c6c26b7e59951fd144cf89ce7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a046f48c6c26b7e59951fd144cf89ce7e">is_tvm_array</a> = false</td></tr>
<tr class="separator:a046f48c6c26b7e59951fd144cf89ce7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11573f379e5d0f328e1bb86760677788"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11573f379e5d0f328e1bb86760677788"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11573f379e5d0f328e1bb86760677788">is_tvm_array&lt; Array&lt; T &gt; &gt;</a> = true</td></tr>
<tr class="separator:a11573f379e5d0f328e1bb86760677788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a77303649fb143634796b3dc50a286"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">kAllocAlignment</a> = 64</td></tr>
<tr class="memdesc:ac8a77303649fb143634796b3dc50a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to.  <a href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">More...</a><br /></td></tr>
<tr class="separator:ac8a77303649fb143634796b3dc50a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">kTempAllocaAlignment</a> = 64</td></tr>
<tr class="memdesc:a8f5819cabea098a1818cf7cda40fdb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to in temporary allocation.  <a href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">More...</a><br /></td></tr>
<tr class="separator:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">kMaxStackAlloca</a> = 1024</td></tr>
<tr class="memdesc:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size that can be allocated on stack.  <a href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">More...</a><br /></td></tr>
<tr class="separator:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a551bab1e24e2e794f8ccd4446b63a7af">kDefaultWorkspaceAlignment</a> = 1</td></tr>
<tr class="memdesc:a551bab1e24e2e794f8ccd4446b63a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors.  <a href="namespacetvm_1_1runtime.html#a551bab1e24e2e794f8ccd4446b63a7af">More...</a><br /></td></tr>
<tr class="separator:a551bab1e24e2e794f8ccd4446b63a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">kRPCSessMask</a> = 128</td></tr>
<tr class="memdesc:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type bigger than this is RPC device.  <a href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">More...</a><br /></td></tr>
<tr class="separator:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acf4599f17bfe79ae1fe8afc1af053b43">kTVMNDArrayMagic</a> = 0xDD5E40F096B4A13F</td></tr>
<tr class="memdesc:acf4599f17bfe79ae1fe8afc1af053b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> file.  <a href="namespacetvm_1_1runtime.html#acf4599f17bfe79ae1fe8afc1af053b43">More...</a><br /></td></tr>
<tr class="separator:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a28022a2dc86007a65b24b8c41e0c7da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28022a2dc86007a65b24b8c41e0c7da3">&#9670;&nbsp;</a></span>FSig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#a28022a2dc86007a65b24b8c41e0c7da3">tvm::runtime::FSig</a> = typedef std::string()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using static function to output <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html" title="Please refer to TypedPackedFunc&lt;R(Args..)&gt;.">TypedPackedFunc</a> signature. </p>

</div>
</div>
<a id="a4bc1ad60cb099dde44f5b5ee0f1b7216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc1ad60cb099dde44f5b5ee0f1b7216">&#9670;&nbsp;</a></span>IntTuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#a4bc1ad60cb099dde44f5b5ee0f1b7216">tvm::runtime::IntTuple</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae05cfd921c5454ad8100de9e0f6c6a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05cfd921c5454ad8100de9e0f6c6a3b">&#9670;&nbsp;</a></span>IntTupleObj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1runtime.html#ae05cfd921c5454ad8100de9e0f6c6a3b">tvm::runtime::IntTupleObj</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1ShapeTupleObj.html">ShapeTupleObj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a46fef1ca0ccc05473e9bb0a8c6b66619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fef1ca0ccc05473e9bb0a8c6b66619">&#9670;&nbsp;</a></span>DeviceAttrKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">tvm::runtime::DeviceAttrKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the query type into GetAttr </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb"></a>kExist&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4"></a>kMaxThreadsPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da"></a>kWarpSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264"></a>kMaxSharedMemoryPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b"></a>kComputeVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca"></a>kDeviceName&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630"></a>kMaxClockRate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd"></a>kMultiProcessorCount&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991"></a>kMaxThreadDimensions&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ac1e3197d589b7cbc7464ea7269f34357"></a>kMaxRegistersPerBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201"></a>kGcnArch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a69fe0643750b0c49e8b8aefb1cada337"></a>kApiVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619a100cda550bad77fbaf993566c022bdf9"></a>kDriverVersion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619afebd0fa20dbcf8f5fe6b31f7bdfb7496"></a>kL2CacheSizeBytes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619aaefa5c35ec7a4ef2fab9d26949b3de12"></a>kTotalGlobalMemory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a46fef1ca0ccc05473e9bb0a8c6b66619ab5557051e97fe70b60484ce6589f91de"></a>kAvailableGlobalMemory&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4ba6565e739bed4d5078c2ff998deae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba6565e739bed4d5078c2ff998deae8">&#9670;&nbsp;</a></span>DiscoAction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">tvm::runtime::DiscoAction</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All possible kinds of Disco commands. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aff48289104dbc943d0354379e43f7e5f"></a>kShutDown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8ad6aaaf2cb07d224d5aed793c09a777ef"></a>kKillReg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8abd597f33da21ed3ec14131295daab521"></a>kGetGlobalFunc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aeab0582e669357bc410678d34b50178f"></a>kCallPacked&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8ac4e6997e9ed12a3933fa5ab71fc364ef"></a>kSyncWorker&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8a3bc0e63927f289f5a8956e0c2c791cea"></a>kCopyFromWorker0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8affb0ed964f1001fecda2ea2e8ac90bea"></a>kCopyToWorker0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8aa9e0e3dadb4ecfc65792001a864b868a"></a>kDebugGetFromRemote&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6565e739bed4d5078c2ff998deae8a08f61e83ccd56e0950d9b9b36d6f1a15"></a>kDebugSetRegister&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6edb2235f96c34eaf0119834d293ca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edb2235f96c34eaf0119834d293ca54">&#9670;&nbsp;</a></span>ModulePropertyMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a6edb2235f96c34eaf0119834d293ca54">tvm::runtime::ModulePropertyMask</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property of runtime module We classify the property of runtime module into the following categories. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6edb2235f96c34eaf0119834d293ca54abb73d116e7bde220e81a19e98cc62103"></a>kBinarySerializable&#160;</td><td class="fielddoc"><p>kBinarySerializable we can serialize the module to the stream of bytes. CUDA/OpenCL/JSON runtime are representative examples. A binary exportable module can be integrated into final runtime artifact by being serialized as data into the artifact, then deserialized at runtime. This class of modules must implement SaveToBinary, and have a matching deserializer registered as 'runtime.module.loadbinary_&lt;type_key&gt;'. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6edb2235f96c34eaf0119834d293ca54a6aa052b038d11007d0df028d29fcda2e"></a>kRunnable&#160;</td><td class="fielddoc"><p>kRunnable we can run the module directly. LLVM/CUDA/JSON runtime, executors (e.g, virtual machine) runtimes are runnable. Non-runnable modules, such as CSourceModule, requires a few extra steps (e.g,. compilation, link) to make it runnable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6edb2235f96c34eaf0119834d293ca54aeac3ca683f62d5793245a4a4a378015c"></a>kDSOExportable&#160;</td><td class="fielddoc"><p>kDSOExportable we can export the module as DSO. A DSO exportable module (e.g., a CSourceModuleNode of type_key 'c') can be incorporated into the final runtime artifact (ie shared library) by compilation and/or linking using the external compiler (llvm, nvcc, etc). DSO exportable modules must implement SaveToFile. In general, DSO exportable modules are not runnable unless there is a special support like JIT for <code>LLVMModule</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9ebb65e06d120de112c54fdcd10c27d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebb65e06d120de112c54fdcd10c27d7">&#9670;&nbsp;</a></span>ReduceKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">tvm::runtime::ReduceKind</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible kinds of reduction operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa1dc5fbfa16754d1e628d66381725617"></a>kSum&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7a4eef5c699751ff1b31a7fcc194b28a88"></a>kProd&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7a8fbc2f6c44a6d70550df79903eb57d48"></a>kMin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa0b1ac8aae6b1cfbbe89085c642b3b4b"></a>kMax&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ebb65e06d120de112c54fdcd10c27d7aa22c1525680159c49e69ff9c43d1d01b"></a>kAvg&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa93f6c733bf54ca19d642a5ae2ec94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f6c733bf54ca19d642a5ae2ec94be">&#9670;&nbsp;</a></span>AddRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::AddRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_table_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a RPC session mask to a Device. RPC clients typically do this when decoding a Device received from a RPC remote. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device without any RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC server. </td></tr>
    <tr><td class="paramname">session_table_index</td><td>Numeric index of the RPC session in the session table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device with RPC session mask added, valid on the RPC client. </dd></dl>

</div>
</div>
<a id="aad3685684365b05e1d1511461f8ada82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3685684365b05e1d1511461f8ada82">&#9670;&nbsp;</a></span>AllGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AllGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an allgather operation using the underlying communication library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The array send to perform allgather on </td></tr>
    <tr><td class="paramname">recv</td><td>The array receives the outcome of allgather </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad615c644745d2b1e9097e93274760420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad615c644745d2b1e9097e93274760420">&#9670;&nbsp;</a></span>AllReduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AllReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a>&#160;</td>
          <td class="paramname"><em>reduce_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an allreduce operation using the underlying communication library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The array send to perform allreduce on </td></tr>
    <tr><td class="paramname">reduce_kind</td><td>The kind of reduction operation (e.g. sum, avg, min, max) </td></tr>
    <tr><td class="paramname">recv</td><td>The array receives the outcome of allreduce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c142fe6cc61a977ec7ab0e56a77a201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c142fe6cc61a977ec7ab0e56a77a201">&#9670;&nbsp;</a></span>AppendADT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendADT </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a> &amp;&#160;</td>
          <td class="paramname"><em>adt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec8593d6430be00492db4b52b3aad542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8593d6430be00492db4b52b3aad542">&#9670;&nbsp;</a></span>AppendNDArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendNDArray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>nd_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helpers to describe runtime objects in human-friendly form. For <code>nd_arrays</code> we show their shapes and dtypes, but also their contents if 'small' and on the <code>host_device</code> (mostly so that we can see dynamic shapes as they are computed). For <code>adts</code> we show the <a class="el" href="classtvm_1_1runtime_1_1ADT.html" title="reference to algebraic data type objects.">ADT</a> fields. For <code>objects</code> we dispatch to one of the above as appropriate. </p>

</div>
</div>
<a id="a4da4311f8b37f76fad2d4da39c35f50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da4311f8b37f76fad2d4da39c35f50f">&#9670;&nbsp;</a></span>AppendRuntimeObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::AppendRuntimeObject </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a129050a60cebb0bbe18f96b41a36a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129050a60cebb0bbe18f96b41a36a948">&#9670;&nbsp;</a></span>ArgTypeCode2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * tvm::runtime::ArgTypeCode2Str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert argument type code to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>The input type code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding string repr. </dd></dl>

</div>
</div>
<a id="aae07357d6856dcdb0b501e7f0e49e1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae07357d6856dcdb0b501e7f0e49e1ac">&#9670;&nbsp;</a></span>AsLegacyRepr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::AsLegacyRepr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abaecde92a8ed3f84a9e7e870825ad1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaecde92a8ed3f84a9e7e870825ad1b8">&#9670;&nbsp;</a></span>BroadcastFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::BroadcastFromWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a broadcast operation from worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The buffer to be broadcasted </td></tr>
    <tr><td class="paramname">recv</td><td>The buffer receives the broadcasted array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a8b9d4d20b7993992145f73efa2abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b9d4d20b7993992145f73efa2abf2">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;T&gt; tvm::runtime::Concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concat two Arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>first <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs.">Array</a> to be concatenated. </td></tr>
    <tr><td class="paramname">rhs</td><td>second <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs.">Array</a> to be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs.">Array</a>. Original Arrays are kept unchanged. </dd></dl>

</div>
</div>
<a id="ab69f2cbb94a9c579ee870ca7f186cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f2cbb94a9c579ee870ca7f186cf10">&#9670;&nbsp;</a></span>DefaultTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Timer.html">Timer</a> tvm::runtime::DefaultTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default timer if one does not exist for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to time on.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this timer performs synchronization between the device and CPU, which can lead to overhead in the reported results. </p>

</div>
</div>
<a id="a0c3703032b26941b2dc4a6660d7dcc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3703032b26941b2dc4a6660d7dcc14">&#9670;&nbsp;</a></span>DiscoAction2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::DiscoAction2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a4ba6565e739bed4d5078c2ff998deae8">DiscoAction</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the enum class <code>DiscoAction</code> to string. </p>

</div>
</div>
<a id="a1a7aed6ffaafbb6adb9df67bfaa44cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7aed6ffaafbb6adb9df67bfaa44cde">&#9670;&nbsp;</a></span>DiscoEmptyNDArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> tvm::runtime::DiscoEmptyNDArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an uninitialized empty <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> </td></tr>
    <tr><td class="paramname">dtype</td><td>The dtype of the <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> </td></tr>
    <tr><td class="paramname">device</td><td>The device the <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> is created on. If None, use the thread local default device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> created </dd></dl>

</div>
</div>
<a id="ac360f2d9815036ab1b4d84d9cfb46b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac360f2d9815036ab1b4d84d9cfb46b4f">&#9670;&nbsp;</a></span>DLDataType2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::DLDataType2String </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a TVM type to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type in string. </dd></dl>

</div>
</div>
<a id="af9303c49b737675bdab034c4032dcc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9303c49b737675bdab034c4032dcc48">&#9670;&nbsp;</a></span>DLDataTypeCode2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * tvm::runtime::DLDataTypeCode2Str </td>
          <td>(</td>
          <td class="paramtype">DLDataTypeCode&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert type code to its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>The type code . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of type code. </dd></dl>

</div>
</div>
<a id="a1fa64a5babbd1f199e4c14f1d90ed5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa64a5babbd1f199e4c14f1d90ed5dc">&#9670;&nbsp;</a></span>DLDeviceType2Str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::runtime::DLDeviceType2Str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of DLDeviceType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device name. </dd></dl>

</div>
</div>
<a id="a756a222aed384e208f32d35d3412c918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a222aed384e208f32d35d3412c918">&#9670;&nbsp;</a></span>Downcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubRef , typename BaseRef &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubRef tvm::runtime::Downcast </td>
          <td>(</td>
          <td class="paramtype">BaseRef&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast a base reference type to a more specific type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The input reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding SubRef. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SubRef</td><td>The target specific reference type. </td></tr>
    <tr><td class="paramname">BaseRef</td><td>the current reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5edb7ca30cd4affb50eb1fe6e3a1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5edb7ca30cd4affb50eb1fe6e3a1d13">&#9670;&nbsp;</a></span>EnvCheckSignals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::EnvCheckSignals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if signals have been sent to the process and if so invoke the registered signal handler in the frontend environment. </p>
<p>When running TVM in another language (Python), the signal handler may not be immediately executed, but instead the signal is marked in the interpreter state (to ensure non-blocking of the signal handler).</p>
<p>This function can be explicitly invoked to check the cached signal and run the related processing if a signal is marked.</p>
<p>On Linux, when siginterrupt() is set, invoke this function whenever a syscall returns EINTR. When it is not set, invoke it between long-running syscalls when you will not immediately return to the frontend. On Windows, the same rules apply, but due to differences in signal processing, these are likely to only make a difference when used with Ctrl+C and socket calls.</p>
<p>Not inserting this function will not cause any correctness issue, but will delay invoking the Python-side signal handler until the function returns to the Python side. This means that the effect of e.g. pressing Ctrl+C or sending signals the process will be delayed until function return. When a C function is blocked on a syscall such as accept(), it needs to be called when EINTR is received. So this function is not needed in most API functions, which can finish quickly in a reasonable, deterministic amount of time.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> check_signal_every_k_iter = 10;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter = 0; iter &lt; very_large_number; ++iter) {</div>
<div class="line">  <span class="keywordflow">if</span> (iter % check_signal_every_k_iter == 0) {</div>
<div class="line">    <a class="code" href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">tvm::runtime::EnvCheckSignals</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// do work here</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacetvm_1_1runtime_html_af5edb7ca30cd4affb50eb1fe6e3a1d13"><div class="ttname"><a href="namespacetvm_1_1runtime.html#af5edb7ca30cd4affb50eb1fe6e3a1d13">tvm::runtime::EnvCheckSignals</a></div><div class="ttdeci">void EnvCheckSignals()</div><div class="ttdoc">Check if signals have been sent to the process and if so invoke the registered signal handler in the ...</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function is a nop when no PyErr_CheckSignals is registered.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>function throws an exception when the frontend signal handler indicate an error happens, otherwise it returns normally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af171cee6bb9e18f52c1f6b534c4ebbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171cee6bb9e18f52c1f6b534c4ebbd9">&#9670;&nbsp;</a></span>GatherToWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::GatherToWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &gt;&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a gather operation to worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The sending buffer, which must not be None. </td></tr>
    <tr><td class="paramname">recv</td><td>For worker-0, it must be provided, and otherwise, the buffer must be None. The receiving buffer will be divided into equal parts and receive from each worker accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06a49d761ea6373557c24c01eaceb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a49d761ea6373557c24c01eaceb07d">&#9670;&nbsp;</a></span>GetCustomTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::GetCustomTypeName </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for getting custom type name from code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Custom type name </dd></dl>

</div>
</div>
<a id="a1b8eedadc5a269b2f9614ce69a9932e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8eedadc5a269b2f9614ce69a9932e7">&#9670;&nbsp;</a></span>GetCustomTypeRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::GetCustomTypeRegistered </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for checking whether custom type is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1Bool.html" title="Boolean constant.">Bool</a> representing whether type is registered </dd></dl>

</div>
</div>
<a id="a59940b6d63dd4c5175c0fe875047c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59940b6d63dd4c5175c0fe875047c1cf">&#9670;&nbsp;</a></span>GetDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::runtime::GetDataSize </td>
          <td>(</td>
          <td class="paramtype">const DLTensor &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the size of data the DLTensor hold, in term of number of bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input DLTensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of data in the DLTensor. </dd></dl>

</div>
</div>
<a id="a46bcf7948293194c5b9c7db91da96381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bcf7948293194c5b9c7db91da96381">&#9670;&nbsp;</a></span>GetObjectPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object ptr type from a raw object ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BaseType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a id="ac2d903012aff56c2bd54ff66f48450c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d903012aff56c2bd54ff66f48450c3">&#9670;&nbsp;</a></span>GetObjectPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80916ee2a125355bc25dbd5a60c39164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80916ee2a125355bc25dbd5a60c39164">&#9670;&nbsp;</a></span>GetPreferredHostDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::GetPreferredHostDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the preferred host device from the input device. </p>
<ul>
<li>For CUDA and ROCm, CUDAHost and ROCMHost will be returned for pinned memory, since pinned memory reduces copy overhead.</li>
<li>For other devices, CPU is returned as a fallback. </li>
</ul>

</div>
</div>
<a id="aa4a97de4fefd23aa5942c6a545544a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a97de4fefd23aa5942c6a545544a05">&#9670;&nbsp;</a></span>GetRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RelayRefType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a> tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference type from a raw object ptr type. </p>
<p>It is always important to get a reference type if we want to return a value as reference or keep the object alive beyond the scope of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RefType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a id="af63300957592e8991c18c54703123ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63300957592e8991c18c54703123ef7">&#9670;&nbsp;</a></span>GetRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RefType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefType tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d284249899038cca33c40d97eefa1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d284249899038cca33c40d97eefa1e3">&#9670;&nbsp;</a></span>GetRPCSessionIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetRPCSessionIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the RPCSessTable index of the RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> that owns this device. </p>
<dl class="section return"><dt>Returns</dt><dd>the table index. </dd></dl>

</div>
</div>
<a id="ad01a53416152b68029d67190c3709d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a53416152b68029d67190c3709d25">&#9670;&nbsp;</a></span>GetVectorBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetVectorBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes needed in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes needed. </dd></dl>

</div>
</div>
<a id="aa5f13cd8047078f88d142fe53337ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f13cd8047078f88d142fe53337ba6f">&#9670;&nbsp;</a></span>IsRPCSessionDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::IsRPCSessionDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a Device is owned by an RPC session. </p>

</div>
</div>
<a id="a8be7ff3434b2a2d4365f36d94c1dc830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7ff3434b2a2d4365f36d94c1dc830">&#9670;&nbsp;</a></span>LoadVMModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a> tvm::runtime::LoadVMModule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a runtime <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM.">Module</a>, then create and initialize a RelaxVM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the runtime <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM.">Module</a> (a DSO file) to be loaded </td></tr>
    <tr><td class="paramname">device</td><td>The default device used to initialize the RelaxVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RelaxVM as a runtime <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM.">Module</a> </dd></dl>

</div>
</div>
<a id="a0537c9d197068a02c26cd702ab42f6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0537c9d197068a02c26cd702ab42f6ff">&#9670;&nbsp;</a></span>make_inplace_array_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;ArrayType&gt; tvm::runtime::make_inplace_array_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3189d7506cfd1acacd3cdfc04d399a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189d7506cfd1acacd3cdfc04d399a03">&#9670;&nbsp;</a></span>make_object() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1MapNode.html">MapNode</a> &gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af55276b6524dbaf78e3eaba39ee9ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55276b6524dbaf78e3eaba39ee9ce16">&#9670;&nbsp;</a></span>make_object() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate an object using default allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the node type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object.">ObjectPtr</a> to the allocated object. </dd></dl>

</div>
</div>
<a id="aff337677f23f7d665960f553fb52ab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff337677f23f7d665960f553fb52ab86">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, K&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, V&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;K, V&gt; tvm::runtime::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two Maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics,...">Map</a> to merge. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second <a class="el" href="classtvm_1_1runtime_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics,...">Map</a> to merge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged <a class="el" href="classtvm_1_1runtime_1_1Array.html" title="Array, container representing a contiguous sequence of ObjectRefs.">Array</a>. Original Maps are kept unchanged. </dd></dl>

</div>
</div>
<a id="ad4d1999febc0f97ae2e2c9cc12edd280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d1999febc0f97ae2e2c9cc12edd280">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab556e58d616b05ce4ae338f887b17cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab556e58d616b05ce4ae338f887b17cb4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a808c040486da95a7fa2f4725b55635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a808c040486da95a7fa2f4725b55635">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d584f14566754b91a0e7f415b83fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d584f14566754b91a0e7f415b83fbda">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504adcfea8e21b2865b56cdfad447918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504adcfea8e21b2865b56cdfad447918">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a935d5423ffab64da49612e80f775a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935d5423ffab64da49612e80f775a8ff">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc9820cf44823ad5098183e9dbd7b867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9820cf44823ad5098183e9dbd7b867">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca259da80169ea60877e17c98a0b472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca259da80169ea60877e17c98a0b472a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c069145ecfa5909a77841f60332af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c069145ecfa5909a77841f60332af4d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dbaf8d9ec6bd68590a23da05d8a2831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbaf8d9ec6bd68590a23da05d8a2831">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::runtime::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab77f7b17aece9015b0ef91908f75b5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77f7b17aece9015b0ef91908f75b5f4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5305faaeefd679da62186dab423bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5305faaeefd679da62186dab423bdab">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbbf6ce2f770d4f348ace3407ee9c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbf6ce2f770d4f348ace3407ee9c500">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2865dffa2fddf5eff9d7ed397563ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2865dffa2fddf5eff9d7ed397563ebd6">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a263e89c942dc4b01075dd01b6882a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263e89c942dc4b01075dd01b6882a814">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d447b7bdac52d26bca3422fe098f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d447b7bdac52d26bca3422fe098f6f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af22b89284299c81d0c1802199af446d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22b89284299c81d0c1802199af446d7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af88cd3c4604865b859373cb32ff53be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88cd3c4604865b859373cb32ff53be5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ShapeTuple.html">ShapeTuple</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ed99740d7bb838d96617de83ff2363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ed99740d7bb838d96617de83ff2363">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9e8684776f3f98b6a5a13c9c343904f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e8684776f3f98b6a5a13c9c343904f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDevice&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac75e2cf6722f7bb4a9dab69e45054d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75e2cf6722f7bb4a9dab69e45054d8f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c20920d4a09a6c022768b353ec8df2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c20920d4a09a6c022768b353ec8df2a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e76c697beb4a77556a869f7cc45f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76c697beb4a77556a869f7cc45f09a">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8daf39dc422f228fae2ec11a426bab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daf39dc422f228fae2ec11a426bab28">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d696c920a17b8c54775705062de75be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d696c920a17b8c54775705062de75be">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92428efae022d4982b2644f8960d4386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92428efae022d4982b2644f8960d4386">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf2e7e67fd12d69c5bce2be881c8296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf2e7e67fd12d69c5bce2be881c8296">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac77c2b6d2b8176af69f6e6cccbe736c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77c2b6d2b8176af69f6e6cccbe736c2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81dae8fb1a2fa349cfb272525294f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dae8fb1a2fa349cfb272525294f954">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a5995094218eac7fe1f98e1abee852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5995094218eac7fe1f98e1abee852d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04626a0c1e717679d673bc90c6a23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04626a0c1e717679d673bc90c6a23f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5109f107067bdcf493aafafd8896e031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5109f107067bdcf493aafafd8896e031">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa52eb43328fdca2972a8312bb1ed6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa52eb43328fdca2972a8312bb1ed6d0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a031e6c8e64cd9db11754355e3250ab4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e6c8e64cd9db11754355e3250ab4c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2001f8f5205170a33ea1b9db314549c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2001f8f5205170a33ea1b9db314549c9">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7996be0c57184e8ff9e655d0d055edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7996be0c57184e8ff9e655d0d055edc">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf23f2e6b19c87ecf3f27a7506ddf4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf23f2e6b19c87ecf3f27a7506ddf4c0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad83a0ea66d3af9fd1b232e49a960f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83a0ea66d3af9fd1b232e49a960f6f4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f8694e651078c6df7c5c26898ee9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8694e651078c6df7c5c26898ee9f14">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb4bb211393bf9d17b138cad36421c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4bb211393bf9d17b138cad36421c84">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a944029d40e689e4d2acab53ce36a5c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944029d40e689e4d2acab53ce36a5c99">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7310fb8b9944f41f8f30021d92847eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7310fb8b9944f41f8f30021d92847eb">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80885b3cfaabbee3d448c4d0fabec29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80885b3cfaabbee3d448c4d0fabec29f">&#9670;&nbsp;</a></span>PackArgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TVM_ALWAYS_INLINE tvm::runtime::PackArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionTVMValue.html">TVMValue</a> *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type_codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ec7f78231f4bf6c16188f87d98283a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec7f78231f4bf6c16188f87d98283a1">&#9670;&nbsp;</a></span>parallel_for_with_threading_backend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::parallel_for_with_threading_backend </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>flambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2workspace_2include_2tvm_2runtime_2threading_backend_8h-example.html#a15">/workspace/include/tvm/runtime/threading_backend.h</a>.</dd>
</dl>

</div>
</div>
<a id="ac6d167947285dff3c780bd5d01ace9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d167947285dff3c780bd5d01ace9b9">&#9670;&nbsp;</a></span>ParseCustomDatatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t tvm::runtime::ParseCustomDatatype </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for parsing string of the form "custom[&lt;typename&gt;]". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="classtvm_1_1runtime_1_1String.html" title="Reference to string objects.">String</a> to parse </td></tr>
    <tr><td class="paramname">scan</td><td>pointer to parsing pointer, which is scanning across s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type code of custom type parsed </dd></dl>

</div>
</div>
<a id="ab6b211d99323b4e09a76bdb6b6f133cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b211d99323b4e09a76bdb6b6f133cb">&#9670;&nbsp;</a></span>RecvFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::RecvFromWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a buffer from worker-0. No-op if the current worker is worker-0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3467a4ef36085dc8262601478a70869a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3467a4ef36085dc8262601478a70869a">&#9670;&nbsp;</a></span>ReduceKind2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::ReduceKind2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1runtime.html#a9ebb65e06d120de112c54fdcd10c27d7">ReduceKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>ReduceKind</code> to string. </p>

</div>
</div>
<a id="af32398517b6b915361c5716f8e32c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32398517b6b915361c5716f8e32c16f">&#9670;&nbsp;</a></span>RemoveRPCSessionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> tvm::runtime::RemoveRPCSessionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the RPC session mask from a Device. RPC clients typically do this when encoding a Device for transmission to an RPC remote. On the wire, RPCdevice are expected to be valid on the server without interpretation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A Device with non-zero RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Device without any RPC <a class="el" href="classtvm_1_1runtime_1_1Session.html" title="Managed reference to SessionObj.">Session</a> mask, valid on the RPC server. </dd></dl>

</div>
</div>
<a id="ae6d933eb1e7414afa9a9a62d22cd2522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d933eb1e7414afa9a9a62d22cd2522">&#9670;&nbsp;</a></span>RuntimeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::RuntimeEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if runtime module is enabled for target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target module name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether runtime is enabled. </dd></dl>

</div>
</div>
<a id="a5e4682aef4c22170449389fa455ab434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4682aef4c22170449389fa455ab434">&#9670;&nbsp;</a></span>RuntimeObject2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::RuntimeObject2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLDevice &amp;&#160;</td>
          <td class="paramname"><em>host_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_content</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abffd1371d92046a4129a4961ef40755c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffd1371d92046a4129a4961ef40755c">&#9670;&nbsp;</a></span>SanitizeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::SanitizeName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sanitize name for output into compiler artifacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Original name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sanitized name </dd></dl>

</div>
</div>
<a id="a8fb37910dcd9bb6899e6a3a47f006514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb37910dcd9bb6899e6a3a47f006514">&#9670;&nbsp;</a></span>SaveDLTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::SaveDLTensor </td>
          <td>(</td>
          <td class="paramtype">dmlc::Stream *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLTensor *&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a DLTensor to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>The output stream </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a719149b239ba245285be7cda32013b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719149b239ba245285be7cda32013b72">&#9670;&nbsp;</a></span>ScatterFromWorker0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::ScatterFromWorker0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a> &gt;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a scatter operation from worker-0, chunking the given buffer into equal parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>For worker-0, it must be provided, and otherwise, the buffer must be None. The buffer will be divided into equal parts and sent to each worker accordingly. </td></tr>
    <tr><td class="paramname">recv</td><td>The receiving buffer, which must not be None. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a277f104e659f71cd8885744700016341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277f104e659f71cd8885744700016341">&#9670;&nbsp;</a></span>String2DLDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DLDataType tvm::runtime::String2DLDataType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a string to TVM type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type. </dd></dl>

</div>
</div>
<a id="a65f369b9882f8ec57826acd5f86c4404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f369b9882f8ec57826acd5f86c4404">&#9670;&nbsp;</a></span>SyncWorker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::runtime::SyncWorker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the worker thread. Waiting until the worker completes all its tasks. As a specific example, on a CUDA worker, it blocks until all kernels are launched and cudaStreamSynchronize is complete. </p>

</div>
</div>
<a id="afdd7050eda88b079f0a962bd413a34ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd7050eda88b079f0a962bd413a34ea">&#9670;&nbsp;</a></span>TVMArrayHandleToObjectHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a>* tvm::runtime::TVMArrayHandleToObjectHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee574cee6755b0c2f1aa664c6967686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee574cee6755b0c2f1aa664c6967686f">&#9670;&nbsp;</a></span>TypeEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeEqual </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two types are equal . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbabb7cfb79bfb6d802f65a9803e4eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbabb7cfb79bfb6d802f65a9803e4eb6">&#9670;&nbsp;</a></span>TypeMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeMatch </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether type matches the given spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type </td></tr>
    <tr><td class="paramname">code</td><td>The type code. </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to be matched. </td></tr>
    <tr><td class="paramname">lanes</td><td>The number of lanes in the type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d7c335ce64b50b3e6cee085d55c8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d7c335ce64b50b3e6cee085d55c8fc">&#9670;&nbsp;</a></span>WorkerId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::WorkerId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local worker id. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a046f48c6c26b7e59951fd144cf89ce7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046f48c6c26b7e59951fd144cf89ce7e">&#9670;&nbsp;</a></span>is_tvm_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tvm::runtime::is_tvm_array = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11573f379e5d0f328e1bb86760677788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11573f379e5d0f328e1bb86760677788">&#9670;&nbsp;</a></span>is_tvm_array&lt; Array&lt; T &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacetvm_1_1runtime.html#a046f48c6c26b7e59951fd144cf89ce7e">tvm::runtime::is_tvm_array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; T &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbd2b4816e4fde19ac51ed38463fb43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd2b4816e4fde19ac51ed38463fb43c">&#9670;&nbsp;</a></span>is_valid_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tvm::runtime::is_valid_iterator_v = <a class="el" href="structtvm_1_1runtime_1_1is__valid__iterator.html">is_valid_iterator</a>&lt;T, IterType&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8a77303649fb143634796b3dc50a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a77303649fb143634796b3dc50a286">&#9670;&nbsp;</a></span>kAllocAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kAllocAlignment = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to. </p>

</div>
</div>
<a id="a551bab1e24e2e794f8ccd4446b63a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551bab1e24e2e794f8ccd4446b63a7af">&#9670;&nbsp;</a></span>kDefaultWorkspaceAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kDefaultWorkspaceAlignment = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to by default in the workspace buffer to service intermediate tensors. </p>

</div>
</div>
<a id="a2f6f769f6dbbbb24929b7c9f91a48c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6f769f6dbbbb24929b7c9f91a48c90">&#9670;&nbsp;</a></span>kMaxStackAlloca</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kMaxStackAlloca = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size that can be allocated on stack. </p>

</div>
</div>
<a id="a48cbe06e6c95ca6fabc20dd1cbacc2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cbe06e6c95ca6fabc20dd1cbacc2c9">&#9670;&nbsp;</a></span>kRPCSessMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kRPCSessMask = 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device type bigger than this is RPC device. </p>

</div>
</div>
<a id="a8f5819cabea098a1818cf7cda40fdb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5819cabea098a1818cf7cda40fdb1f">&#9670;&nbsp;</a></span>kTempAllocaAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kTempAllocaAlignment = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to in temporary allocation. </p>

</div>
</div>
<a id="acf4599f17bfe79ae1fe8afc1af053b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4599f17bfe79ae1fe8afc1af053b43">&#9670;&nbsp;</a></span>kTVMNDArrayMagic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t tvm::runtime::kTVMNDArrayMagic = 0xDD5E40F096B4A13F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks.">NDArray</a> file. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
