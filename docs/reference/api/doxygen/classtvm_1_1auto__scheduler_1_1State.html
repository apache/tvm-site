<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::auto_scheduler::State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1auto__scheduler.html">auto_scheduler</a></li><li class="navelem"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1auto__scheduler_1_1State-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::auto_scheduler::State Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a>.  
 <a href="classtvm_1_1auto__scheduler_1_1State.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="loop__state_8h_source.html">loop_state.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::auto_scheduler::State:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1auto__scheduler_1_1State__inherit__graph.svg" width="190" height="610"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::auto_scheduler::State:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1auto__scheduler_1_1State__coll__graph.svg" width="198" height="898"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e8198b1f51b42cfbbee4b9f42160749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a9e8198b1f51b42cfbbee4b9f42160749">State</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">te::Operation</a> &gt; &amp;ops)</td></tr>
<tr class="memdesc:a9e8198b1f51b42cfbbee4b9f42160749"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a9e8198b1f51b42cfbbee4b9f42160749">More...</a><br /></td></tr>
<tr class="separator:a9e8198b1f51b42cfbbee4b9f42160749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2b1cbaece2a0cd0d0d26f808b2331b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#acc2b1cbaece2a0cd0d0d26f808b2331b">ToStr</a> (bool delete_trivial_loop=true) const</td></tr>
<tr class="memdesc:acc2b1cbaece2a0cd0d0d26f808b2331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-print the state to a human readable string.  <a href="#acc2b1cbaece2a0cd0d0d26f808b2331b">More...</a><br /></td></tr>
<tr class="separator:acc2b1cbaece2a0cd0d0d26f808b2331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4bbe8e149a2ac418b3be72054b0649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#afe4bbe8e149a2ac418b3be72054b0649">bind</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, <a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">IteratorAnnotation</a> thread_type)</td></tr>
<tr class="memdesc:afe4bbe8e149a2ac418b3be72054b0649"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa9ace0034447b461610ebc1c2de69a26" title="Bind the IterVar to thread index. ">te::Stage::bind</a></code>.  <a href="#afe4bbe8e149a2ac418b3be72054b0649">More...</a><br /></td></tr>
<tr class="separator:afe4bbe8e149a2ac418b3be72054b0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a2376f0180bc5b5dd4b456f2a75d4a366">parallel</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a60a6be10a1a96cb594c1399efabafef3" title="Parallelize iteration. ">te::Stage::parallel</a></code>.  <a href="#a2376f0180bc5b5dd4b456f2a75d4a366">More...</a><br /></td></tr>
<tr class="separator:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aa68a9d2e226bae38a36e4be4af1d1ae4">unroll</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int max_unroll=-1)</td></tr>
<tr class="memdesc:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#af83ad8672660403504f472228b044b33" title="Unroll iteration. ">te::Stage::unroll</a></code>.  <a href="#aa68a9d2e226bae38a36e4be4af1d1ae4">More...</a><br /></td></tr>
<tr class="separator:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b8a21210d63bea241dbab085d89b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a97b8a21210d63bea241dbab085d89b53">vectorize</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a97b8a21210d63bea241dbab085d89b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a></code>.  <a href="#a97b8a21210d63bea241dbab085d89b53">More...</a><br /></td></tr>
<tr class="separator:a97b8a21210d63bea241dbab085d89b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76198c368b38ad64eefa45a3147aa6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a76198c368b38ad64eefa45a3147aa6ac">fuse</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;iters)</td></tr>
<tr class="memdesc:a76198c368b38ad64eefa45a3147aa6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5658065d9cbbee620bbd107d30c4ae72" title="Fuse the inner outer domain to the target. ">te::Stage::fuse</a></code>.  <a href="#a76198c368b38ad64eefa45a3147aa6ac">More...</a><br /></td></tr>
<tr class="separator:a76198c368b38ad64eefa45a3147aa6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0872404e5a0b56ad16644b8fb0f324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#ada0872404e5a0b56ad16644b8fb0f324">pragma</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;pragma_type)</td></tr>
<tr class="memdesc:ada0872404e5a0b56ad16644b8fb0f324"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a7045099f180e5cdcf9b1959b280a2d35" title="Annotate the iteration with pragma. ">te.Stage.pragma</a></code>.  <a href="#ada0872404e5a0b56ad16644b8fb0f324">More...</a><br /></td></tr>
<tr class="separator:ada0872404e5a0b56ad16644b8fb0f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e95966b46977eff629a5f4f1564533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a16e95966b46977eff629a5f4f1564533">reorder</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;order)</td></tr>
<tr class="memdesc:a16e95966b46977eff629a5f4f1564533"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#ad96cd240a92df9cafae89cdf2a7e302e" title="Reorder the iteration. ">te::Stage::reorder</a></code>.  <a href="#a16e95966b46977eff629a5f4f1564533">More...</a><br /></td></tr>
<tr class="separator:a16e95966b46977eff629a5f4f1564533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5815f21fc90ba7cc379c2410c05ab54c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a5815f21fc90ba7cc379c2410c05ab54c">split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; &amp;lengths, bool inner_to_outer=true)</td></tr>
<tr class="memdesc:a5815f21fc90ba7cc379c2410c05ab54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5a7cd562be59b68a187ad97085a3425d" title="Split the parent by factor, generate. ">te::Stage::split</a></code>.  <a href="#a5815f21fc90ba7cc379c2410c05ab54c">More...</a><br /></td></tr>
<tr class="separator:a5815f21fc90ba7cc379c2410c05ab54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd6d26db25a42427d6fb51b3717effc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a3cd6d26db25a42427d6fb51b3717effc">follow_split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int src_step_id, int n_split)</td></tr>
<tr class="memdesc:a3cd6d26db25a42427d6fb51b3717effc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive similar to split, but uses split factors from previous steps.  <a href="#a3cd6d26db25a42427d6fb51b3717effc">More...</a><br /></td></tr>
<tr class="separator:a3cd6d26db25a42427d6fb51b3717effc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d72cbcaa97f157076e98ed30a9f477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a26d72cbcaa97f157076e98ed30a9f477">follow_fused_split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;src_step_ids, int level, bool factor_or_nparts)</td></tr>
<tr class="memdesc:a26d72cbcaa97f157076e98ed30a9f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive similar to split, but uses split factors from fused previous steps.  <a href="#a26d72cbcaa97f157076e98ed30a9f477">More...</a><br /></td></tr>
<tr class="separator:a26d72cbcaa97f157076e98ed30a9f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab006690418e43cc9b7ad021c02657ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#ab006690418e43cc9b7ad021c02657ed6">storage_align</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int factor, int offset)</td></tr>
<tr class="memdesc:ab006690418e43cc9b7ad021c02657ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa73e3a269d84c3b4f0a1994371d67bab" title="Set alignment requirement for specific dimension. ">te.Stage.storage_align</a></code>.  <a href="#ab006690418e43cc9b7ad021c02657ed6">More...</a><br /></td></tr>
<tr class="separator:ab006690418e43cc9b7ad021c02657ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e00bb2f70dc2e28c236c92a14204850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a0e00bb2f70dc2e28c236c92a14204850">compute_at</a> (int stage_id, int target_stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;target_iter)</td></tr>
<tr class="memdesc:a0e00bb2f70dc2e28c236c92a14204850"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a071545484de7a894c01ccf0e77183730" title="specify the schedule to be computed at the parent schedule&#39;s scope. ">te::Stage::compute_at</a></code>.  <a href="#a0e00bb2f70dc2e28c236c92a14204850">More...</a><br /></td></tr>
<tr class="separator:a0e00bb2f70dc2e28c236c92a14204850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa383a9b40e490c131ed696d696c3c7a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aa383a9b40e490c131ed696d696c3c7a0">compute_inline</a> (int stage_id)</td></tr>
<tr class="memdesc:aa383a9b40e490c131ed696d696c3c7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a1c58b35e37561739440b322c29d30c3b" title="Compute the function inline. ">te::Stage::compute_inline</a></code>.  <a href="#aa383a9b40e490c131ed696d696c3c7a0">More...</a><br /></td></tr>
<tr class="separator:aa383a9b40e490c131ed696d696c3c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b192456798daac7d5b8403c1215d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a6a0b192456798daac7d5b8403c1215d8">compute_root</a> (int stage_id)</td></tr>
<tr class="memdesc:a6a0b192456798daac7d5b8403c1215d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a95b58b2d2ec034ecd0bdb99f95c0b0ba" title="Compute the function at group root. ">te::Stage::compute_root</a></code>.  <a href="#a6a0b192456798daac7d5b8403c1215d8">More...</a><br /></td></tr>
<tr class="separator:a6a0b192456798daac7d5b8403c1215d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff71b692f0eabfabf515ed91b59a116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a4ff71b692f0eabfabf515ed91b59a116">cache_read</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;scope_name, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;reader_stage_ids, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a4ff71b692f0eabfabf515ed91b59a116"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b" title="create a cache read of original tensor for readers. This will mutate the body of the readers...">te::Schedule::cache_read</a></code>.  <a href="#a4ff71b692f0eabfabf515ed91b59a116">More...</a><br /></td></tr>
<tr class="separator:a4ff71b692f0eabfabf515ed91b59a116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385adc36d7cb242e8204fe14c4df8335"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a385adc36d7cb242e8204fe14c4df8335">cache_write</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;scope_name, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a385adc36d7cb242e8204fe14c4df8335"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71" title="Create a cache write tensor for producing tensor. The the tensor will take over body of original tens...">te::Schedule::cache_write</a></code>.  <a href="#a385adc36d7cb242e8204fe14c4df8335">More...</a><br /></td></tr>
<tr class="separator:a385adc36d7cb242e8204fe14c4df8335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c27b06d439267f8b981fa05c5f48a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a21c27b06d439267f8b981fa05c5f48a0">rfactor</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int factor_iter_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a21c27b06d439267f8b981fa05c5f48a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a34ae85add41bbed0140726d024d08862" title="Factor a reduction axis in tensor&#39;s schedule to be an explicit axis. This will create a new stage tha...">te::Schedule::rfactor</a></code>.  <a href="#a21c27b06d439267f8b981fa05c5f48a0">More...</a><br /></td></tr>
<tr class="separator:a21c27b06d439267f8b981fa05c5f48a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31c450ae9eb4fac98974d0de647575f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#af31c450ae9eb4fac98974d0de647575f">TVM_DEFINE_OBJECT_REF_METHODS</a> (<a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>, <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>)</td></tr>
<tr class="separator:af31c450ae9eb4fac98974d0de647575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea500365cb7a964a21ac1677fc29fc99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aea500365cb7a964a21ac1677fc29fc99">TVM_DEFINE_OBJECT_REF_COW_METHOD</a> (<a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>)</td></tr>
<tr class="separator:aea500365cb7a964a21ac1677fc29fc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">ObjectRef</a> ()=default</td></tr>
<tr class="memdesc:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">More...</a><br /></td></tr>
<tr class="separator:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">ObjectRef</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; data)</td></tr>
<tr class="memdesc:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from existing object ptr.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">More...</a><br /></td></tr>
<tr class="separator:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">same_as</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">More...</a><br /></td></tr>
<tr class="separator:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">More...</a><br /></td></tr>
<tr class="separator:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">More...</a><br /></td></tr>
<tr class="separator:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">More...</a><br /></td></tr>
<tr class="separator:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a17d8d5ad92691f9e18e3e0ae8ef69e4f">defined</a> () const</td></tr>
<tr class="separator:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aadbc0886ffa80162ff31eefd0431ba09">get</a> () const</td></tr>
<tr class="separator:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3deeeac5827a88f375b8c6ae1039c219">operator-&gt;</a> () const</td></tr>
<tr class="separator:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4e7cdb1574b93a59e784d70aa47b8da7">unique</a> () const</td></tr>
<tr class="separator:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a0ae0da21d247cd87ea94fe3777c4405e">use_count</a> () const</td></tr>
<tr class="separator:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">const ObjectType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">as</a> () const</td></tr>
<tr class="memdesc:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to downcast the internal <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> to a raw pointer of a corresponding type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">More...</a><br /></td></tr>
<tr class="separator:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">ContainerType</a> = <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">type indicate the container type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">More...</a><br /></td></tr>
<tr class="separator:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3e9b0901b6e01257b060a45e159cc37e">_type_is_nullable</a> = true</td></tr>
<tr class="separator:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae423057ecf93c18714d17f53cd1d318f">get_mutable</a> () const</td></tr>
<tr class="separator:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">DowncastNoCheck</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> ref)</td></tr>
<tr class="memdesc:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function downcast a ref without check.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">More...</a><br /></td></tr>
<tr class="separator:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">FFIClearAfterMove</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> *ref)</td></tr>
<tr class="memdesc:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the object ref data field without DecRef after we successfully moved the field.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">More...</a><br /></td></tr>
<tr class="separator:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ObjectType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">GetDataPtr</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ref)</td></tr>
<tr class="memdesc:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function get data_ as <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> of ObjectType.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">More...</a><br /></td></tr>
<tr class="separator:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">data_</a></td></tr>
<tr class="memdesc:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal pointer that backs the reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">More...</a><br /></td></tr>
<tr class="separator:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e8198b1f51b42cfbbee4b9f42160749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8198b1f51b42cfbbee4b9f42160749">&#9670;&nbsp;</a></span>State()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::State </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">te::Operation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td><code><a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">te::Operation</a></code>s for a compute declaration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe4bbe8e149a2ac418b3be72054b0649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4bbe8e149a2ac418b3be72054b0649">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">IteratorAnnotation</a>&#160;</td>
          <td class="paramname"><em>thread_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa9ace0034447b461610ebc1c2de69a26" title="Bind the IterVar to thread index. ">te::Stage::bind</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be binded. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be binded. </td></tr>
    <tr><td class="paramname">thread_type</td><td>The thread type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator after binding. </dd></dl>

</div>
</div>
<a id="a4ff71b692f0eabfabf515ed91b59a116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff71b692f0eabfabf515ed91b59a116">&#9670;&nbsp;</a></span>cache_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::auto_scheduler::State::cache_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_stage_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b" title="create a cache read of original tensor for readers. This will mutate the body of the readers...">te::Schedule::cache_read</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be cache_read. </td></tr>
    <tr><td class="paramname">scope_name</td><td>The scope name of the newly added stage. </td></tr>
    <tr><td class="paramname">reader_stage_ids</td><td>The indices of reader stages. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cache read step will add an extra stage to the original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> (at the back of the target stage), an up-to-date <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> is stored in <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>'s <code>current_compute_dag</code>. </dd></dl>

</div>
</div>
<a id="a385adc36d7cb242e8204fe14c4df8335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385adc36d7cb242e8204fe14c4df8335">&#9670;&nbsp;</a></span>cache_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::auto_scheduler::State::cache_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71" title="Create a cache write tensor for producing tensor. The the tensor will take over body of original tens...">te::Schedule::cache_write</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be cache_write. </td></tr>
    <tr><td class="paramname">scope_name</td><td>The scope name of the newly added stage. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cache write step will add an extra stage to the original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> (in the front of the target stage), an up-to-date <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> is stored in <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>'s <code>current_compute_dag</code>. This step will cache write all output tensors of the target stage. </dd></dl>

</div>
</div>
<a id="a0e00bb2f70dc2e28c236c92a14204850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e00bb2f70dc2e28c236c92a14204850">&#9670;&nbsp;</a></span>compute_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>target_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a071545484de7a894c01ccf0e77183730" title="specify the schedule to be computed at the parent schedule&#39;s scope. ">te::Stage::compute_at</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the source stage of computed at. </td></tr>
    <tr><td class="paramname">target_stage_id</td><td>The index of stage that this step will compute at to. </td></tr>
    <tr><td class="paramname">target_iter</td><td>The indiex of the target iterator in the target stage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After compute_at, we need careful dependency analysis to compute the accurate bound information. However, it is relatively expensive and complicated, so we just fill "None" as bound for the newly created iterators. Call <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html#afb5f2d4e0c49e8b674a15664987ce9b0" title="Fill the correct bound information for a given state by calling ir_pass::InferBound. The states can lose complete bound information after some transform steps (e.g., compute_at). We can call this function to infer and fill all the bound information. This function calls TVM InferBound pass internally to get the bound. The returned state of this function is guaranteed to have complete bound information. ">ComputeDAG::InferBound</a> on the updated state if you need the complete bound information. </dd></dl>

</div>
</div>
<a id="aa383a9b40e490c131ed696d696c3c7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa383a9b40e490c131ed696d696c3c7a0">&#9670;&nbsp;</a></span>compute_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_inline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a1c58b35e37561739440b322c29d30c3b" title="Compute the function inline. ">te::Stage::compute_inline</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be marked compute inlined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a0b192456798daac7d5b8403c1215d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0b192456798daac7d5b8403c1215d8">&#9670;&nbsp;</a></span>compute_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_root </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a95b58b2d2ec034ecd0bdb99f95c0b0ba" title="Compute the function at group root. ">te::Stage::compute_root</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be marked compute at root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After compute_root, we need careful dependency analysis to compute the accurate bound information. However, it is relatively expensive and complicated, so we just fill "None" as bound for the newly created iterators. Call <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html#afb5f2d4e0c49e8b674a15664987ce9b0" title="Fill the correct bound information for a given state by calling ir_pass::InferBound. The states can lose complete bound information after some transform steps (e.g., compute_at). We can call this function to infer and fill all the bound information. This function calls TVM InferBound pass internally to get the bound. The returned state of this function is guaranteed to have complete bound information. ">ComputeDAG::InferBound</a> on the updated state if you need the complete bound information. </dd></dl>

</div>
</div>
<a id="a26d72cbcaa97f157076e98ed30a9f477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d72cbcaa97f157076e98ed30a9f477">&#9670;&nbsp;</a></span>follow_fused_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::follow_fused_split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_step_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>factor_or_nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive similar to split, but uses split factors from fused previous steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">src_step_ids</td><td>The indices of the split steps to be followed in the history. </td></tr>
    <tr><td class="paramname">level</td><td>Use the length in this split level. </td></tr>
    <tr><td class="paramname">factor_or_nparts</td><td>True to use <code>factor</code> for split from inner to outer, False to use <code>nparts</code> for split from outer to inner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split new Iterators. </dd></dl>

</div>
</div>
<a id="a3cd6d26db25a42427d6fb51b3717effc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd6d26db25a42427d6fb51b3717effc">&#9670;&nbsp;</a></span>follow_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::follow_split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_step_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive similar to split, but uses split factors from previous steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">src_step_id</td><td>The index of the split step to be followed in the history. </td></tr>
    <tr><td class="paramname">n_split</td><td>The number of split level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split new Iterators. </dd></dl>

</div>
</div>
<a id="a76198c368b38ad64eefa45a3147aa6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76198c368b38ad64eefa45a3147aa6ac">&#9670;&nbsp;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::fuse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>iters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5658065d9cbbee620bbd107d30c4ae72" title="Fuse the inner outer domain to the target. ">te::Stage::fuse</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be fused. </td></tr>
    <tr><td class="paramname">iters</td><td>The iterators to be fused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after fuse. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the iterators to be fused have stages attached at them(by compute_at), the fused result will become the new attach point. </dd></dl>

</div>
</div>
<a id="a2376f0180bc5b5dd4b456f2a75d4a366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376f0180bc5b5dd4b456f2a75d4a366">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::parallel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a60a6be10a1a96cb594c1399efabafef3" title="Parallelize iteration. ">te::Stage::parallel</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be paralleled. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be paralleled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator after parallel. </dd></dl>

</div>
</div>
<a id="ada0872404e5a0b56ad16644b8fb0f324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0872404e5a0b56ad16644b8fb0f324">&#9670;&nbsp;</a></span>pragma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::pragma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pragma_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a7045099f180e5cdcf9b1959b280a2d35" title="Annotate the iteration with pragma. ">te.Stage.pragma</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to add pragma. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to add pragma. </td></tr>
    <tr><td class="paramname">pragma_type</td><td>The pragma string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16e95966b46977eff629a5f4f1564533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e95966b46977eff629a5f4f1564533">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::reorder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#ad96cd240a92df9cafae89cdf2a7e302e" title="Reorder the iteration. ">te::Stage::reorder</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be reordered. </td></tr>
    <tr><td class="paramname">order</td><td>The expected iterator order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21c27b06d439267f8b981fa05c5f48a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c27b06d439267f8b981fa05c5f48a0">&#9670;&nbsp;</a></span>rfactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::auto_scheduler::State::rfactor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor_iter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a34ae85add41bbed0140726d024d08862" title="Factor a reduction axis in tensor&#39;s schedule to be an explicit axis. This will create a new stage tha...">te::Schedule::rfactor</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the iterator to be factored. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be factored. </td></tr>
    <tr><td class="paramname">factor_iter_id</td><td>The position where the new iterator is placed. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Rfactor step will add an extra stage to the original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> (in the front of the target stage), an up-to-date <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> is stored in <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>'s <code>current_compute_dag</code>. </dd></dl>

</div>
</div>
<a id="a5815f21fc90ba7cc379c2410c05ab54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5815f21fc90ba7cc379c2410c05ab54c">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inner_to_outer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5a7cd562be59b68a187ad97085a3425d" title="Split the parent by factor, generate. ">te::Stage::split</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">lengths</td><td>The multiple split factors. Can be None to be filled by search policy. </td></tr>
    <tr><td class="paramname">inner_to_outer</td><td>Whether the factors go from inner to outer, or from outer to inner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator after splitting. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If we do split on an iterator which has stages attached at it(by compute_at), the inner most iterator of split results will become the new attach point. </dd></dl>

</div>
</div>
<a id="ab006690418e43cc9b7ad021c02657ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab006690418e43cc9b7ad021c02657ed6">&#9670;&nbsp;</a></span>storage_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::storage_align </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa73e3a269d84c3b4f0a1994371d67bab" title="Set alignment requirement for specific dimension. ">te.Stage.storage_align</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be aligned. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be aligned. </td></tr>
    <tr><td class="paramname">factor</td><td>The factor in alignment specification. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the alignment specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2b1cbaece2a0cd0d0d26f808b2331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2b1cbaece2a0cd0d0d26f808b2331b">&#9670;&nbsp;</a></span>ToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::auto_scheduler::State::ToStr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_trivial_loop</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty-print the state to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delete_trivial_loop</td><td>True for skipping the trivial loops. (undefined or extent == 1, default set to True) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The human readable string. </dd></dl>

</div>
</div>
<a id="aea500365cb7a964a21ac1677fc29fc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea500365cb7a964a21ac1677fc29fc99">&#9670;&nbsp;</a></span>TVM_DEFINE_OBJECT_REF_COW_METHOD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::TVM_DEFINE_OBJECT_REF_COW_METHOD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af31c450ae9eb4fac98974d0de647575f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31c450ae9eb4fac98974d0de647575f">&#9670;&nbsp;</a></span>TVM_DEFINE_OBJECT_REF_METHODS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::TVM_DEFINE_OBJECT_REF_METHODS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa68a9d2e226bae38a36e4be4af1d1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68a9d2e226bae38a36e4be4af1d1ae4">&#9670;&nbsp;</a></span>unroll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::unroll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_unroll</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#af83ad8672660403504f472228b044b33" title="Unroll iteration. ">te::Stage::unroll</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be unrolled. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be unrolled. </td></tr>
    <tr><td class="paramname">max_unroll</td><td>The max unroll limit. <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html" title="Managed reference to IteratorNode. ">Iterator</a> with extent larger than this limit will be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator after unroll. </dd></dl>

</div>
</div>
<a id="a97b8a21210d63bea241dbab085d89b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b8a21210d63bea241dbab085d89b53">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::vectorize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The schedule primitive corresponding to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be vectorized. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be vectorized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator after vectorization. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/auto_scheduler/<a class="el" href="loop__state_8h_source.html">loop_state.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
