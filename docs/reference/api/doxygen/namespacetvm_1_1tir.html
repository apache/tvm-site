<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> specific attribute names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1builtin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html">builtin</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1builtin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of builtin intrinsics as ops. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferAxisHash.html">BufferAxisHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferAxisGraphExtractor.html">BufferAxisGraphExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an axis group graph from a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>. Two buffer axis are connected if they are accessed by the same index.  <a href="classtvm_1_1tir_1_1BufferAxisGraphExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutAxis.html">LayoutAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutNode.html">LayoutNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode.">Layout</a> is to describe how data is organized within an N-dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. Here subordinate axis channel_block=16 is the factor size of the primal axis C (channel). <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode.">Layout</a> for scalar is defined, while both its name and axes have size 0.  <a href="classtvm_1_1tir_1_1LayoutNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Layout.html">Layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LayoutNode.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">LayoutNode</a>.  <a href="classtvm_1_1tir_1_1Layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayoutNode.html">BijectiveLayoutNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html">BijectiveLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bijective function mapping for data layout transformation. Given two <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode.">Layout</a>, <a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html" title="Bijective function mapping for data layout transformation. Given two Layout, BijectiveLayout build an...">BijectiveLayout</a> build and store the mapping rules, provides API to transform N-dimention tensor from the source indices (i0, i1, .., im) to the destination indices (j0, j1, .., jm).  <a href="classtvm_1_1tir_1_1BijectiveLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockDependenceInfoNode.html">SBlockDependenceInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that helps build and query block level dependences using the 2 core objects <a class="el" href="classtvm_1_1tir_1_1SBlockScope.html" title="Managed reference to SBlockScopeNode.">SBlockScope</a> and <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html" title="Managed reference to StmtSRefNode.">StmtSRef</a>.  <a href="classtvm_1_1tir_1_1SBlockDependenceInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockDependenceInfo.html">SBlockDependenceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SBlockDependenceInfoNode.html" title="An object that helps build and query block level dependences using the 2 core objects SBlockScope and...">SBlockDependenceInfoNode</a>.  <a href="classtvm_1_1tir_1_1SBlockDependenceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html">StmtSRefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that refers to schedulable elements (block/for-loop) in TensorIR, aka "sref".  <a href="classtvm_1_1tir_1_1StmtSRefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html" title="An object that refers to schedulable elements (block/for-loop) in TensorIR, aka &quot;sref&quot;.">StmtSRefNode</a>.  <a href="classtvm_1_1tir_1_1StmtSRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SRefTreeCreator.html">SRefTreeCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DependencyNode.html">DependencyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple (src, dst, kind) representing certain types of dependency. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, (A, B, kRAW) means block B depends on block A, and the dependency kind is read-after-write, which means block B reads the result written by block A.  <a href="classtvm_1_1tir_1_1DependencyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Dependency.html">Dependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DependencyNode.html" title="A tuple (src, dst, kind) representing certain types of dependency. For example, (A,...">DependencyNode</a>.  <a href="classtvm_1_1tir_1_1Dependency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockScopeNode.html">SBlockScopeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object with 1-to-1 correspondence with each block reference in the sref tree. This data structure is used to track the producer-consumer dependencies between blocks. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example even leaf nodes have a scope node, even though they have no dependencies.  <a href="classtvm_1_1tir_1_1SBlockScopeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockScope.html">SBlockScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SBlockScopeNode.html" title="An object with 1-to-1 correspondence with each block reference in the sref tree. This data structure ...">SBlockScopeNode</a>.  <a href="classtvm_1_1tir_1_1SBlockScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1ExprDeepEqual.html">ExprDeepEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions recursively and check if they are equal to each other without var remapping.  <a href="structtvm_1_1tir_1_1ExprDeepEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferNode.html">BufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to represent a buffer.  <a href="classtvm_1_1tir_1_1BufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types,...">Buffer</a> is a symbolic n-darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input.  <a href="classtvm_1_1tir_1_1Buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html">DataProducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node for data producers.  <a href="classtvm_1_1tir_1_1DataProducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducer.html">DataProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html" title="Base node for data producers.">DataProducerNode</a>.  <a href="classtvm_1_1tir_1_1DataProducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ffi::String constants, only used in asserts.  <a href="classtvm_1_1tir_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StringImmNode.html" title="ffi::String constants, only used in asserts.">StringImmNode</a>.  <a href="classtvm_1_1tir_1_1StringImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CastNode.html">CastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Cast.html" title="Managed reference to CastNode.">Cast</a> value from one data type to another.  <a href="classtvm_1_1tir_1_1CastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CastNode.html" title="Cast value from one data type to another.">CastNode</a>.  <a href="classtvm_1_1tir_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BinaryOpNode.html">BinaryOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement binary ops.  <a href="classtvm_1_1tir_1_1BinaryOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AddNode.html">AddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + b  <a href="classtvm_1_1tir_1_1AddNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AddNode.html" title="a + b">AddNode</a>.  <a href="classtvm_1_1tir_1_1Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SubNode.html">SubNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a - b  <a href="classtvm_1_1tir_1_1SubNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SubNode.html" title="a - b">SubNode</a>.  <a href="classtvm_1_1tir_1_1Sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MulNode.html">MulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a * b  <a href="classtvm_1_1tir_1_1MulNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MulNode.html" title="a * b">MulNode</a>.  <a href="classtvm_1_1tir_1_1Mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DivNode.html">DivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a / b in the C semnatics.  <a href="classtvm_1_1tir_1_1DivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DivNode.html" title="a / b in the C semnatics.">DivNode</a>.  <a href="classtvm_1_1tir_1_1Div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ModNode.html">ModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a % b in the C semnatics.  <a href="classtvm_1_1tir_1_1ModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ModNode.html" title="a % b in the C semnatics.">ModNode</a>.  <a href="classtvm_1_1tir_1_1Mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html">FloorDivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor division, floor(a/b)  <a href="classtvm_1_1tir_1_1FloorDivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDiv.html">FloorDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html" title="Floor division, floor(a/b)">FloorDivNode</a>.  <a href="classtvm_1_1tir_1_1FloorDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorModNode.html">FloorModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the floordiv.  <a href="classtvm_1_1tir_1_1FloorModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorMod.html">FloorMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorModNode.html" title="The remainder of the floordiv.">FloorModNode</a>.  <a href="classtvm_1_1tir_1_1FloorMod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MinNode.html">MinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(a, b)  <a href="classtvm_1_1tir_1_1MinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MinNode.html" title="min(a, b)">MinNode</a>.  <a href="classtvm_1_1tir_1_1Min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MaxNode.html">MaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">max(a, b)  <a href="classtvm_1_1tir_1_1MaxNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MaxNode.html" title="max(a, b)">MaxNode</a>.  <a href="classtvm_1_1tir_1_1Max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CmpOpNode.html">CmpOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement comparison ops.  <a href="classtvm_1_1tir_1_1CmpOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQNode.html">EQNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b  <a href="classtvm_1_1tir_1_1EQNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQ.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EQNode.html" title="a == b">EQNode</a>.  <a href="classtvm_1_1tir_1_1EQ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NENode.html">NENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a != b  <a href="classtvm_1_1tir_1_1NENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NE.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NENode.html" title="a != b">NENode</a>.  <a href="classtvm_1_1tir_1_1NE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LTNode.html">LTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt; b  <a href="classtvm_1_1tir_1_1LTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LT.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LTNode.html" title="a &lt; b">LTNode</a>.  <a href="classtvm_1_1tir_1_1LT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1LENode.html">LENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt;= b  <a href="structtvm_1_1tir_1_1LENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LE.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="structtvm_1_1tir_1_1LENode.html" title="a &lt;= b">LENode</a>.  <a href="classtvm_1_1tir_1_1LE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GTNode.html">GTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt; b  <a href="classtvm_1_1tir_1_1GTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GT.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GTNode.html" title="a &gt; b">GTNode</a>.  <a href="classtvm_1_1tir_1_1GT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GENode.html">GENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt;= b  <a href="classtvm_1_1tir_1_1GENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GE.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GENode.html" title="a &gt;= b">GENode</a>.  <a href="classtvm_1_1tir_1_1GE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AndNode.html">AndNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &amp;&amp; b  <a href="classtvm_1_1tir_1_1AndNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1And.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AndNode.html" title="a &amp;&amp; b">AndNode</a>.  <a href="classtvm_1_1tir_1_1And.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1OrNode.html">OrNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a || b  <a href="classtvm_1_1tir_1_1OrNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1OrNode.html" title="a || b">OrNode</a>.  <a href="classtvm_1_1tir_1_1Or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NotNode.html">NotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">!a  <a href="classtvm_1_1tir_1_1NotNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NotNode.html" title="!a">NotNode</a>.  <a href="classtvm_1_1tir_1_1Not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SelectNode.html">SelectNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true_value if condition is true, otherwise return false_value.  <a href="classtvm_1_1tir_1_1SelectNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SelectNode.html" title="return true_value if condition is true, otherwise return false_value.">SelectNode</a>.  <a href="classtvm_1_1tir_1_1Select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html">BufferLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load value from the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoad.html">BufferLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html" title="Load value from the high dimension buffer.">BufferLoadNode</a>.  <a href="classtvm_1_1tir_1_1BufferLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html">ProducerLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load value from the result produced by the producer.  <a href="classtvm_1_1tir_1_1ProducerLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoad.html">ProducerLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html" title="Load value from the result produced by the producer.">ProducerLoadNode</a>.  <a href="classtvm_1_1tir_1_1ProducerLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RampNode.html">RampNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load.  <a href="classtvm_1_1tir_1_1RampNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1RampNode.html" title="Construct a vector with lanes elements where its i-th element equals base + i * stride....">RampNode</a>.  <a href="classtvm_1_1tir_1_1Ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html">BroadcastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector where all the elements are value.  <a href="classtvm_1_1tir_1_1BroadcastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html" title="Create a vector where all the elements are value.">BroadcastNode</a>.  <a href="classtvm_1_1tir_1_1Broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode.">Let</a> binding. Bind var to value then evaluate body.  <a href="classtvm_1_1tir_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetNode.html" title="Let binding. Bind var to value then evaluate body.">LetNode</a>.  <a href="classtvm_1_1tir_1_1Let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode.">Call</a> node.  <a href="classtvm_1_1tir_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CallNode.html" title="Call node.">CallNode</a>.  <a href="classtvm_1_1tir_1_1Call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html">ShuffleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html" title="Managed reference to ShuffleNode.">Shuffle</a> instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...)  <a href="classtvm_1_1tir_1_1ShuffleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html" title="Shuffle instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ....">ShuffleNode</a>.  <a href="classtvm_1_1tir_1_1Shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html">CommReducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A commutative reducer node to represent a commutative binary operator with identity element.  <a href="classtvm_1_1tir_1_1CommReducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducer.html">CommReducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html" title="A commutative reducer node to represent a commutative binary operator with identity element.">CommReducerNode</a>.  <a href="classtvm_1_1tir_1_1CommReducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ReduceNode.html">ReduceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operator.  <a href="classtvm_1_1tir_1_1ReduceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Reduce.html">Reduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ReduceNode.html" title="Reduction operator.">ReduceNode</a>.  <a href="classtvm_1_1tir_1_1Reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function.  <a href="classtvm_1_1tir_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const PrimExpr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html" title="ExprVisitor.">ExprVisitor</a>.  <a href="classtvm_1_1tir_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html" title="ExprMutator that mutates expressions.">ExprMutator</a> that mutates expressions.  <a href="classtvm_1_1tir_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive functions that contains TIR statements.  <a href="classtvm_1_1tir_1_1PrimFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html" title="Primitive functions that contains TIR statements.">PrimFuncNode</a>.  <a href="classtvm_1_1tir_1_1PrimFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1TensorIntrinNode.html">TensorIntrinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor intrinsics for tensorization.  <a href="classtvm_1_1tir_1_1TensorIntrinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1TensorIntrin.html">TensorIntrin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1TensorIntrinNode.html" title="Tensor intrinsics for tensorization.">TensorIntrinNode</a>.  <a href="classtvm_1_1tir_1_1TensorIntrin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IndexMapNode.html">IndexMapNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mapping between two representations of indices into a buffer.  <a href="classtvm_1_1tir_1_1IndexMapNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of all statements.  <a href="classtvm_1_1tir_1_1StmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all statements.  <a href="classtvm_1_1tir_1_1Stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html">LetStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode.">Let</a> binding, bind var to value, then run body.  <a href="classtvm_1_1tir_1_1LetStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html" title="Let binding, bind var to value, then run body.">LetStmtNode</a>.  <a href="classtvm_1_1tir_1_1LetStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html">AttrStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body.  <a href="classtvm_1_1tir_1_1AttrStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmt.html">AttrStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html" title="Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary inform...">AttrStmtNode</a>.  <a href="classtvm_1_1tir_1_1AttrStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html">AssertStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert condition, if an error occurs, return the error message.  <a href="classtvm_1_1tir_1_1AssertStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html" title="Assert condition, if an error occurs, return the error message.">AssertStmtNode</a>.  <a href="classtvm_1_1tir_1_1AssertStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html">BufferStoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value to the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferStoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStore.html">BufferStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html" title="Store value to the high dimension buffer.">BufferStoreNode</a>.  <a href="classtvm_1_1tir_1_1BufferStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateNode.html">AllocateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode.">Allocate</a> a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AllocateNode.html" title="Allocate a buffer that can be used in body.">AllocateNode</a>.  <a href="classtvm_1_1tir_1_1Allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DeclBufferNode.html">DeclBufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a buffer that can be used in the body.  <a href="classtvm_1_1tir_1_1DeclBufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DeclBuffer.html">DeclBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DeclBufferNode.html" title="Declare a buffer that can be used in the body.">DeclBufferNode</a>.  <a href="classtvm_1_1tir_1_1DeclBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container of seq statement. Represent a sequence of statements.  <a href="classtvm_1_1tir_1_1SeqStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html">EvaluateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression. This is mostly used for putting a <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode.">Call</a> node into <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a>.  <a href="classtvm_1_1tir_1_1EvaluateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html" title="Evaluates an expression. This is mostly used for putting a Call node into Stmt.">EvaluateNode</a>.  <a href="classtvm_1_1tir_1_1Evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt.html">SeqStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence statement.  <a href="classtvm_1_1tir_1_1SeqStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html">IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode.">IfThenElse</a> statement.  <a href="classtvm_1_1tir_1_1IfThenElseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html" title="IfThenElse statement.">IfThenElseNode</a>.  <a href="classtvm_1_1tir_1_1IfThenElse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ForNode.html">ForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop, with possible type annotations.  <a href="classtvm_1_1tir_1_1ForNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1For.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ForNode.html" title="A for loop, with possible type annotations.">ForNode</a>.  <a href="classtvm_1_1tir_1_1For.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1WhileNode.html">WhileNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtvm_1_1tir_1_1While.html" title="Managed reference to WhileNode.">While</a> loop.  <a href="classtvm_1_1tir_1_1WhileNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1While.html">While</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1WhileNode.html" title="A While loop.">WhileNode</a>.  <a href="classtvm_1_1tir_1_1While.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRegionNode.html">BufferRegionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representing the region of multi-dimensional buffer access.  <a href="classtvm_1_1tir_1_1BufferRegionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferRegionNode.html" title="Representing the region of multi-dimensional buffer access.">BufferRegionNode</a>.  <a href="classtvm_1_1tir_1_1BufferRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MatchBufferRegionNode.html">MatchBufferRegionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match introduces a constraint that the source buffer region can be remapped to the data layout specified by the buffer field. The constraint can be checked in later part of lowering (or optionally during runtime).  <a href="classtvm_1_1tir_1_1MatchBufferRegionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MatchBufferRegion.html">MatchBufferRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MatchBufferRegionNode.html" title="Match introduces a constraint that the source buffer region can be remapped to the data layout specif...">MatchBufferRegionNode</a>.  <a href="classtvm_1_1tir_1_1MatchBufferRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockNode.html">SBlockNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block is a basic schedule unit in TIR.  <a href="classtvm_1_1tir_1_1SBlockNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SBlockNode.html" title="A block is a basic schedule unit in TIR.">SBlockNode</a>.  <a href="classtvm_1_1tir_1_1SBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockRealizeNode.html">SBlockRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block realization node represents execution of the block at the binding values.  <a href="classtvm_1_1tir_1_1SBlockRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SBlockRealize.html">SBlockRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to BlockRealizeNode.  <a href="classtvm_1_1tir_1_1SBlockRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor.html">StmtFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> except it is applied on statements.  <a href="classtvm_1_1tir_1_1StmtFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8_01args_08_4.html">StmtFunctor&lt; R(const Stmt &amp;n, Args... args)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html">StmtVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html" title="StmtVisitor.">StmtVisitor</a>.  <a href="classtvm_1_1tir_1_1StmtVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html">StmtMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html" title="StmtMutator that mutates the statements.">StmtMutator</a> that mutates the statements.  <a href="classtvm_1_1tir_1_1StmtMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprVisitor.html">StmtExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor that recursively visit stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprMutator.html">StmtExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator that recursively mutates stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node in the IR.  <a href="classtvm_1_1tir_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable in TIR  <a href="classtvm_1_1tir_1_1Var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVarNode.html">SizeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node represent a tensor index size, whose value must be non-negative.  <a href="classtvm_1_1tir_1_1SizeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVar.html">SizeVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable represents a tensor index size  <a href="classtvm_1_1tir_1_1SizeVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVarNode.html">IterVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iteration variable representing an iteration over a one dimensional interval.  <a href="classtvm_1_1tir_1_1IterVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration Variable, represents an iteration over an integer interval.  <a href="classtvm_1_1tir_1_1IterVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adae6fba969a8ae541944301374b70927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adae6fba969a8ae541944301374b70927">TIRVarAxis</a> = std::pair&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, int &gt;</td></tr>
<tr class="separator:adae6fba969a8ae541944301374b70927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e456de71660e7af137e15549998f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a513e456de71660e7af137e15549998f1">BufferAxis</a> = std::pair&lt; <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, int &gt;</td></tr>
<tr class="separator:a513e456de71660e7af137e15549998f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">IntImmNode</a> = <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td></tr>
<tr class="separator:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb123be81447d2871f4c716ce2d1dc00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">FloatImmNode</a> = <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td></tr>
<tr class="separator:adb123be81447d2871f4c716ce2d1dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78e27103c60daad7ca744617e0b050"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a7d78e27103c60daad7ca744617e0b050">TGlobalSymbol</a> = ffi::String</td></tr>
<tr class="memdesc:a7d78e27103c60daad7ca744617e0b050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global symbol of the op after lowering.  <a href="namespacetvm_1_1tir.html#a7d78e27103c60daad7ca744617e0b050">More...</a><br /></td></tr>
<tr class="separator:a7d78e27103c60daad7ca744617e0b050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">TVectorizable</a> = bool</td></tr>
<tr class="memdesc:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the op is overloaded for vector form.  <a href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">More...</a><br /></td></tr>
<tr class="separator:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450d600615ef75e4598efa2b1383649c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a450d600615ef75e4598efa2b1383649c">FLowerIntrinsic</a> = ffi::TypedFunction&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td></tr>
<tr class="memdesc:a450d600615ef75e4598efa2b1383649c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic lowering function for given op.  <a href="namespacetvm_1_1tir.html#a450d600615ef75e4598efa2b1383649c">More...</a><br /></td></tr>
<tr class="separator:a450d600615ef75e4598efa2b1383649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5eeba9ded2bf2d39cbf3ef65182ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae8a5eeba9ded2bf2d39cbf3ef65182ef">FLegalize</a> = ffi::TypedFunction&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td></tr>
<tr class="memdesc:ae8a5eeba9ded2bf2d39cbf3ef65182ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The legalization function for given tir op.  <a href="namespacetvm_1_1tir.html#ae8a5eeba9ded2bf2d39cbf3ef65182ef">More...</a><br /></td></tr>
<tr class="separator:ae8a5eeba9ded2bf2d39cbf3ef65182ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313faca441362d9cfe8df91119627b21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a313faca441362d9cfe8df91119627b21">TScriptPrinterName</a> = ffi::String</td></tr>
<tr class="memdesc:a313faca441362d9cfe8df91119627b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator's name in TVMScript printer.  <a href="namespacetvm_1_1tir.html#a313faca441362d9cfe8df91119627b21">More...</a><br /></td></tr>
<tr class="separator:a313faca441362d9cfe8df91119627b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85a9723d52c53bd767ae70236358289"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae85a9723d52c53bd767ae70236358289">TScriptDtypePrintLocation</a> = <a class="el" href="classtvm_1_1Integer.html">Integer</a></td></tr>
<tr class="separator:ae85a9723d52c53bd767ae70236358289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e82a046f157a7d286b0985b3edb84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">TCallEffectKind</a> = <a class="el" href="classtvm_1_1Integer.html">Integer</a></td></tr>
<tr class="memdesc:a651e82a046f157a7d286b0985b3edb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use integer to record the kind.  <a href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">More...</a><br /></td></tr>
<tr class="separator:a651e82a046f157a7d286b0985b3edb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f1aa0cdcd55abe485b2ca344794ee6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac2f1aa0cdcd55abe485b2ca344794ee6">Region</a> = ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;</td></tr>
<tr class="separator:ac2f1aa0cdcd55abe485b2ca344794ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">DepKind</a> : int32_t { <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12ea565ac768da7890c2660ff4b12d267f4b">kRAW</a> = 0
, <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12eaf3b1d6a59161fbe655adccdd10c6eda4">kWAW</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12ea8b16acbc820d7479d796a3a0ac180724">kWAR</a> = 2
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = 3
 }</td></tr>
<tr class="memdesc:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of dependency. Right now we have 4 types of dependencies 1) Read-after-write (kRAW) 2) Write-after-write (kWAW) 3) Write-after-read (kWAR) 4) Opaque dependency (kOpaque)  <a href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">More...</a><br /></td></tr>
<tr class="separator:a82f5fe564edbe0dadbc4a56a82dfe12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">BufferType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39">kDefault</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663">kAutoBroadcast</a> = 2
 }</td></tr>
<tr class="memdesc:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer type  <a href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">More...</a><br /></td></tr>
<tr class="separator:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52a7f5a7dfc8ed07258b2f526df603e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603e">ScriptDtypePrintLocation</a> : int { <a class="el" href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603ea35c3ace1970663a16e5c65baa5941b13">kNone</a> = 0
, <a class="el" href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603ea9fda60ba14f0809e152bc08409aa2737">kFirst</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603eaa9243c3d6084397b601cf95f073384a6">kLast</a> = 2
 }</td></tr>
<tr class="memdesc:ae52a7f5a7dfc8ed07258b2f526df603e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that TVMScript printer prints the dtype as the first/last argument. If not specified, dtype will not be printed.  <a href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603e">More...</a><br /></td></tr>
<tr class="separator:ae52a7f5a7dfc8ed07258b2f526df603e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4a86b205145696c0555fd02bd37f46"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b">kExprAnnotation</a> = 0
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a">kPure</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7">kReadState</a> = 2
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0">kUpdateState</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b">kSpecialCallArg</a> = 4
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373">kEmbedInfo</a> = 5
, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a2ded73cfb5a05bf0e37b284e42769c9c">kControlJump</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a8f4a86b205145696c0555fd02bd37f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The effect type of the call.  <a href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">More...</a><br /></td></tr>
<tr class="separator:a8f4a86b205145696c0555fd02bd37f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aaf54983ae8eb79e77ee6be2f8384e1cb1">kSerial</a> = 0
, <a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aa6fb3551e3657204372d76d2d9b83a3b9">kParallel</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6">kVectorized</a> = 2
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16">kUnrolled</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40aa037de60b0cc37e063125a29b487104b7">kThreadBinding</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of the loop.  <a href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">More...</a><br /></td></tr>
<tr class="separator:a9f59694e9c3912cc5e80654ddbc1e40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422">kDataPar</a> = 0
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0">kThreadIndex</a> = 1
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4">kCommReduce</a> = 2
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b">kOrdered</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c">kOpaque</a> = 4
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = 3
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403">kUnrolled</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16">kUnrolled</a> = 3
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd">kVectorized</a> = 6
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6">kVectorized</a> = 2
, <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652">kParallelized</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47">kTensorized</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iteration variable. Each IterVar have a specific type.  <a href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">More...</a><br /></td></tr>
<tr class="separator:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad33c2dd1fa58678c5d8a6466708aee8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad33c2dd1fa58678c5d8a6466708aee8f">GetShardingVarFromIndex</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> index, ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; var_range, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:ad33c2dd1fa58678c5d8a6466708aee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we want to shard a buffer along a specific dimension, we need to know how to rewrite the access index of the buffer. To make it simple, we only support the case that the access can be rewritten by changing the extent of an iter var.  <a href="namespacetvm_1_1tir.html#ad33c2dd1fa58678c5d8a6466708aee8f">More...</a><br /></td></tr>
<tr class="separator:ad33c2dd1fa58678c5d8a6466708aee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c7001c29b17be7c5d030d8bd8d34c"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a044c7001c29b17be7c5d030d8bd8d34c">GetSBlockAccessRegion</a> (const <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &amp;block, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;buffer_var_map)</td></tr>
<tr class="memdesc:a044c7001c29b17be7c5d030d8bd8d34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto detect the block access region according to its body stmt It will detect the access region as an array in order of appearance in AST.  <a href="namespacetvm_1_1tir.html#a044c7001c29b17be7c5d030d8bd8d34c">More...</a><br /></td></tr>
<tr class="separator:a044c7001c29b17be7c5d030d8bd8d34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b26d233a34a675ae2ec3e512bb0a99"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a66b26d233a34a675ae2ec3e512bb0a99">GetSBlockReadWriteRegion</a> (const <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &amp;block, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;buffer_var_map)</td></tr>
<tr class="memdesc:a66b26d233a34a675ae2ec3e512bb0a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto detect the block read/write region according to its body stmt. An opaque access will be counted as both a read and a write access.  <a href="namespacetvm_1_1tir.html#a66b26d233a34a675ae2ec3e512bb0a99">More...</a><br /></td></tr>
<tr class="separator:a66b26d233a34a675ae2ec3e512bb0a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4277d7f667f2fdb6d8dedefbbdbb6d8"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, ffi::Optional&lt; <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae4277d7f667f2fdb6d8dedefbbdbb6d8">DetectBufferAccessLCA</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:ae4277d7f667f2fdb6d8dedefbbdbb6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect the lowest common ancestor(LCA) of buffer access, including both high-level access(BufferLoad, BufferStore) and low-level access(Load, Store and opaque access). The LCA may be a <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loop or a Block.  <a href="namespacetvm_1_1tir.html#ae4277d7f667f2fdb6d8dedefbbdbb6d8">More...</a><br /></td></tr>
<tr class="separator:ae4277d7f667f2fdb6d8dedefbbdbb6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d546671b72767bd72737fde5474adf4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1tir_1_1SBlockNode.html">tir::SBlockNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1d546671b72767bd72737fde5474adf4">FindAnchorBlock</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a1d546671b72767bd72737fde5474adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the "anchor block" of the given module. We define the anchor block to be the block with (1) an init statement and (2) having the biggest flops count. The latter condition is only used when there are multiple blocks with an init statement. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, if the input module is conv2d + fused spatial blocks, conv2d is the anchor block. The input module may not contain more than one such block. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, a module having two conv2d is not allowed as an input. However, a module created from winograd convolution has multiple blocks with an init statement (input transform, batched GEMM, and output transform). We use the second condition, the flops count, to determine that the batched GEMM block is the anchor block.  <a href="namespacetvm_1_1tir.html#a1d546671b72767bd72737fde5474adf4">More...</a><br /></td></tr>
<tr class="separator:a1d546671b72767bd72737fde5474adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6070cccf4bb454e7a87bbb6d066c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5f6070cccf4bb454e7a87bbb6d066c55">SetSeqIndex</a> (std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &gt; &amp;stmt2ref, const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, int seq_index, bool include_loops=true)</td></tr>
<tr class="memdesc:a5f6070cccf4bb454e7a87bbb6d066c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code><a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html#a1ce9920064b0c2ed42be0e9412fd3939" title="If the statement the sref points to is an element of a SeqStmt in the AST, then seq_index is set to i...">StmtSRefNode::seq_index</a></code> field for stmt.  <a href="namespacetvm_1_1tir.html#a5f6070cccf4bb454e7a87bbb6d066c55">More...</a><br /></td></tr>
<tr class="separator:a5f6070cccf4bb454e7a87bbb6d066c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd0feb99db08fa0ae2ddb4f47f64dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4dd0feb99db08fa0ae2ddb4f47f64dca">SetSeqIndexInChildren</a> (std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &gt; &amp;stmt2ref, const <a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a> *seq_stmt, bool include_loops=true)</td></tr>
<tr class="memdesc:a4dd0feb99db08fa0ae2ddb4f47f64dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update seq_index of the children of a <a class="el" href="classtvm_1_1tir_1_1SeqStmt.html" title="Sequence statement.">SeqStmt</a>.  <a href="namespacetvm_1_1tir.html#a4dd0feb99db08fa0ae2ddb4f47f64dca">More...</a><br /></td></tr>
<tr class="separator:a4dd0feb99db08fa0ae2ddb4f47f64dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memTemplParams" colspan="2">template&lt;class FLambda &gt; </td></tr>
<tr class="memitem:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1f69889b13455cd290e6b1a6453e3c1d">VisitPrimFuncs</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, FLambda fvisit)</td></tr>
<tr class="memdesc:a1f69889b13455cd290e6b1a6453e3c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>.  <a href="namespacetvm_1_1tir.html#a1f69889b13455cd290e6b1a6453e3c1d">More...</a><br /></td></tr>
<tr class="separator:a1f69889b13455cd290e6b1a6453e3c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f5a8fbf008808fd614e3e1583fb82"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab60f5a8fbf008808fd614e3e1583fb82">UndefinedVars</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:ab60f5a8fbf008808fd614e3e1583fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the statement.  <a href="namespacetvm_1_1tir.html#ab60f5a8fbf008808fd614e3e1583fb82">More...</a><br /></td></tr>
<tr class="separator:ab60f5a8fbf008808fd614e3e1583fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9452382d40919b2c0c41684bc9a331"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afc9452382d40919b2c0c41684bc9a331">UndefinedVars</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:afc9452382d40919b2c0c41684bc9a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the expression.  <a href="namespacetvm_1_1tir.html#afc9452382d40919b2c0c41684bc9a331">More...</a><br /></td></tr>
<tr class="separator:afc9452382d40919b2c0c41684bc9a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9f8c99509a6bbc58b3968ea7d8b6e0"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8f9f8c99509a6bbc58b3968ea7d8b6e0">UndefinedVars</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr, const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:a8f9f8c99509a6bbc58b3968ea7d8b6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the expression.  <a href="namespacetvm_1_1tir.html#a8f9f8c99509a6bbc58b3968ea7d8b6e0">More...</a><br /></td></tr>
<tr class="separator:a8f9f8c99509a6bbc58b3968ea7d8b6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aeb03afda344eb4d3a5d2d3fd4e1d266d">SideEffect</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the side effect of an expression.  <a href="namespacetvm_1_1tir.html#aeb03afda344eb4d3a5d2d3fd4e1d266d">More...</a><br /></td></tr>
<tr class="separator:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad41992c8a069ebdfde7ff87d67dd66bd">UsesVar</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt; vset_contains)</td></tr>
<tr class="memdesc:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a> uses any var in the given variable set.  <a href="namespacetvm_1_1tir.html#ad41992c8a069ebdfde7ff87d67dd66bd">More...</a><br /></td></tr>
<tr class="separator:ad41992c8a069ebdfde7ff87d67dd66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a60b80ecfe05e8cbc1ae824c169c4dc5c">UsesVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr, std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt; vset_contains)</td></tr>
<tr class="memdesc:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> uses any var in the given variable set.  <a href="namespacetvm_1_1tir.html#a60b80ecfe05e8cbc1ae824c169c4dc5c">More...</a><br /></td></tr>
<tr class="separator:a60b80ecfe05e8cbc1ae824c169c4dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38edd60b6ff952cefb74842a8ae826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826">VerifySSA</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:a3b38edd60b6ff952cefb74842a8ae826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">Var</a> is defined and assigned once(in Let/For)  <a href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826">More...</a><br /></td></tr>
<tr class="separator:a3b38edd60b6ff952cefb74842a8ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69bcf127843e5e671379e44ab47ca27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27">VerifyMemory</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:ac69bcf127843e5e671379e44ab47ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if memory accesses are legal for a specific target device type.  <a href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27">More...</a><br /></td></tr>
<tr class="separator:ac69bcf127843e5e671379e44ab47ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfaeb3b1ce8601eab8d9b575d66f025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#accfaeb3b1ce8601eab8d9b575d66f025">CalculateExprComplexity</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:accfaeb3b1ce8601eab8d9b575d66f025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expression complexity based on number of symbols it contains.  <a href="namespacetvm_1_1tir.html#accfaeb3b1ce8601eab8d9b575d66f025">More...</a><br /></td></tr>
<tr class="separator:accfaeb3b1ce8601eab8d9b575d66f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7314714e14035c9b1096737920c689ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a7314714e14035c9b1096737920c689ee">CalculateConstantBytes</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;constant_byte_alignment)</td></tr>
<tr class="memdesc:a7314714e14035c9b1096737920c689ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the constants size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>.  <a href="namespacetvm_1_1tir.html#a7314714e14035c9b1096737920c689ee">More...</a><br /></td></tr>
<tr class="separator:a7314714e14035c9b1096737920c689ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f9f5bc52105a2a38a7a97390c55f18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a24f9f5bc52105a2a38a7a97390c55f18">CalculateWorkspaceBytes</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;workspace_byte_alignment)</td></tr>
<tr class="memdesc:a24f9f5bc52105a2a38a7a97390c55f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the workspace size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>.  <a href="namespacetvm_1_1tir.html#a24f9f5bc52105a2a38a7a97390c55f18">More...</a><br /></td></tr>
<tr class="separator:a24f9f5bc52105a2a38a7a97390c55f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3d251f82ef3a0f446ea23f8980d84e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aee3d251f82ef3a0f446ea23f8980d84e">VerifyWellFormed</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, bool assert_mode=true)</td></tr>
<tr class="memdesc:aee3d251f82ef3a0f446ea23f8980d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if the given TIR is well-formed. The verification includes:  <a href="namespacetvm_1_1tir.html#aee3d251f82ef3a0f446ea23f8980d84e">More...</a><br /></td></tr>
<tr class="separator:aee3d251f82ef3a0f446ea23f8980d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28960a0b9f97220f747148376ed16e85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a28960a0b9f97220f747148376ed16e85">VerifyWellFormed</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, bool assert_mode=true)</td></tr>
<tr class="memdesc:a28960a0b9f97220f747148376ed16e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if the TIR in the given IRMOdule is well-formed.  <a href="namespacetvm_1_1tir.html#a28960a0b9f97220f747148376ed16e85">More...</a><br /></td></tr>
<tr class="separator:a28960a0b9f97220f747148376ed16e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c64bf0c1bf0a62f8828c48fb573233"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#af6c64bf0c1bf0a62f8828c48fb573233">FindEntryFunc</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> *result_g_var)</td></tr>
<tr class="memdesc:af6c64bf0c1bf0a62f8828c48fb573233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the entry function of the given <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>, i.e, functions marked by <code><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a489d0cebd2820025bc3d6c5a9011cdd4" title="Mark the function as the entry function of the final generated runtime module.">tir::attr::kIsEntryFunc</a></code>, whose name is <code>main</code> or being the only PrimeFunc.  <a href="namespacetvm_1_1tir.html#af6c64bf0c1bf0a62f8828c48fb573233">More...</a><br /></td></tr>
<tr class="separator:af6c64bf0c1bf0a62f8828c48fb573233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514a80098d90dbd3b0c25262c932a981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a514a80098d90dbd3b0c25262c932a981">DefaultIndexType</a> ()</td></tr>
<tr class="memdesc:a514a80098d90dbd3b0c25262c932a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">if TVM_INDEX_DEFAULT_I64 is set, return int64, otherwise return int32  <a href="namespacetvm_1_1tir.html#a514a80098d90dbd3b0c25262c932a981">More...</a><br /></td></tr>
<tr class="separator:a514a80098d90dbd3b0c25262c932a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79e5c24dfb22cc60b4da7f2d37d6e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae79e5c24dfb22cc60b4da7f2d37d6e04">decl_buffer</a> (ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype=<a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32), ffi::String name=&quot;buffer&quot;, ffi::String storage_scope=&quot;&quot;, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt; axis_separators=std::nullopt, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:ae79e5c24dfb22cc60b4da7f2d37d6e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new buffer given shape, and dtype.  <a href="namespacetvm_1_1tir.html#ae79e5c24dfb22cc60b4da7f2d37d6e04">More...</a><br /></td></tr>
<tr class="separator:ae79e5c24dfb22cc60b4da7f2d37d6e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2b82fa6b780c3d3396ec300ddc1039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ada2b82fa6b780c3d3396ec300ddc1039">BufferWithOffsetAlignment</a> (ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype, std::string name, int data_alignment, int offset_factor, bool compact, std::string memory_scope=&quot;&quot;)</td></tr>
<tr class="memdesc:ada2b82fa6b780c3d3396ec300ddc1039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates TIR <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types,...">Buffer</a> for provided parameters.  <a href="namespacetvm_1_1tir.html#ada2b82fa6b780c3d3396ec300ddc1039">More...</a><br /></td></tr>
<tr class="separator:ada2b82fa6b780c3d3396ec300ddc1039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd04238c82a745536133dc59a0d36c5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a5bd04238c82a745536133dc59a0d36c5"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5bd04238c82a745536133dc59a0d36c5">as_unordered_map</a> (const ffi::Map&lt; K, V &gt; &amp;dmap)</td></tr>
<tr class="separator:a5bd04238c82a745536133dc59a0d36c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25d03546f0ca1e6d24b38126180e3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae25d03546f0ca1e6d24b38126180e3d9">Specialize</a> (<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> func, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, ffi::Variant&lt; <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&gt; &amp;param_map)</td></tr>
<tr class="memdesc:ae25d03546f0ca1e6d24b38126180e3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize parameters of <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>.  <a href="namespacetvm_1_1tir.html#ae25d03546f0ca1e6d24b38126180e3d9">More...</a><br /></td></tr>
<tr class="separator:ae25d03546f0ca1e6d24b38126180e3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1426f7882b4e36da1419c88b48bd1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae1426f7882b4e36da1419c88b48bd1d9">Substitute</a> (const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; f_subst)</td></tr>
<tr class="memdesc:ae1426f7882b4e36da1419c88b48bd1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables in an index map.  <a href="namespacetvm_1_1tir.html#ae1426f7882b4e36da1419c88b48bd1d9">More...</a><br /></td></tr>
<tr class="separator:ae1426f7882b4e36da1419c88b48bd1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd6ae7623f42cddbb05cc008c33711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48cd6ae7623f42cddbb05cc008c33711">IsPointerType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;type, const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;element_type)</td></tr>
<tr class="memdesc:a48cd6ae7623f42cddbb05cc008c33711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a pointer to a runtime element type.  <a href="namespacetvm_1_1tir.html#a48cd6ae7623f42cddbb05cc008c33711">More...</a><br /></td></tr>
<tr class="separator:a48cd6ae7623f42cddbb05cc008c33711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1a071208bbbab6b220cf46f5cdccdd86">make_const</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a1a071208bbbab6b220cf46f5cdccdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const value with certain data type.  <a href="namespacetvm_1_1tir.html#a1a071208bbbab6b220cf46f5cdccdd86">More...</a><br /></td></tr>
<tr class="separator:a1a071208bbbab6b220cf46f5cdccdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3f57cf8d1c3546f075701898c5b70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aed3f57cf8d1c3546f075701898c5b70f">make_zero</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:aed3f57cf8d1c3546f075701898c5b70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const zero expr.  <a href="namespacetvm_1_1tir.html#aed3f57cf8d1c3546f075701898c5b70f">More...</a><br /></td></tr>
<tr class="separator:aed3f57cf8d1c3546f075701898c5b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd84303a9864b5b366835fa628a7824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8dd84303a9864b5b366835fa628a7824">const_true</a> (int lanes=1, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a8dd84303a9864b5b366835fa628a7824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant true expression.  <a href="namespacetvm_1_1tir.html#a8dd84303a9864b5b366835fa628a7824">More...</a><br /></td></tr>
<tr class="separator:a8dd84303a9864b5b366835fa628a7824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875c28f423ab96ae8f0d21f1263abe14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a875c28f423ab96ae8f0d21f1263abe14">const_false</a> (int lanes=1, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a875c28f423ab96ae8f0d21f1263abe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant false expression.  <a href="namespacetvm_1_1tir.html#a875c28f423ab96ae8f0d21f1263abe14">More...</a><br /></td></tr>
<tr class="separator:a875c28f423ab96ae8f0d21f1263abe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8f225faaf34c540194921a7ee6a66"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#acbe8f225faaf34c540194921a7ee6a66">as_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:acbe8f225faaf34c540194921a7ee6a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get x as constant int expression.  <a href="namespacetvm_1_1tir.html#acbe8f225faaf34c540194921a7ee6a66">More...</a><br /></td></tr>
<tr class="separator:acbe8f225faaf34c540194921a7ee6a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c414d5e54c099ad7287be302aac8f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5c414d5e54c099ad7287be302aac8f02">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int64_t value)</td></tr>
<tr class="memdesc:a5c414d5e54c099ad7287be302aac8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer expression.  <a href="namespacetvm_1_1tir.html#a5c414d5e54c099ad7287be302aac8f02">More...</a><br /></td></tr>
<tr class="separator:a5c414d5e54c099ad7287be302aac8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8de8f843c6eb433b6ddfbf34e24099ef">is_no_op</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether stmt is nop.  <a href="namespacetvm_1_1tir.html#a8de8f843c6eb433b6ddfbf34e24099ef">More...</a><br /></td></tr>
<tr class="separator:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5104dcf0933da31329bb0b2580a947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9b5104dcf0933da31329bb0b2580a947">is_one</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a9b5104dcf0933da31329bb0b2580a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 1.  <a href="namespacetvm_1_1tir.html#a9b5104dcf0933da31329bb0b2580a947">More...</a><br /></td></tr>
<tr class="separator:a9b5104dcf0933da31329bb0b2580a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bad3db162b334837716bf8e7ba9285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48bad3db162b334837716bf8e7ba9285">is_zero</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a48bad3db162b334837716bf8e7ba9285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 0.  <a href="namespacetvm_1_1tir.html#a48bad3db162b334837716bf8e7ba9285">More...</a><br /></td></tr>
<tr class="separator:a48bad3db162b334837716bf8e7ba9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65923ae132fcc764357a8765878fb528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a65923ae132fcc764357a8765878fb528">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a65923ae132fcc764357a8765878fb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer constant.  <a href="namespacetvm_1_1tir.html#a65923ae132fcc764357a8765878fb528">More...</a><br /></td></tr>
<tr class="separator:a65923ae132fcc764357a8765878fb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96c80ce43c8276e39c15787d997651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5b96c80ce43c8276e39c15787d997651">is_const_number</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a5b96c80ce43c8276e39c15787d997651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer/float constant.  <a href="namespacetvm_1_1tir.html#a5b96c80ce43c8276e39c15787d997651">More...</a><br /></td></tr>
<tr class="separator:a5b96c80ce43c8276e39c15787d997651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a3d6465ecd0e1f33f16dbea96bafe3"><td class="memTemplParams" colspan="2">template&lt;typename FReduce &gt; </td></tr>
<tr class="memitem:a96a3d6465ecd0e1f33f16dbea96bafe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a96a3d6465ecd0e1f33f16dbea96bafe3">foldl</a> (FReduce freduce, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> init_value, const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;values, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:a96a3d6465ecd0e1f33f16dbea96bafe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left fold.  <a href="namespacetvm_1_1tir.html#a96a3d6465ecd0e1f33f16dbea96bafe3">More...</a><br /></td></tr>
<tr class="separator:a96a3d6465ecd0e1f33f16dbea96bafe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a246623a4a0c9cd8f8a209ec952a8d1c3">is_const_power_of_two_integer</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int *shift)</td></tr>
<tr class="memdesc:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant power of two If x is power of two, write the power to the shift.  <a href="namespacetvm_1_1tir.html#a246623a4a0c9cd8f8a209ec952a8d1c3">More...</a><br /></td></tr>
<tr class="separator:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dc226f8b2b537efdc56b1f76351d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a782dc226f8b2b537efdc56b1f76351d1">is_positive_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a782dc226f8b2b537efdc56b1f76351d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d552441331effb387b7c8fb241c454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a51d552441331effb387b7c8fb241c454">is_negative_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a51d552441331effb387b7c8fb241c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db485654cd60d43962f532a1b16026c"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a0db485654cd60d43962f532a1b16026c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0db485654cd60d43962f532a1b16026c">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="separator:a0db485654cd60d43962f532a1b16026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a79fc1666a383e629654ca5f8d2cdf9f4">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, bool value, <a class="el" href="classtvm_1_1Span.html">Span</a> span)</td></tr>
<tr class="separator:a79fc1666a383e629654ca5f8d2cdf9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b14dba63bb7d64a1da68dad8651d81"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a82b14dba63bb7d64a1da68dad8651d81">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> side_effect)</td></tr>
<tr class="separator:a82b14dba63bb7d64a1da68dad8651d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf355a4fdeb063b1adb4946cad5fca68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abf355a4fdeb063b1adb4946cad5fca68">TypeAnnotation</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype, <a class="el" href="classtvm_1_1Span.html">Span</a> span=<a class="el" href="classtvm_1_1Span.html">Span</a>())</td></tr>
<tr class="memdesc:abf355a4fdeb063b1adb4946cad5fca68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="namespacetvm_1_1tir.html#abf355a4fdeb063b1adb4946cad5fca68">More...</a><br /></td></tr>
<tr class="separator:abf355a4fdeb063b1adb4946cad5fca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba58d59be99ed4026f32b0c10f690929"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aba58d59be99ed4026f32b0c10f690929">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> kind)</td></tr>
<tr class="separator:aba58d59be99ed4026f32b0c10f690929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c36414c1be2960099e023ffba09f6e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a03c36414c1be2960099e023ffba09f6e">ForKind2String</a> (<a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a> t)</td></tr>
<tr class="separator:a03c36414c1be2960099e023ffba09f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af9b88298a46f82b98e9263a73a16e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a7af9b88298a46f82b98e9263a73a16e4">IRTransform</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const ffi::Function &amp;preorder, const ffi::Function &amp;postorder, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; only_enable=std::nullopt)</td></tr>
<tr class="memdesc:a7af9b88298a46f82b98e9263a73a16e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir nodes in post DFS order, and transform it  <a href="namespacetvm_1_1tir.html#a7af9b88298a46f82b98e9263a73a16e4">More...</a><br /></td></tr>
<tr class="separator:a7af9b88298a46f82b98e9263a73a16e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5067fa233d111c9db9cc402ed599c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4b5067fa233d111c9db9cc402ed599c3">PostOrderVisit</a> (const ObjectRef &amp;node, std::function&lt; void(const ObjectRef &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a4b5067fa233d111c9db9cc402ed599c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="namespacetvm_1_1tir.html#a4b5067fa233d111c9db9cc402ed599c3">More...</a><br /></td></tr>
<tr class="separator:a4b5067fa233d111c9db9cc402ed599c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78c5dad1b862811d85475ae8f0f158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1f78c5dad1b862811d85475ae8f0f158">Substitute</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a1f78c5dad1b862811d85475ae8f0f158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="namespacetvm_1_1tir.html#a1f78c5dad1b862811d85475ae8f0f158">More...</a><br /></td></tr>
<tr class="separator:a1f78c5dad1b862811d85475ae8f0f158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f7a270d69fee62ef09d035f6a3d232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac6f7a270d69fee62ef09d035f6a3d232">Substitute</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:ac6f7a270d69fee62ef09d035f6a3d232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="namespacetvm_1_1tir.html#ac6f7a270d69fee62ef09d035f6a3d232">More...</a><br /></td></tr>
<tr class="separator:ac6f7a270d69fee62ef09d035f6a3d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb211ea61127a85cb03101a5b665b5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bb211ea61127a85cb03101a5b665b5b"><td class="memTemplItemLeft" align="right" valign="top">ffi::Array&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2bb211ea61127a85cb03101a5b665b5b">Substitute</a> (const ffi::Array&lt; T &gt; &amp;arr, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a2bb211ea61127a85cb03101a5b665b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="namespacetvm_1_1tir.html#a2bb211ea61127a85cb03101a5b665b5b">More...</a><br /></td></tr>
<tr class="separator:a2bb211ea61127a85cb03101a5b665b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8079514fc51653cd08c1b251ea7dd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab8079514fc51653cd08c1b251ea7dd01">Substitute</a> (const <a class="el" href="classtvm_1_1Range.html">Range</a> &amp;range, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:ab8079514fc51653cd08c1b251ea7dd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#ab8079514fc51653cd08c1b251ea7dd01">More...</a><br /></td></tr>
<tr class="separator:ab8079514fc51653cd08c1b251ea7dd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02f0ae425059c4f48dbd7c81199f12f"><td class="memTemplParams" colspan="2">template&lt;typename Obj &gt; </td></tr>
<tr class="memitem:ad02f0ae425059c4f48dbd7c81199f12f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad02f0ae425059c4f48dbd7c81199f12f">Substitute</a> (Obj &amp;&amp;obj, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;vmap)</td></tr>
<tr class="memdesc:ad02f0ae425059c4f48dbd7c81199f12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#ad02f0ae425059c4f48dbd7c81199f12f">More...</a><br /></td></tr>
<tr class="separator:ad02f0ae425059c4f48dbd7c81199f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41314898eaf580f362bd1f2175637426"><td class="memTemplParams" colspan="2">template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </td></tr>
<tr class="memitem:a41314898eaf580f362bd1f2175637426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a41314898eaf580f362bd1f2175637426">Substitute</a> (Obj &amp;&amp;obj, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, Expr &gt; &amp;vmap)</td></tr>
<tr class="memdesc:a41314898eaf580f362bd1f2175637426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#a41314898eaf580f362bd1f2175637426">More...</a><br /></td></tr>
<tr class="separator:a41314898eaf580f362bd1f2175637426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584558202adb418ba93d2405b82264c9"><td class="memTemplParams" colspan="2">template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </td></tr>
<tr class="memitem:a584558202adb418ba93d2405b82264c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a584558202adb418ba93d2405b82264c9">Substitute</a> (Obj &amp;&amp;obj, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, Expr &gt; &amp;vmap)</td></tr>
<tr class="memdesc:a584558202adb418ba93d2405b82264c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#a584558202adb418ba93d2405b82264c9">More...</a><br /></td></tr>
<tr class="separator:a584558202adb418ba93d2405b82264c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09688b33ed7ff6f354ed26bfc5436209"><td class="memTemplParams" colspan="2">template&lt;typename Obj , typename Expr , typename Hasher , typename EqualityChecker , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </td></tr>
<tr class="memitem:a09688b33ed7ff6f354ed26bfc5436209"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a09688b33ed7ff6f354ed26bfc5436209">Substitute</a> (Obj &amp;&amp;obj, const std::unordered_map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, Expr, Hasher, EqualityChecker &gt; &amp;vmap)</td></tr>
<tr class="memdesc:a09688b33ed7ff6f354ed26bfc5436209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#a09688b33ed7ff6f354ed26bfc5436209">More...</a><br /></td></tr>
<tr class="separator:a09688b33ed7ff6f354ed26bfc5436209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1301a585fe9a09feb38a15b3300d8b"><td class="memTemplParams" colspan="2">template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9e1301a585fe9a09feb38a15b3300d8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9e1301a585fe9a09feb38a15b3300d8b">Substitute</a> (Obj &amp;&amp;obj, const std::unordered_map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, Expr &gt; &amp;iter_vmap)</td></tr>
<tr class="memdesc:a9e1301a585fe9a09feb38a15b3300d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the vars specified by vmap.  <a href="namespacetvm_1_1tir.html#a9e1301a585fe9a09feb38a15b3300d8b">More...</a><br /></td></tr>
<tr class="separator:a9e1301a585fe9a09feb38a15b3300d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55695d11007d759834be744e2b61f5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a55695d11007d759834be744e2b61f5df">SubstituteWithDataTypeLegalization</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;)&gt; vmap)</td></tr>
<tr class="memdesc:a55695d11007d759834be744e2b61f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap and legalize data types after substitution.  <a href="namespacetvm_1_1tir.html#a55695d11007d759834be744e2b61f5df">More...</a><br /></td></tr>
<tr class="separator:a55695d11007d759834be744e2b61f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb34a45c4b78126305d60d21fb6947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a79cb34a45c4b78126305d60d21fb6947">SubstituteWithDataTypeLegalization</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;)&gt; vmap)</td></tr>
<tr class="memdesc:a79cb34a45c4b78126305d60d21fb6947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap and legalize data types after substitution.  <a href="namespacetvm_1_1tir.html#a79cb34a45c4b78126305d60d21fb6947">More...</a><br /></td></tr>
<tr class="separator:a79cb34a45c4b78126305d60d21fb6947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982b5f74aafaa506a146ec8bed07b3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a982b5f74aafaa506a146ec8bed07b3f5">PreOrderVisit</a> (const ObjectRef &amp;stmt_or_expr, const std::function&lt; bool(const ObjectRef &amp;)&gt; &amp;fvisit)</td></tr>
<tr class="memdesc:a982b5f74aafaa506a146ec8bed07b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively visit the IR in pre DFS order node, apply fvisit. If fvisit returns false, it won't visit the children of the node.  <a href="namespacetvm_1_1tir.html#a982b5f74aafaa506a146ec8bed07b3f5">More...</a><br /></td></tr>
<tr class="separator:a982b5f74aafaa506a146ec8bed07b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e86a6db6acc68d381d49df3e665415a"><td class="memTemplParams" colspan="2">template&lt;typename Node , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;StmtNode, Node&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2e86a6db6acc68d381d49df3e665415a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2e86a6db6acc68d381d49df3e665415a">ContainsNode</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a2e86a6db6acc68d381d49df3e665415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the statement contains the specified node type.  <a href="namespacetvm_1_1tir.html#a2e86a6db6acc68d381d49df3e665415a">More...</a><br /></td></tr>
<tr class="separator:a2e86a6db6acc68d381d49df3e665415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fdee9fc81462318d59dbe64c8df26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afc0fdee9fc81462318d59dbe64c8df26">IterVarType2String</a> (<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> t)</td></tr>
<tr class="separator:afc0fdee9fc81462318d59dbe64c8df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a513e456de71660e7af137e15549998f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e456de71660e7af137e15549998f1">&#9670;&nbsp;</a></span>BufferAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a513e456de71660e7af137e15549998f1">tvm::tir::BufferAxis</a> = typedef std::pair&lt;<a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8a5eeba9ded2bf2d39cbf3ef65182ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a5eeba9ded2bf2d39cbf3ef65182ef">&#9670;&nbsp;</a></span>FLegalize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae8a5eeba9ded2bf2d39cbf3ef65182ef">tvm::tir::FLegalize</a> = typedef ffi::TypedFunction&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The legalization function for given tir op. </p>

</div>
</div>
<a id="adb123be81447d2871f4c716ce2d1dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb123be81447d2871f4c716ce2d1dc00">&#9670;&nbsp;</a></span>FloatImmNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">tvm::tir::FloatImmNode</a> = typedef <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a450d600615ef75e4598efa2b1383649c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450d600615ef75e4598efa2b1383649c">&#9670;&nbsp;</a></span>FLowerIntrinsic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a450d600615ef75e4598efa2b1383649c">tvm::tir::FLowerIntrinsic</a> = typedef ffi::TypedFunction&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>(<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intrinsic lowering function for given op. </p>

</div>
</div>
<a id="ae8c7db788e840dc1c2ed1f365d5ea829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c7db788e840dc1c2ed1f365d5ea829">&#9670;&nbsp;</a></span>IntImmNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">tvm::tir::IntImmNode</a> = typedef <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2f1aa0cdcd55abe485b2ca344794ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f1aa0cdcd55abe485b2ca344794ee6">&#9670;&nbsp;</a></span>Region</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ac2f1aa0cdcd55abe485b2ca344794ee6">tvm::tir::Region</a> = typedef ffi::Array&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a651e82a046f157a7d286b0985b3edb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651e82a046f157a7d286b0985b3edb84">&#9670;&nbsp;</a></span>TCallEffectKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">tvm::tir::TCallEffectKind</a> = typedef <a class="el" href="classtvm_1_1Integer.html">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use integer to record the kind. </p>

</div>
</div>
<a id="a7d78e27103c60daad7ca744617e0b050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78e27103c60daad7ca744617e0b050">&#9670;&nbsp;</a></span>TGlobalSymbol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a7d78e27103c60daad7ca744617e0b050">tvm::tir::TGlobalSymbol</a> = typedef ffi::String</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global symbol of the op after lowering. </p>

</div>
</div>
<a id="adae6fba969a8ae541944301374b70927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae6fba969a8ae541944301374b70927">&#9670;&nbsp;</a></span>TIRVarAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#adae6fba969a8ae541944301374b70927">tvm::tir::TIRVarAxis</a> = typedef std::pair&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae85a9723d52c53bd767ae70236358289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85a9723d52c53bd767ae70236358289">&#9670;&nbsp;</a></span>TScriptDtypePrintLocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae85a9723d52c53bd767ae70236358289">tvm::tir::TScriptDtypePrintLocation</a> = typedef <a class="el" href="classtvm_1_1Integer.html">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a313faca441362d9cfe8df91119627b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313faca441362d9cfe8df91119627b21">&#9670;&nbsp;</a></span>TScriptPrinterName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a313faca441362d9cfe8df91119627b21">tvm::tir::TScriptPrinterName</a> = typedef ffi::String</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operator's name in TVMScript printer. </p>

</div>
</div>
<a id="a0c5d42cf669b8ceeb42aa13d95cb5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5d42cf669b8ceeb42aa13d95cb5262">&#9670;&nbsp;</a></span>TVectorizable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">tvm::tir::TVectorizable</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the op is overloaded for vector form. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9ac05a14db42ca73da1d3945e7ce2fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac05a14db42ca73da1d3945e7ce2fd1">&#9670;&nbsp;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">tvm::tir::BufferType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39"></a>kDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663"></a>kAutoBroadcast&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8f4a86b205145696c0555fd02bd37f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4a86b205145696c0555fd02bd37f46">&#9670;&nbsp;</a></span>CallEffectKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">tvm::tir::CallEffectKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The effect type of the call. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b"></a>kExprAnnotation&#160;</td><td class="fielddoc"><p>Function corresponds to an annotation(e.g. likely) and can translate to identity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a"></a>kPure&#160;</td><td class="fielddoc"><p>Pure function that do not interacts with any external state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7"></a>kReadState&#160;</td><td class="fielddoc"><p>Function's that may read from states(e.g. RAM) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0"></a>kUpdateState&#160;</td><td class="fielddoc"><p>Function that may read/write from states(e.g. RAM). </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"><p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b"></a>kSpecialCallArg&#160;</td><td class="fielddoc"><p>Special intrinsic to annotate call arguments info only valid as a direct argument to a call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373"></a>kEmbedInfo&#160;</td><td class="fielddoc"><p>Embed opaque information in the Expr, cannot be codegen. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f4a86b205145696c0555fd02bd37f46a2ded73cfb5a05bf0e37b284e42769c9c"></a>kControlJump&#160;</td><td class="fielddoc"><p>Function that changes control flow. </p>
</td></tr>
</table>

</div>
</div>
<a id="a82f5fe564edbe0dadbc4a56a82dfe12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5fe564edbe0dadbc4a56a82dfe12e">&#9670;&nbsp;</a></span>DepKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a82f5fe564edbe0dadbc4a56a82dfe12e">tvm::tir::DepKind</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode.">Type</a> of dependency. Right now we have 4 types of dependencies 1) Read-after-write (kRAW) 2) Write-after-write (kWAW) 3) Write-after-read (kWAR) 4) Opaque dependency (kOpaque) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12ea565ac768da7890c2660ff4b12d267f4b"></a>kRAW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12eaf3b1d6a59161fbe655adccdd10c6eda4"></a>kWAW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a82f5fe564edbe0dadbc4a56a82dfe12ea8b16acbc820d7479d796a3a0ac180724"></a>kWAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9f59694e9c3912cc5e80654ddbc1e40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f59694e9c3912cc5e80654ddbc1e40a">&#9670;&nbsp;</a></span>ForKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">tvm::tir::ForKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kind of the loop. </p>
<p>ForKind can change the control flow semantics of the loop. So the kind field needs to be considered in all TIR passes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aaf54983ae8eb79e77ee6be2f8384e1cb1"></a>kSerial&#160;</td><td class="fielddoc"><p>default semantics &ndash; serial execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aa6fb3551e3657204372d76d2d9b83a3b9"></a>kParallel&#160;</td><td class="fielddoc"><p>Parallel execution on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6"></a>kVectorized&#160;</td><td class="fielddoc"><p>Vector SIMD loop. The loop body will be vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The loop body must be unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f59694e9c3912cc5e80654ddbc1e40aa037de60b0cc37e063125a29b487104b7"></a>kThreadBinding&#160;</td><td class="fielddoc"><p>The loop variable is bound to a thread in an environment. In the final stage of lowering, the loop is simply removed and the loop variable is mapped to the corresponding context thread. </p>
</td></tr>
</table>

</div>
</div>
<a id="add7d0a6b1dd91f0c3c5dd2f4cf64358e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7d0a6b1dd91f0c3c5dd2f4cf64358e">&#9670;&nbsp;</a></span>IterVarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">tvm::tir::IterVarType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode.">Type</a> of iteration variable. Each <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> have a specific type. </p>
<p>The type of iter var can be overriden via stage.iter_var_attrs given they are compatible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422"></a>kDataPar&#160;</td><td class="fielddoc"><p>Data parallel iteration. This normally corresponds to axis of Tensor. Allow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> manipulations. </p>
<dl class="section note"><dt>Note</dt><dd>This does not mean the loop have to be executed in parallel fashion. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0"></a>kThreadIndex&#160;</td><td class="fielddoc"><p>The <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> itself is a thread-index of a fixed thread launching group. Note that this is already assumed to be parallelized. </p>
<p>Disallow: split/fuse/vectorize/parallel </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4"></a>kCommReduce&#160;</td><td class="fielddoc"><p>Communicative reduction. Cannot be directly parallelized. </p>
<p>Disallow: parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b"></a>kOrdered&#160;</td><td class="fielddoc"><p>Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-ordered. </p>
<p>Disallow: reorder/parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c"></a>kOpaque&#160;</td><td class="fielddoc"><p><a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> is opaque,. </p>
<p>May not corresponds to any generated loop Disallow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval.">IterVar</a> manipulations and compute_at</p>
<dl class="section note"><dt>Note</dt><dd>This is usually used to implement composite op or external op, where the </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc"><p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The execution is unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1bc8dc9347e62b074ae6ba7c20bcee16"></a>kUnrolled&#160;</td><td class="fielddoc"><p>The loop body must be unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd"></a>kVectorized&#160;</td><td class="fielddoc"><p>The loop is vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ead3e330e7fdb5593e51d3fad3845e0be6"></a>kVectorized&#160;</td><td class="fielddoc"><p>Vector SIMD loop. The loop body will be vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652"></a>kParallelized&#160;</td><td class="fielddoc"><p>The loop is parallelized. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47"></a>kTensorized&#160;</td><td class="fielddoc"><p>Marks boundary of tensorization intrinsic. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae52a7f5a7dfc8ed07258b2f526df603e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52a7f5a7dfc8ed07258b2f526df603e">&#9670;&nbsp;</a></span>ScriptDtypePrintLocation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#ae52a7f5a7dfc8ed07258b2f526df603e">tvm::tir::ScriptDtypePrintLocation</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that TVMScript printer prints the dtype as the first/last argument. If not specified, dtype will not be printed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae52a7f5a7dfc8ed07258b2f526df603ea35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>Do not print dtype as an argument. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae52a7f5a7dfc8ed07258b2f526df603ea9fda60ba14f0809e152bc08409aa2737"></a>kFirst&#160;</td><td class="fielddoc"><p>Print dtype as the first argument. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae52a7f5a7dfc8ed07258b2f526df603eaa9243c3d6084397b601cf95f073384a6"></a>kLast&#160;</td><td class="fielddoc"><p>FPrint dtype as the last argument. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acbe8f225faaf34c540194921a7ee6a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe8f225faaf34c540194921a7ee6a66">&#9670;&nbsp;</a></span>as_const_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t* tvm::tir::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get x as constant int expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address to the int expression, return nullptr, if x is not <a class="el" href="classtvm_1_1IntImm.html" title="Managed reference class to IntImmNode.">IntImm</a>. </dd></dl>

</div>
</div>
<a id="a5bd04238c82a745536133dc59a0d36c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd04238c82a745536133dc59a0d36c5">&#9670;&nbsp;</a></span>as_unordered_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;K, V&gt; tvm::tir::as_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const ffi::Map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>dmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada2b82fa6b780c3d3396ec300ddc1039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2b82fa6b780c3d3396ec300ddc1039">&#9670;&nbsp;</a></span>BufferWithOffsetAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> tvm::tir::BufferWithOffsetAlignment </td>
          <td>(</td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>memory_scope</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates TIR <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types,...">Buffer</a> for provided parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape of the buffer </td></tr>
    <tr><td class="paramname">dtype</td><td>data type </td></tr>
    <tr><td class="paramname">name</td><td>buffer name </td></tr>
    <tr><td class="paramname">data_alignment</td><td>alignment requirement of data pointer in bytes </td></tr>
    <tr><td class="paramname">offset_factor</td><td>Factor of elem_offset field, elem_offset is guaranteed to be multiple of offset_factor User can specify data_alignment and offset_factor to be 0 A default value will be picked. </td></tr>
    <tr><td class="paramname">compact</td><td>If the statement has already bound to a compact buffer. </td></tr>
    <tr><td class="paramname">memory_scope</td><td>memory scope of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7314714e14035c9b1096737920c689ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7314714e14035c9b1096737920c689ee">&#9670;&nbsp;</a></span>CalculateConstantBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::tir::CalculateConstantBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>constant_byte_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the constants size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> for which the constants size to be calculated </td></tr>
    <tr><td class="paramname">constant_byte_alignment</td><td>The byte alignment required for each constant allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accfaeb3b1ce8601eab8d9b575d66f025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfaeb3b1ce8601eab8d9b575d66f025">&#9670;&nbsp;</a></span>CalculateExprComplexity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::tir::CalculateExprComplexity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the expression complexity based on number of symbols it contains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expr to be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f9f5bc52105a2a38a7a97390c55f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f9f5bc52105a2a38a7a97390c55f18">&#9670;&nbsp;</a></span>CalculateWorkspaceBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::tir::CalculateWorkspaceBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Integer.html">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>workspace_byte_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the workspace size in bytes needed by the TIR allocates inside the TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The TIR <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> for which the workspace size to be calculated </td></tr>
    <tr><td class="paramname">workspace_byte_alignment</td><td>The byte alignment required for each tensor allocated in this workspace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a875c28f423ab96ae8f0d21f1263abe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875c28f423ab96ae8f0d21f1263abe14">&#9670;&nbsp;</a></span>const_false()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant false expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a id="a8dd84303a9864b5b366835fa628a7824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd84303a9864b5b366835fa628a7824">&#9670;&nbsp;</a></span>const_true()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant true expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a id="a2e86a6db6acc68d381d49df3e665415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e86a6db6acc68d381d49df3e665415a">&#9670;&nbsp;</a></span>ContainsNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;StmtNode, Node&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::ContainsNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the statement contains the specified node type. </p>
<p>This utility potentially walks the entire statement, and should therefore not be used if it could otherwise be merged with another pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether stmt contains Node </dd></dl>

</div>
</div>
<a id="ae79e5c24dfb22cc60b4da7f2d37d6e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79e5c24dfb22cc60b4da7f2d37d6e04">&#9670;&nbsp;</a></span>decl_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> tvm::tir::decl_buffer </td>
          <td>(</td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;buffer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>storage_scope</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>axis_separators</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new buffer given shape, and dtype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the buffer, </td></tr>
    <tr><td class="paramname">dtype</td><td>The content data type. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope associated with this buffer </td></tr>
    <tr><td class="paramname">axis_separators</td><td>Divisions defining the groups of axes that will be flattened together. </td></tr>
    <tr><td class="paramname">span</td><td>The location of this object in the source code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created buffer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types,...">Buffer</a> for complete constructor. </dd></dl>

</div>
</div>
<a id="a514a80098d90dbd3b0c25262c932a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514a80098d90dbd3b0c25262c932a981">&#9670;&nbsp;</a></span>DefaultIndexType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> tvm::tir::DefaultIndexType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if TVM_INDEX_DEFAULT_I64 is set, return int64, otherwise return int32 </p>

</div>
</div>
<a id="ae4277d7f667f2fdb6d8dedefbbdbb6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4277d7f667f2fdb6d8dedefbbdbb6d8">&#9670;&nbsp;</a></span>DetectBufferAccessLCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, ffi::Optional&lt;<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&gt; &gt; tvm::tir::DetectBufferAccessLCA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect the lowest common ancestor(LCA) of buffer access, including both high-level access(BufferLoad, BufferStore) and low-level access(Load, Store and opaque access). The LCA may be a <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> loop or a Block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Map from buffer to the LCA of all access to it. The lca is function root if the return stmt is std::nullopt. </dd></dl>

</div>
</div>
<a id="a1d546671b72767bd72737fde5474adf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d546671b72767bd72737fde5474adf4">&#9670;&nbsp;</a></span>FindAnchorBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1tir_1_1SBlockNode.html">tir::SBlockNode</a>* tvm::tir::FindAnchorBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the "anchor block" of the given module. We define the anchor block to be the block with (1) an init statement and (2) having the biggest flops count. The latter condition is only used when there are multiple blocks with an init statement. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, if the input module is conv2d + fused spatial blocks, conv2d is the anchor block. The input module may not contain more than one such block. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, a module having two conv2d is not allowed as an input. However, a module created from winograd convolution has multiple blocks with an init statement (input transform, batched GEMM, and output transform). We use the second condition, the flops count, to determine that the batched GEMM block is the anchor block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The input TIR module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The anchor block if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a id="af6c64bf0c1bf0a62f8828c48fb573233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c64bf0c1bf0a62f8828c48fb573233">&#9670;&nbsp;</a></span>FindEntryFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a>* tvm::tir::FindEntryFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> *&#160;</td>
          <td class="paramname"><em>result_g_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the entry function of the given <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>, i.e, functions marked by <code><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a489d0cebd2820025bc3d6c5a9011cdd4" title="Mark the function as the entry function of the final generated runtime module.">tir::attr::kIsEntryFunc</a></code>, whose name is <code>main</code> or being the only PrimeFunc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to find the entry function. </td></tr>
    <tr><td class="paramname">result_g_var</td><td>The result <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> of the entry function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entry function. </dd></dl>

</div>
</div>
<a id="a96a3d6465ecd0e1f33f16dbea96bafe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a3d6465ecd0e1f33f16dbea96bafe3">&#9670;&nbsp;</a></span>foldl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FReduce &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::foldl </td>
          <td>(</td>
          <td class="paramtype">FReduce&#160;</td>
          <td class="paramname"><em>freduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>init_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left fold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freduce</td><td>The reduction function. </td></tr>
    <tr><td class="paramname">init_value</td><td>The initial value. </td></tr>
    <tr><td class="paramname">values</td><td>The values to be folded. </td></tr>
    <tr><td class="paramname">span</td><td>The location of the fold in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FReduce</td><td>The type of the reduction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c36414c1be2960099e023ffba09f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c36414c1be2960099e023ffba09f6e">&#9670;&nbsp;</a></span>ForKind2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::ForKind2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a044c7001c29b17be7c5d030d8bd8d34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044c7001c29b17be7c5d030d8bd8d34c">&#9670;&nbsp;</a></span>GetSBlockAccessRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a>&gt; &gt; tvm::tir::GetSBlockAccessRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto detect the block access region according to its body stmt It will detect the access region as an array in order of appearance in AST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be detected </td></tr>
    <tr><td class="paramname">buffer_var_map</td><td>The outside buffers which may be accessed the block. It is a map from buffer var to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of access regions. There are three arrays of <a class="el" href="classtvm_1_1tir_1_1BufferRegion.html" title="Managed reference to BufferRegionNode.">BufferRegion</a>:<ul>
<li>first: read regions</li>
<li>second: write regions</li>
<li>third: opaque regions </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a66b26d233a34a675ae2ec3e512bb0a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b26d233a34a675ae2ec3e512bb0a99">&#9670;&nbsp;</a></span>GetSBlockReadWriteRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1BufferRegion.html">BufferRegion</a>&gt; &gt; tvm::tir::GetSBlockReadWriteRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto detect the block read/write region according to its body stmt. An opaque access will be counted as both a read and a write access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be detected </td></tr>
    <tr><td class="paramname">buffer_var_map</td><td>The outside buffers which may be accessed the block. It is a map from buffer var to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array only consisting of the read regions and write regions of the input block </dd></dl>

</div>
</div>
<a id="ad33c2dd1fa58678c5d8a6466708aee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33c2dd1fa58678c5d8a6466708aee8f">&#9670;&nbsp;</a></span>GetShardingVarFromIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> tvm::tir::GetShardingVarFromIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>var_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppose we want to shard a buffer along a specific dimension, we need to know how to rewrite the access index of the buffer. To make it simple, we only support the case that the access can be rewritten by changing the extent of an iter var. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The access index </td></tr>
    <tr><td class="paramname">var_range</td><td>The range of each iter var </td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iter var whose extent to be changed </dd></dl>

</div>
</div>
<a id="a7af9b88298a46f82b98e9263a73a16e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af9b88298a46f82b98e9263a73a16e4">&#9670;&nbsp;</a></span>IRTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::IRTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Function &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Function &amp;&#160;</td>
          <td class="paramname"><em>postorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>only_enable</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir nodes in post DFS order, and transform it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The ir to be transformed. </td></tr>
    <tr><td class="paramname">preorder</td><td>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won't do further recursion. </td></tr>
    <tr><td class="paramname">postorder</td><td>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </td></tr>
    <tr><td class="paramname">only_enable</td><td>List of String. If it is null, all IRNode will call preorder/postorder If it is not null, preorder/postorder will only be called when the IRNode's type key is in the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65923ae132fcc764357a8765878fb528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65923ae132fcc764357a8765878fb528">&#9670;&nbsp;</a></span>is_const_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a id="a5c414d5e54c099ad7287be302aac8f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c414d5e54c099ad7287be302aac8f02">&#9670;&nbsp;</a></span>is_const_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
    <tr><td class="paramname">value</td><td>the value to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant expression. </dd></dl>

</div>
</div>
<a id="a5b96c80ce43c8276e39c15787d997651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b96c80ce43c8276e39c15787d997651">&#9670;&nbsp;</a></span>is_const_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer/float constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a id="a246623a4a0c9cd8f8a209ec952a8d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246623a4a0c9cd8f8a209ec952a8d1c3">&#9670;&nbsp;</a></span>is_const_power_of_two_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether x is a constant power of two If x is power of two, write the power to the shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input expression. </td></tr>
    <tr><td class="paramname">shift</td><td>The output shift if x is power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant power of two </dd></dl>

</div>
</div>
<a id="a51d552441331effb387b7c8fb241c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d552441331effb387b7c8fb241c454">&#9670;&nbsp;</a></span>is_negative_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8de8f843c6eb433b6ddfbf34e24099ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de8f843c6eb433b6ddfbf34e24099ef">&#9670;&nbsp;</a></span>is_no_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether stmt is nop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The input statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether stmt is nop </dd></dl>

</div>
</div>
<a id="a9b5104dcf0933da31329bb0b2580a947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5104dcf0933da31329bb0b2580a947">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 1 </dd></dl>

</div>
</div>
<a id="a782dc226f8b2b537efdc56b1f76351d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782dc226f8b2b537efdc56b1f76351d1">&#9670;&nbsp;</a></span>is_positive_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48bad3db162b334837716bf8e7ba9285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bad3db162b334837716bf8e7ba9285">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>

</div>
</div>
<a id="a48cd6ae7623f42cddbb05cc008c33711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd6ae7623f42cddbb05cc008c33711">&#9670;&nbsp;</a></span>IsPointerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::IsPointerType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if type is a pointer to a runtime element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to be checked. </td></tr>
    <tr><td class="paramname">element_type</td><td>The corresponding element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The check results </dd></dl>

</div>
</div>
<a id="afc0fdee9fc81462318d59dbe64c8df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0fdee9fc81462318d59dbe64c8df26">&#9670;&nbsp;</a></span>IterVarType2String()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::IterVarType2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a071208bbbab6b220cf46f5cdccdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a071208bbbab6b220cf46f5cdccdd86">&#9670;&nbsp;</a></span>make_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const value with certain data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">value</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The constant value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed3f57cf8d1c3546f075701898c5b70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3f57cf8d1c3546f075701898c5b70f">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const zero expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">span</td><td>The location of this operation in the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>

</div>
</div>
<a id="a79fc1666a383e629654ca5f8d2cdf9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fc1666a383e629654ca5f8d2cdf9f4">&#9670;&nbsp;</a></span>MakeConstScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0db485654cd60d43962f532a1b16026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db485654cd60d43962f532a1b16026c">&#9670;&nbsp;</a></span>MakeConstScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b14dba63bb7d64a1da68dad8651d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b14dba63bb7d64a1da68dad8651d81">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::tir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a>&#160;</td>
          <td class="paramname"><em>side_effect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba58d59be99ed4026f32b0c10f690929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba58d59be99ed4026f32b0c10f690929">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::tir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#a9f59694e9c3912cc5e80654ddbc1e40a">ForKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b5067fa233d111c9db9cc402ed599c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5067fa233d111c9db9cc402ed599c3">&#9670;&nbsp;</a></span>PostOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const ObjectRef &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const ObjectRef &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982b5f74aafaa506a146ec8bed07b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982b5f74aafaa506a146ec8bed07b3f5">&#9670;&nbsp;</a></span>PreOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PreOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const ObjectRef &amp;&#160;</td>
          <td class="paramname"><em>stmt_or_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const ObjectRef &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively visit the IR in pre DFS order node, apply fvisit. If fvisit returns false, it won't visit the children of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt_or_expr</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. If fvisit returns false, it won't visit the children of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f6070cccf4bb454e7a87bbb6d066c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6070cccf4bb454e7a87bbb6d066c55">&#9670;&nbsp;</a></span>SetSeqIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::SetSeqIndex </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stmt2ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seq_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_loops</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <code><a class="el" href="classtvm_1_1tir_1_1StmtSRefNode.html#a1ce9920064b0c2ed42be0e9412fd3939" title="If the statement the sref points to is an element of a SeqStmt in the AST, then seq_index is set to i...">StmtSRefNode::seq_index</a></code> field for stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt2ref</td><td>The stmt2ref map to be updated with seq_index </td></tr>
    <tr><td class="paramname">stmt</td><td>The statement, or the realize node of the statement whose sref to be set </td></tr>
    <tr><td class="paramname">seq_index</td><td>The seq_index to be set </td></tr>
    <tr><td class="paramname">include_loops</td><td>Ignore ForNodes if this value is false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The method is NOP for statements that are not schedulable, i.e. not <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> or <a class="el" href="classtvm_1_1tir_1_1SBlock.html" title="Managed reference to SBlockNode.">SBlock</a> </dd></dl>

</div>
</div>
<a id="a4dd0feb99db08fa0ae2ddb4f47f64dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd0feb99db08fa0ae2ddb4f47f64dca">&#9670;&nbsp;</a></span>SetSeqIndexInChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::SetSeqIndexInChildren </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *, <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stmt2ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a> *&#160;</td>
          <td class="paramname"><em>seq_stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_loops</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update seq_index of the children of a <a class="el" href="classtvm_1_1tir_1_1SeqStmt.html" title="Sequence statement.">SeqStmt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt2ref</td><td>The stmt2ref map to be updated with indices </td></tr>
    <tr><td class="paramname">seq_stmt</td><td>The <a class="el" href="classtvm_1_1tir_1_1SeqStmt.html" title="Sequence statement.">SeqStmt</a> whose children need updating </td></tr>
    <tr><td class="paramname">include_loops</td><td>Ignore ForNodes if this value is false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb03afda344eb4d3a5d2d3fd4e1d266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb03afda344eb4d3a5d2d3fd4e1d266d">&#9670;&nbsp;</a></span>SideEffect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> tvm::tir::SideEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the side effect of an expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CallEffectKind, can be kPure, kReadState or kUpdateState </dd></dl>

</div>
</div>
<a id="ae25d03546f0ca1e6d24b38126180e3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25d03546f0ca1e6d24b38126180e3d9">&#9670;&nbsp;</a></span>Specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> tvm::tir::Specialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, ffi::Variant&lt; <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>param_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialize parameters of <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to be specialized. </td></tr>
    <tr><td class="paramname">param_map</td><td>The mapping from function params to the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new function with parameter specialized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We can define a Meta TIR function with symbolic shape:</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">@T.prim_func</span></div>
<div class="line"><span class="keyword">def </span>mem_copy(a: T.handle, b: T.handle, m: T.int32, n: T.int32) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    A = T.match_buffer(a, (m, n), <span class="stringliteral">&quot;float32&quot;</span>)</div>
<div class="line">    B = T.match_buffer(b, (m, n), <span class="stringliteral">&quot;float32&quot;</span>)</div>
<div class="line">    <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> T.grid(m, n):</div>
<div class="line">        <span class="keyword">with</span> T.sblock():</div>
<div class="line">            vi, vj = T.axis.remap(<span class="stringliteral">&quot;SS&quot;</span>, [i, j])</div>
<div class="line">            B[vi, vj] = A[vi, vj]</div>
</div><!-- fragment --><p>Then we can make it specialized with given shapes or buffers.</p>
<div class="fragment"><div class="line">a, _, m, n = mem_copy.params</div>
<div class="line">func = mem_copy.specialize({a: tir.decl_buffer((16, 16))})</div>
<div class="line"><span class="comment"># or</span></div>
<div class="line">func = mem_copy.specialize({n: 16, m: 16})</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">@T.prim_func</span></div>
<div class="line"><span class="keyword">def </span>mem_copy_16_16(a: T.handle, b: T.handle) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    A = T.match_buffer(a, (16, 16), <span class="stringliteral">&quot;float32&quot;</span>)</div>
<div class="line">    B = T.match_buffer(b, (16, 16), <span class="stringliteral">&quot;float32&quot;</span>)</div>
<div class="line">    <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> T.grid(16, 16):</div>
<div class="line">        <span class="keyword">with</span> T.sblock():</div>
<div class="line">            vi, vj = T.axis.remap(<span class="stringliteral">&quot;SS&quot;</span>, [i, j])</div>
<div class="line">            B[vi, vj] = A[vi, vj]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2bb211ea61127a85cb03101a5b665b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb211ea61127a85cb03101a5b665b5b">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;T&gt; tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array of Stmt/PrimExpr to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="ae1426f7882b4e36da1419c88b48bd1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1426f7882b4e36da1419c88b48bd1d9">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>f_subst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables in an index map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_map</td><td>The index_map </td></tr>
    <tr><td class="paramname">f_subst</td><td>The substitution function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8079514fc51653cd08c1b251ea7dd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8079514fc51653cd08c1b251ea7dd01">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Range.html">Range</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The array of Stmt/PrimExpr to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified <a class="el" href="classtvm_1_1Range.html" title="Range container">Range</a>. </dd></dl>

</div>
</div>
<a id="a41314898eaf580f362bd1f2175637426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41314898eaf580f362bd1f2175637426">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<p>Delegates to the Substitute methods that use std::function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object in which TIR variables should be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>Map defining the TIR variables to be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified object. </dd></dl>

</div>
</div>
<a id="ad02f0ae425059c4f48dbd7c81199f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02f0ae425059c4f48dbd7c81199f12f">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<p>Delegates to the Substitute methods that use std::function. This overload allows braced-initialization of the Map, whereas the template&lt;typename Expr&gt; overload cannot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object in which TIR variables should be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>Map defining the TIR variables to be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified object. </dd></dl>

</div>
</div>
<a id="a584558202adb418ba93d2405b82264c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584558202adb418ba93d2405b82264c9">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<p>Delegates to the Substitute methods that use std::function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object in which TIR variables should be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>Map defining the TIR variables to be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified object. </dd></dl>

</div>
</div>
<a id="a9e1301a585fe9a09feb38a15b3300d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1301a585fe9a09feb38a15b3300d8b">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj , typename Expr , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>iter_vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<p>Delegates to the Substitute methods that use std::function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object in which TIR variables should be substituted </td></tr>
    <tr><td class="paramname">iter_vmap</td><td>Map defining the TIR variables to be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified object. </dd></dl>

</div>
</div>
<a id="a09688b33ed7ff6f354ed26bfc5436209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09688b33ed7ff6f354ed26bfc5436209">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Obj , typename Expr , typename Hasher , typename EqualityChecker , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;PrimExpr, Expr&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, Expr, Hasher, EqualityChecker &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the vars specified by vmap. </p>
<p>Delegates to the Substitute methods that use std::function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object in which TIR variables should be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>Map defining the TIR variables to be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified object. </dd></dl>

</div>
</div>
<a id="ac6f7a270d69fee62ef09d035f6a3d232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f7a270d69fee62ef09d035f6a3d232">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a1f78c5dad1b862811d85475ae8f0f158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78c5dad1b862811d85475ae8f0f158">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a id="a79cb34a45c4b78126305d60d21fb6947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cb34a45c4b78126305d60d21fb6947">&#9670;&nbsp;</a></span>SubstituteWithDataTypeLegalization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::SubstituteWithDataTypeLegalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap and legalize data types after substitution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>Unlike <code>Substitute</code>, this allows the substitution to change the data type of the expression.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#ae1426f7882b4e36da1419c88b48bd1d9" title="Substitute variables in an index map.">Substitute</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a55695d11007d759834be744e2b61f5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55695d11007d759834be744e2b61f5df">&#9670;&nbsp;</a></span>SubstituteWithDataTypeLegalization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::SubstituteWithDataTypeLegalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap and legalize data types after substitution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>Unlike <code>Substitute</code>, this allows the substitution to change the data type of the expression.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir.html#ae1426f7882b4e36da1419c88b48bd1d9" title="Substitute variables in an index map.">Substitute</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="abf355a4fdeb063b1adb4946cad5fca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf355a4fdeb063b1adb4946cad5fca68">&#9670;&nbsp;</a></span>TypeAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::TypeAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Span.html">Span</a>&#160;</td>
          <td class="paramname"><em>span</em> = <code><a class="el" href="classtvm_1_1Span.html">Span</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a type annotation expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type </td></tr>
    <tr><td class="paramname">span</td><td>The location of this object in the source code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expr a expression with dtype. </dd></dl>

</div>
</div>
<a id="afc9452382d40919b2c0c41684bc9a331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9452382d40919b2c0c41684bc9a331">&#9670;&nbsp;</a></span>UndefinedVars() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a id="a8f9f8c99509a6bbc58b3968ea7d8b6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9f8c99509a6bbc58b3968ea7d8b6e0">&#9670;&nbsp;</a></span>UndefinedVars() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a id="ab60f5a8fbf008808fd614e3e1583fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f5a8fbf008808fd614e3e1583fb82">&#9670;&nbsp;</a></span>UndefinedVars() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a id="a60b80ecfe05e8cbc1ae824c169c4dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b80ecfe05e8cbc1ae824c169c4dc5c">&#9670;&nbsp;</a></span>UsesVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::UsesVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>vset_contains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the given <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> uses any var in the given variable set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> to be checked. </td></tr>
    <tr><td class="paramname">vset_contains</td><td>The check function to see if var is in the variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>expr</code> uses any var in the given variable set. </dd></dl>

</div>
</div>
<a id="ad41992c8a069ebdfde7ff87d67dd66bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41992c8a069ebdfde7ff87d67dd66bd">&#9670;&nbsp;</a></span>UsesVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::UsesVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>vset_contains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the given <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a> uses any var in the given variable set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements.">Stmt</a> to be checked. </td></tr>
    <tr><td class="paramname">vset_contains</td><td>The check function to see if a var is in the variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>stmt</code> uses any var in the given variable set. </dd></dl>

</div>
</div>
<a id="ac69bcf127843e5e671379e44ab47ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69bcf127843e5e671379e44ab47ca27">&#9670;&nbsp;</a></span>VerifyMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if memory accesses are legal for a specific target device type. </p>
<p>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of memory verification. </dd></dl>

</div>
</div>
<a id="a3b38edd60b6ff952cefb74842a8ae826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38edd60b6ff952cefb74842a8ae826">&#9670;&nbsp;</a></span>VerifySSA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifySSA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">Var</a> is defined and assigned once(in Let/For) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether IR is in SSA form.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All passes in TIR consume and produce SSA form. </dd></dl>

</div>
</div>
<a id="a28960a0b9f97220f747148376ed16e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28960a0b9f97220f747148376ed16e85">&#9670;&nbsp;</a></span>VerifyWellFormed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyWellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assert_mode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if the TIR in the given IRMOdule is well-formed. </p>
<p>In addition to the checks performed for each <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> (see above), the following checks are performed:</p>
<ul>
<li>The same TIR variable may not be defined in more than one function</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to be verified. </td></tr>
    <tr><td class="paramname">assert_mode</td><td>The indicator if it raises an error when the function is not well-formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether it is a well-formed TIR module. </dd></dl>

</div>
</div>
<a id="aee3d251f82ef3a0f446ea23f8980d84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3d251f82ef3a0f446ea23f8980d84e">&#9670;&nbsp;</a></span>VerifyWellFormed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyWellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assert_mode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if the given TIR is well-formed. The verification includes: </p>
<ul>
<li>All variables are defined prior to their point of use.</li>
<li>No variables are used outside of the scope of their definition.</li>
<li>Each variable has a single point of definition.</li>
<li>Expressions within a <a class="el" href="classtvm_1_1tir_1_1SBlock.html" title="Managed reference to SBlockNode.">tir::SBlock</a> may not reference variables defined outside the block. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode.">For</a> example, for a block with iter vars &lsquo;vi, vj = T.axis.remap('SS&rsquo;, [i,j])<code>, the statement </code>B[i,j] = A[i,j]<code>would be ill-formed, because it uses the loop variables</code>i<code>and</code>j<code>instead of the block variables</code>vi<code>and </code>vj`.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> to be verified. </td></tr>
    <tr><td class="paramname">assert_mode</td><td>The indicator if it raises an error when the function is not well-formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether it is a well-formed TIR function. </dd></dl>

</div>
</div>
<a id="a1f69889b13455cd290e6b1a6453e3c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f69889b13455cd290e6b1a6453e3c1d">&#9670;&nbsp;</a></span>VisitPrimFuncs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FLambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::VisitPrimFuncs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLambda&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FLambda</td><td>The type of the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">PrimFunc</a> visitor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to be visited </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor to the PrimFuncs in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
