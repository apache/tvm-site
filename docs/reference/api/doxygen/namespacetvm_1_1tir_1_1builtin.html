<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::builtin Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html">builtin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::builtin Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of builtin intrinsics as ops.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad3b90c881b67ebe8e8fe68f14143bb1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1c">TVMStructFieldKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca0b8af30aa268164148d5bfe1d8c2ba54">kArrAddr</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca9076fb1a58386bac2e0f1fdae9cab844">kArrData</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca57f69fd3d141caaa7e2e72fda7d6a1da">kArrShape</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca96e7b6492b5b174219cf60e19af0857c">kArrStrides</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1cad28cfc7b69fd8745e12a4f0024d6942a">kArrNDim</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca5ce842cabb26975681dd561c5132af1b">kArrTypeCode</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca344dc1f419339b81024d4d3628083a1e">kArrTypeBits</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca0c960782c20a4f16cfe203c516760b00">kArrTypeLanes</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1cafdb925cdf50f17a2b96c7ac4faefa1fb">kArrByteOffset</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca9539d6f9103aa0c177cd8cee72c39d74">kArrDeviceId</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1cabf798b873c868b7d77ced30c9907037d">kArrDeviceType</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca4d4a5d54434514fd8b0ce57160059c92">kArrKindBound_</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1ca779c07403e11f671e936ec2813ce2304">kTVMValueContent</a>, 
<a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1caa73457ed97931251f1762cb319adc858">kTVMValueKindBound_</a>
<br />
 }<tr class="memdesc:ad3b90c881b67ebe8e8fe68f14143bb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of structure field info used in intrinsic.  <a href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad3b90c881b67ebe8e8fe68f14143bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae7816fdebd5d56f2145cdf371b756eb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae7816fdebd5d56f2145cdf371b756eb4">ret</a> ()</td></tr>
<tr class="memdesc:ae7816fdebd5d56f2145cdf371b756eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value.  <a href="#ae7816fdebd5d56f2145cdf371b756eb4">More...</a><br /></td></tr>
<tr class="separator:ae7816fdebd5d56f2145cdf371b756eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b555bc5cca2f5e7b26c1037bc0001ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a7b555bc5cca2f5e7b26c1037bc0001ce">reinterpret</a> ()</td></tr>
<tr class="memdesc:a7b555bc5cca2f5e7b26c1037bc0001ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the value using the target type.  <a href="#a7b555bc5cca2f5e7b26c1037bc0001ce">More...</a><br /></td></tr>
<tr class="separator:a7b555bc5cca2f5e7b26c1037bc0001ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d1f0395dca5af4a90cdb42c1d1d154"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a21d1f0395dca5af4a90cdb42c1d1d154">likely</a> ()</td></tr>
<tr class="memdesc:a21d1f0395dca5af4a90cdb42c1d1d154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a condition is likely going to happen.  <a href="#a21d1f0395dca5af4a90cdb42c1d1d154">More...</a><br /></td></tr>
<tr class="separator:a21d1f0395dca5af4a90cdb42c1d1d154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e633f53c50e14d7e2fc07636a223309"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0e633f53c50e14d7e2fc07636a223309">bitwise_and</a> ()</td></tr>
<tr class="memdesc:a0e633f53c50e14d7e2fc07636a223309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and operator.  <a href="#a0e633f53c50e14d7e2fc07636a223309">More...</a><br /></td></tr>
<tr class="separator:a0e633f53c50e14d7e2fc07636a223309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0f4de023bfe86e9510036028ea1580"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a5b0f4de023bfe86e9510036028ea1580">bitwise_or</a> ()</td></tr>
<tr class="memdesc:a5b0f4de023bfe86e9510036028ea1580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or operator.  <a href="#a5b0f4de023bfe86e9510036028ea1580">More...</a><br /></td></tr>
<tr class="separator:a5b0f4de023bfe86e9510036028ea1580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2ac37b80c498ded412572146ecc67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0cd2ac37b80c498ded412572146ecc67">bitwise_xor</a> ()</td></tr>
<tr class="memdesc:a0cd2ac37b80c498ded412572146ecc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor operator.  <a href="#a0cd2ac37b80c498ded412572146ecc67">More...</a><br /></td></tr>
<tr class="separator:a0cd2ac37b80c498ded412572146ecc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ef99dc63f6945588dbb81c968ca15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a091ef99dc63f6945588dbb81c968ca15">bitwise_not</a> ()</td></tr>
<tr class="memdesc:a091ef99dc63f6945588dbb81c968ca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise not operator.  <a href="#a091ef99dc63f6945588dbb81c968ca15">More...</a><br /></td></tr>
<tr class="separator:a091ef99dc63f6945588dbb81c968ca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26472adf05d821f1929cfbc02bc3c231"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a26472adf05d821f1929cfbc02bc3c231">shift_left</a> ()</td></tr>
<tr class="memdesc:a26472adf05d821f1929cfbc02bc3c231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift.  <a href="#a26472adf05d821f1929cfbc02bc3c231">More...</a><br /></td></tr>
<tr class="separator:a26472adf05d821f1929cfbc02bc3c231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af103ae0715d4ebcbaccd49d2b6a12afe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#af103ae0715d4ebcbaccd49d2b6a12afe">shift_right</a> ()</td></tr>
<tr class="memdesc:af103ae0715d4ebcbaccd49d2b6a12afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right shift.  <a href="#af103ae0715d4ebcbaccd49d2b6a12afe">More...</a><br /></td></tr>
<tr class="separator:af103ae0715d4ebcbaccd49d2b6a12afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ae63444ed4e5fcf7247aa93f8bb7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a322ae63444ed4e5fcf7247aa93f8bb7c">large_uint_imm</a> ()</td></tr>
<tr class="memdesc:a322ae63444ed4e5fcf7247aa93f8bb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a322ae63444ed4e5fcf7247aa93f8bb7c">More...</a><br /></td></tr>
<tr class="separator:a322ae63444ed4e5fcf7247aa93f8bb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ebdcec34d7c79dc8480e5dab8547a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0c2ebdcec34d7c79dc8480e5dab8547a">q_multiply_shift</a> ()</td></tr>
<tr class="memdesc:a0c2ebdcec34d7c79dc8480e5dab8547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a multiplication between two Q-numbers x and y followed by a right shift s The default rounding rule is to the nearest value, rounding half up (i.e., round(x.1) = x and round (x.5) = x+1)  <a href="#a0c2ebdcec34d7c79dc8480e5dab8547a">More...</a><br /></td></tr>
<tr class="separator:a0c2ebdcec34d7c79dc8480e5dab8547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700b7018f2c1f1fba8b4e28f264d8bbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a700b7018f2c1f1fba8b4e28f264d8bbb">address_of</a> ()</td></tr>
<tr class="memdesc:a700b7018f2c1f1fba8b4e28f264d8bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of an element in the buffer (see pseudocode below).  <a href="#a700b7018f2c1f1fba8b4e28f264d8bbb">More...</a><br /></td></tr>
<tr class="separator:a700b7018f2c1f1fba8b4e28f264d8bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae741e67259cd4b844a8934f2e2704adc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae741e67259cd4b844a8934f2e2704adc">if_then_else</a> ()</td></tr>
<tr class="memdesc:ae741e67259cd4b844a8934f2e2704adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as select, used for unsafe memory access.  <a href="#ae741e67259cd4b844a8934f2e2704adc">More...</a><br /></td></tr>
<tr class="separator:ae741e67259cd4b844a8934f2e2704adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b0e90771b35d78b6c07c0054abe023"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#aa5b0e90771b35d78b6c07c0054abe023">isnullptr</a> ()</td></tr>
<tr class="memdesc:aa5b0e90771b35d78b6c07c0054abe023"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#aa5b0e90771b35d78b6c07c0054abe023">More...</a><br /></td></tr>
<tr class="separator:aa5b0e90771b35d78b6c07c0054abe023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f53be295396c301082696ca0c113501"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a6f53be295396c301082696ca0c113501">isnan</a> ()</td></tr>
<tr class="memdesc:a6f53be295396c301082696ca0c113501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if value is nan.  <a href="#a6f53be295396c301082696ca0c113501">More...</a><br /></td></tr>
<tr class="separator:a6f53be295396c301082696ca0c113501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2172690dd21d7fd50a4fd4d696ea7bb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a2172690dd21d7fd50a4fd4d696ea7bb2">popcount</a> ()</td></tr>
<tr class="memdesc:a2172690dd21d7fd50a4fd4d696ea7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Popcount.  <a href="#a2172690dd21d7fd50a4fd4d696ea7bb2">More...</a><br /></td></tr>
<tr class="separator:a2172690dd21d7fd50a4fd4d696ea7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15b04fe89f7899e09e528946aa5bb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a1e15b04fe89f7899e09e528946aa5bb4">fma</a> ()</td></tr>
<tr class="memdesc:a1e15b04fe89f7899e09e528946aa5bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fused multiply add.  <a href="#a1e15b04fe89f7899e09e528946aa5bb4">More...</a><br /></td></tr>
<tr class="separator:a1e15b04fe89f7899e09e528946aa5bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668eaad07b6c46238f2bf758e61b58a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a668eaad07b6c46238f2bf758e61b58a5">call_extern</a> ()</td></tr>
<tr class="memdesc:a668eaad07b6c46238f2bf758e61b58a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an extern C function with given name and signature from the types of args in the runtime environment.  <a href="#a668eaad07b6c46238f2bf758e61b58a5">More...</a><br /></td></tr>
<tr class="separator:a668eaad07b6c46238f2bf758e61b58a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2add6e324d391782d367360a68ccf51"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae2add6e324d391782d367360a68ccf51">call_pure_extern</a> ()</td></tr>
<tr class="memdesc:ae2add6e324d391782d367360a68ccf51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an pure extern C function with given name and signature from the types of args in the runtime environment.  <a href="#ae2add6e324d391782d367360a68ccf51">More...</a><br /></td></tr>
<tr class="separator:ae2add6e324d391782d367360a68ccf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83892dca19e44a96752625c65c38d645"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a83892dca19e44a96752625c65c38d645">call_llvm_intrin</a> ()</td></tr>
<tr class="memdesc:a83892dca19e44a96752625c65c38d645"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an LLVM intrinsic with a given intrinsic id and signature from the types of args in the runtime environment.  <a href="#a83892dca19e44a96752625c65c38d645">More...</a><br /></td></tr>
<tr class="separator:a83892dca19e44a96752625c65c38d645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3504415c78f3f8fd719a21e5280b38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a8e3504415c78f3f8fd719a21e5280b38">call_llvm_pure_intrin</a> ()</td></tr>
<tr class="memdesc:a8e3504415c78f3f8fd719a21e5280b38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an LLVM pure intrinsic with a given intrinsic id and signature from the types of args in the runtime environment.  <a href="#a8e3504415c78f3f8fd719a21e5280b38">More...</a><br /></td></tr>
<tr class="separator:a8e3504415c78f3f8fd719a21e5280b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4887bd93ad67619ad290a33e2bdd340"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ac4887bd93ad67619ad290a33e2bdd340">call_spirv_pure_glsl450</a> ()</td></tr>
<tr class="memdesc:ac4887bd93ad67619ad290a33e2bdd340"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an SPIRV pure GLSL450 intrinsic.  <a href="#ac4887bd93ad67619ad290a33e2bdd340">More...</a><br /></td></tr>
<tr class="separator:ac4887bd93ad67619ad290a33e2bdd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f1fc334d2bc830add972895a03f17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a543f1fc334d2bc830add972895a03f17">prefetch</a> ()</td></tr>
<tr class="memdesc:a543f1fc334d2bc830add972895a03f17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Prefetch.html" title="Managed reference to PrefetchNode. ">Prefetch</a> a cacheline.  <a href="#a543f1fc334d2bc830add972895a03f17">More...</a><br /></td></tr>
<tr class="separator:a543f1fc334d2bc830add972895a03f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84c73dbbcf7f97008ac84c169feae9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a3e84c73dbbcf7f97008ac84c169feae9">tvm_access_ptr</a> ()</td></tr>
<tr class="memdesc:a3e84c73dbbcf7f97008ac84c169feae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get head access address with memory access pattern info.  <a href="#a3e84c73dbbcf7f97008ac84c169feae9">More...</a><br /></td></tr>
<tr class="separator:a3e84c73dbbcf7f97008ac84c169feae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeb24a28d19cdc60e4e1fa7b420d7fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a6aeb24a28d19cdc60e4e1fa7b420d7fd">tvm_static_handle</a> ()</td></tr>
<tr class="memdesc:a6aeb24a28d19cdc60e4e1fa7b420d7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function local static handle that iniitalizes to nullptr. can be used to cache function local static resources.  <a href="#a6aeb24a28d19cdc60e4e1fa7b420d7fd">More...</a><br /></td></tr>
<tr class="separator:a6aeb24a28d19cdc60e4e1fa7b420d7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ad8b095dcbefa786394981ea0b71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a21c2ad8b095dcbefa786394981ea0b71">tvm_context_id</a> ()</td></tr>
<tr class="memdesc:a21c2ad8b095dcbefa786394981ea0b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique context id, used for hint of workspace separation. Different context id ganrantees not having overlapping workspace.  <a href="#a21c2ad8b095dcbefa786394981ea0b71">More...</a><br /></td></tr>
<tr class="separator:a21c2ad8b095dcbefa786394981ea0b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424ca353ceedd88a95fc37eeb9628a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ab424ca353ceedd88a95fc37eeb9628a9">tvm_tuple</a> ()</td></tr>
<tr class="memdesc:ab424ca353ceedd88a95fc37eeb9628a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm_tuple is not an actual function and cannot codegen. It is used to represent tuple structure in value field of <a class="el" href="classtvm_1_1tir_1_1AttrStmt.html" title="Managed reference to AttrStmtNode. ">AttrStmt</a>, for the sake of giving hint to optimization.  <a href="#ab424ca353ceedd88a95fc37eeb9628a9">More...</a><br /></td></tr>
<tr class="separator:ab424ca353ceedd88a95fc37eeb9628a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23003bd9331efaa58d8420529ea96c0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a23003bd9331efaa58d8420529ea96c0b">tvm_struct_get</a> ()</td></tr>
<tr class="memdesc:a23003bd9331efaa58d8420529ea96c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a23003bd9331efaa58d8420529ea96c0b">More...</a><br /></td></tr>
<tr class="separator:a23003bd9331efaa58d8420529ea96c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df03eca1d9cc14d0db6cdd39120a867"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a6df03eca1d9cc14d0db6cdd39120a867">tvm_struct_set</a> ()</td></tr>
<tr class="memdesc:a6df03eca1d9cc14d0db6cdd39120a867"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a6df03eca1d9cc14d0db6cdd39120a867">More...</a><br /></td></tr>
<tr class="separator:a6df03eca1d9cc14d0db6cdd39120a867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5125377c482e5b34bf8710b7b3dc1e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#af5125377c482e5b34bf8710b7b3dc1e6">lookup_param</a> ()</td></tr>
<tr class="memdesc:af5125377c482e5b34bf8710b7b3dc1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pseudo code <a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> lookup_param(String param_name) { return __tvm_param__param_name; }.  <a href="#af5125377c482e5b34bf8710b7b3dc1e6">More...</a><br /></td></tr>
<tr class="separator:af5125377c482e5b34bf8710b7b3dc1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92624d2aa5c435cd7a0ea8efb698a115"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a92624d2aa5c435cd7a0ea8efb698a115">tvm_throw_last_error</a> ()</td></tr>
<tr class="memdesc:a92624d2aa5c435cd7a0ea8efb698a115"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a92624d2aa5c435cd7a0ea8efb698a115">More...</a><br /></td></tr>
<tr class="separator:a92624d2aa5c435cd7a0ea8efb698a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5e0e0478e0ebff91690f60992cf3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a15c5e0e0478e0ebff91690f60992cf3f">tvm_stack_alloca</a> ()</td></tr>
<tr class="memdesc:a15c5e0e0478e0ebff91690f60992cf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a15c5e0e0478e0ebff91690f60992cf3f">More...</a><br /></td></tr>
<tr class="separator:a15c5e0e0478e0ebff91690f60992cf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd540cb73407771ecfb4f78722ce5a1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#abd540cb73407771ecfb4f78722ce5a1b">tvm_stack_make_shape</a> ()</td></tr>
<tr class="memdesc:abd540cb73407771ecfb4f78722ce5a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a shape tuple on stack, return the handle.  <a href="#abd540cb73407771ecfb4f78722ce5a1b">More...</a><br /></td></tr>
<tr class="separator:abd540cb73407771ecfb4f78722ce5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f99e6dd767482765b854ee9fc71f2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a28f99e6dd767482765b854ee9fc71f2c">tvm_stack_make_array</a> ()</td></tr>
<tr class="memdesc:a28f99e6dd767482765b854ee9fc71f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a NDArray(DLTensor) on stack, return the handle.  <a href="#a28f99e6dd767482765b854ee9fc71f2c">More...</a><br /></td></tr>
<tr class="separator:a28f99e6dd767482765b854ee9fc71f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c13c6e4b2f92e17f357665f9f11736c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a2c13c6e4b2f92e17f357665f9f11736c">tvm_call_packed</a> ()</td></tr>
<tr class="memdesc:a2c13c6e4b2f92e17f357665f9f11736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a2c13c6e4b2f92e17f357665f9f11736c">More...</a><br /></td></tr>
<tr class="separator:a2c13c6e4b2f92e17f357665f9f11736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e35988d61914016c49d3cf8a5af3f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a1e35988d61914016c49d3cf8a5af3f54">tvm_call_cpacked</a> ()</td></tr>
<tr class="memdesc:a1e35988d61914016c49d3cf8a5af3f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#a1e35988d61914016c49d3cf8a5af3f54">More...</a><br /></td></tr>
<tr class="separator:a1e35988d61914016c49d3cf8a5af3f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54288cc9f1fee8c26db9bd87ac320ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ac54288cc9f1fee8c26db9bd87ac320ee">tvm_call_trace_packed</a> ()</td></tr>
<tr class="memdesc:ac54288cc9f1fee8c26db9bd87ac320ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#ac54288cc9f1fee8c26db9bd87ac320ee">More...</a><br /></td></tr>
<tr class="separator:ac54288cc9f1fee8c26db9bd87ac320ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23897d81faa46ac29ab0d6d8fc618707"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a23897d81faa46ac29ab0d6d8fc618707">tvm_check_return</a> ()</td></tr>
<tr class="memdesc:a23897d81faa46ac29ab0d6d8fc618707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the return value of another call is correct or returns a given value.  <a href="#a23897d81faa46ac29ab0d6d8fc618707">More...</a><br /></td></tr>
<tr class="separator:a23897d81faa46ac29ab0d6d8fc618707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be181be34fba13d129aadc6c9a23f73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a6be181be34fba13d129aadc6c9a23f73">tvm_thread_context</a> ()</td></tr>
<tr class="memdesc:a6be181be34fba13d129aadc6c9a23f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code Mark the content as thread local context, can get optimized by only call the call once at thread start.  <a href="#a6be181be34fba13d129aadc6c9a23f73">More...</a><br /></td></tr>
<tr class="separator:a6be181be34fba13d129aadc6c9a23f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0117a4a76af962576a6a3bbf32f97b36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0117a4a76af962576a6a3bbf32f97b36">tvm_call_packed_lowered</a> ()</td></tr>
<tr class="memdesc:a0117a4a76af962576a6a3bbf32f97b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowered version of call packed, the space of value and type codes are explicitly allocated.  <a href="#a0117a4a76af962576a6a3bbf32f97b36">More...</a><br /></td></tr>
<tr class="separator:a0117a4a76af962576a6a3bbf32f97b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131992ea9acd964fb7d3ca782d74805"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a3131992ea9acd964fb7d3ca782d74805">tvm_call_cpacked_lowered</a> ()</td></tr>
<tr class="memdesc:a3131992ea9acd964fb7d3ca782d74805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowered version of call c-packed, the space of value and type codes are explicitly allocated.  <a href="#a3131992ea9acd964fb7d3ca782d74805">More...</a><br /></td></tr>
<tr class="separator:a3131992ea9acd964fb7d3ca782d74805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e23eac98abb8378b9837011a5c04b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#aa6e23eac98abb8378b9837011a5c04b5">tvm_call_trace_packed_lowered</a> ()</td></tr>
<tr class="memdesc:aa6e23eac98abb8378b9837011a5c04b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowered version of trace intrinsic, the space of value and type codes are explicitly allocated. The return value is the (end - 1) value on the stack.  <a href="#aa6e23eac98abb8378b9837011a5c04b5">More...</a><br /></td></tr>
<tr class="separator:aa6e23eac98abb8378b9837011a5c04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925a45e5bb05e0cbf2daf2ffdbdcf53a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a925a45e5bb05e0cbf2daf2ffdbdcf53a">tvm_storage_sync</a> ()</td></tr>
<tr class="memdesc:a925a45e5bb05e0cbf2daf2ffdbdcf53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pseudo code.  <a href="#a925a45e5bb05e0cbf2daf2ffdbdcf53a">More...</a><br /></td></tr>
<tr class="separator:a925a45e5bb05e0cbf2daf2ffdbdcf53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44a85c87273dfab1731421f4edd2bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#aca44a85c87273dfab1731421f4edd2bf">tvm_warp_shuffle</a> ()</td></tr>
<tr class="memdesc:aca44a85c87273dfab1731421f4edd2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pseudo code.  <a href="#aca44a85c87273dfab1731421f4edd2bf">More...</a><br /></td></tr>
<tr class="separator:aca44a85c87273dfab1731421f4edd2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0470bd69bb03047aae4cb52e1e6e337"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae0470bd69bb03047aae4cb52e1e6e337">tvm_warp_shuffle_up</a> ()</td></tr>
<tr class="separator:ae0470bd69bb03047aae4cb52e1e6e337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1c48570e10287683d58f22e4de98f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#af6d1c48570e10287683d58f22e4de98f">tvm_warp_shuffle_down</a> ()</td></tr>
<tr class="separator:af6d1c48570e10287683d58f22e4de98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4086a245ded9076de226ae802ced32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#afc4086a245ded9076de226ae802ced32">tvm_warp_activemask</a> ()</td></tr>
<tr class="separator:afc4086a245ded9076de226ae802ced32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7bc86b8fa81453291ae5299062001"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ac8e7bc86b8fa81453291ae5299062001">tvm_global_barrier_kinit</a> ()</td></tr>
<tr class="memdesc:ac8e7bc86b8fa81453291ae5299062001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global barrier. <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> this at beginning of kernel that need global barrier.  <a href="#ac8e7bc86b8fa81453291ae5299062001">More...</a><br /></td></tr>
<tr class="separator:ac8e7bc86b8fa81453291ae5299062001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d19e758595200998a4e1ea39767b6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#aa1d19e758595200998a4e1ea39767b6b">tvm_thread_allreduce</a> ()</td></tr>
<tr class="memdesc:aa1d19e758595200998a4e1ea39767b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See pesudo code.  <a href="#aa1d19e758595200998a4e1ea39767b6b">More...</a><br /></td></tr>
<tr class="separator:aa1d19e758595200998a4e1ea39767b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b4dd000c31a1d35f493786380d108d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a93b4dd000c31a1d35f493786380d108d">tvm_load_matrix_sync</a> ()</td></tr>
<tr class="memdesc:a93b4dd000c31a1d35f493786380d108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core load operators.  <a href="#a93b4dd000c31a1d35f493786380d108d">More...</a><br /></td></tr>
<tr class="separator:a93b4dd000c31a1d35f493786380d108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbd267877168afd5bbea35f0e5d70fe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0cbd267877168afd5bbea35f0e5d70fe">tvm_mma_sync</a> ()</td></tr>
<tr class="memdesc:a0cbd267877168afd5bbea35f0e5d70fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core mma_sync operators.  <a href="#a0cbd267877168afd5bbea35f0e5d70fe">More...</a><br /></td></tr>
<tr class="separator:a0cbd267877168afd5bbea35f0e5d70fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5e173f1a16740172a9ad6f2aa85a08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a8d5e173f1a16740172a9ad6f2aa85a08">tvm_bmma_sync</a> ()</td></tr>
<tr class="memdesc:a8d5e173f1a16740172a9ad6f2aa85a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core bmma_sync operators.  <a href="#a8d5e173f1a16740172a9ad6f2aa85a08">More...</a><br /></td></tr>
<tr class="separator:a8d5e173f1a16740172a9ad6f2aa85a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616992eb291d701cac42c670d83c206c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a616992eb291d701cac42c670d83c206c">tvm_fill_fragment</a> ()</td></tr>
<tr class="memdesc:a616992eb291d701cac42c670d83c206c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core fill_fragment operators.  <a href="#a616992eb291d701cac42c670d83c206c">More...</a><br /></td></tr>
<tr class="separator:a616992eb291d701cac42c670d83c206c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc81da8cbcd7f34ec5e1e80d837ca265"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#afc81da8cbcd7f34ec5e1e80d837ca265">tvm_store_matrix_sync</a> ()</td></tr>
<tr class="memdesc:afc81da8cbcd7f34ec5e1e80d837ca265"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for tensor core store operators.  <a href="#afc81da8cbcd7f34ec5e1e80d837ca265">More...</a><br /></td></tr>
<tr class="separator:afc81da8cbcd7f34ec5e1e80d837ca265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99599849e8572bcd46e22636f908fca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad99599849e8572bcd46e22636f908fca">ptx_mma</a> ()</td></tr>
<tr class="memdesc:ad99599849e8572bcd46e22636f908fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for ptx tensor core mma instructions.  <a href="#ad99599849e8572bcd46e22636f908fca">More...</a><br /></td></tr>
<tr class="separator:ad99599849e8572bcd46e22636f908fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3343bb32988cda13d3050e8fc2a75a78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a3343bb32988cda13d3050e8fc2a75a78">ptx_mma_sp</a> ()</td></tr>
<tr class="memdesc:a3343bb32988cda13d3050e8fc2a75a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for sparse tensor core ptx instructions.  <a href="#a3343bb32988cda13d3050e8fc2a75a78">More...</a><br /></td></tr>
<tr class="separator:a3343bb32988cda13d3050e8fc2a75a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79143f4df15683d7ee25c0b958e2189"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae79143f4df15683d7ee25c0b958e2189">ptx_ldmatrix</a> ()</td></tr>
<tr class="memdesc:ae79143f4df15683d7ee25c0b958e2189"><td class="mdescLeft">&#160;</td><td class="mdescRight">tvm intrinsic for ptx load matrix from shared memory.  <a href="#ae79143f4df15683d7ee25c0b958e2189">More...</a><br /></td></tr>
<tr class="separator:ae79143f4df15683d7ee25c0b958e2189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bf65ca7ca01d2016e0b609117d7e25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a45bf65ca7ca01d2016e0b609117d7e25">vectorhigh</a> ()</td></tr>
<tr class="memdesc:a45bf65ca7ca01d2016e0b609117d7e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the high level half of the vector.  <a href="#a45bf65ca7ca01d2016e0b609117d7e25">More...</a><br /></td></tr>
<tr class="separator:a45bf65ca7ca01d2016e0b609117d7e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed64a9fb0a7f575fc63e1e0395e96a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a7ed64a9fb0a7f575fc63e1e0395e96a6">vectorlow</a> ()</td></tr>
<tr class="memdesc:a7ed64a9fb0a7f575fc63e1e0395e96a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the low-level half of the vector.  <a href="#a7ed64a9fb0a7f575fc63e1e0395e96a6">More...</a><br /></td></tr>
<tr class="separator:a7ed64a9fb0a7f575fc63e1e0395e96a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dff65bc2c142b57fae7f60e378ff43"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a30dff65bc2c142b57fae7f60e378ff43">vectorcombine</a> ()</td></tr>
<tr class="memdesc:a30dff65bc2c142b57fae7f60e378ff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concat two vectors.  <a href="#a30dff65bc2c142b57fae7f60e378ff43">More...</a><br /></td></tr>
<tr class="separator:a30dff65bc2c142b57fae7f60e378ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a648f6e7451af295688f243a215cd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ab4a648f6e7451af295688f243a215cd7">atomic_add</a> ()</td></tr>
<tr class="memdesc:ab4a648f6e7451af295688f243a215cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">atomic add instruction, corresponding e.g. to atomicAdd in CUDA  <a href="#ab4a648f6e7451af295688f243a215cd7">More...</a><br /></td></tr>
<tr class="separator:ab4a648f6e7451af295688f243a215cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9603510b7eff067c253eb340310c2996"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a9603510b7eff067c253eb340310c2996">nd_mem_alloc_with_scope</a> ()</td></tr>
<tr class="memdesc:a9603510b7eff067c253eb340310c2996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Nd memory allocation with storage scope.  <a href="#a9603510b7eff067c253eb340310c2996">More...</a><br /></td></tr>
<tr class="separator:a9603510b7eff067c253eb340310c2996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea87b06a1eb1050b7503ef6cc1bab34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a6ea87b06a1eb1050b7503ef6cc1bab34">texture2d_store</a> ()</td></tr>
<tr class="memdesc:a6ea87b06a1eb1050b7503ef6cc1bab34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> to texture 2d memory.  <a href="#a6ea87b06a1eb1050b7503ef6cc1bab34">More...</a><br /></td></tr>
<tr class="separator:a6ea87b06a1eb1050b7503ef6cc1bab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52feb3e7828262a1b8a31062642ae36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ae52feb3e7828262a1b8a31062642ae36">texture2d_load</a> ()</td></tr>
<tr class="memdesc:ae52feb3e7828262a1b8a31062642ae36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> from texture 2d memory.  <a href="#ae52feb3e7828262a1b8a31062642ae36">More...</a><br /></td></tr>
<tr class="separator:ae52feb3e7828262a1b8a31062642ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee850e8e98b29fbcc8f269f5136e92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1Op.html">Op</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a0aee850e8e98b29fbcc8f269f5136e92">mem_copy</a> ()</td></tr>
<tr class="memdesc:a0aee850e8e98b29fbcc8f269f5136e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy 1d memory from source to destination Same semantics as memcpy(destination, source, size) Allows for device specific implementations e.g. direct memory access (DMA)  <a href="#a0aee850e8e98b29fbcc8f269f5136e92">More...</a><br /></td></tr>
<tr class="separator:a0aee850e8e98b29fbcc8f269f5136e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of builtin intrinsics as ops. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad3b90c881b67ebe8e8fe68f14143bb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b90c881b67ebe8e8fe68f14143bb1c">&#9670;&nbsp;</a></span>TVMStructFieldKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1c">tvm::tir::builtin::TVMStructFieldKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of structure field info used in intrinsic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca0b8af30aa268164148d5bfe1d8c2ba54"></a>kArrAddr&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca9076fb1a58386bac2e0f1fdae9cab844"></a>kArrData&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca57f69fd3d141caaa7e2e72fda7d6a1da"></a>kArrShape&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca96e7b6492b5b174219cf60e19af0857c"></a>kArrStrides&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1cad28cfc7b69fd8745e12a4f0024d6942a"></a>kArrNDim&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca5ce842cabb26975681dd561c5132af1b"></a>kArrTypeCode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca344dc1f419339b81024d4d3628083a1e"></a>kArrTypeBits&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca0c960782c20a4f16cfe203c516760b00"></a>kArrTypeLanes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1cafdb925cdf50f17a2b96c7ac4faefa1fb"></a>kArrByteOffset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca9539d6f9103aa0c177cd8cee72c39d74"></a>kArrDeviceId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1cabf798b873c868b7d77ced30c9907037d"></a>kArrDeviceType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca4d4a5d54434514fd8b0ce57160059c92"></a>kArrKindBound_&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1ca779c07403e11f671e936ec2813ce2304"></a>kTVMValueContent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad3b90c881b67ebe8e8fe68f14143bb1caa73457ed97931251f1762cb319adc858"></a>kTVMValueKindBound_&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a700b7018f2c1f1fba8b4e28f264d8bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700b7018f2c1f1fba8b4e28f264d8bbb">&#9670;&nbsp;</a></span>address_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::address_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of an element in the buffer (see pseudocode below). </p>
<p>The number of indices should match the dimensionality of the buffer being accessed. If this operation occurs after buffer flattening, the number of indices must be supported by the target (i.e. N&gt;1 only on targets that support non-flat memory buffers).</p>
<p>Handle address_of(BufferLoad *op) { return &amp;op-&gt;buffer_var[op-&gt;indices[0], op-&gt;indices[1], ..., op-&gt;indices[N-1]]; } </p>

</div>
</div>
<a id="ab4a648f6e7451af295688f243a215cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a648f6e7451af295688f243a215cd7">&#9670;&nbsp;</a></span>atomic_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::atomic_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>atomic add instruction, corresponding e.g. to atomicAdd in CUDA </p>

</div>
</div>
<a id="a0e633f53c50e14d7e2fc07636a223309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e633f53c50e14d7e2fc07636a223309">&#9670;&nbsp;</a></span>bitwise_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::bitwise_and </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise and operator. </p>

</div>
</div>
<a id="a091ef99dc63f6945588dbb81c968ca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091ef99dc63f6945588dbb81c968ca15">&#9670;&nbsp;</a></span>bitwise_not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::bitwise_not </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise not operator. </p>

</div>
</div>
<a id="a5b0f4de023bfe86e9510036028ea1580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0f4de023bfe86e9510036028ea1580">&#9670;&nbsp;</a></span>bitwise_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::bitwise_or </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise or operator. </p>

</div>
</div>
<a id="a0cd2ac37b80c498ded412572146ecc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd2ac37b80c498ded412572146ecc67">&#9670;&nbsp;</a></span>bitwise_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::bitwise_xor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise xor operator. </p>

</div>
</div>
<a id="a668eaad07b6c46238f2bf758e61b58a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668eaad07b6c46238f2bf758e61b58a5">&#9670;&nbsp;</a></span>call_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::call_extern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an extern C function with given name and signature from the types of args in the runtime environment. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> call_extern(name, args...) { return dlsym(name)(args...); }</p>
<dl class="section note"><dt>Note</dt><dd>This intrinsic does not provide any type checking, and is main used for backward compatibility reasons. Always consider use pre-registered and typed <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">tvm::Op</a> first. </dd></dl>

</div>
</div>
<a id="a83892dca19e44a96752625c65c38d645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83892dca19e44a96752625c65c38d645">&#9670;&nbsp;</a></span>call_llvm_intrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::call_llvm_intrin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an LLVM intrinsic with a given intrinsic id and signature from the types of args in the runtime environment. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> call_llvm_pure_intrin(intrin_id, args...) { return dlsym(name)(args...); }</p>
<dl class="section note"><dt>Note</dt><dd>This op does not provide any type checking. </dd></dl>

</div>
</div>
<a id="a8e3504415c78f3f8fd719a21e5280b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3504415c78f3f8fd719a21e5280b38">&#9670;&nbsp;</a></span>call_llvm_pure_intrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::call_llvm_pure_intrin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an LLVM pure intrinsic with a given intrinsic id and signature from the types of args in the runtime environment. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> call_llvm_pure_intrin(intrin_id, args...) { return dlsym(name)(args...); }</p>
<dl class="section note"><dt>Note</dt><dd>This op does not provide any type checking. </dd></dl>

</div>
</div>
<a id="ae2add6e324d391782d367360a68ccf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2add6e324d391782d367360a68ccf51">&#9670;&nbsp;</a></span>call_pure_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::call_pure_extern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an pure extern C function with given name and signature from the types of args in the runtime environment. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> call_pure_extern(name, args...) { return dlsym(name)(args...); }</p>
<dl class="section note"><dt>Note</dt><dd>This intrinsic does not provide any type checking, and is main used for backward compatibility reasons. Always consider use pre-registered and typed <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">tvm::Op</a> first. </dd></dl>

</div>
</div>
<a id="ac4887bd93ad67619ad290a33e2bdd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4887bd93ad67619ad290a33e2bdd340">&#9670;&nbsp;</a></span>call_spirv_pure_glsl450()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::call_spirv_pure_glsl450 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> an SPIRV pure GLSL450 intrinsic. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> call_spirv_pure_glsl450(intrin_id, args...) { return dlsym(name)(args...); }</p>
<dl class="section note"><dt>Note</dt><dd>This op does not provide any type checking. </dd></dl>

</div>
</div>
<a id="a1e15b04fe89f7899e09e528946aa5bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e15b04fe89f7899e09e528946aa5bb4">&#9670;&nbsp;</a></span>fma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::fma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fused multiply add. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> fma(a, b, c) { return a * b + c; } </p>

</div>
</div>
<a id="ae741e67259cd4b844a8934f2e2704adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae741e67259cd4b844a8934f2e2704adc">&#9670;&nbsp;</a></span>if_then_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::if_then_else </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as select, used for unsafe memory access. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_if_then_else(cond, a, b) { return cond ? a : b; } </p>

</div>
</div>
<a id="a6f53be295396c301082696ca0c113501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f53be295396c301082696ca0c113501">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::isnan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if value is nan. </p>

</div>
</div>
<a id="aa5b0e90771b35d78b6c07c0054abe023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b0e90771b35d78b6c07c0054abe023">&#9670;&nbsp;</a></span>isnullptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::isnullptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>bool isnullptr(void* handle) { return handle == nullptr } </p>

</div>
</div>
<a id="a322ae63444ed4e5fcf7247aa93f8bb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322ae63444ed4e5fcf7247aa93f8bb7c">&#9670;&nbsp;</a></span>large_uint_imm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::large_uint_imm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>Construct a big uint that may not be representable by int64</p>
<p>Expr large_uint_imm(uint32_t v0, uin32_t v1) { return (v1 &lt;&lt; 32) | v0; } </p>

</div>
</div>
<a id="a21d1f0395dca5af4a90cdb42c1d1d154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d1f0395dca5af4a90cdb42c1d1d154">&#9670;&nbsp;</a></span>likely()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::likely </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a condition is likely going to happen. </p>

</div>
</div>
<a id="af5125377c482e5b34bf8710b7b3dc1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5125377c482e5b34bf8710b7b3dc1e6">&#9670;&nbsp;</a></span>lookup_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::lookup_param </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pseudo code <a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> lookup_param(String param_name) { return __tvm_param__param_name; }. </p>

</div>
</div>
<a id="a0aee850e8e98b29fbcc8f269f5136e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee850e8e98b29fbcc8f269f5136e92">&#9670;&nbsp;</a></span>mem_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::mem_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy 1d memory from source to destination Same semantics as memcpy(destination, source, size) Allows for device specific implementations e.g. direct memory access (DMA) </p>

</div>
</div>
<a id="a9603510b7eff067c253eb340310c2996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9603510b7eff067c253eb340310c2996">&#9670;&nbsp;</a></span>nd_mem_alloc_with_scope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::nd_mem_alloc_with_scope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Nd memory allocation with storage scope. </p>

</div>
</div>
<a id="a2172690dd21d7fd50a4fd4d696ea7bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2172690dd21d7fd50a4fd4d696ea7bb2">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::popcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Popcount. </p>

</div>
</div>
<a id="a543f1fc334d2bc830add972895a03f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f1fc334d2bc830add972895a03f17">&#9670;&nbsp;</a></span>prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::prefetch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Prefetch.html" title="Managed reference to PrefetchNode. ">Prefetch</a> a cacheline. </p>

</div>
</div>
<a id="ae79143f4df15683d7ee25c0b958e2189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79143f4df15683d7ee25c0b958e2189">&#9670;&nbsp;</a></span>ptx_ldmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::ptx_ldmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for ptx load matrix from shared memory. </p>
<p>void ptx_ldmatrix(<a class="el" href="classtvm_1_1Bool.html" title="Boolean constant. ">Bool</a> trans, <a class="el" href="classtvm_1_1IntImm.html" title="Managed reference class to IntImmNode. ">IntImm</a> num, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> type, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> local_ptr, Expr local_offset, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> smem_ptr, Expr smem_offset); </p>

</div>
</div>
<a id="ad99599849e8572bcd46e22636f908fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99599849e8572bcd46e22636f908fca">&#9670;&nbsp;</a></span>ptx_mma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::ptx_mma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for ptx tensor core mma instructions. </p>
<p>void ptx_mma(<a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> shape, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> A_layout, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> B_layout, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> A_dtype, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> B_dtype, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> C_dtype, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> multiplicand_a, Expr a_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> multiplicand_b, Expr b_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> accumulator, Expr c_index, bool saturate); </p>

</div>
</div>
<a id="a3343bb32988cda13d3050e8fc2a75a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3343bb32988cda13d3050e8fc2a75a78">&#9670;&nbsp;</a></span>ptx_mma_sp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::ptx_mma_sp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for sparse tensor core ptx instructions. </p>
<p>void ptx_mma_sp(<a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> shape, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> A_layout, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> B_layout, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> A_dtype, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> B_dtype, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> C_dtype, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> multiplicand_a, Expr a_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> multiplicand_b, Expr b_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> accumulator, Expr c_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> metadata, Expr meta_index, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> sparse_selector, bool saturate); </p>

</div>
</div>
<a id="a0c2ebdcec34d7c79dc8480e5dab8547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2ebdcec34d7c79dc8480e5dab8547a">&#9670;&nbsp;</a></span>q_multiply_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::q_multiply_shift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a multiplication between two Q-numbers x and y followed by a right shift s The default rounding rule is to the nearest value, rounding half up (i.e., round(x.1) = x and round (x.5) = x+1) </p>

</div>
</div>
<a id="a7b555bc5cca2f5e7b26c1037bc0001ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b555bc5cca2f5e7b26c1037bc0001ce">&#9670;&nbsp;</a></span>reinterpret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::reinterpret </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinterpret the value using the target type. </p>

</div>
</div>
<a id="ae7816fdebd5d56f2145cdf371b756eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7816fdebd5d56f2145cdf371b756eb4">&#9670;&nbsp;</a></span>ret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::ret </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value. </p>

</div>
</div>
<a id="a26472adf05d821f1929cfbc02bc3c231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26472adf05d821f1929cfbc02bc3c231">&#9670;&nbsp;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::shift_left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left shift. </p>

</div>
</div>
<a id="af103ae0715d4ebcbaccd49d2b6a12afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af103ae0715d4ebcbaccd49d2b6a12afe">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::shift_right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right shift. </p>

</div>
</div>
<a id="ae52feb3e7828262a1b8a31062642ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52feb3e7828262a1b8a31062642ae36">&#9670;&nbsp;</a></span>texture2d_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::texture2d_load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> from texture 2d memory. </p>

</div>
</div>
<a id="a6ea87b06a1eb1050b7503ef6cc1bab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea87b06a1eb1050b7503ef6cc1bab34">&#9670;&nbsp;</a></span>texture2d_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::texture2d_store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> to texture 2d memory. </p>

</div>
</div>
<a id="a3e84c73dbbcf7f97008ac84c169feae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84c73dbbcf7f97008ac84c169feae9">&#9670;&nbsp;</a></span>tvm_access_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_access_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get head access address with memory access pattern info. </p>
<p>This operator also marks range of the memory access The offset and extent are in unit of the DType(including vectorization factor). rw_mask is a bit_mask setting whether the access is a read(1) or write(2). The access is assume to happen in the current expression.</p>
<p>PtrType tvm_access_ptr(Expr dtype, DType* data, int offset, int extent, int rw_mask) { // DType == dtype.type(); return &amp;data[offset]; } </p>

</div>
</div>
<a id="a8d5e173f1a16740172a9ad6f2aa85a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5e173f1a16740172a9ad6f2aa85a08">&#9670;&nbsp;</a></span>tvm_bmma_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_bmma_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core bmma_sync operators. </p>
<p>void tvm_bmma_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_d, Expr index_d, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_a, Expr index_a, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_b, Expr index_b, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_c, Expr index_c) { nvcuda::wmma::bmma_sync(fragment_d[index_d], fragment_a[index_a], fragment_b[index_b], fragment_c[index_c]); } </p>

</div>
</div>
<a id="a1e35988d61914016c49d3cf8a5af3f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e35988d61914016c49d3cf8a5af3f54">&#9670;&nbsp;</a></span>tvm_call_cpacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_cpacked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>return_type tvm_call_packed(fname, TVMValue* args) { int ret_code; <a class="el" href="unionTVMValue.html" title="Union type of values being passed through API and function calls. ">TVMValue</a> ret_value; (*fname)(args, type_code_of(args), len(args), &amp;ret_value, &amp;ret_code); return cast(return_type, ret_value.v_return_type); } </p>

</div>
</div>
<a id="a3131992ea9acd964fb7d3ca782d74805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131992ea9acd964fb7d3ca782d74805">&#9670;&nbsp;</a></span>tvm_call_cpacked_lowered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_cpacked_lowered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowered version of call c-packed, the space of value and type codes are explicitly allocated. </p>
<p>int tvm_call_packed_lowered(fname, TVMValue* value_stack, int* tcode_stack, int begin, int end) { fname(<a class="el" href="structTVMArgs.html">TVMArgs(value_stack[begin:end], tcode_stack[begin:end])</a>, TVMRetValue(value_stack + end, tcode_stack + end)); } </p>

</div>
</div>
<a id="a2c13c6e4b2f92e17f357665f9f11736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c13c6e4b2f92e17f357665f9f11736c">&#9670;&nbsp;</a></span>tvm_call_packed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_packed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>return_type tvm_call_packed(name, TVMValue* args) { <a class="el" href="unionTVMValue.html" title="Union type of values being passed through API and function calls. ">TVMValue</a> ret_value; int ret_code; ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); (*f)(args, type_code_of(args), len(args), &amp;ret_value, &amp;ret_code); // return type can be int, float, handle. return cast(return_type, ret_value.v_return_type); } </p>

</div>
</div>
<a id="a0117a4a76af962576a6a3bbf32f97b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0117a4a76af962576a6a3bbf32f97b36">&#9670;&nbsp;</a></span>tvm_call_packed_lowered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_packed_lowered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowered version of call packed, the space of value and type codes are explicitly allocated. </p>
<p>return_type tvm_call_packed_lowered(name, TVMValue* value_stack, int* tcode_stack, int begin, int end) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); f-&gt;CallPacked(<a class="el" href="structTVMArgs.html">TVMArgs</a>(value_stack[begin:end], tcode_stack[begin:end]), TVMRetValue(value_stack + end, tcode_stack + end)); // return type can be int, float, handle. return cast(return_type, load_return_from(tcode_stack + end)) } </p>

</div>
</div>
<a id="ac54288cc9f1fee8c26db9bd87ac320ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54288cc9f1fee8c26db9bd87ac320ee">&#9670;&nbsp;</a></span>tvm_call_trace_packed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_trace_packed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>return_type tvm_call_trace_packed(name, TVMValue* args) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); (*f)(args, type_code_of(args), len(args)); // return type can be int, float, handle. return cast(return_type, ret_value.v_return_type); } </p>

</div>
</div>
<a id="aa6e23eac98abb8378b9837011a5c04b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e23eac98abb8378b9837011a5c04b5">&#9670;&nbsp;</a></span>tvm_call_trace_packed_lowered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_call_trace_packed_lowered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowered version of trace intrinsic, the space of value and type codes are explicitly allocated. The return value is the (end - 1) value on the stack. </p>
<p>return_type tvm_call_trace_packed_lowered(name, TVMValue* value_stack, int* tcode_stack, int begin, int end) { ModuleNode* env = GetCurrentEnv(); const PackedFunc* f = env-&gt;GetFuncFromEnv(name); f-&gt;CallPacked(<a class="el" href="structTVMArgs.html">TVMArgs</a>(value_stack[begin:end], tcode_stack[begin:end]), TVMRetValue(value_stack + end, tcode_stack + end)); // return type can be int, float, handle. return cast(return_type, load_return_from(tcode_stack + end)) } </p>

</div>
</div>
<a id="a23897d81faa46ac29ab0d6d8fc618707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23897d81faa46ac29ab0d6d8fc618707">&#9670;&nbsp;</a></span>tvm_check_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_check_return </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the return value of another call is correct or returns a given value. </p>
<dl class="section note"><dt>Note</dt><dd>This is meant to serve a specific case for AOT code generator whilst this cannot be fully represented in TIR.</dd></dl>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_check_return(expected, return_unexpected, nested_call) { if (nested_call() != expected) { return return_unexpected; } } </p>

</div>
</div>
<a id="a21c2ad8b095dcbefa786394981ea0b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c2ad8b095dcbefa786394981ea0b71">&#9670;&nbsp;</a></span>tvm_context_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_context_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a unique context id, used for hint of workspace separation. Different context id ganrantees not having overlapping workspace. </p>

</div>
</div>
<a id="a616992eb291d701cac42c670d83c206c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616992eb291d701cac42c670d83c206c">&#9670;&nbsp;</a></span>tvm_fill_fragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_fill_fragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core fill_fragment operators. </p>
<p>void tvm_fill_fragment(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr value) { // m, n, k are the shape of wmma fragment // fragments must be in 'wmma.accumulator' scope. nvcuda::wmma::fill_fragment(fragment[index], value); } </p>

</div>
</div>
<a id="ac8e7bc86b8fa81453291ae5299062001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7bc86b8fa81453291ae5299062001">&#9670;&nbsp;</a></span>tvm_global_barrier_kinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_global_barrier_kinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global barrier. <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> this at beginning of kernel that need global barrier. </p>

</div>
</div>
<a id="a93b4dd000c31a1d35f493786380d108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b4dd000c31a1d35f493786380d108d">&#9670;&nbsp;</a></span>tvm_load_matrix_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_load_matrix_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core load operators. </p>
<p>void tvm_load_matrix_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr buffer_ptr, Expr stride, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> layout) { // m, n, k are the shape of wmma fragment. // Determine fragment layout(column-major or row major) by layout. // fragments must be in 'wmma.matrix_a' or 'wmma.matrix_b' scope. nvcuda::wmma::load_matrix_sync(fragment[index], buffer_ptr, stride); } </p>

</div>
</div>
<a id="a0cbd267877168afd5bbea35f0e5d70fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbd267877168afd5bbea35f0e5d70fe">&#9670;&nbsp;</a></span>tvm_mma_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_mma_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core mma_sync operators. </p>
<p>void tvm_mma_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_d, Expr index_d, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_a, Expr index_a, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_b, Expr index_b, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment_c, Expr index_c) { nvcuda::wmma::mma_sync(fragment_d[index_d], fragment_a[index_a], fragment_b[index_b], fragment_c[index_c]); } </p>

</div>
</div>
<a id="a15c5e0e0478e0ebff91690f60992cf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c5e0e0478e0ebff91690f60992cf3f">&#9670;&nbsp;</a></span>tvm_stack_alloca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_stack_alloca </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>dtype in {shape, array, arg_value, arg_tcode}</p>
<p>Handle tvm_stack_alloca(string dtype, int num) { return new on stack dtype[num]; } </p>

</div>
</div>
<a id="a28f99e6dd767482765b854ee9fc71f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f99e6dd767482765b854ee9fc71f2c">&#9670;&nbsp;</a></span>tvm_stack_make_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_stack_make_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a NDArray(DLTensor) on stack, return the handle. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_stack_make_array(Expr data, Expr shape, Expr strides, Expr ndim, Expr dtype, Expr elem_offset) { ret = alloca stack DLTensor(); ret-&gt;data = data; ret-&gt;shape = shape; ret-&gt;strides = strides != 0 ? strides : nullptr; ret-&gt;ndim = ndim; ret-&gt;dtype = dtype.type(); ret-&gt;byte_offset = elem_offset * sizeof(dtype); return ret; } </p>

</div>
</div>
<a id="abd540cb73407771ecfb4f78722ce5a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd540cb73407771ecfb4f78722ce5a1b">&#9670;&nbsp;</a></span>tvm_stack_make_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_stack_make_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a shape tuple on stack, return the handle. </p>
<p>Handle tvm_stack_make_shape(list args) { ret = alloca stack int64_t[len(args)]; for i in range(len(args)): ret[i] = args[i] return &amp;ret[0]; } </p>

</div>
</div>
<a id="a6aeb24a28d19cdc60e4e1fa7b420d7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aeb24a28d19cdc60e4e1fa7b420d7fd">&#9670;&nbsp;</a></span>tvm_static_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_static_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function local static handle that iniitalizes to nullptr. can be used to cache function local static resources. </p>

</div>
</div>
<a id="a925a45e5bb05e0cbf2daf2ffdbdcf53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925a45e5bb05e0cbf2daf2ffdbdcf53a">&#9670;&nbsp;</a></span>tvm_storage_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_storage_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pseudo code. </p>
<p>int tvm_storage_sync(std::string storage_scope) { __sync(storage_scope); return 0; } </p>

</div>
</div>
<a id="afc81da8cbcd7f34ec5e1e80d837ca265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc81da8cbcd7f34ec5e1e80d837ca265">&#9670;&nbsp;</a></span>tvm_store_matrix_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_store_matrix_sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm intrinsic for tensor core store operators. </p>
<p>void tvm_store_matrix_sync(<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> fragment, UIntImm m, UIntImm, n, UIntImm k, Expr index, Expr buffer_ptr, Expr stride, <a class="el" href="classtvm_1_1tir_1_1StringImm.html" title="Managed reference to StringImmNode. ">StringImm</a> layout) { // m, n, k are the shape of wmma fragment // fragments must be in 'wmma.accumulator' scope. nvcuda::wmma::store_matrix_sync(fragment[index], buffer_ptr, stride, layout); } </p>

</div>
</div>
<a id="a23003bd9331efaa58d8420529ea96c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23003bd9331efaa58d8420529ea96c0b">&#9670;&nbsp;</a></span>tvm_struct_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_struct_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_struct_get(StructType* arr, int index, int field_id) { return arr[index]-&gt;field; } </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1c" title="The kind of structure field info used in intrinsic. ">TVMStructFieldKind</a> </dd></dl>

</div>
</div>
<a id="a6df03eca1d9cc14d0db6cdd39120a867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df03eca1d9cc14d0db6cdd39120a867">&#9670;&nbsp;</a></span>tvm_struct_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_struct_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>Handle tvm_struct_set(StructType* arr, int index, int field_id, value) { arr[index]-&gt;field = value; } </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1builtin.html#ad3b90c881b67ebe8e8fe68f14143bb1c" title="The kind of structure field info used in intrinsic. ">TVMStructFieldKind</a> </dd></dl>

</div>
</div>
<a id="aa1d19e758595200998a4e1ea39767b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d19e758595200998a4e1ea39767b6b">&#9670;&nbsp;</a></span>tvm_thread_allreduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_thread_allreduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>void tvm_thread_allreduce(UIntImm size, Expr source0, ..., Expr cond, <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> reduce_temp0, .., <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> thread_idx1, ...) { // constraint by the other thread_idx remain the same. // reduce_temp is used to save intermediate result. reduce_temp0, ... = reduce(combiner, source0, ..., cond over [thread_idx1, thread_idx2] passed by any caller) } </p>

</div>
</div>
<a id="a6be181be34fba13d129aadc6c9a23f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be181be34fba13d129aadc6c9a23f73">&#9670;&nbsp;</a></span>tvm_thread_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_thread_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code Mark the content as thread local context, can get optimized by only call the call once at thread start. </p>
<p>Do not allow nesting(getting a thread context from another).</p>
<p>Handle tvm_thread_context(Expr call) { return call; } </p>

</div>
</div>
<a id="a92624d2aa5c435cd7a0ea8efb698a115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92624d2aa5c435cd7a0ea8efb698a115">&#9670;&nbsp;</a></span>tvm_throw_last_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_throw_last_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pesudo code. </p>
<p>void <a class="el" href="namespacetvm_1_1tir_1_1builtin.html#a92624d2aa5c435cd7a0ea8efb698a115" title="See pesudo code. ">tvm_throw_last_error()</a> { throw <a class="el" href="c__runtime__api_8h.html#a775383bcd8c0237e36bdf0c9654d62c3" title="return str message of the last error all function in this file will return 0 when success and nonzero...">TVMGetLastError()</a>; } </p>

</div>
</div>
<a id="ab424ca353ceedd88a95fc37eeb9628a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab424ca353ceedd88a95fc37eeb9628a9">&#9670;&nbsp;</a></span>tvm_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_tuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tvm_tuple is not an actual function and cannot codegen. It is used to represent tuple structure in value field of <a class="el" href="classtvm_1_1tir_1_1AttrStmt.html" title="Managed reference to AttrStmtNode. ">AttrStmt</a>, for the sake of giving hint to optimization. </p>
<p>Handle tvm_tuple(value0, value1, ..., value_n); </p>

</div>
</div>
<a id="afc4086a245ded9076de226ae802ced32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4086a245ded9076de226ae802ced32">&#9670;&nbsp;</a></span>tvm_warp_activemask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_warp_activemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca44a85c87273dfab1731421f4edd2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca44a85c87273dfab1731421f4edd2bf">&#9670;&nbsp;</a></span>tvm_warp_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_warp_shuffle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See pseudo code. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle(mask, Type value, warp_id, width, warp_size) { return (value passed in by warp indicated by this_warp_id); }</p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle_up(mask, Type value, offset, width, warp_size) { return (value passed in by warp indicated by this_warp_id - offset); }</p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> tvm_warp_shuffle_down(mask, Type value, offset, width, warp_size) { return (value passed in by warp indicated by this_warp_id + offset); }</p>
<p>unsigned <a class="el" href="namespacetvm_1_1tir_1_1builtin.html#afc4086a245ded9076de226ae802ced32">tvm_warp_activemask()</a> { return (32-bit mask of currently active threads in the calling warp); }</p>
<p>Parameter warp_id indicates the source thread ID in a warp.</p>
<p>Parameter offset indicates the relative distance to this_warp_id.</p>
<p>Parameter width indicates the number of threads involved in one shuffle. See CUDA document for __shfl_sync, __shfl_up_sync, __shfl_down_sync and __activemask.</p>
<p>Parameter warp_size is the size of a warp, which helps a backend to determine wheter the width paramter is legal. </p>

</div>
</div>
<a id="af6d1c48570e10287683d58f22e4de98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d1c48570e10287683d58f22e4de98f">&#9670;&nbsp;</a></span>tvm_warp_shuffle_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_warp_shuffle_down </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0470bd69bb03047aae4cb52e1e6e337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0470bd69bb03047aae4cb52e1e6e337">&#9670;&nbsp;</a></span>tvm_warp_shuffle_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::tvm_warp_shuffle_up </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30dff65bc2c142b57fae7f60e378ff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dff65bc2c142b57fae7f60e378ff43">&#9670;&nbsp;</a></span>vectorcombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::vectorcombine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concat two vectors. </p>

</div>
</div>
<a id="a45bf65ca7ca01d2016e0b609117d7e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bf65ca7ca01d2016e0b609117d7e25">&#9670;&nbsp;</a></span>vectorhigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::vectorhigh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the high level half of the vector. </p>

</div>
</div>
<a id="a7ed64a9fb0a7f575fc63e1e0395e96a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed64a9fb0a7f575fc63e1e0395e96a6">&#9670;&nbsp;</a></span>vectorlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1Op.html">Op</a>&amp; tvm::tir::builtin::vectorlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the low-level half of the vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
