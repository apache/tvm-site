<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relax Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relax.html">relax</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relax Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1attr.html">attr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1distributed"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1distributed.html">distributed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1VarUsageInfo.html">VarUsageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility struct returned by CollectVarUsage.  <a href="structtvm_1_1relax_1_1VarUsageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AllReduceAttrs.html">AllReduceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in allreduce operators.  <a href="structtvm_1_1relax_1_1AllReduceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AllGatherAttrs.html">AllGatherAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in allgather operators.  <a href="structtvm_1_1relax_1_1AllGatherAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ScatterCollectiveAttrs.html">ScatterCollectiveAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in scatter operators.  <a href="structtvm_1_1relax_1_1ScatterCollectiveAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1InitAttrs.html">InitAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in full/full_like, ones/ones_like, and zeros/zeros_like operators.  <a href="structtvm_1_1relax_1_1InitAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TriluAttrs.html">TriluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tril and triu operator.  <a href="structtvm_1_1relax_1_1TriluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AstypeAttrs.html">AstypeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in astype operator.  <a href="structtvm_1_1relax_1_1AstypeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1WrapParamAttrs.html">WrapParamAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in wrap_param operator.  <a href="structtvm_1_1relax_1_1WrapParamAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1DistributionAttrs.html">DistributionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for redistribute and annotate_sharding operator.  <a href="structtvm_1_1relax_1_1DistributionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Resize2DAttrs.html">Resize2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize2d operator.  <a href="structtvm_1_1relax_1_1Resize2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TakeAttrs.html">TakeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in take operator.  <a href="structtvm_1_1relax_1_1TakeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1StridedSliceAttrs.html">StridedSliceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in strided_slice operator.  <a href="structtvm_1_1relax_1_1StridedSliceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MatmulAttrs.html">MatmulAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for matmul operator.  <a href="structtvm_1_1relax_1_1MatmulAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1EinsumAttrs.html">EinsumAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in einsum operator.  <a href="structtvm_1_1relax_1_1EinsumAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ConcatAttrs.html">ConcatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in concat operators.  <a href="structtvm_1_1relax_1_1ConcatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ExpandDimsAttrs.html">ExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in expand_dims operators.  <a href="structtvm_1_1relax_1_1ExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1LayoutTransformAttrs.html">LayoutTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in layout_transform operator.  <a href="structtvm_1_1relax_1_1LayoutTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PermuteDimsAttrs.html">PermuteDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in permute_dims operator.  <a href="structtvm_1_1relax_1_1PermuteDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SplitAttrs.html">SplitAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in split operator.  <a href="structtvm_1_1relax_1_1SplitAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SqueezeAttrs.html">SqueezeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in squeeze operators.  <a href="structtvm_1_1relax_1_1SqueezeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1StackAttrs.html">StackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in stack operators.  <a href="structtvm_1_1relax_1_1StackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1RepeatAttrs.html">RepeatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in repeat operators.  <a href="structtvm_1_1relax_1_1RepeatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TileAttrs.html">TileAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tile operators.  <a href="structtvm_1_1relax_1_1TileAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1FlipAttrs.html">FlipAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in flip operators.  <a href="structtvm_1_1relax_1_1FlipAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1GatherElementsAttrs.html">GatherElementsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in gather_elements operators.  <a href="structtvm_1_1relax_1_1GatherElementsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1GatherNDAttrs.html">GatherNDAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in gather_nd operators.  <a href="structtvm_1_1relax_1_1GatherNDAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1IndexPutAttrs.html">IndexPutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in index_put operator.  <a href="structtvm_1_1relax_1_1IndexPutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MeshgridAttrs.html">MeshgridAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute used in meshgrid operator.  <a href="structtvm_1_1relax_1_1MeshgridAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ScatterElementsAttrs.html">ScatterElementsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in scatter_elements operators.  <a href="structtvm_1_1relax_1_1ScatterElementsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ScatterNDAttrs.html">ScatterNDAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in scatter_nd operators.  <a href="structtvm_1_1relax_1_1ScatterNDAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SliceScatterAttrs.html">SliceScatterAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in slice_scatter operator.  <a href="structtvm_1_1relax_1_1SliceScatterAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1OneHotAttrs.html">OneHotAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in one_hot operator.  <a href="structtvm_1_1relax_1_1OneHotAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv1DAttrs.html">Conv1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv1d operator.  <a href="structtvm_1_1relax_1_1Conv1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv2DAttrs.html">Conv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv2d operator.  <a href="structtvm_1_1relax_1_1Conv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv3DAttrs.html">Conv3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv3d operator.  <a href="structtvm_1_1relax_1_1Conv3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv1DTransposeAttrs.html">Conv1DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv1DTranspose operator.  <a href="structtvm_1_1relax_1_1Conv1DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv2DTransposeAttrs.html">Conv2DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv2d operator.  <a href="structtvm_1_1relax_1_1Conv2DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Pool1DAttrs.html">Pool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in max_pool1d and avg_pool1d operator.  <a href="structtvm_1_1relax_1_1Pool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Pool2DAttrs.html">Pool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in max_pool2d and avg_pool2d operator.  <a href="structtvm_1_1relax_1_1Pool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Pool3DAttrs.html">Pool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in max_pool3d and avg_pool3d operator.  <a href="structtvm_1_1relax_1_1Pool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AdaptivePool1DAttrs.html">AdaptivePool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1d adaptive pool operator.  <a href="structtvm_1_1relax_1_1AdaptivePool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AdaptivePool2DAttrs.html">AdaptivePool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 2d adaptive pool operator.  <a href="structtvm_1_1relax_1_1AdaptivePool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AdaptivePool3DAttrs.html">AdaptivePool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3d adaptive pool operator.  <a href="structtvm_1_1relax_1_1AdaptivePool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SoftmaxAttrs.html">SoftmaxAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relax_1_1SoftmaxAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1LeakyReluAttrs.html">LeakyReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relax_1_1LeakyReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SoftplusAttrs.html">SoftplusAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softplus operators.  <a href="structtvm_1_1relax_1_1SoftplusAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PReluAttrs.html">PReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in PReLU operator.  <a href="structtvm_1_1relax_1_1PReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1BatchNormAttrs.html">BatchNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in batch_norm operator.  <a href="structtvm_1_1relax_1_1BatchNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1LayerNormAttrs.html">LayerNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in layer_norm operator.  <a href="structtvm_1_1relax_1_1LayerNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1GroupNormAttrs.html">GroupNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in group_norm operator.  <a href="structtvm_1_1relax_1_1GroupNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1InstanceNormAttrs.html">InstanceNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in instance_norm operator.  <a href="structtvm_1_1relax_1_1InstanceNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1RMSNormAttrs.html">RMSNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in rms_norm operator.  <a href="structtvm_1_1relax_1_1RMSNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1NLLLossAttrs.html">NLLLossAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in nll_loss operator.  <a href="structtvm_1_1relax_1_1NLLLossAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1DropoutAttrs.html">DropoutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dropout operator.  <a href="structtvm_1_1relax_1_1DropoutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AttentionAttrs.html">AttentionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Attention operator.  <a href="structtvm_1_1relax_1_1AttentionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PadAttrs.html">PadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the padding operator.  <a href="structtvm_1_1relax_1_1PadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PixelShuffleAttrs.html">PixelShuffleAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the pixel shuffle operator.  <a href="structtvm_1_1relax_1_1PixelShuffleAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1CallTIRWithGradAttrs.html">CallTIRWithGradAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in call_tir_with_grad.  <a href="structtvm_1_1relax_1_1CallTIRWithGradAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1CallTIRInplaceAttrs.html">CallTIRInplaceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in call_tir_inplace.  <a href="structtvm_1_1relax_1_1CallTIRInplaceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1CallInplacePackedAttrs.html">CallInplacePackedAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in call_inplace_packed.  <a href="structtvm_1_1relax_1_1CallInplacePackedAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ToVDeviceAttrs.html">ToVDeviceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in to_vdevice.  <a href="structtvm_1_1relax_1_1ToVDeviceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1HintOnDeviceAttrs.html">HintOnDeviceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in hint_on_device.  <a href="structtvm_1_1relax_1_1HintOnDeviceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1QuantizeAttrs.html">QuantizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for relax.quantize/relax.dequantize operator.  <a href="structtvm_1_1relax_1_1QuantizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MultinomialFromUniformAttrs.html">MultinomialFromUniformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in multinomial_from_uniform operator.  <a href="structtvm_1_1relax_1_1MultinomialFromUniformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ArgmaxArgminAttrs.html">ArgmaxArgminAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for search operators.  <a href="structtvm_1_1relax_1_1ArgmaxArgminAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1BucketizeAttrs.html">BucketizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for bucketize operator.  <a href="structtvm_1_1relax_1_1BucketizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SortAttrs.html">SortAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in sort operator.  <a href="structtvm_1_1relax_1_1SortAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ArgsortAttrs.html">ArgsortAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in argsort operator.  <a href="structtvm_1_1relax_1_1ArgsortAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TopKAttrs.html">TopKAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in topk operator.  <a href="structtvm_1_1relax_1_1TopKAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1StatisticalAttrs.html">StatisticalAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for statistical operators.  <a href="structtvm_1_1relax_1_1StatisticalAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ScanopAttrs.html">ScanopAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in scan operators like cumsum, cumprod.  <a href="structtvm_1_1relax_1_1ScanopAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AllClassNonMaximumSuppressionAttrs.html">AllClassNonMaximumSuppressionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in AllClassNonMaximumSuppression operator.  <a href="structtvm_1_1relax_1_1AllClassNonMaximumSuppressionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockRewriteNode.html">DataflowBlockRewriteNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement rewriter for <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">relax.DataflowBlock</a>.  <a href="classtvm_1_1relax_1_1DataflowBlockRewriteNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockRewrite.html">DataflowBlockRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement rewriter for <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">relax.DataflowBlock</a>.  <a href="classtvm_1_1relax_1_1DataflowBlockRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BlockBuilderNode.html">BlockBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to build Relax binding blocks.  <a href="classtvm_1_1relax_1_1BlockBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternNode.html">DFPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all dataflow patterns.  <a href="classtvm_1_1relax_1_1DFPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to dataflow patterns.  <a href="classtvm_1_1relax_1_1DFPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PairCons.html">PairCons</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint of a <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns.">DFPattern</a> edge (producer -&gt; consumer) in graph-level matching.  <a href="structtvm_1_1relax_1_1PairCons.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFConstraintNode.html">DFConstraintNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional constraints on the graph.  <a href="classtvm_1_1relax_1_1DFConstraintNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFConstraint.html">DFConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternSeqNode.html">PatternSeqNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of DFPatterns that the previous <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns.">DFPattern</a> is connected to the next one.  <a href="classtvm_1_1relax_1_1PatternSeqNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to pattern sequences.  <a href="classtvm_1_1relax_1_1PatternSeq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternContextNode.html">PatternContextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context to manage the graph-level pattern matching.  <a href="classtvm_1_1relax_1_1PatternContextNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a pattern context.  <a href="classtvm_1_1relax_1_1PatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprPatternNode.html">ExprPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for Relax Expression.  <a href="classtvm_1_1relax_1_1ExprPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to an <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern.">ExprPattern</a>.  <a href="classtvm_1_1relax_1_1ExprPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarPatternNode.html">VarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Variable.  <a href="classtvm_1_1relax_1_1VarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern.">VarPattern</a>.  <a href="classtvm_1_1relax_1_1VarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarPatternNode.html">DataflowVarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Dataflow Variable.  <a href="classtvm_1_1relax_1_1DataflowVarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarPattern.html">DataflowVarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1DataflowVarPattern.html" title="Managed reference to a DataflowVarPattern.">DataflowVarPattern</a>.  <a href="classtvm_1_1relax_1_1DataflowVarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1GlobalVarPatternNode.html">GlobalVarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Global Variable.  <a href="classtvm_1_1relax_1_1GlobalVarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1GlobalVarPattern.html">GlobalVarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1GlobalVarPattern.html" title="Managed reference to a GlobalVarPattern.">GlobalVarPattern</a>.  <a href="classtvm_1_1relax_1_1GlobalVarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantPatternNode.html">ConstantPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax <a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a>.  <a href="classtvm_1_1relax_1_1ConstantPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern.">ConstantPattern</a>.  <a href="classtvm_1_1relax_1_1ConstantPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallPatternNode.html">CallPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match a callable node in Relax.  <a href="classtvm_1_1relax_1_1CallPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimArrPatternNode.html">PrimArrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match an array of <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a>.  <a href="classtvm_1_1relax_1_1PrimArrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimArrPattern.html">PrimArrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1PrimArrPattern.html" title="Managed reference to a PrimArrPattern.">PrimArrPattern</a>.  <a href="classtvm_1_1relax_1_1PrimArrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionPatternNode.html">FunctionPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match a Relax <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>.  <a href="classtvm_1_1relax_1_1FunctionPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionPattern.html">FunctionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1FunctionPatternNode.html" title="A pattern to match a Relax Function.">FunctionPatternNode</a>.  <a href="classtvm_1_1relax_1_1FunctionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuplePatternNode.html">TuplePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern to match a tuple of ordered expressions.  <a href="classtvm_1_1relax_1_1TuplePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TuplePatternNode.html" title="Pattern to match a tuple of ordered expressions.">TuplePatternNode</a>.  <a href="classtvm_1_1relax_1_1TuplePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html">UnorderedTuplePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match multiple expressions unorderedly.  <a href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html">UnorderedTuplePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html" title="A pattern to match multiple expressions unorderedly.">UnorderedTuplePatternNode</a>.  <a href="classtvm_1_1relax_1_1UnorderedTuplePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html">TupleGetItemPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match n'th indexing to a tuple.  <a href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html" title="A pattern to match n&#39;th indexing to a tuple.">TupleGetItemPatternNode</a>.  <a href="classtvm_1_1relax_1_1TupleGetItemPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AndPatternNode.html">AndPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a conjunction of other patterns.  <a href="classtvm_1_1relax_1_1AndPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AndPattern.html">AndPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1AndPatternNode.html" title="Match a conjunction of other patterns.">AndPatternNode</a>.  <a href="classtvm_1_1relax_1_1AndPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1OrPatternNode.html">OrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a disjunction of other patterns.  <a href="classtvm_1_1relax_1_1OrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1OrPattern.html">OrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1OrPatternNode.html" title="Match a disjunction of other patterns.">OrPatternNode</a>.  <a href="classtvm_1_1relax_1_1OrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NotPatternNode.html">NotPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for rejecting a certain pattern.  <a href="classtvm_1_1relax_1_1NotPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NotPattern.html">NotPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1NotPatternNode.html" title="Pattern for rejecting a certain pattern.">NotPatternNode</a>.  <a href="classtvm_1_1relax_1_1NotPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1WildcardPatternNode.html">WildcardPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wildcard Pattern is a pattern that can match anything.  <a href="classtvm_1_1relax_1_1WildcardPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1WildcardPatternNode.html" title="Wildcard Pattern is a pattern that can match anything.">WildcardPatternNode</a>.  <a href="classtvm_1_1relax_1_1WildcardPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoPatternNode.html">StructInfoPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for matching a certain struct info.  <a href="classtvm_1_1relax_1_1StructInfoPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoPattern.html">StructInfoPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapePatternNode.html">ShapePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has a certain shape.  <a href="classtvm_1_1relax_1_1ShapePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapePattern.html">ShapePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ShapePatternNode.html" title="A pattern that asserting a root pattern has a certain shape.">ShapePatternNode</a>.  <a href="classtvm_1_1relax_1_1ShapePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SameShapeConstraintNode.html">SameShapeConstraintNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting multiple root patterns have the same shape.  <a href="classtvm_1_1relax_1_1SameShapeConstraintNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SameShapeConstraint.html">SameShapeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to SameShapePatternNode.  <a href="classtvm_1_1relax_1_1SameShapeConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypePatternNode.html">DataTypePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has a certain data type.  <a href="classtvm_1_1relax_1_1DataTypePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypePattern.html">DataTypePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DataTypePatternNode.html" title="A pattern that asserting a root pattern has a certain data type.">DataTypePatternNode</a>.  <a href="classtvm_1_1relax_1_1DataTypePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AttrPatternNode.html">AttrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has certain attributes.  <a href="classtvm_1_1relax_1_1AttrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AttrPattern.html">AttrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1AttrPatternNode.html" title="A pattern that asserting a root pattern has certain attributes.">AttrPatternNode</a>.  <a href="classtvm_1_1relax_1_1AttrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncPatternNode.html">ExternFuncPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern of external function.  <a href="classtvm_1_1relax_1_1ExternFuncPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncPattern.html">ExternFuncPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ExternFuncPatternNode.html" title="A pattern of external function.">ExternFuncPatternNode</a>.  <a href="classtvm_1_1relax_1_1ExternFuncPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor.html">DFPatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns.">DFPattern</a> argument.  <a href="classtvm_1_1relax_1_1DFPatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor_3_01R_07const_01DFPattern_01_6n_00_01Args_8_8_8_08_4.html">DFPatternFunctor&lt; R(const DFPattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternVisitor.html">DFPatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor.html" title="A dynamical functor that dispatches on in the first DFPattern argument.">DFPatternFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relax_1_1DFPatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExecBuilderNode.html">ExecBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder provides api to build VM executable with instructions.  <a href="classtvm_1_1relax_1_1ExecBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExecBuilder.html">ExecBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1IdNode.html">IdNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier of variables.  <a href="classtvm_1_1relax_1_1IdNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Id.html">Id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoNode.html">StructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all structure information.  <a href="classtvm_1_1relax_1_1StructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1StructInfoNode.html" title="Base type of all structure information.">StructInfoNode</a>.  <a href="classtvm_1_1relax_1_1StructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> corresponds to callable invocation. Corresponds to operation in computational graph terminology.  <a href="classtvm_1_1relax_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleNode.html">TupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relax_1_1TupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemNode.html">TupleGetItemNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index-th field out of a tuple.  <a href="classtvm_1_1relax_1_1TupleGetItemNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1LeafExprNode.html">LeafExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all (non-function) leaf Exprs.  <a href="classtvm_1_1relax_1_1LeafExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1LeafExpr.html">LeafExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1BaseExprNode.html" title="Base type of all the expressions.">BaseExprNode</a>.  <a href="classtvm_1_1relax_1_1LeafExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeExprNode.html">ShapeExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shape expression which allows users to construct a shape containing <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a>.  <a href="classtvm_1_1relax_1_1ShapeExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeExpr.html">ShapeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable class for all Relax bindings.  <a href="classtvm_1_1relax_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarNode.html">DataflowVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sub-type of the variable node used to mark dataflow variables from normal visible "function local" bindings.  <a href="classtvm_1_1relax_1_1DataflowVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVar.html">DataflowVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantNode.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a> tensor.  <a href="classtvm_1_1relax_1_1ConstantNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimValueNode.html">PrimValueNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1PrimValue.html" title="Managed reference to PrimValueNode.">PrimValue</a>.  <a href="classtvm_1_1relax_1_1PrimValueNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimValue.html">PrimValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PrimValueNode.html" title="PrimValue.">PrimValueNode</a>.  <a href="classtvm_1_1relax_1_1PrimValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a string literal constant.  <a href="classtvm_1_1relax_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StringImm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1StringImm.html" title="Managed reference to StringImm.">StringImm</a>.  <a href="classtvm_1_1relax_1_1StringImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypeImmNode.html">DataTypeImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a data type constant.  <a href="classtvm_1_1relax_1_1DataTypeImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypeImm.html">DataTypeImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DataTypeImm.html" title="Managed reference to DataTypeImm.">DataTypeImm</a>.  <a href="classtvm_1_1relax_1_1DataTypeImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingNode.html">BindingNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of a variable binding in Relax.  <a href="classtvm_1_1relax_1_1BindingNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchCastNode.html">MatchCastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime-match the value to the struct info.  <a href="classtvm_1_1relax_1_1MatchCastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchCast.html">MatchCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1MatchCastNode.html" title="Runtime-match the value to the struct info.">MatchCastNode</a>.  <a href="classtvm_1_1relax_1_1MatchCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarBindingNode.html">VarBindingNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarBinding.html">VarBinding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingBlockNode.html">BindingBlockNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingBlock.html">BindingBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockNode.html">DataflowBlockNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SeqExprNode.html">SeqExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of blocks followed by an expression.  <a href="classtvm_1_1relax_1_1SeqExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SeqExpr.html">SeqExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1IfNode.html">IfNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition expression.  <a href="classtvm_1_1relax_1_1IfNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionNode.html">FunctionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Relax function.  <a href="classtvm_1_1relax_1_1FunctionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncNode.html">ExternFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extern function, which can represent packed function.  <a href="classtvm_1_1relax_1_1ExternFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFunc.html">ExternFunc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>.  <a href="classtvm_1_1relax_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relax_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relax_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprMutatorBase.html">ExprMutatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator works in unnormalized form.  <a href="classtvm_1_1relax_1_1ExprMutatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator works in normal form.  <a href="classtvm_1_1relax_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container that stores possibly nested message with leaf message type T.  <a href="classtvm_1_1relax_1_1NestedMsg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectStructInfoNode.html">ObjectStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque object.  <a href="classtvm_1_1relax_1_1ObjectStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectStructInfo.html">ObjectStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ObjectStructInfoNode.html" title="Opaque object.">ObjectStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1ObjectStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimStructInfoNode.html">PrimStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive value.  <a href="classtvm_1_1relax_1_1PrimStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimStructInfo.html">PrimStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PrimStructInfoNode.html" title="Primitive value.">PrimStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1PrimStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeStructInfoNode.html">ShapeStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> of shape value.  <a href="classtvm_1_1relax_1_1ShapeStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeStructInfo.html">ShapeStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ShapeStructInfoNode.html" title="StructInfo of shape value.">ShapeStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1ShapeStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorStructInfoNode.html">TensorStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> of Tensor.  <a href="classtvm_1_1relax_1_1TensorStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorStructInfo.html">TensorStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TensorStructInfoNode.html" title="StructInfo of Tensor.">TensorStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1TensorStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleStructInfoNode.html">TupleStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> of <a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>.  <a href="classtvm_1_1relax_1_1TupleStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleStructInfo.html">TupleStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TupleStructInfoNode.html" title="StructInfo of Tuple.">TupleStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1TupleStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FuncStructInfoNode.html">FuncStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure information about function.  <a href="classtvm_1_1relax_1_1FuncStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1FuncStructInfoNode.html" title="Structure information about function.">FuncStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1FuncStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoFunctor.html">StructInfoFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoFunctor_3_01R_07const_01StructInfo_01_6n_00_01Args_8_8_8_08_4.html">StructInfoFunctor&lt; R(const StructInfo &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoVisitor.html">StructInfoVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct info visitor.  <a href="classtvm_1_1relax_1_1StructInfoVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoMutator.html">StructInfoMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfoMutator.html" title="StructInfoMutator that mutates struct info.">StructInfoMutator</a> that mutates struct info.  <a href="classtvm_1_1relax_1_1StructInfoMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchResultNode.html">MatchResultNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchResult.html">MatchResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1MatchResultNode.html">MatchResultNode</a>.  <a href="classtvm_1_1relax_1_1MatchResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeTypeNode.html">ShapeTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeType.html">ShapeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorTypeNode.html">TensorTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic version of <a class="el" href="classtvm_1_1relax_1_1TensorType.html" title="Managed reference to TensorTypeNode.">TensorType</a>.  <a href="classtvm_1_1relax_1_1TensorTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TensorTypeNode.html" title="Dynamic version of TensorType.">TensorTypeNode</a>.  <a href="classtvm_1_1relax_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectTypeNode.html">ObjectTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectType.html">ObjectType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PackedFuncTypeNode.html">PackedFuncTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PackedFuncType.html">PackedFuncType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac287c47b30d1126e4017da1b96957fa0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> = <a class="el" href="classtvm_1_1RelaxExpr.html">RelaxExpr</a></td></tr>
<tr class="separator:ac287c47b30d1126e4017da1b96957fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b7f14f445c67648c3849d69ea8f5bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a71b7f14f445c67648c3849d69ea8f5bc">ExprNode</a> = <a class="el" href="classtvm_1_1RelaxExprNode.html">RelaxExprNode</a></td></tr>
<tr class="separator:a71b7f14f445c67648c3849d69ea8f5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785a8c88785c92ac51caffa58a49a5fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a785a8c88785c92ac51caffa58a49a5fc">FInferStructInfo</a> = ffi::TypedFunction&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:a785a8c88785c92ac51caffa58a49a5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer output struct info given the call.  <a href="namespacetvm_1_1relax.html#a785a8c88785c92ac51caffa58a49a5fc">More...</a><br /></td></tr>
<tr class="separator:a785a8c88785c92ac51caffa58a49a5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496b1f2440af7d57184d0d793fe5fd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a496b1f2440af7d57184d0d793fe5fd2c">FCallPacked</a> = ffi::String</td></tr>
<tr class="memdesc:a496b1f2440af7d57184d0d793fe5fd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed function implementation for operators. The relax operator will be lowered to this packed function call during codegen.  <a href="namespacetvm_1_1relax.html#a496b1f2440af7d57184d0d793fe5fd2c">More...</a><br /></td></tr>
<tr class="separator:a496b1f2440af7d57184d0d793fe5fd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f50c4ff744c12ce98ae9baff16e039"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ac7f50c4ff744c12ce98ae9baff16e039">FNormalize</a> = ffi::TypedFunction&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;bb, <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> call)&gt;</td></tr>
<tr class="memdesc:ac7f50c4ff744c12ce98ae9baff16e039"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of a normalization function.  <a href="namespacetvm_1_1relax.html#ac7f50c4ff744c12ce98ae9baff16e039">More...</a><br /></td></tr>
<tr class="separator:ac7f50c4ff744c12ce98ae9baff16e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f7cc3741498211157c83d236d3eb7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a40f7cc3741498211157c83d236d3eb7a">FValidate</a> = ffi::TypedFunction&lt; void(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call)&gt;</td></tr>
<tr class="memdesc:a40f7cc3741498211157c83d236d3eb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of a validation function.  <a href="namespacetvm_1_1relax.html#a40f7cc3741498211157c83d236d3eb7a">More...</a><br /></td></tr>
<tr class="separator:a40f7cc3741498211157c83d236d3eb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a6ed68c50ce093ea96351e8d983ea4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad5a6ed68c50ce093ea96351e8d983ea4">FLegalize</a> = ffi::TypedFunction&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;bb, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call)&gt;</td></tr>
<tr class="memdesc:ad5a6ed68c50ce093ea96351e8d983ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of a legalization function.  <a href="namespacetvm_1_1relax.html#ad5a6ed68c50ce093ea96351e8d983ea4">More...</a><br /></td></tr>
<tr class="separator:ad5a6ed68c50ce093ea96351e8d983ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51243f350e2459b5dfc51741202b0d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae51243f350e2459b5dfc51741202b0d2">FLowerBuiltin</a> = ffi::TypedFunction&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;bb, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call)&gt;</td></tr>
<tr class="memdesc:ae51243f350e2459b5dfc51741202b0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of a function to lower the runtime builtin.  <a href="namespacetvm_1_1relax.html#ae51243f350e2459b5dfc51741202b0d2">More...</a><br /></td></tr>
<tr class="separator:ae51243f350e2459b5dfc51741202b0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae500b48c6aeb83a0bdd72bf8fb022d47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae500b48c6aeb83a0bdd72bf8fb022d47">FPrimalGradient</a> = ffi::TypedFunction&lt; tvm::ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;orig_var, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;orig_call, const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;output_grad, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:ae500b48c6aeb83a0bdd72bf8fb022d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient for a specific op.  <a href="namespacetvm_1_1relax.html#ae500b48c6aeb83a0bdd72bf8fb022d47">More...</a><br /></td></tr>
<tr class="separator:ae500b48c6aeb83a0bdd72bf8fb022d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30be57dbb36533467727929c21bd237"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af30be57dbb36533467727929c21bd237">StructInfoDeriveFunc</a> = <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:af30be57dbb36533467727929c21bd237"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom-defined <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> derivation function.  <a href="namespacetvm_1_1relax.html#af30be57dbb36533467727929c21bd237">More...</a><br /></td></tr>
<tr class="separator:af30be57dbb36533467727929c21bd237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4609a7fed731069af110d2ba9965246"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae4609a7fed731069af110d2ba9965246">TIRPattern</a> = <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a></td></tr>
<tr class="separator:ae4609a7fed731069af110d2ba9965246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2b1d07a3f88e22320b95cd02a5383"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a5bd2b1d07a3f88e22320b95cd02a5383">FCodegen</a> = ffi::TypedFunction&lt; ffi::Array&lt; ffi::Any &gt;(ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1MatchResult.html">MatchResult</a> &gt; match_results)&gt;</td></tr>
<tr class="separator:a5bd2b1d07a3f88e22320b95cd02a5383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23883a54f4c8a912ac3122b89aa06a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa23883a54f4c8a912ac3122b89aa06a9">TensorTypeNode</a> = <a class="el" href="classtvm_1_1relax_1_1TensorTypeNode.html">TensorTypeNode</a></td></tr>
<tr class="separator:aa23883a54f4c8a912ac3122b89aa06a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06538b181df82292bdb5f73d6f21de94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a06538b181df82292bdb5f73d6f21de94">TensorType</a> = <a class="el" href="classtvm_1_1relax_1_1TensorType.html">TensorType</a></td></tr>
<tr class="separator:a06538b181df82292bdb5f73d6f21de94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a04ee98afc287f8466486f83957bbceb2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a> { <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2aea0d6c7bc4e0f3e1ae27af5ab8d3ead1">kFailL0</a> = 0
, <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a44bf4c796712d49aa9e166a28b5b4877">kFailL1</a> = 1
, <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a445a5e4200190564cfb0a1a85823831f">kFailL2</a> = 2
, <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a42b60afb2c7698ee5c4d41840ca1210e">kPass</a> = 3
 }</td></tr>
<tr class="memdesc:a04ee98afc287f8466486f83957bbceb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fine grained result of base check.  <a href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">More...</a><br /></td></tr>
<tr class="separator:a04ee98afc287f8466486f83957bbceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffa9e980a7331f2eb89cce97f2e3575"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575">OpPatternKind</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575a7a3fb5d59f4cd93830b2188ec6c263c5">kElemWise</a> = 0
, <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575abea71ce5432e0ebfa7039b36f018e26e">kBroadcast</a> = 1
, <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575aad7813b18db6196460bcd45dc8cd4567">kInjective</a> = 2
, <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575ace8074089a6395be731ae800adcceb97">kCommReduce</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575aaacd35420305d82c6ef118ed5d982a1c">kOutEWiseFusable</a> = 4
, <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575a6a77a35dd616597cb7186487d6f076cc">kTuple</a> = 7
, <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575a15ea1f34cc6d4a52372b78fca0bda8b9">kOpaque</a> = 8
<br />
 }</td></tr>
<tr class="separator:acffa9e980a7331f2eb89cce97f2e3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d99a4dc10bb283daa818463a1d3d04e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a6d99a4dc10bb283daa818463a1d3d04e">CanProveShapeEqual</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;lhs, const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana)</td></tr>
<tr class="memdesc:a6d99a4dc10bb283daa818463a1d3d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can prove the two symbolic shape arrays equals to each other.  <a href="namespacetvm_1_1relax.html#a6d99a4dc10bb283daa818463a1d3d04e">More...</a><br /></td></tr>
<tr class="separator:a6d99a4dc10bb283daa818463a1d3d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0d355ea6891b47940c7bf24a55d8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aafb0d355ea6891b47940c7bf24a55d8b">CanProveShapeEqual</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;lhs, const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana)</td></tr>
<tr class="memdesc:aafb0d355ea6891b47940c7bf24a55d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can prove the two symbolic shape expressions equals to each other.  <a href="namespacetvm_1_1relax.html#aafb0d355ea6891b47940c7bf24a55d8b">More...</a><br /></td></tr>
<tr class="separator:aafb0d355ea6891b47940c7bf24a55d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a76d13e1d70ccc9a43c11cda36bcc3414">GetStaticType</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding static type from a given struct info.  <a href="namespacetvm_1_1relax.html#a76d13e1d70ccc9a43c11cda36bcc3414">More...</a><br /></td></tr>
<tr class="separator:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886a4846aaed5d3cabb7ba6277d895b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a886a4846aaed5d3cabb7ba6277d895b6">StructInfoFromType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a886a4846aaed5d3cabb7ba6277d895b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding struct info from static type.  <a href="namespacetvm_1_1relax.html#a886a4846aaed5d3cabb7ba6277d895b6">More...</a><br /></td></tr>
<tr class="separator:a886a4846aaed5d3cabb7ba6277d895b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc2189e6a25f2df774b38c7d72f23f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#abfc2189e6a25f2df774b38c7d72f23f9">DeriveCallRetStructInfo</a> (const <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a> &amp;finfo, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="separator:abfc2189e6a25f2df774b38c7d72f23f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b372668ea8c4e1c3b7c6b38fc3146ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a7b372668ea8c4e1c3b7c6b38fc3146ef">EraseToWellDefined</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info, std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &amp;var)&gt; f_shape_var_map=nullptr, std::function&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;var)&gt; f_var_map=nullptr, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a7b372668ea8c4e1c3b7c6b38fc3146ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the info to a corresponding more coarse grained struct info that is still well-defined(with all the vars in scope).  <a href="namespacetvm_1_1relax.html#a7b372668ea8c4e1c3b7c6b38fc3146ef">More...</a><br /></td></tr>
<tr class="separator:a7b372668ea8c4e1c3b7c6b38fc3146ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d14d26c0625c9841b99d6faa9b6474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a55d14d26c0625c9841b99d6faa9b6474">EraseToWellDefined</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info, ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape_var_map, ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; var_map, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a55d14d26c0625c9841b99d6faa9b6474"><td class="mdescLeft">&#160;</td><td class="mdescRight">EraseToWellDefined variant with map.  <a href="namespacetvm_1_1relax.html#a55d14d26c0625c9841b99d6faa9b6474">More...</a><br /></td></tr>
<tr class="separator:a55d14d26c0625c9841b99d6faa9b6474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be05801cdf62e4e3a012dc2e410302d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1be05801cdf62e4e3a012dc2e410302d">StructInfoBaseCheck</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;base, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;derived, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a1be05801cdf62e4e3a012dc2e410302d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a base check to see if base subsumes derived.  <a href="namespacetvm_1_1relax.html#a1be05801cdf62e4e3a012dc2e410302d">More...</a><br /></td></tr>
<tr class="separator:a1be05801cdf62e4e3a012dc2e410302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a717c05debf2815aee7bcbe7d61e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad86a717c05debf2815aee7bcbe7d61e4">IsBaseOf</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;base, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;derived, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:ad86a717c05debf2815aee7bcbe7d61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the relation of two struct info to see if one subsumes another one.  <a href="namespacetvm_1_1relax.html#ad86a717c05debf2815aee7bcbe7d61e4">More...</a><br /></td></tr>
<tr class="separator:ad86a717c05debf2815aee7bcbe7d61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74568b8d1e2c4ae8b56210c0bc0136a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af74568b8d1e2c4ae8b56210c0bc0136a">StructInfoBaseCheckPrecondition</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;base, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;derived)</td></tr>
<tr class="memdesc:af74568b8d1e2c4ae8b56210c0bc0136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the condition for which base is a superset of derived.  <a href="namespacetvm_1_1relax.html#af74568b8d1e2c4ae8b56210c0bc0136a">More...</a><br /></td></tr>
<tr class="separator:af74568b8d1e2c4ae8b56210c0bc0136a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1c8438730f1ee0320fd8bff9226e0d1b">StructInfoLCA</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify the two struct info to their least common ancestor.  <a href="namespacetvm_1_1relax.html#a1c8438730f1ee0320fd8bff9226e0d1b">More...</a><br /></td></tr>
<tr class="separator:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca023f523d107c9c2652474c84573b"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a97ca023f523d107c9c2652474c84573b">TIRVarsInStructInfo</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;sinfo)</td></tr>
<tr class="memdesc:a97ca023f523d107c9c2652474c84573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TIR variables that appear in the input struct info. The returned list is deduplicated - each TIR variable will appear at most once.  <a href="namespacetvm_1_1relax.html#a97ca023f523d107c9c2652474c84573b">More...</a><br /></td></tr>
<tr class="separator:a97ca023f523d107c9c2652474c84573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2a6cdb84b007c9a32c0ff1e247ee1"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a54d2a6cdb84b007c9a32c0ff1e247ee1">DefinableTIRVarsInStructInfo</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;sinfo)</td></tr>
<tr class="memdesc:a54d2a6cdb84b007c9a32c0ff1e247ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TIR variables that appear in the input struct info.  <a href="namespacetvm_1_1relax.html#a54d2a6cdb84b007c9a32c0ff1e247ee1">More...</a><br /></td></tr>
<tr class="separator:a54d2a6cdb84b007c9a32c0ff1e247ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9235885a259d3adfce6e8efca1b9066a"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a9235885a259d3adfce6e8efca1b9066a">CollectNonNegativeExpressions</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;sinfo)</td></tr>
<tr class="memdesc:a9235885a259d3adfce6e8efca1b9066a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect expressions whose usage requires them to be non-negative.  <a href="namespacetvm_1_1relax.html#a9235885a259d3adfce6e8efca1b9066a">More...</a><br /></td></tr>
<tr class="separator:a9235885a259d3adfce6e8efca1b9066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7f1d01021ff6fecf49feb0cedd60b1"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#abe7f1d01021ff6fecf49feb0cedd60b1">DefinedSymbolicVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:abe7f1d01021ff6fecf49feb0cedd60b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TIR variables that defined in the input function. The returned list is deduplicated - each TIR variable will appear at most once.  <a href="namespacetvm_1_1relax.html#abe7f1d01021ff6fecf49feb0cedd60b1">More...</a><br /></td></tr>
<tr class="separator:abe7f1d01021ff6fecf49feb0cedd60b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18820bc38a0faab1e6a35acbd72bfd50"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a18820bc38a0faab1e6a35acbd72bfd50">FreeSymbolicVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a18820bc38a0faab1e6a35acbd72bfd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TIR variables that are used but not defined in the input function. The returned list is deduplicated - each TIR variable will appear at most once.  <a href="namespacetvm_1_1relax.html#a18820bc38a0faab1e6a35acbd72bfd50">More...</a><br /></td></tr>
<tr class="separator:a18820bc38a0faab1e6a35acbd72bfd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef624ea81426dce933d433512deae3"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae4ef624ea81426dce933d433512deae3">BoundVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae4ef624ea81426dce933d433512deae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="namespacetvm_1_1relax.html#ae4ef624ea81426dce933d433512deae3">More...</a><br /></td></tr>
<tr class="separator:ae4ef624ea81426dce933d433512deae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4db78e883277e8d527650f26ad6456"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a9d4db78e883277e8d527650f26ad6456">FreeVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a9d4db78e883277e8d527650f26ad6456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="namespacetvm_1_1relax.html#a9d4db78e883277e8d527650f26ad6456">More...</a><br /></td></tr>
<tr class="separator:a9d4db78e883277e8d527650f26ad6456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03b98266ae240c3f58583712bb02049"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad03b98266ae240c3f58583712bb02049">AllVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ad03b98266ae240c3f58583712bb02049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="namespacetvm_1_1relax.html#ad03b98266ae240c3f58583712bb02049">More...</a><br /></td></tr>
<tr class="separator:ad03b98266ae240c3f58583712bb02049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d29a9c41dcc0ec7eefef20f5d7b5eb"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab9d29a9c41dcc0ec7eefef20f5d7b5eb">AllGlobalVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab9d29a9c41dcc0ec7eefef20f5d7b5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all global variables from expression expr.  <a href="namespacetvm_1_1relax.html#ab9d29a9c41dcc0ec7eefef20f5d7b5eb">More...</a><br /></td></tr>
<tr class="separator:ab9d29a9c41dcc0ec7eefef20f5d7b5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af998c81ee29fc6667b1f11be11125dc8"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Array&lt; tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af998c81ee29fc6667b1f11be11125dc8">DetectRecursion</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;m)</td></tr>
<tr class="memdesc:af998c81ee29fc6667b1f11be11125dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all sets of recursive or mutually recursive functions in the module.  <a href="namespacetvm_1_1relax.html#af998c81ee29fc6667b1f11be11125dc8">More...</a><br /></td></tr>
<tr class="separator:af998c81ee29fc6667b1f11be11125dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722f1672eb1feb9a3be7b7683ccbb290"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a722f1672eb1feb9a3be7b7683ccbb290">AnalyzeVar2Value</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;m)</td></tr>
<tr class="memdesc:a722f1672eb1feb9a3be7b7683ccbb290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="namespacetvm_1_1relax.html#a722f1672eb1feb9a3be7b7683ccbb290">More...</a><br /></td></tr>
<tr class="separator:a722f1672eb1feb9a3be7b7683ccbb290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c9ea2b6e6f12ad0d40a1f02af04a1b"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a05c9ea2b6e6f12ad0d40a1f02af04a1b">AnalyzeVar2Value</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a05c9ea2b6e6f12ad0d40a1f02af04a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="namespacetvm_1_1relax.html#a05c9ea2b6e6f12ad0d40a1f02af04a1b">More...</a><br /></td></tr>
<tr class="separator:a05c9ea2b6e6f12ad0d40a1f02af04a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cf989d5c92bb59a166f6748d27131d"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af9cf989d5c92bb59a166f6748d27131d">AnalyzeVar2Value</a> (const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb)</td></tr>
<tr class="memdesc:af9cf989d5c92bb59a166f6748d27131d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="namespacetvm_1_1relax.html#af9cf989d5c92bb59a166f6748d27131d">More...</a><br /></td></tr>
<tr class="separator:af9cf989d5c92bb59a166f6748d27131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3370ca0f9f9e283b3fe9c3983b565ae"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; ffi::String, ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab3370ca0f9f9e283b3fe9c3983b565ae">NameToBinding</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;fn)</td></tr>
<tr class="memdesc:ab3370ca0f9f9e283b3fe9c3983b565ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mapping from variable name to its Bindings.  <a href="namespacetvm_1_1relax.html#ab3370ca0f9f9e283b3fe9c3983b565ae">More...</a><br /></td></tr>
<tr class="separator:ab3370ca0f9f9e283b3fe9c3983b565ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69809a1998b173f456c43ee4877276e"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa69809a1998b173f456c43ee4877276e">DataflowBlockUseDef</a> (const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb)</td></tr>
<tr class="memdesc:aa69809a1998b173f456c43ee4877276e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the use-def chain of variables inside a dataflow block.  <a href="namespacetvm_1_1relax.html#aa69809a1998b173f456c43ee4877276e">More...</a><br /></td></tr>
<tr class="separator:aa69809a1998b173f456c43ee4877276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd45f5a49fc8378666461fb076d5458"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;, ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afbd45f5a49fc8378666461fb076d5458">FunctionUseDef</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:afbd45f5a49fc8378666461fb076d5458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the use-def chain of variables inside a function.  <a href="namespacetvm_1_1relax.html#afbd45f5a49fc8378666461fb076d5458">More...</a><br /></td></tr>
<tr class="separator:afbd45f5a49fc8378666461fb076d5458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6df7d984c8ca85b632dce561b84531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtvm_1_1relax_1_1VarUsageInfo.html">VarUsageInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afd6df7d984c8ca85b632dce561b84531">CollectVarUsage</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:afd6df7d984c8ca85b632dce561b84531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect variable bindings and usage.  <a href="namespacetvm_1_1relax.html#afd6df7d984c8ca85b632dce561b84531">More...</a><br /></td></tr>
<tr class="separator:afd6df7d984c8ca85b632dce561b84531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc012aed7e73dbbe354553614acd14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a32fc012aed7e73dbbe354553614acd14">RemoveAllUnused</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr)</td></tr>
<tr class="memdesc:a32fc012aed7e73dbbe354553614acd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused statements inside DataflowBlocks.  <a href="namespacetvm_1_1relax.html#a32fc012aed7e73dbbe354553614acd14">More...</a><br /></td></tr>
<tr class="separator:a32fc012aed7e73dbbe354553614acd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae97ce4a915c7c0f1088ed61261e1f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575">OpPatternKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaae97ce4a915c7c0f1088ed61261e1f0">AnalyzeOpPatternKind</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:aaae97ce4a915c7c0f1088ed61261e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind for PrimFunc, which is used in relax FuseOps.  <a href="namespacetvm_1_1relax.html#aaae97ce4a915c7c0f1088ed61261e1f0">More...</a><br /></td></tr>
<tr class="separator:aaae97ce4a915c7c0f1088ed61261e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0625d588e3d480f49c80c7589fe5f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a9a0625d588e3d480f49c80c7589fe5f6">HasReshapePattern</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:a9a0625d588e3d480f49c80c7589fe5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given PrimFunc is essentially doing a reshape operation. The reshape operation also includes expand_dims, squeeze, flatten, etc.  <a href="namespacetvm_1_1relax.html#a9a0625d588e3d480f49c80c7589fe5f6">More...</a><br /></td></tr>
<tr class="separator:a9a0625d588e3d480f49c80c7589fe5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ed75c6b4e2b27f1e6950fcfbc3ace0"><td class="memItemLeft" align="right" valign="top">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a14ed75c6b4e2b27f1e6950fcfbc3ace0">FindImpureCall</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr, const ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;own_name=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(std::nullopt))</td></tr>
<tr class="memdesc:a14ed75c6b4e2b27f1e6950fcfbc3ace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given expression (likely a function body) contains any impure calls.  <a href="namespacetvm_1_1relax.html#a14ed75c6b4e2b27f1e6950fcfbc3ace0">More...</a><br /></td></tr>
<tr class="separator:a14ed75c6b4e2b27f1e6950fcfbc3ace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205aa2060f1e013a9e72666a2a0b41e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a205aa2060f1e013a9e72666a2a0b41e3">ContainsImpureCall</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr, const ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;own_name=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(std::nullopt))</td></tr>
<tr class="memdesc:a205aa2060f1e013a9e72666a2a0b41e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given expression (likely a function body) contains any impure calls.  <a href="namespacetvm_1_1relax.html#a205aa2060f1e013a9e72666a2a0b41e3">More...</a><br /></td></tr>
<tr class="separator:a205aa2060f1e013a9e72666a2a0b41e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f71a11cfb52e59f09df83a984cc007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a73f71a11cfb52e59f09df83a984cc007">WellFormed</a> (ffi::Variant&lt; <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &gt; obj, bool check_struct_info=true)</td></tr>
<tr class="memdesc:a73f71a11cfb52e59f09df83a984cc007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> is well formed.  <a href="namespacetvm_1_1relax.html#a73f71a11cfb52e59f09df83a984cc007">More...</a><br /></td></tr>
<tr class="separator:a73f71a11cfb52e59f09df83a984cc007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89eeb16f9f5992f08ccbceba43408e"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Block.html">tir::Block</a>, ffi::Map&lt; ObjectRef, <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a5f89eeb16f9f5992f08ccbceba43408e">SuggestLayoutTransforms</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;fn, ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a> &gt; write_buffer_transformations)</td></tr>
<tr class="memdesc:a5f89eeb16f9f5992f08ccbceba43408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the layout transforms on the outputs, suggest layout transformation on the blocks and buffers for the PrimFunc.  <a href="namespacetvm_1_1relax.html#a5f89eeb16f9f5992f08ccbceba43408e">More...</a><br /></td></tr>
<tr class="separator:a5f89eeb16f9f5992f08ccbceba43408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f6936f70633ea84fc984a55a13fed6"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a91f6936f70633ea84fc984a55a13fed6">ComputableAtCompileTime</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;func)</td></tr>
<tr class="separator:a91f6936f70633ea84fc984a55a13fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc1215a6a863b7e640ac99076a55ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaabc1215a6a863b7e640ac99076a55ac">MatchExpr</a> (<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt; bindings=std::nullopt)</td></tr>
<tr class="memdesc:aaabc1215a6a863b7e640ac99076a55ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a pattern matches an expression.  <a href="namespacetvm_1_1relax.html#aaabc1215a6a863b7e640ac99076a55ac">More...</a><br /></td></tr>
<tr class="separator:aaabc1215a6a863b7e640ac99076a55ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038c99139492ca7fecf8430cf919e35f"><td class="memItemLeft" align="right" valign="top">ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a038c99139492ca7fecf8430cf919e35f">ExtractMatchedExpr</a> (<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt; bindings=std::nullopt)</td></tr>
<tr class="separator:a038c99139492ca7fecf8430cf919e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7b62e2c594369bba00b5044464945"><td class="memItemLeft" align="right" valign="top">ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a66c7b62e2c594369bba00b5044464945">MatchGraph</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;ctx, const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb)</td></tr>
<tr class="memdesc:a66c7b62e2c594369bba00b5044464945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a sub-graph in a <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> with a graph of patterns and return the mapping.  <a href="namespacetvm_1_1relax.html#a66c7b62e2c594369bba00b5044464945">More...</a><br /></td></tr>
<tr class="separator:a66c7b62e2c594369bba00b5044464945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5845e4d011ab64d1ebbb8faa289c8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af5845e4d011ab64d1ebbb8faa289c8b6">RewriteBindings</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;ctx, ffi::TypedFunction&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;, ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;)&gt; rewriter, <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> f)</td></tr>
<tr class="memdesc:af5845e4d011ab64d1ebbb8faa289c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a function with the given pattern and the rewriter function.  <a href="namespacetvm_1_1relax.html#af5845e4d011ab64d1ebbb8faa289c8b6">More...</a><br /></td></tr>
<tr class="separator:af5845e4d011ab64d1ebbb8faa289c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adfa32db8b3d194fc6fb2ff0edf6ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a4adfa32db8b3d194fc6fb2ff0edf6ce4">RewriteCall</a> (const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &amp;pattern, ffi::TypedFunction&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>, ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;)&gt; rewriter, <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> func)</td></tr>
<tr class="memdesc:a4adfa32db8b3d194fc6fb2ff0edf6ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a function with the given pattern and the rewriter function.  <a href="namespacetvm_1_1relax.html#a4adfa32db8b3d194fc6fb2ff0edf6ce4">More...</a><br /></td></tr>
<tr class="separator:a4adfa32db8b3d194fc6fb2ff0edf6ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51bf4cd12992d277cc20eb82881ca23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae51bf4cd12992d277cc20eb82881ca23">UsedBy</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs, int index=-1)</td></tr>
<tr class="memdesc:ae51bf4cd12992d277cc20eb82881ca23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned.  <a href="namespacetvm_1_1relax.html#ae51bf4cd12992d277cc20eb82881ca23">More...</a><br /></td></tr>
<tr class="separator:ae51bf4cd12992d277cc20eb82881ca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b594f8efba6fb6620a207fc79b46369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1b594f8efba6fb6620a207fc79b46369">operator^</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1b594f8efba6fb6620a207fc79b46369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar of UsedBy(lhs, rhs, -1).  <a href="namespacetvm_1_1relax.html#a1b594f8efba6fb6620a207fc79b46369">More...</a><br /></td></tr>
<tr class="separator:a1b594f8efba6fb6620a207fc79b46369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d3238251393e90f87314ae9ea1d773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae7d3238251393e90f87314ae9ea1d773">OnlyUsedBy</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs, int index=-1)</td></tr>
<tr class="memdesc:ae7d3238251393e90f87314ae9ea1d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create only-used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned.  <a href="namespacetvm_1_1relax.html#ae7d3238251393e90f87314ae9ea1d773">More...</a><br /></td></tr>
<tr class="separator:ae7d3238251393e90f87314ae9ea1d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af2174df5a7b6bfc1e747068c11bcdb3c">operator&gt;&gt;</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs)</td></tr>
<tr class="memdesc:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar of OnlyUsedBy(lhs, rhs, -1).  <a href="namespacetvm_1_1relax.html#af2174df5a7b6bfc1e747068c11bcdb3c">More...</a><br /></td></tr>
<tr class="separator:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf90b27a59bc837d06cb19f47ba1ce32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaf90b27a59bc837d06cb19f47ba1ce32">IsVar</a> (const ffi::String &amp;name)</td></tr>
<tr class="memdesc:aaf90b27a59bc837d06cb19f47ba1ce32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern.">VarPattern</a> with a name.  <a href="namespacetvm_1_1relax.html#aaf90b27a59bc837d06cb19f47ba1ce32">More...</a><br /></td></tr>
<tr class="separator:aaf90b27a59bc837d06cb19f47ba1ce32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad2c52b340b0a2524bdcd85d3289a18ac">IsConst</a> ()</td></tr>
<tr class="memdesc:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern.">ConstantPattern</a>.  <a href="namespacetvm_1_1relax.html#ad2c52b340b0a2524bdcd85d3289a18ac">More...</a><br /></td></tr>
<tr class="separator:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaa590000b3e0f6bf9e545786c39f4f0f">Wildcard</a> ()</td></tr>
<tr class="memdesc:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html" title="Managed reference to WildcardPatternNode.">WildcardPattern</a>.  <a href="namespacetvm_1_1relax.html#aaa590000b3e0f6bf9e545786c39f4f0f">More...</a><br /></td></tr>
<tr class="separator:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb4fdc17642caa5813a62a86cb3efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aefdb4fdc17642caa5813a62a86cb3efa">IsExpr</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aefdb4fdc17642caa5813a62a86cb3efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern.">ExprPattern</a>.  <a href="namespacetvm_1_1relax.html#aefdb4fdc17642caa5813a62a86cb3efa">More...</a><br /></td></tr>
<tr class="separator:aefdb4fdc17642caa5813a62a86cb3efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b976a18e4065076addbd70445d3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a5b7b976a18e4065076addbd70445d3fa">IsOp</a> (const ffi::String &amp;op_name)</td></tr>
<tr class="memdesc:a5b7b976a18e4065076addbd70445d3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern.">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a>.  <a href="namespacetvm_1_1relax.html#a5b7b976a18e4065076addbd70445d3fa">More...</a><br /></td></tr>
<tr class="separator:a5b7b976a18e4065076addbd70445d3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7912efc0c7d089f966c51508673ee8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a7912efc0c7d089f966c51508673ee8db">IsCallTIR</a> (const ffi::String &amp;name, ffi::Optional&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt; args=std::nullopt)</td></tr>
<tr class="memdesc:a7912efc0c7d089f966c51508673ee8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_tir (return a tensor)  <a href="namespacetvm_1_1relax.html#a7912efc0c7d089f966c51508673ee8db">More...</a><br /></td></tr>
<tr class="separator:a7912efc0c7d089f966c51508673ee8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a96a5f6db60f52ff7f401ba100bf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa8a96a5f6db60f52ff7f401ba100bf9e">IsCallTIR</a> (const ffi::String &amp;name, <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> var_args)</td></tr>
<tr class="memdesc:aa8a96a5f6db60f52ff7f401ba100bf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_tir (return a tuple of tensor)  <a href="namespacetvm_1_1relax.html#aa8a96a5f6db60f52ff7f401ba100bf9e">More...</a><br /></td></tr>
<tr class="separator:aa8a96a5f6db60f52ff7f401ba100bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e11264a4f3bd4e62a912b04cd974023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a8e11264a4f3bd4e62a912b04cd974023">IsCallDPSPacked</a> (const ffi::String &amp;name, ffi::Optional&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt; args=std::nullopt)</td></tr>
<tr class="memdesc:a8e11264a4f3bd4e62a912b04cd974023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_dps_packed (return a tensor)  <a href="namespacetvm_1_1relax.html#a8e11264a4f3bd4e62a912b04cd974023">More...</a><br /></td></tr>
<tr class="separator:a8e11264a4f3bd4e62a912b04cd974023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a7f47b3f4508bf3d1f68094cae59c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a89a7f47b3f4508bf3d1f68094cae59c4">IsCallDPSPacked</a> (const ffi::String &amp;name, <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> var_args)</td></tr>
<tr class="memdesc:a89a7f47b3f4508bf3d1f68094cae59c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_dps_packed (return a tuple of tensor)  <a href="namespacetvm_1_1relax.html#a89a7f47b3f4508bf3d1f68094cae59c4">More...</a><br /></td></tr>
<tr class="separator:a89a7f47b3f4508bf3d1f68094cae59c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ce90c18674c873c97549155a0ce111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a66ce90c18674c873c97549155a0ce111">IsTuple</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &gt; &amp;fields, bool unordered=false)</td></tr>
<tr class="memdesc:a66ce90c18674c873c97549155a0ce111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html" title="Managed reference to TuplePatternNode.">TuplePattern</a> or <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html" title="Managed reference to UnorderedTuplePatternNode.">UnorderedTuplePattern</a> (unordered=true)  <a href="namespacetvm_1_1relax.html#a66ce90c18674c873c97549155a0ce111">More...</a><br /></td></tr>
<tr class="separator:a66ce90c18674c873c97549155a0ce111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af6cb1e75374b6a5d61f9464ffcedd5ee">IsTupleGetItem</a> (const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> tuple, int index=-1)</td></tr>
<tr class="memdesc:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html" title="Managed reference to TupleGetItemPatternNode.">TupleGetItemPattern</a>.  <a href="namespacetvm_1_1relax.html#af6cb1e75374b6a5d61f9464ffcedd5ee">More...</a><br /></td></tr>
<tr class="separator:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75740f5aac40453e46fbfbd99a683f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a75740f5aac40453e46fbfbd99a683f4d">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> call, ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; opt_op=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(), ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt; opt_args=ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt; opt_attrs=ffi::Optional&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;(), ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt; opt_sinfo_args=ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:a75740f5aac40453e46fbfbd99a683f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>call</code> with the given properties. A null property denotes 'no change'. Returns <code>call</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="namespacetvm_1_1relax.html#a75740f5aac40453e46fbfbd99a683f4d">More...</a><br /></td></tr>
<tr class="separator:a75740f5aac40453e46fbfbd99a683f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e9ffbb5672aabc29894ce2af41a26a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad2e9ffbb5672aabc29894ce2af41a26a">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> tuple, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt; opt_fields=ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:ad2e9ffbb5672aabc29894ce2af41a26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>tuple</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="namespacetvm_1_1relax.html#ad2e9ffbb5672aabc29894ce2af41a26a">More...</a><br /></td></tr>
<tr class="separator:ad2e9ffbb5672aabc29894ce2af41a26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92393e4bcd4552332e8ffccd99dc675e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a92393e4bcd4552332e8ffccd99dc675e">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a> tuple_get_item, ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; opt_tuple=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; opt_index=ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:a92393e4bcd4552332e8ffccd99dc675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>tuple_get_item</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple_get_item</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="namespacetvm_1_1relax.html#a92393e4bcd4552332e8ffccd99dc675e">More...</a><br /></td></tr>
<tr class="separator:a92393e4bcd4552332e8ffccd99dc675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7341dfff4eb8c8f5db32bc5e84b968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#abd7341dfff4eb8c8f5db32bc5e84b968">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1If.html">If</a> if_expr, ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; opt_cond=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(), ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; opt_true_branch=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(), ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; opt_false_branch=ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(), ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:abd7341dfff4eb8c8f5db32bc5e84b968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>if_expr</code> with the given properties. A null property denotes 'no change'. Returns <code>if_expr</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="namespacetvm_1_1relax.html#abd7341dfff4eb8c8f5db32bc5e84b968">More...</a><br /></td></tr>
<tr class="separator:abd7341dfff4eb8c8f5db32bc5e84b968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed72bed8b9182caf234b2ddae778c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afed72bed8b9182caf234b2ddae778c39">GetShapeOf</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:afed72bed8b9182caf234b2ddae778c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shape of Expr.  <a href="namespacetvm_1_1relax.html#afed72bed8b9182caf234b2ddae778c39">More...</a><br /></td></tr>
<tr class="separator:afed72bed8b9182caf234b2ddae778c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8591e3bb5b5ca5ca31964916f27ac1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af8591e3bb5b5ca5ca31964916f27ac1a">PostOrderVisit</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;node, std::function&lt; void(const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;)&gt; fvisit)</td></tr>
<tr class="separator:af8591e3bb5b5ca5ca31964916f27ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc02e3f6e603613190eff65a679ea38c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:adc02e3f6e603613190eff65a679ea38c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#adc02e3f6e603613190eff65a679ea38c">ForEachLeaf</a> (const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;msg, FType fvisit)</td></tr>
<tr class="memdesc:adc02e3f6e603613190eff65a679ea38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply fvisit for each leaf elements in the nested message.  <a href="namespacetvm_1_1relax.html#adc02e3f6e603613190eff65a679ea38c">More...</a><br /></td></tr>
<tr class="separator:adc02e3f6e603613190eff65a679ea38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff256c278f6c4493843a3b8fe5703092"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:aff256c278f6c4493843a3b8fe5703092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aff256c278f6c4493843a3b8fe5703092">Equal</a> (const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;rhs, FType fequal)</td></tr>
<tr class="memdesc:aff256c278f6c4493843a3b8fe5703092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively compare two nested messages.  <a href="namespacetvm_1_1relax.html#aff256c278f6c4493843a3b8fe5703092">More...</a><br /></td></tr>
<tr class="separator:aff256c278f6c4493843a3b8fe5703092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411130ea776624757d25953c0afd23e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:a411130ea776624757d25953c0afd23e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a411130ea776624757d25953c0afd23e4">MapToNestedMsg</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, FType fmapleaf)</td></tr>
<tr class="memdesc:a411130ea776624757d25953c0afd23e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map expr with possible nested-tuple to nested message.  <a href="namespacetvm_1_1relax.html#a411130ea776624757d25953c0afd23e4">More...</a><br /></td></tr>
<tr class="separator:a411130ea776624757d25953c0afd23e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ac0cb404c219dc00406a5cc62687b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:ad13ac0cb404c219dc00406a5cc62687b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad13ac0cb404c219dc00406a5cc62687b">MapToNestedMsg</a> (<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> sinfo, FType fmapleaf)</td></tr>
<tr class="memdesc:ad13ac0cb404c219dc00406a5cc62687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map structinfo with possible nested-sinfo to nested message.  <a href="namespacetvm_1_1relax.html#ad13ac0cb404c219dc00406a5cc62687b">More...</a><br /></td></tr>
<tr class="separator:ad13ac0cb404c219dc00406a5cc62687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca8353ff150a403bc950cc945776d51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:acca8353ff150a403bc950cc945776d51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#acca8353ff150a403bc950cc945776d51">MapToNestedMsgBySInfo</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, FType fmapleaf)</td></tr>
<tr class="memdesc:acca8353ff150a403bc950cc945776d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map expr with possible nested-tuple to nested message.  <a href="namespacetvm_1_1relax.html#acca8353ff150a403bc950cc945776d51">More...</a><br /></td></tr>
<tr class="separator:acca8353ff150a403bc950cc945776d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e390702bd71ff0ce2e0a8f1cb07b7d2"><td class="memTemplParams" colspan="2">template&lt;typename TargetType , typename T , typename FMapLeaf , typename FCombine &gt; </td></tr>
<tr class="memitem:a6e390702bd71ff0ce2e0a8f1cb07b7d2"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a6e390702bd71ff0ce2e0a8f1cb07b7d2">NestedMsgTo</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FMapLeaf fmapleaf, FCombine fcombine)</td></tr>
<tr class="memdesc:a6e390702bd71ff0ce2e0a8f1cb07b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map nested message back to TargetType.  <a href="namespacetvm_1_1relax.html#a6e390702bd71ff0ce2e0a8f1cb07b7d2">More...</a><br /></td></tr>
<tr class="separator:a6e390702bd71ff0ce2e0a8f1cb07b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad78aea2a337c8133df868081838a81"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:afad78aea2a337c8133df868081838a81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afad78aea2a337c8133df868081838a81">NestedMsgToExpr</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FType fmapleaf)</td></tr>
<tr class="memdesc:afad78aea2a337c8133df868081838a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map nested message back to the expr.  <a href="namespacetvm_1_1relax.html#afad78aea2a337c8133df868081838a81">More...</a><br /></td></tr>
<tr class="separator:afad78aea2a337c8133df868081838a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a22d8bde0bbaa62a91f73ff41a4e0a04e">CombineNestedMsg</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; lhs, <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; rhs, FType fcombine)</td></tr>
<tr class="memdesc:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively combine two nested message into one.  <a href="namespacetvm_1_1relax.html#a22d8bde0bbaa62a91f73ff41a4e0a04e">More...</a><br /></td></tr>
<tr class="separator:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7002f60ee447156bbf2e376782bf70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:aba7002f60ee447156bbf2e376782bf70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aba7002f60ee447156bbf2e376782bf70">MapNestedMsg</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FType fmapleaf)</td></tr>
<tr class="memdesc:aba7002f60ee447156bbf2e376782bf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively map a nested message to another one, with leaf mapped by the input fmapleaf.  <a href="namespacetvm_1_1relax.html#aba7002f60ee447156bbf2e376782bf70">More...</a><br /></td></tr>
<tr class="separator:aba7002f60ee447156bbf2e376782bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae78e913eed24a1c178d68acf66aa9e9c">DecomposeNestedMsg</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FType fvisitleaf)</td></tr>
<tr class="memdesc:ae78e913eed24a1c178d68acf66aa9e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively decompose the tuple structure in expr and msg along with it.  <a href="namespacetvm_1_1relax.html#ae78e913eed24a1c178d68acf66aa9e9c">More...</a><br /></td></tr>
<tr class="separator:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3028c04ea455bd0ae3643978fd69d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename FType &gt; </td></tr>
<tr class="memitem:a58d3028c04ea455bd0ae3643978fd69d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a58d3028c04ea455bd0ae3643978fd69d">TransformTupleLeaf</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt; msgs, FType ftransleaf)</td></tr>
<tr class="memdesc:a58d3028c04ea455bd0ae3643978fd69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively transform the tuple structure in expr and msgs along with it.  <a href="namespacetvm_1_1relax.html#a58d3028c04ea455bd0ae3643978fd69d">More...</a><br /></td></tr>
<tr class="separator:a58d3028c04ea455bd0ae3643978fd69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c79f0abeaed5e66b76febd08a3fcb7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename FType &gt; </td></tr>
<tr class="memitem:a22c79f0abeaed5e66b76febd08a3fcb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a22c79f0abeaed5e66b76febd08a3fcb7">TransformTupleLeaf</a> (<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> sinfo, std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt; msgs, FType ftransleaf)</td></tr>
<tr class="memdesc:a22c79f0abeaed5e66b76febd08a3fcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively transform the tuple structure in sinfo and msgs along with it.  <a href="namespacetvm_1_1relax.html#a22c79f0abeaed5e66b76febd08a3fcb7">More...</a><br /></td></tr>
<tr class="separator:a22c79f0abeaed5e66b76febd08a3fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c79ee1a7b2c78d2c74a4595f1ccee3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6c79ee1a7b2c78d2c74a4595f1ccee3"><td class="memTemplItemLeft" align="right" valign="top">ffi::Optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae6c79ee1a7b2c78d2c74a4595f1ccee3">MatchStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae6c79ee1a7b2c78d2c74a4595f1ccee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and check if expr have <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> T and return it.  <a href="namespacetvm_1_1relax.html#ae6c79ee1a7b2c78d2c74a4595f1ccee3">More...</a><br /></td></tr>
<tr class="separator:ae6c79ee1a7b2c78d2c74a4595f1ccee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1cc7fa75a25650e3846c2cde062d96e2">GetStructInfoAs</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a1cc7fa75a25650e3846c2cde062d96e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the structure info of a given expr and try to cast it as const T*.  <a href="namespacetvm_1_1relax.html#a1cc7fa75a25650e3846c2cde062d96e2">More...</a><br /></td></tr>
<tr class="separator:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80dd203171d2efc5553d3fe8d4e3945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab80dd203171d2efc5553d3fe8d4e3945">GetStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab80dd203171d2efc5553d3fe8d4e3945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying structure info of expr.  <a href="namespacetvm_1_1relax.html#ab80dd203171d2efc5553d3fe8d4e3945">More...</a><br /></td></tr>
<tr class="separator:ab80dd203171d2efc5553d3fe8d4e3945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">HasVoidStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the expr has void struct info.  <a href="namespacetvm_1_1relax.html#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">More...</a><br /></td></tr>
<tr class="separator:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab521e5660159c700a02f430290430592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab521e5660159c700a02f430290430592">UpdateStructInfo</a> (<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> expr, <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> struct_info)</td></tr>
<tr class="memdesc:ab521e5660159c700a02f430290430592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the struct info of an Expr.  <a href="namespacetvm_1_1relax.html#ab521e5660159c700a02f430290430592">More...</a><br /></td></tr>
<tr class="separator:ab521e5660159c700a02f430290430592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950d79a8b6b5c96e8c8bc3af407d1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a7950d79a8b6b5c96e8c8bc3af407d1e9">Bind</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr, const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;binds, const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;symbolic_var_map={})</td></tr>
<tr class="memdesc:a7950d79a8b6b5c96e8c8bc3af407d1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the variables to a Relax expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> any free variables are introduced into a function, those are added to the function parameters. Additionally this may change the order of parameters if you map a variable to a variable.  <a href="namespacetvm_1_1relax.html#a7950d79a8b6b5c96e8c8bc3af407d1e9">More...</a><br /></td></tr>
<tr class="separator:a7950d79a8b6b5c96e8c8bc3af407d1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf32b8d9c0986244999342c7ea16453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a2bf32b8d9c0986244999342c7ea16453">Bind</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;sinfo, const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;symbolic_var_map)</td></tr>
<tr class="memdesc:a2bf32b8d9c0986244999342c7ea16453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the symbolic variables to a <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a>. This is a helper function usually called by other pass functions to help optimizations.  <a href="namespacetvm_1_1relax.html#a2bf32b8d9c0986244999342c7ea16453">More...</a><br /></td></tr>
<tr class="separator:a2bf32b8d9c0986244999342c7ea16453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7c4e3aec7a2ce1ea3beba0eaec9a67"><td class="memItemLeft" align="right" valign="top">tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaf7c4e3aec7a2ce1ea3beba0eaec9a67">InferSymbolicVarMap</a> (const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">relax::Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">relax::Expr</a> &gt; &amp;binds, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:aaf7c4e3aec7a2ce1ea3beba0eaec9a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer a binding map for symbolic variables.  <a href="namespacetvm_1_1relax.html#aaf7c4e3aec7a2ce1ea3beba0eaec9a67">More...</a><br /></td></tr>
<tr class="separator:aaf7c4e3aec7a2ce1ea3beba0eaec9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d949ba3b55902d53afd3c179f05287"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af4d949ba3b55902d53afd3c179f05287">IsBoolStructInfo</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;sinfo, bool permit_unknown_rank=true, bool permit_unknown_dtype=true)</td></tr>
<tr class="memdesc:af4d949ba3b55902d53afd3c179f05287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> is for a boolean scalar (tensor of rank 0 with a boolean dtype).  <a href="namespacetvm_1_1relax.html#af4d949ba3b55902d53afd3c179f05287">More...</a><br /></td></tr>
<tr class="separator:af4d949ba3b55902d53afd3c179f05287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ade67ebcba4b40c0e0c38c0ddd3279131">IsLeafOrTuple</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given expression is a "leaf" node or tuple node for normalization purposes.  <a href="namespacetvm_1_1relax.html#ade67ebcba4b40c0e0c38c0ddd3279131">More...</a><br /></td></tr>
<tr class="separator:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91202291e3d31370f2bfab2b8934723a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a91202291e3d31370f2bfab2b8934723a">IsImpureCall</a> (const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call)</td></tr>
<tr class="memdesc:a91202291e3d31370f2bfab2b8934723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> node is an impure operation. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the callee is a general expression, this simply requires checking the purity field of the <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode.">FuncStructInfo</a>. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> it is an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a>, then this checks the <code>fPurity</code> field.  <a href="namespacetvm_1_1relax.html#a91202291e3d31370f2bfab2b8934723a">More...</a><br /></td></tr>
<tr class="separator:a91202291e3d31370f2bfab2b8934723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e1446608b37ab892b51acd178ef4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a28e1446608b37ab892b51acd178ef4b1">CopyWithNewVars</a> (<a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> func)</td></tr>
<tr class="memdesc:a28e1446608b37ab892b51acd178ef4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given function. All variables that are bound inside the original function would be copied to satisfy the restriction in the well-formed check: Variables in Relax must be bound exactly once. This also ensures that both the function and its copy can be inserted into the same <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>, and be asserted on the structural equality agaisnt <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> created by TVMScript.  <a href="namespacetvm_1_1relax.html#a28e1446608b37ab892b51acd178ef4b1">More...</a><br /></td></tr>
<tr class="separator:a28e1446608b37ab892b51acd178ef4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1804479b52f4fadfbd2baa078e577cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1804479b52f4fadfbd2baa078e577cfe">ToNonDataflow</a> (const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a1804479b52f4fadfbd2baa078e577cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all dataflow structure to non-dataflow version.  <a href="namespacetvm_1_1relax.html#a1804479b52f4fadfbd2baa078e577cfe">More...</a><br /></td></tr>
<tr class="separator:a1804479b52f4fadfbd2baa078e577cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12a64be1ff95eac3cc837f12ad0e5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af12a64be1ff95eac3cc837f12ad0e5d0">GetBoundValue</a> (const <a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a> &amp;b)</td></tr>
<tr class="memdesc:af12a64be1ff95eac3cc837f12ad0e5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value bound in the binding.  <a href="namespacetvm_1_1relax.html#af12a64be1ff95eac3cc837f12ad0e5d0">More...</a><br /></td></tr>
<tr class="separator:af12a64be1ff95eac3cc837f12ad0e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac287c47b30d1126e4017da1b96957fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac287c47b30d1126e4017da1b96957fa0">&#9670;&nbsp;</a></span>Expr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">tvm::relax::Expr</a> = typedef <a class="el" href="classtvm_1_1RelaxExpr.html">RelaxExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71b7f14f445c67648c3849d69ea8f5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b7f14f445c67648c3849d69ea8f5bc">&#9670;&nbsp;</a></span>ExprNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a71b7f14f445c67648c3849d69ea8f5bc">tvm::relax::ExprNode</a> = typedef <a class="el" href="classtvm_1_1RelaxExprNode.html">RelaxExprNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a496b1f2440af7d57184d0d793fe5fd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496b1f2440af7d57184d0d793fe5fd2c">&#9670;&nbsp;</a></span>FCallPacked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a496b1f2440af7d57184d0d793fe5fd2c">tvm::relax::FCallPacked</a> = typedef ffi::String</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packed function implementation for operators. The relax operator will be lowered to this packed function call during codegen. </p>

</div>
</div>
<a id="a5bd2b1d07a3f88e22320b95cd02a5383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd2b1d07a3f88e22320b95cd02a5383">&#9670;&nbsp;</a></span>FCodegen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a5bd2b1d07a3f88e22320b95cd02a5383">tvm::relax::FCodegen</a> = typedef ffi::TypedFunction&lt;ffi::Array&lt;ffi::Any&gt;(ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1MatchResult.html">MatchResult</a>&gt; match_results)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a785a8c88785c92ac51caffa58a49a5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785a8c88785c92ac51caffa58a49a5fc">&#9670;&nbsp;</a></span>FInferStructInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a785a8c88785c92ac51caffa58a49a5fc">tvm::relax::FInferStructInfo</a> = typedef ffi::TypedFunction&lt;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer output struct info given the call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5a6ed68c50ce093ea96351e8d983ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a6ed68c50ce093ea96351e8d983ea4">&#9670;&nbsp;</a></span>FLegalize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ad5a6ed68c50ce093ea96351e8d983ea4">tvm::relax::FLegalize</a> = typedef ffi::TypedFunction&lt;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; bb, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of a legalization function. </p>
<p>A legalization function is used to replace a <code><a class="el" href="classtvm_1_1relax_1_1Call.html">relax::Call</a></code> with more concrete implementations. For example, the operation <code>relax.op.add</code> may be replaced with a call to a TIR function implementing addition of two tensors.</p>
<p>The purpose of <code>FLegalize</code> is to remove calls to the operator while lowering. Therefore, unlike <code>FNormalize</code>, the resulting expression may <em>not</em> contain the original operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> context. </td></tr>
    <tr><td class="paramname">call</td><td>The call to be legalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae51243f350e2459b5dfc51741202b0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51243f350e2459b5dfc51741202b0d2">&#9670;&nbsp;</a></span>FLowerBuiltin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ae51243f350e2459b5dfc51741202b0d2">tvm::relax::FLowerBuiltin</a> = typedef ffi::TypedFunction&lt;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; bb, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of a function to lower the runtime builtin. </p>
<p>A builtin function may be lowered to a lowered form in <code>LowerRuntimeBuiltin</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> context. </td></tr>
    <tr><td class="paramname">call</td><td>The call to be lowered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f50c4ff744c12ce98ae9baff16e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f50c4ff744c12ce98ae9baff16e039">&#9670;&nbsp;</a></span>FNormalize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ac7f50c4ff744c12ce98ae9baff16e039">tvm::relax::FNormalize</a> = typedef ffi::TypedFunction&lt;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; bb, <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> call)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of a normalization function. </p>
<p>A normalization function is used when a <code><a class="el" href="classtvm_1_1relax_1_1Call.html">relax::Call</a></code> may be expressed in multiple syntactically valid and semantically equivalent forms, to normalize to a single representation.</p>
<p>Note: <code>FNormalize</code> is applied for each expression as part of the <code><a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">relax::BlockBuilder</a></code>. While operator-specific validation may be performed within the <code>FNormalize</code> implementation, ensuring that errors are caught as early as possible, this should only be used when validation is fast to apply. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the validation logic may be slow, it should instead be implemented in <code>FValidate</code>, which is only run as part of the well-formed checker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> context.</td></tr>
    <tr><td class="paramname">call</td><td>The call to be normalized. It is provided by-value, to avoid copies for the common case where the call is already normalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae500b48c6aeb83a0bdd72bf8fb022d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae500b48c6aeb83a0bdd72bf8fb022d47">&#9670;&nbsp;</a></span>FPrimalGradient</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ae500b48c6aeb83a0bdd72bf8fb022d47">tvm::relax::FPrimalGradient</a> = typedef ffi::TypedFunction&lt;tvm::ffi::Array&lt;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt;( const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&amp; orig_var, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; orig_call, const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&amp; output_grad, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gradient for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_var</td><td>the original var corresponding to orig_call. </td></tr>
    <tr><td class="paramname">orig_call</td><td>the original Call(op) expr. </td></tr>
    <tr><td class="paramname">output_grad</td><td>the gradient of the Expr. </td></tr>
    <tr><td class="paramname">ctx</td><td>the current block builder context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gradient for each parameter. </dd></dl>

</div>
</div>
<a id="a40f7cc3741498211157c83d236d3eb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f7cc3741498211157c83d236d3eb7a">&#9670;&nbsp;</a></span>FValidate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a40f7cc3741498211157c83d236d3eb7a">tvm::relax::FValidate</a> = typedef ffi::TypedFunction&lt;void(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of a validation function. </p>
<p>A validation function is used to define constraints that should be verified for an operator as part of the well-formed checker.</p>
<p>Note: <code>FValidate</code> is only applied as part of the well-formed checker. While this minimizes overhead while compiling Relax, this delay between generating an ill-formed <code><a class="el" href="classtvm_1_1relax_1_1Call.html">relax::Call</a></code> and identifying the ill-formed call may complicate debugging. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the validation logic is very fast to check, and doing so would not introduce a significant overhead, consider validating as part of <code>FNormalize</code>, which is applied by the block builder for each <code><a class="el" href="classtvm_1_1relax_1_1Call.html">relax::Call</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call to be validated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30be57dbb36533467727929c21bd237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30be57dbb36533467727929c21bd237">&#9670;&nbsp;</a></span>StructInfoDeriveFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#af30be57dbb36533467727929c21bd237">tvm::relax::StructInfoDeriveFunc</a> = typedef <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>custom-defined <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> derivation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived struct info of the call. </dd></dl>

</div>
</div>
<a id="a06538b181df82292bdb5f73d6f21de94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06538b181df82292bdb5f73d6f21de94">&#9670;&nbsp;</a></span>TensorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1relax_1_1TensorType.html">tvm::relax::TensorType</a> = typedef <a class="el" href="classtvm_1_1relax_1_1TensorType.html">TensorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa23883a54f4c8a912ac3122b89aa06a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23883a54f4c8a912ac3122b89aa06a9">&#9670;&nbsp;</a></span>TensorTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1relax_1_1TensorTypeNode.html">tvm::relax::TensorTypeNode</a> = typedef <a class="el" href="classtvm_1_1relax_1_1TensorTypeNode.html">TensorTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4609a7fed731069af110d2ba9965246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4609a7fed731069af110d2ba9965246">&#9670;&nbsp;</a></span>TIRPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ae4609a7fed731069af110d2ba9965246">tvm::relax::TIRPattern</a> = typedef <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a04ee98afc287f8466486f83957bbceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ee98afc287f8466486f83957bbceb2">&#9670;&nbsp;</a></span>BaseCheckResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">tvm::relax::BaseCheckResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fine grained result of base check. </p>
<p>This analysis comes with different levels of checking failures that can help to customize the compilation decisions.</p>
<p>For a given pair of lhs_struct_info, rhs_struct_info. We adopt the following terminology:</p><ul>
<li>LSet = {value | value matches lhs_struct_info}</li>
<li>RSet = {value | value matches rhs_struct_info}</li>
</ul>
<p>See the definition of each level below. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2aea0d6c7bc4e0f3e1ae27af5ab8d3ead1"></a>kFailL0&#160;</td><td class="fielddoc"><p>The two value sets have no intersection at all: Interset(LSet, RSet) = empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a44bf4c796712d49aa9e166a28b5b4877"></a>kFailL1&#160;</td><td class="fielddoc"><p>LSet is not superset of RSet by only looking at static information. </p>
<dl class="section note"><dt>Note</dt><dd>This level will trigger static type checking error when lhs is param and rhs is arg. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a445a5e4200190564cfb0a1a85823831f"></a>kFailL2&#160;</td><td class="fielddoc"><p>WLSet is not superset of RSet because of mismatch in value information. </p>
<p>L1-level mismatches in params of <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode.">FuncStructInfo</a> is categorized as <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> lhs is <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode.">FuncStructInfo</a>, then L1-level mismatch in its params is categorized as L2-level mismatch for lhs.</p>
<p>Design considerations for functions:</p><ul>
<li>(a) We want to be able to erase type/value in function signature when we unify function struct info and preserve simpler representations.</li>
<li>(b) We automatically insert match_cast at function boundary, so we can erase (int)-&gt;int argument as (object)-&gt;int. The input shape/type mismatch will be detected by runtime checks at function boundary. This behavior is also consistent with the ffi::Function behavior.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This level means there is no problem about static known information. It is OK for the checker to do best effort and return this value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a42b60afb2c7698ee5c4d41840ca1210e"></a>kPass&#160;</td><td class="fielddoc"><p>LSet is superset of RSet. </p>
</td></tr>
</table>

</div>
</div>
<a id="acffa9e980a7331f2eb89cce97f2e3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffa9e980a7331f2eb89cce97f2e3575">&#9670;&nbsp;</a></span>OpPatternKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575">tvm::relax::OpPatternKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575a7a3fb5d59f4cd93830b2188ec6c263c5"></a>kElemWise&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575abea71ce5432e0ebfa7039b36f018e26e"></a>kBroadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575aad7813b18db6196460bcd45dc8cd4567"></a>kInjective&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575ace8074089a6395be731ae800adcceb97"></a>kCommReduce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575aaacd35420305d82c6ef118ed5d982a1c"></a>kOutEWiseFusable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575a6a77a35dd616597cb7186487d6f076cc"></a>kTuple&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acffa9e980a7331f2eb89cce97f2e3575a15ea1f34cc6d4a52372b78fca0bda8b9"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab9d29a9c41dcc0ec7eefef20f5d7b5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d29a9c41dcc0ec7eefef20f5d7b5eb">&#9670;&nbsp;</a></span>AllGlobalVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Array&lt;<a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a>&gt; tvm::relax::AllGlobalVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all global variables from expression expr. </p>
<p>AllVars is a superset of BoundVars and FreeVars. The union of BoundVars and FreeVars is Allvars.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all global variables, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="ad03b98266ae240c3f58583712bb02049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03b98266ae240c3f58583712bb02049">&#9670;&nbsp;</a></span>AllVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::AllVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all variables from expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="aaae97ce4a915c7c0f1088ed61261e1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae97ce4a915c7c0f1088ed61261e1f0">&#9670;&nbsp;</a></span>AnalyzeOpPatternKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#acffa9e980a7331f2eb89cce97f2e3575">OpPatternKind</a> tvm::relax::AnalyzeOpPatternKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind for PrimFunc, which is used in relax FuseOps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The PrimFunc to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This analysis applies on TIR function but is primarily used by relax passes. As a result we place it under the relax namespace. </dd></dl>

</div>
</div>
<a id="af9cf989d5c92bb59a166f6748d27131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cf989d5c92bb59a166f6748d27131d">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfb</td><td>The dataflow block to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="a05c9ea2b6e6f12ad0d40a1f02af04a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c9ea2b6e6f12ad0d40a1f02af04a1b">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="a722f1672eb1feb9a3be7b7683ccbb290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722f1672eb1feb9a3be7b7683ccbb290">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="a7950d79a8b6b5c96e8c8bc3af407d1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7950d79a8b6b5c96e8c8bc3af407d1e9">&#9670;&nbsp;</a></span>Bind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbolic_var_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the variables to a Relax expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> any free variables are introduced into a function, those are added to the function parameters. Additionally this may change the order of parameters if you map a variable to a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">binds</td><td>The variable to expression map that will be used to help the binding. </td></tr>
    <tr><td class="paramname">symbolic_var_map</td><td>The map from symbolic var to the expr it binds to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated expression. </dd></dl>

</div>
</div>
<a id="a2bf32b8d9c0986244999342c7ea16453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf32b8d9c0986244999342c7ea16453">&#9670;&nbsp;</a></span>Bind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>sinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbolic_var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the symbolic variables to a <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a>. This is a helper function usually called by other pass functions to help optimizations. </p>

</div>
</div>
<a id="ae4ef624ea81426dce933d433512deae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef624ea81426dce933d433512deae3">&#9670;&nbsp;</a></span>BoundVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from expression expr. </p>
<p>Bound variables are all variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="aafb0d355ea6891b47940c7bf24a55d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0d355ea6891b47940c7bf24a55d8b">&#9670;&nbsp;</a></span>CanProveShapeEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::CanProveShapeEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can prove the two symbolic shape expressions equals to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>The analyzer used for integer analysis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does best effort prove, which means if result is false, there is still possibility that two shapes equals to each other during runtime. </dd></dl>

</div>
</div>
<a id="a6d99a4dc10bb283daa818463a1d3d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d99a4dc10bb283daa818463a1d3d04e">&#9670;&nbsp;</a></span>CanProveShapeEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::CanProveShapeEqual </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can prove the two symbolic shape arrays equals to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>The analyzer used for integer analysis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prove result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does best effort prove, which means if result is false, there is still possibility that two shapes equals to each other during runtime. </dd></dl>

</div>
</div>
<a id="a9235885a259d3adfce6e8efca1b9066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9235885a259d3adfce6e8efca1b9066a">&#9670;&nbsp;</a></span>CollectNonNegativeExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::relax::CollectNonNegativeExpressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>sinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect expressions whose usage requires them to be non-negative. </p>
<p>Any <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a> that is used as a tensor shape, or as an element in a <a class="el" href="classtvm_1_1relax_1_1ShapeExpr.html">ShapeExpr</a>, may not be negative. This utility function can be used to generate assertions prior to calling a kernel, or to provide assumptions within a kernel that may be useful for simplification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The struct info to be analyzed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of non-negative expressions. </dd></dl>

</div>
</div>
<a id="afd6df7d984c8ca85b632dce561b84531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6df7d984c8ca85b632dce561b84531">&#9670;&nbsp;</a></span>CollectVarUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtvm_1_1relax_1_1VarUsageInfo.html">VarUsageInfo</a> tvm::relax::CollectVarUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect variable bindings and usage. </p>
<p>This function is equivalent to calling both FunctionUseDef and AnalyzeVar2Value, but requires only a single traversal of the expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to analyze</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The collected information </dd></dl>

</div>
</div>
<a id="a22d8bde0bbaa62a91f73ff41a4e0a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d8bde0bbaa62a91f73ff41a4e0a04e">&#9670;&nbsp;</a></span>CombineNestedMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::CombineNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fcombine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively combine two nested message into one. </p>
<p>This function requires the two messages to be compatible with each other. The combination rule is as follows:</p><ul>
<li>combine(null, msg) =&gt; msg</li>
<li>combine(leaf1, leaf2) =&gt; fcombine(leaf1, leaf2)</li>
<li>combine(array1, array2) =&gt; [combine(x, y) for x, y in zip(array1, array2)]</li>
<li>This function will throw an error if array have different size</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">fcombine</td><td>with signature T fcombine(T lhs, T rhs) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>combine function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91f6936f70633ea84fc984a55a13fed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f6936f70633ea84fc984a55a13fed6">&#9670;&nbsp;</a></span>ComputableAtCompileTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::ComputableAtCompileTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a205aa2060f1e013a9e72666a2a0b41e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205aa2060f1e013a9e72666a2a0b41e3">&#9670;&nbsp;</a></span>ContainsImpureCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::ContainsImpureCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>own_name</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;(std::nullopt)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given expression (likely a function body) contains any impure calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be examined. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> expr is a function, we check the body. </td></tr>
    <tr><td class="paramname">own_name</td><td>(Optional.) <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> we are checking a recursive function body, the caller can pass the function's name so recursive calls can be ignored in the check (must be a <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> or <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the expression contains any impure calls. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Relies on <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> annotations, so ensure that the module has been normalized first. Also, an impure call in a <em>nested</em> function does <em>not</em> mean that the outer expression contains an impure call&ndash;it only does if the nested function is <em>later called</em>. </dd></dl>

</div>
</div>
<a id="a28e1446608b37ab892b51acd178ef4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e1446608b37ab892b51acd178ef4b1">&#9670;&nbsp;</a></span>CopyWithNewVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> tvm::relax::CopyWithNewVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given function. All variables that are bound inside the original function would be copied to satisfy the restriction in the well-formed check: Variables in Relax must be bound exactly once. This also ensures that both the function and its copy can be inserted into the same <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>, and be asserted on the structural equality agaisnt <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> created by TVMScript. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The relax function to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copied function. </dd></dl>

</div>
</div>
<a id="aa69809a1998b173f456c43ee4877276e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69809a1998b173f456c43ee4877276e">&#9670;&nbsp;</a></span>DataflowBlockUseDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt; tvm::relax::DataflowBlockUseDef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the use-def chain of variables inside a dataflow block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfb</td><td>The dataflow block to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map mapping variable definitions to a set of uses. </dd></dl>

</div>
</div>
<a id="ae78e913eed24a1c178d68acf66aa9e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78e913eed24a1c178d68acf66aa9e9c">&#9670;&nbsp;</a></span>DecomposeNestedMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::DecomposeNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fvisitleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively decompose the tuple structure in expr and msg along with it. </p>
<p>This function will call fvisitleaf for each leaf expression in expr. This function will throw an error if the nesting structure in msg does not match the tuple nesting structure in expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression to be decomposed. </td></tr>
    <tr><td class="paramname">msg</td><td>The input nested message. </td></tr>
    <tr><td class="paramname">fvisitleaf</td><td>with signature fvisitleaf(Expr expr, NestedMsg&lt;T&gt; msg) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The visit function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54d2a6cdb84b007c9a32c0ff1e247ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d2a6cdb84b007c9a32c0ff1e247ee1">&#9670;&nbsp;</a></span>DefinableTIRVarsInStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>&gt; tvm::relax::DefinableTIRVarsInStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>sinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TIR variables that appear in the input struct info. </p>
<p>Returns all symbolic variables that are definable based on, and used within, the <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The struct info object to be analyzed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of (definable,used) TIR variables. Both lists are deduplicated, each TIR variable will appear at most once, and in order of occurrence. </dd></dl>

</div>
</div>
<a id="abe7f1d01021ff6fecf49feb0cedd60b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7f1d01021ff6fecf49feb0cedd60b1">&#9670;&nbsp;</a></span>DefinedSymbolicVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>&gt; tvm::relax::DefinedSymbolicVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TIR variables that defined in the input function. The returned list is deduplicated - each TIR variable will appear at most once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The relax expression (e.g. a <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>) to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of TIR variables that are defined in the input function. </dd></dl>

</div>
</div>
<a id="abfc2189e6a25f2df774b38c7d72f23f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc2189e6a25f2df774b38c7d72f23f9">&#9670;&nbsp;</a></span>DeriveCallRetStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::DeriveCallRetStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Derive the call's ret value struct info from inputs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>The function struct info. </td></tr>
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived struct info of the call. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>call-&gt;op field is ignored during derivation and we only rely on information presented by func_sinfo. </dd></dl>

</div>
</div>
<a id="af998c81ee29fc6667b1f11be11125dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af998c81ee29fc6667b1f11be11125dc8">&#9670;&nbsp;</a></span>DetectRecursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Array&lt;tvm::ffi::Array&lt;<a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a>&gt; &gt; tvm::relax::DetectRecursion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all sets of recursive or mutually recursive functions in the module. </p>
<p>Two or more functions are mutually recursive if there is some cycle of references among them. For example, if there are two functions A and B, they are mutually recursive if A calls B and B calls A. Another case would be with three functions A, B, and C, where A calls B, B calls C, and C calls A.</p>
<p>(Note that functions do not have to call each other to reference each other. For example, if a function returns another function, that is still a reference that could potentially be recursive, even without a call.)</p>
<p><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> a function is simply recursive and not mutually recursive with any other, it will be reported as a group by itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all groups of mutually recursive functions. Each member of the result is a list of functions in the module that are all mutually recursive. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> a function is simply recursive and not mutually recursive with any other, then it will be listed as a group by itself. </dd></dl>

</div>
</div>
<a id="aff256c278f6c4493843a3b8fe5703092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff256c278f6c4493843a3b8fe5703092">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fequal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively compare two nested messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">fequal</td><td>The equal functor with signature bool fequal(T, T) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>the equal comparator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55d14d26c0625c9841b99d6faa9b6474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d14d26c0625c9841b99d6faa9b6474">&#9670;&nbsp;</a></span>EraseToWellDefined() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::EraseToWellDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape_var_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>var_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EraseToWellDefined variant with map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
    <tr><td class="paramname">shape_var_map</td><td>map to specify whether a symbolic shape var is defined and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">var_map</td><td>map to specify whether a var is defined in the target scope and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding erased struct info. </dd></dl>

</div>
</div>
<a id="a7b372668ea8c4e1c3b7c6b38fc3146ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b372668ea8c4e1c3b7c6b38fc3146ef">&#9670;&nbsp;</a></span>EraseToWellDefined() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::EraseToWellDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>f_shape_var_map</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>f_var_map</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the info to a corresponding more coarse grained struct info that is still well-defined(with all the vars in scope). </p>
<p>When we are returning a <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> to another scope, it is important to remember that <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> may carry dependencies on var that is not defined the other scope.</p>
<p>In such cases, it is important to call EraseToWellDefined to get another <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> that <b>only</b> contains the vars that are defined in the target scope.</p>
<p>For example, consider the following function</p>
<div class="fragment"><div class="line">@R.function</div>
<div class="line">def f(x: R.Tensor[(n, m)]):</div>
<div class="line">    k = tir.Var(<span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;int64&quot;</span>)</div>
<div class="line">    v0 = opaque_fn(x)</div>
<div class="line">    v1 = match_cast(v0, R.Tensor[(n, k)])</div>
<div class="line">    v2 : R.Tensor[(n + 1, k + 2)] = <a class="code" href="namespacetvm_1_1topi.html#a8b25c82fe78fb593e495461cc54aedc3">pad</a>(v1)</div>
<div class="line">    return v2</div>
<div class="ttc" id="anamespacetvm_1_1topi_html_a8b25c82fe78fb593e495461cc54aedc3"><div class="ttname"><a href="namespacetvm_1_1topi.html#a8b25c82fe78fb593e495461cc54aedc3">tvm::topi::pad</a></div><div class="ttdeci">tvm::te::Tensor pad(const tvm::te::Tensor &amp;t, const tvm::ffi::Array&lt; tvm::PrimExpr &gt; &amp;pad_before, tvm::ffi::Array&lt; tvm::PrimExpr &gt; pad_after=tvm::ffi::Array&lt; tvm::PrimExpr &gt;(), PrimExpr pad_value=PrimExpr(), std::string name=&quot;T_pad&quot;, std::string tag=kElementWise, std::string pad_mode=&quot;constant&quot;, const ffi::Array&lt; PrimExpr &gt; *dyn_output_shape=nullptr)</div><div class="ttdoc">Creates an operation that performs padding.</div><div class="ttdef"><b>Definition:</b> nn.h:155</div></div>
</div><!-- fragment --><p>In the above code, the return value y have shape <code>(n + 1, k + 2)</code>, However, at the level of function signature, only n, m are defined, k is undefined here.</p>
<p>When we call EraseToWellDefined(R.Tensor[(n + 1, k + 2)], fshape_var_map={n: n, m: m}), we will obtain R.Tensor(ndim=2), which is an erased info that does not depend on k(which is undefined from parameter signature).</p>
<p>However, if we call EraseToWellDefined(R.Tensor[(n + 1, m)], fshape_var_map={n: n, m: m}), Then the return value will be R.Tensor[(n + 1, m)], because both n and m are defined.</p>
<p>We can also make these var map to return a different expression. For example, EraseToWellDefined(R.Tensor[(n + 1, m)], fshape_var_map={n: 2, m: m}) will give us R.Tensor[(3, m)], where n get replaced by 2.</p>
<p>Use this function in the following scenarios:</p><ul>
<li>Decide the struct_info of expr with sub-scopes, such as <a class="el" href="classtvm_1_1relax_1_1If.html">If</a>, <a class="el" href="classtvm_1_1relax_1_1SeqExpr.html">SeqExpr</a></li>
<li>Decide the deduced return struct_info of a function that can be fully decided by params.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
    <tr><td class="paramname">f_shape_var_map</td><td>callback function to specify whether a symbolic shape var is defined and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">f_var_map</td><td>callback function to specify whether a var is defined in the target scope and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding erased struct info. </dd></dl>

</div>
</div>
<a id="a038c99139492ca7fecf8430cf919e35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038c99139492ca7fecf8430cf919e35f">&#9670;&nbsp;</a></span>ExtractMatchedExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt; &gt; tvm::relax::ExtractMatchedExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>bindings</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14ed75c6b4e2b27f1e6950fcfbc3ace0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ed75c6b4e2b27f1e6950fcfbc3ace0">&#9670;&nbsp;</a></span>FindImpureCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&gt; tvm::relax::FindImpureCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>own_name</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;(std::nullopt)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given expression (likely a function body) contains any impure calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be examined. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> expr is a function, we check the body. </td></tr>
    <tr><td class="paramname">own_name</td><td>(Optional.) <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> we are checking a recursive function body, the caller can pass the function's name so recursive calls can be ignored in the check (must be a <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> or <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The impure expression, if one exists within the given expression. Otherwise, std::nullopt. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Relies on <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> annotations, so ensure that the module has been normalized first. Also, an impure call in a <em>nested</em> function does <em>not</em> mean that the outer expression contains an impure call&ndash;it only does if the nested function is <em>later called</em>. </dd></dl>

</div>
</div>
<a id="adc02e3f6e603613190eff65a679ea38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc02e3f6e603613190eff65a679ea38c">&#9670;&nbsp;</a></span>ForEachLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::ForEachLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply fvisit for each leaf elements in the nested message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fvisit</td><td>The visit callback. </td></tr>
    <tr><td class="paramname">msg</td><td>The input nested message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>the visitor type with signature void fvisit(T) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18820bc38a0faab1e6a35acbd72bfd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18820bc38a0faab1e6a35acbd72bfd50">&#9670;&nbsp;</a></span>FreeSymbolicVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>&gt; tvm::relax::FreeSymbolicVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TIR variables that are used but not defined in the input function. The returned list is deduplicated - each TIR variable will appear at most once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The relax expression (e.g. a <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>) to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of TIR variables that are used but not defined in the input function. </dd></dl>

</div>
</div>
<a id="a9d4db78e883277e8d527650f26ad6456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4db78e883277e8d527650f26ad6456">&#9670;&nbsp;</a></span>FreeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::FreeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free type parameters from expression expr. </p>
<p>Free variables are variables that are not bound by a varbinding or a function parameter in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="afbd45f5a49fc8378666461fb076d5458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd45f5a49fc8378666461fb076d5458">&#9670;&nbsp;</a></span>FunctionUseDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt;, ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt; tvm::relax::FunctionUseDef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the use-def chain of variables inside a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be analyzed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of variable usage and variable outputs. The first element is a map from variable definitions to the set of downstream users of that definition. The second element is a list of variables whose usage occurs outside of any variable binding, typically the output body of a <a class="el" href="classtvm_1_1relax_1_1Function.html">relax::Function</a> or a <a class="el" href="classtvm_1_1relax_1_1SeqExpr.html">relax::SeqExpr</a>. </dd></dl>

</div>
</div>
<a id="af12a64be1ff95eac3cc837f12ad0e5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12a64be1ff95eac3cc837f12ad0e5d0">&#9670;&nbsp;</a></span>GetBoundValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::GetBoundValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value bound in the binding. </p>

</div>
</div>
<a id="afed72bed8b9182caf234b2ddae778c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed72bed8b9182caf234b2ddae778c39">&#9670;&nbsp;</a></span>GetShapeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::GetShapeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the shape of Expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresonding shape.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires expr to be normalized. The function will report an error if expr's <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> is not <a class="el" href="classtvm_1_1relax_1_1TensorStructInfo.html" title="Managed reference to TensorStructInfoNode.">TensorStructInfo</a>. It will try to return symbolic function when possible. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the tensor do not have a compile-time symbolic shape, the function will then choose to return <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>(relax.op.shape_of, [expr]). </dd></dl>

</div>
</div>
<a id="a76d13e1d70ccc9a43c11cda36bcc3414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d13e1d70ccc9a43c11cda36bcc3414">&#9670;&nbsp;</a></span>GetStaticType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Type.html">Type</a> tvm::relax::GetStaticType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the corresponding static type from a given struct info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding static type. </dd></dl>

</div>
</div>
<a id="ab80dd203171d2efc5553d3fe8d4e3945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80dd203171d2efc5553d3fe8d4e3945">&#9670;&nbsp;</a></span>GetStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::GetStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying structure info of expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>underlying struct info. </dd></dl>

</div>
</div>
<a id="a1cc7fa75a25650e3846c2cde062d96e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc7fa75a25650e3846c2cde062d96e2">&#9670;&nbsp;</a></span>GetStructInfoAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* tvm::relax::GetStructInfoAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the structure info of a given expr and try to cast it as const T*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer. Returns nullptr if the type does not match </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying structure info type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a0625d588e3d480f49c80c7589fe5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0625d588e3d480f49c80c7589fe5f6">&#9670;&nbsp;</a></span>HasReshapePattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::HasReshapePattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given PrimFunc is essentially doing a reshape operation. The reshape operation also includes expand_dims, squeeze, flatten, etc. </p>
<p>Here the allowed reshape pattern is: for example, assume the operation is <code>B[l_0, l_1, ..., l_b] = A[r_0, r_1, ..., r_a]</code>, we check if we can prove that the flattened index of l_0, ..., l_b under buffer B equals to the flattened index of r_0, ..., r_a under buffer A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the given PrimFunc is doing a reshape. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>According to the description above, the returned result can only be false-negative and cannot be false-positive, since whenever we cannot prove the equality, we return false. This property guarantees the safety of this function. </dd></dl>

</div>
</div>
<a id="ae0c3fe13cc8a1af27bcb32ddf15bbf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">&#9670;&nbsp;</a></span>HasVoidStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::HasVoidStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the expr has void struct info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the expr has void struct info. </dd></dl>

</div>
</div>
<a id="aaf7c4e3aec7a2ce1ea3beba0eaec9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7c4e3aec7a2ce1ea3beba0eaec9a67">&#9670;&nbsp;</a></span>InferSymbolicVarMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::relax::InferSymbolicVarMap </td>
          <td>(</td>
          <td class="paramtype">const tvm::ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">relax::Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">relax::Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer a binding map for symbolic variables. </p>
<p><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> a set of relax variables are replaced within an expression, this may result in removal of the definition site of a symbolic variable. This utility function determines the symbolic variable replacements that can be inferred based on the replaced relax variables, and can be used alongside the <code>Bind</code> utility function to replace both the relax variables and the implied symbolic variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binds</td><td>A map of relax variables to relax expressions</td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer to use for simplifications</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of TIR variables to TIR expressions </dd></dl>

</div>
</div>
<a id="ad86a717c05debf2815aee7bcbe7d61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a717c05debf2815aee7bcbe7d61e4">&#9670;&nbsp;</a></span>IsBaseOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsBaseOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the relation of two struct info to see if one subsumes another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base struct info. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived struct info. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the relation holds. </dd></dl>

</div>
</div>
<a id="af4d949ba3b55902d53afd3c179f05287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d949ba3b55902d53afd3c179f05287">&#9670;&nbsp;</a></span>IsBoolStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsBoolStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>sinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_unknown_rank</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_unknown_dtype</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> is for a boolean scalar (tensor of rank 0 with a boolean dtype). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The input <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a>. </td></tr>
    <tr><td class="paramname">permit_unknown_rank</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, it will permit the input type to have unknown rank (ndim of -1), which will require a dynamic check. </td></tr>
    <tr><td class="paramname">permit_unknown_dtype</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, it will permit the input type to have an unknown dtype (namely, void), which will require a dynamic check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the input type is a boolean scalar type (or, depending on options, has unknown rank or dtype) </dd></dl>

</div>
</div>
<a id="a8e11264a4f3bd4e62a912b04cd974023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e11264a4f3bd4e62a912b04cd974023">&#9670;&nbsp;</a></span>IsCallDPSPacked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallDPSPacked </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_dps_packed (return a tensor) </p>

</div>
</div>
<a id="a89a7f47b3f4508bf3d1f68094cae59c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a7f47b3f4508bf3d1f68094cae59c4">&#9670;&nbsp;</a></span>IsCallDPSPacked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallDPSPacked </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a>&#160;</td>
          <td class="paramname"><em>var_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_dps_packed (return a tuple of tensor) </p>

</div>
</div>
<a id="a7912efc0c7d089f966c51508673ee8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7912efc0c7d089f966c51508673ee8db">&#9670;&nbsp;</a></span>IsCallTIR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallTIR </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_tir (return a tensor) </p>

</div>
</div>
<a id="aa8a96a5f6db60f52ff7f401ba100bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a96a5f6db60f52ff7f401ba100bf9e">&#9670;&nbsp;</a></span>IsCallTIR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallTIR </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a>&#160;</td>
          <td class="paramname"><em>var_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_tir (return a tuple of tensor) </p>

</div>
</div>
<a id="ad2c52b340b0a2524bdcd85d3289a18ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c52b340b0a2524bdcd85d3289a18ac">&#9670;&nbsp;</a></span>IsConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a> tvm::relax::IsConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern.">ConstantPattern</a>. </p>

</div>
</div>
<a id="aefdb4fdc17642caa5813a62a86cb3efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb4fdc17642caa5813a62a86cb3efa">&#9670;&nbsp;</a></span>IsExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a> tvm::relax::IsExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern.">ExprPattern</a>. </p>

</div>
</div>
<a id="a91202291e3d31370f2bfab2b8934723a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91202291e3d31370f2bfab2b8934723a">&#9670;&nbsp;</a></span>IsImpureCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsImpureCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;&#160;</td>
          <td class="paramname"><em>call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> node is an impure operation. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the callee is a general expression, this simply requires checking the purity field of the <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode.">FuncStructInfo</a>. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> it is an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a>, then this checks the <code>fPurity</code> field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The input call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the call is impure (definitely or possibly results in a visible side effect). That is, a call is considered pure only if definitely does not result in a visible side effect. </dd></dl>

</div>
</div>
<a id="ade67ebcba4b40c0e0c38c0ddd3279131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade67ebcba4b40c0e0c38c0ddd3279131">&#9670;&nbsp;</a></span>IsLeafOrTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsLeafOrTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given expression is a "leaf" node or tuple node for normalization purposes. </p>
<p>The following expressions are defined as leaf nodes: <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a>, <a class="el" href="classtvm_1_1relax_1_1ShapeExpr.html">ShapeExpr</a>, <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a>, <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a>, <a class="el" href="classtvm_1_1relax_1_1ExternFunc.html">ExternFunc</a>.</p>
<p>Tuples are included in this list mainly for convenience in grouping operator arguments. <em>Note</em>: Since tuples can contain nested expressions, it is necessary to ensure that values nested inside them are also leaves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the input expression is a "leaf" node (a value allowed to appear inline without being bound to a var during normalization). </dd></dl>

</div>
</div>
<a id="a5b7b976a18e4065076addbd70445d3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7b976a18e4065076addbd70445d3fa">&#9670;&nbsp;</a></span>IsOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a> tvm::relax::IsOp </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>op_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern.">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a>. </p>

</div>
</div>
<a id="a66ce90c18674c873c97549155a0ce111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ce90c18674c873c97549155a0ce111">&#9670;&nbsp;</a></span>IsTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> tvm::relax::IsTuple </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html" title="Managed reference to TuplePatternNode.">TuplePattern</a> or <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html" title="Managed reference to UnorderedTuplePatternNode.">UnorderedTuplePattern</a> (unordered=true) </p>

</div>
</div>
<a id="af6cb1e75374b6a5d61f9464ffcedd5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cb1e75374b6a5d61f9464ffcedd5ee">&#9670;&nbsp;</a></span>IsTupleGetItem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a> tvm::relax::IsTupleGetItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html" title="Managed reference to TupleGetItemPatternNode.">TupleGetItemPattern</a>. </p>

</div>
</div>
<a id="aaf90b27a59bc837d06cb19f47ba1ce32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf90b27a59bc837d06cb19f47ba1ce32">&#9670;&nbsp;</a></span>IsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a> tvm::relax::IsVar </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern.">VarPattern</a> with a name. </p>

</div>
</div>
<a id="aba7002f60ee447156bbf2e376782bf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7002f60ee447156bbf2e376782bf70">&#9670;&nbsp;</a></span>MapNestedMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively map a nested message to another one, with leaf mapped by the input fmapleaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The nested message to be mapped. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The leaf map function, with signature NestedMsg&lt;T&gt; fmapleaf(T msg) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The content type of nested message. </td></tr>
    <tr><td class="paramname">FType</td><td>The leaf map function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new nested message. </dd></dl>

</div>
</div>
<a id="a411130ea776624757d25953c0afd23e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411130ea776624757d25953c0afd23e4">&#9670;&nbsp;</a></span>MapToNestedMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map expr with possible nested-tuple to nested message. </p>
<p>This function will unpack recursive tuples and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the tuple structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>&lt;T&gt; fmap(Expr)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13ac0cb404c219dc00406a5cc62687b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13ac0cb404c219dc00406a5cc62687b">&#9670;&nbsp;</a></span>MapToNestedMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td>
          <td class="paramname"><em>sinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map structinfo with possible nested-sinfo to nested message. </p>
<p>This function will unpack recursive sinfo and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the tuple structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The input struct info. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>&lt;T&gt; fmap(StructInfo)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca8353ff150a403bc950cc945776d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca8353ff150a403bc950cc945776d51">&#9670;&nbsp;</a></span>MapToNestedMsgBySInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsgBySInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map expr with possible nested-tuple to nested message. </p>
<p>This function will unpack recursive expr by its struct info and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the struct info of expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression which should have struct info. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T.">NestedMsg</a>&lt;T&gt; fmapleaf(Expr)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaabc1215a6a863b7e640ac99076a55ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabc1215a6a863b7e640ac99076a55ac">&#9670;&nbsp;</a></span>MatchExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::MatchExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>bindings</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a pattern matches an expression. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior of MatchExpr is to match a <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">relax.Expr</a> (<code>expr</code>) syntactically through one given pattern (<code>pattern</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to match </td></tr>
    <tr><td class="paramname">expr</td><td>The expression to match </td></tr>
    <tr><td class="paramname">bindings</td><td>The mapping from <a class="el" href="classtvm_1_1relax_1_1Var.html">relax.Var</a> to <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">relax.Expr</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if matched </dd>
<dd>
false if unmatched </dd></dl>

</div>
</div>
<a id="a66c7b62e2c594369bba00b5044464945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c7b62e2c594369bba00b5044464945">&#9670;&nbsp;</a></span>MatchGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;ffi::Map&lt;<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt; tvm::relax::MatchGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a sub-graph in a <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> with a graph of patterns and return the mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The graph-wise patterns. </td></tr>
    <tr><td class="paramname">dfb</td><td>The function to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matched patterns and corresponding bound variables </dd></dl>

</div>
</div>
<a id="ae6c79ee1a7b2c78d2c74a4595f1ccee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c79ee1a7b2c78d2c74a4595f1ccee3">&#9670;&nbsp;</a></span>MatchStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;T&gt; tvm::relax::MatchStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match and check if expr have <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> T and return it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of match. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying structure info type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3370ca0f9f9e283b3fe9c3983b565ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3370ca0f9f9e283b3fe9c3983b565ae">&#9670;&nbsp;</a></span>NameToBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;ffi::String, ffi::Array&lt;<a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a>&gt; &gt; tvm::relax::NameToBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mapping from variable name to its Bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping from variable name to its Bindings. </dd></dl>

</div>
</div>
<a id="a6e390702bd71ff0ce2e0a8f1cb07b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e390702bd71ff0ce2e0a8f1cb07b7d2">&#9670;&nbsp;</a></span>NestedMsgTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType , typename T , typename FMapLeaf , typename FCombine &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetType tvm::relax::NestedMsgTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FMapLeaf&#160;</td>
          <td class="paramname"><em>fmapleaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FCombine&#160;</td>
          <td class="paramname"><em>fcombine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map nested message back to TargetType. </p>
<p>This function will decompose the nested message and run fmapleaf for each leaf message and get the leaf value, then recursively combines the results by fcombine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The input nested message. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code>TargetType fmapleaf(ffi::Optional&lt;T&gt;)</code>. </td></tr>
    <tr><td class="paramname">fcombine</td><td>The function for combining all childs of a node into TargetType with signature <code>TargetType fmapleaf(ffi::Array&lt;TargetType&gt;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetType</td><td>the target type to map nested msg to. </td></tr>
    <tr><td class="paramname">T</td><td>the content type of nested msg. </td></tr>
    <tr><td class="paramname">FMapLeaf</td><td>The leaf mapping function type. </td></tr>
    <tr><td class="paramname">FCombine</td><td>The combining function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad78aea2a337c8133df868081838a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad78aea2a337c8133df868081838a81">&#9670;&nbsp;</a></span>NestedMsgToExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::NestedMsgToExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map nested message back to the expr. </p>
<p>This function will decompose the nested message and run fmapleaf for each leaf message and get the leaf expr, then recursively combines the results as tuple expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The input nested message. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code>Expr fmapleaf(ffi::Optional&lt;T&gt;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg. </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7d3238251393e90f87314ae9ea1d773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d3238251393e90f87314ae9ea1d773">&#9670;&nbsp;</a></span>OnlyUsedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::OnlyUsedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create only-used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">index</td><td>lhs[-1] is used as the index'th argument of rhs[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html" title="Managed reference to pattern sequences.">PatternSeq</a> The concatenated sequence of [*lhs, *rhs]. </dd></dl>

</div>
</div>
<a id="af2174df5a7b6bfc1e747068c11bcdb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2174df5a7b6bfc1e747068c11bcdb3c">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntax sugar of OnlyUsedBy(lhs, rhs, -1). </p>

</div>
</div>
<a id="a1b594f8efba6fb6620a207fc79b46369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b594f8efba6fb6620a207fc79b46369">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntax sugar of UsedBy(lhs, rhs, -1). </p>

</div>
</div>
<a id="af8591e3bb5b5ca5ca31964916f27ac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8591e3bb5b5ca5ca31964916f27ac1a">&#9670;&nbsp;</a></span>PostOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32fc012aed7e73dbbe354553614acd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fc012aed7e73dbbe354553614acd14">&#9670;&nbsp;</a></span>RemoveAllUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::RemoveAllUnused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused statements inside DataflowBlocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression (typically a <a class="el" href="classtvm_1_1relax_1_1Function.html">relax::Function</a>) from which to remove unused statements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated function with no unused statements in <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a>. </dd></dl>

</div>
</div>
<a id="af5845e4d011ab64d1ebbb8faa289c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5845e4d011ab64d1ebbb8faa289c8b6">&#9670;&nbsp;</a></span>RewriteBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> tvm::relax::RewriteBindings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::TypedFunction&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;(ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;, ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a function with the given pattern and the rewriter function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The pattern constraint context under which rewriting takes place. </td></tr>
    <tr><td class="paramname">rewriter</td><td>The function to be called on a successful matching for rewriting. Given the map of patterns and corresponding variables (bound variables or parameters), it should return a map that specifies new values for matched bound variables. </td></tr>
    <tr><td class="paramname">f</td><td>The function to rewrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten or the input function, depending on the pattern matching result. </dd></dl>

</div>
</div>
<a id="a4adfa32db8b3d194fc6fb2ff0edf6ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adfa32db8b3d194fc6fb2ff0edf6ce4">&#9670;&nbsp;</a></span>RewriteCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> tvm::relax::RewriteCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::TypedFunction&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>(<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>, ffi::Map&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a function with the given pattern and the rewriter function. </p>
<p>Pattern match and replace at an expression level. This level of granularity does not allow simultaneous replacement cannot be performed. In addition, removal of bindings cannot be performed explicitly, and is only done implicitly through RemoveAllUnused. See also <code>RewriteBindings</code>, which performs replacement on a block-level, and does not have these restrictions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to be replaced</td></tr>
    <tr><td class="paramname">rewriter</td><td>The function to be called on a successful pattern matching. Given the matched expression and a map of sub-matches, it should return the replacement expression. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the expression doesn't require updating (e.g. replacement required checks beyond those expressed in the pattern), it should return the expression unmodified.</td></tr>
    <tr><td class="paramname">func</td><td>The function to rewrite</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated function, if any updates were applied. </dd></dl>

</div>
</div>
<a id="a1be05801cdf62e4e3a012dc2e410302d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be05801cdf62e4e3a012dc2e410302d">&#9670;&nbsp;</a></span>StructInfoBaseCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a> tvm::relax::StructInfoBaseCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a base check to see if base subsumes derived. </p>
<p>This function returns fine-grained base-check result on reasons of failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base struct info. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived struct info. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the relation holds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2" title="Fine grained result of base check.">BaseCheckResult</a> </dd></dl>

</div>
</div>
<a id="af74568b8d1e2c4ae8b56210c0bc0136a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74568b8d1e2c4ae8b56210c0bc0136a">&#9670;&nbsp;</a></span>StructInfoBaseCheckPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::relax::StructInfoBaseCheckPrecondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the condition for which base is a superset of derived. </p>
<p>This function returns finer-grained conditions for kFailL2 than StructInfoBaseCheck</p>
<p><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the returned expression is true, or simplifies to true, then base is a superset of derived. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the returned expression is false, or simplifies to false, then base is not a superset of derived.</p>
<p><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the returned expression is neither true nor false, it is an expression in terms of the symbolic variables available in <code>base</code> and <code>derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base struct info. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived struct info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether base is a base of derived.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2" title="Fine grained result of base check.">BaseCheckResult</a> </dd></dl>

</div>
</div>
<a id="a886a4846aaed5d3cabb7ba6277d895b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886a4846aaed5d3cabb7ba6277d895b6">&#9670;&nbsp;</a></span>StructInfoFromType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::StructInfoFromType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the corresponding struct info from static type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding struct info. </dd></dl>

</div>
</div>
<a id="a1c8438730f1ee0320fd8bff9226e0d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8438730f1ee0320fd8bff9226e0d1b">&#9670;&nbsp;</a></span>StructInfoLCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::StructInfoLCA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unify the two struct info to their least common ancestor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unified information. </dd></dl>

</div>
</div>
<a id="a5f89eeb16f9f5992f08ccbceba43408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f89eeb16f9f5992f08ccbceba43408e">&#9670;&nbsp;</a></span>SuggestLayoutTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Block.html">tir::Block</a>, ffi::Map&lt;ObjectRef, <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a>&gt; &gt; tvm::relax::SuggestLayoutTransforms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a> &gt;&#160;</td>
          <td class="paramname"><em>write_buffer_transformations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the layout transforms on the outputs, suggest layout transformation on the blocks and buffers for the PrimFunc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The PrimFunc to be analyzed. </td></tr>
    <tr><td class="paramname">write_buffer_transformations</td><td>Array of IndexMap transformations on PrimFunc outputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suggested transforms per block in <code>fn</code>. For each block the returned value is a map from the object (block or buffer) to it's index map transformation. </dd></dl>

</div>
</div>
<a id="a97ca023f523d107c9c2652474c84573b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ca023f523d107c9c2652474c84573b">&#9670;&nbsp;</a></span>TIRVarsInStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>&gt; tvm::relax::TIRVarsInStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>sinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TIR variables that appear in the input struct info. The returned list is deduplicated - each TIR variable will appear at most once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The struct info object to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of TIR variables that appear in the input struct info. </dd></dl>

</div>
</div>
<a id="a1804479b52f4fadfbd2baa078e577cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1804479b52f4fadfbd2baa078e577cfe">&#9670;&nbsp;</a></span>ToNonDataflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::ToNonDataflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform all dataflow structure to non-dataflow version. </p>

</div>
</div>
<a id="a58d3028c04ea455bd0ae3643978fd69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d3028c04ea455bd0ae3643978fd69d">&#9670;&nbsp;</a></span>TransformTupleLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> tvm::relax::TransformTupleLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt;&#160;</td>
          <td class="paramname"><em>msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>ftransleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively transform the tuple structure in expr and msgs along with it. </p>
<p>This function will call ftransleaf for each leaf expression in expr. This function will throw an error if the nesting structure in msg does not match the tuple nesting structure in expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression to be transform.&#160; </td></tr>
    <tr><td class="paramname">msgs</td><td>The input messages to guide the transformation. </td></tr>
    <tr><td class="paramname">ftransleaf</td><td>with signature ftransleaf(Expr, ffi::Array&lt;NestedMsg&lt;T&gt;&gt;)-&gt;Expr </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">N</td><td>the number of messages </td></tr>
    <tr><td class="paramname">FType</td><td>The visit function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c79f0abeaed5e66b76febd08a3fcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c79f0abeaed5e66b76febd08a3fcb7">&#9670;&nbsp;</a></span>TransformTupleLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::TransformTupleLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td>
          <td class="paramname"><em>sinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt;&#160;</td>
          <td class="paramname"><em>msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>ftransleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively transform the tuple structure in sinfo and msgs along with it. </p>
<p>This function will call ftransleaf for each leaf sinfo in sinfo. This function will throw an error if the nesting structure in msg does not match the tuple nesting structure in sinfo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The input sinfo to be transform.&#160; </td></tr>
    <tr><td class="paramname">msgs</td><td>The input messages to guide the transformation. </td></tr>
    <tr><td class="paramname">ftransleaf</td><td>with signature ftransleaf(StructInfo, ffi::Array&lt;NestedMsg&lt;T&gt;&gt;)-&gt;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode.">StructInfo</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">N</td><td>the number of messages </td></tr>
    <tr><td class="paramname">FType</td><td>The visit function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab521e5660159c700a02f430290430592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab521e5660159c700a02f430290430592">&#9670;&nbsp;</a></span>UpdateStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::UpdateStructInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td>
          <td class="paramname"><em>struct_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the struct info of an Expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The Expr whose struct info to be updated. </td></tr>
    <tr><td class="paramname">struct_info</td><td>The struct_info assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We ensure idempotence, that is we can only update the struct_info of an Expr only if the original one is nullptr. </dd></dl>

</div>
</div>
<a id="ae51bf4cd12992d277cc20eb82881ca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51bf4cd12992d277cc20eb82881ca23">&#9670;&nbsp;</a></span>UsedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::UsedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">index</td><td>lhs[-1] is used as the index'th argument of rhs[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html" title="Managed reference to pattern sequences.">PatternSeq</a> The concatenated sequence of [*lhs, *rhs]. </dd></dl>

</div>
</div>
<a id="a73f71a11cfb52e59f09df83a984cc007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f71a11cfb52e59f09df83a984cc007">&#9670;&nbsp;</a></span>WellFormed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::WellFormed </td>
          <td>(</td>
          <td class="paramtype">ffi::Variant&lt; <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_struct_info</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> is well formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> or <a class="el" href="classtvm_1_1relax_1_1Function.html">relax::Function</a> to check. </td></tr>
    <tr><td class="paramname">check_struct_info</td><td>A boolean flag indicating if the property "every Expr
must have defined structure info" will be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is well formed, false if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>By default the structure info is always checked. It is only in test cases where <code>check_struct_info</code> might be false, so that other well-formed requirements will be well tested and will not be blocked by not having structure info. </dd></dl>

</div>
</div>
<a id="aaa590000b3e0f6bf9e545786c39f4f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa590000b3e0f6bf9e545786c39f4f0f">&#9670;&nbsp;</a></span>Wildcard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a> tvm::relax::Wildcard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html" title="Managed reference to WildcardPatternNode.">WildcardPattern</a>. </p>

</div>
</div>
<a id="a75740f5aac40453e46fbfbd99a683f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75740f5aac40453e46fbfbd99a683f4d">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_op</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_args</em> = <code>ffi::Optional&lt;&#160;ffi::Array&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_attrs</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_sinfo_args</em> = <code>ffi::Optional&lt;&#160;ffi::Array&lt;&#160;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>call</code> with the given properties. A null property denotes 'no change'. Returns <code>call</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="abd7341dfff4eb8c8f5db32bc5e84b968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7341dfff4eb8c8f5db32bc5e84b968">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a>&#160;</td>
          <td class="paramname"><em>if_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_cond</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_true_branch</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_false_branch</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>if_expr</code> with the given properties. A null property denotes 'no change'. Returns <code>if_expr</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="ad2e9ffbb5672aabc29894ce2af41a26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e9ffbb5672aabc29894ce2af41a26a">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_fields</em> = <code>ffi::Optional&lt;&#160;ffi::Array&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>tuple</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="a92393e4bcd4552332e8ffccd99dc675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92393e4bcd4552332e8ffccd99dc675e">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td>
          <td class="paramname"><em>tuple_get_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_tuple</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#ac287c47b30d1126e4017da1b96957fa0">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_index</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Integer.html">Integer</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code>ffi::Optional&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>tuple_get_item</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple_get_item</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
