<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::s_tir::ScheduleNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1s__tir.html">s_tir</a></li><li class="navelem"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html">ScheduleNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtvm_1_1s__tir_1_1ScheduleNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::s_tir::ScheduleNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The user-facing schedule class.  
 <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::s_tir::ScheduleNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1s__tir_1_1ScheduleNode__inherit__graph.svg" width="227" height="375"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::s_tir::ScheduleNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1s__tir_1_1ScheduleNode__coll__graph.svg" width="227" height="375"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01e579d0811c9ae07614264109563127"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a01e579d0811c9ae07614264109563127">~ScheduleNode</a> ()=default</td></tr>
<tr class="separator:a01e579d0811c9ae07614264109563127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682023d489a0657cc0f228df5df37498"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a682023d489a0657cc0f228df5df37498">TVM_FFI_DECLARE_OBJECT_INFO_FINAL</a> (&quot;s_tir.Schedule&quot;, ScheduleNode, runtime::Object)</td></tr>
<tr class="separator:a682023d489a0657cc0f228df5df37498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7692e40978563d72ac08192f5306528b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7692e40978563d72ac08192f5306528b">mod</a> () const</td></tr>
<tr class="memdesc:a7692e40978563d72ac08192f5306528b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> associated with this schedule.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7692e40978563d72ac08192f5306528b">More...</a><br /></td></tr>
<tr class="separator:a7692e40978563d72ac08192f5306528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bca9c3a1325808ed827e3ee0d457739"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1ScheduleState.html">ScheduleState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a0bca9c3a1325808ed827e3ee0d457739">state</a> () const =0</td></tr>
<tr class="separator:a0bca9c3a1325808ed827e3ee0d457739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc6c0a3bf62b2bbbd7dad072713d7b"><td class="memItemLeft" align="right" valign="top">virtual ffi::Optional&lt; <a class="el" href="classtvm_1_1s__tir_1_1Trace.html">Trace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a12fc6c0a3bf62b2bbbd7dad072713d7b">trace</a> () const =0</td></tr>
<tr class="separator:a12fc6c0a3bf62b2bbbd7dad072713d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19864f350afeca30c16d3b249d9d8dd8"><td class="memItemLeft" align="right" valign="top">virtual ffi::Optional&lt; <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a19864f350afeca30c16d3b249d9d8dd8">func_working_on</a> () const =0</td></tr>
<tr class="separator:a19864f350afeca30c16d3b249d9d8dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7166dccb89aec6fefe6652ad7cd3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a98c7166dccb89aec6fefe6652ad7cd3f">WorkOn</a> (const ffi::String &amp;func_name)=0</td></tr>
<tr class="memdesc:a98c7166dccb89aec6fefe6652ad7cd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the schedule to work on a function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a98c7166dccb89aec6fefe6652ad7cd3f">More...</a><br /></td></tr>
<tr class="separator:a98c7166dccb89aec6fefe6652ad7cd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f97ca31fd603a33ac6d7e688f018201"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9f97ca31fd603a33ac6d7e688f018201">Copy</a> ()=0</td></tr>
<tr class="memdesc:a9f97ca31fd603a33ac6d7e688f018201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the schedule, including both its state and its symbol table, guaranteeing that 1) SRef tree is completely reconstructed; 2) The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> being scheduled is not modified; 3) All the random variables are valid in the copy, pointing to the corresponding sref reconstructed.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9f97ca31fd603a33ac6d7e688f018201">More...</a><br /></td></tr>
<tr class="separator:a9f97ca31fd603a33ac6d7e688f018201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d0699d3080e396206fa44d73134f59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad6d0699d3080e396206fa44d73134f59">Seed</a> (<a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a> seed)=0</td></tr>
<tr class="memdesc:ad6d0699d3080e396206fa44d73134f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the randomness.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad6d0699d3080e396206fa44d73134f59">More...</a><br /></td></tr>
<tr class="separator:ad6d0699d3080e396206fa44d73134f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64f89fdf19fc03dba0bcd46064324ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae64f89fdf19fc03dba0bcd46064324ad">ForkSeed</a> ()=0</td></tr>
<tr class="memdesc:ae64f89fdf19fc03dba0bcd46064324ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fork the random state.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae64f89fdf19fc03dba0bcd46064324ad">More...</a><br /></td></tr>
<tr class="separator:ae64f89fdf19fc03dba0bcd46064324ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa004e3d543d3ca16ed818624ac789"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9bfa004e3d543d3ca16ed818624ac789">Get</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:a9bfa004e3d543d3ca16ed818624ac789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9bfa004e3d543d3ca16ed818624ac789">More...</a><br /></td></tr>
<tr class="separator:a9bfa004e3d543d3ca16ed818624ac789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf82babe866a0014516d861c843b7b20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1For.html">For</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#abf82babe866a0014516d861c843b7b20">Get</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv) const =0</td></tr>
<tr class="memdesc:abf82babe866a0014516d861c843b7b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the for loop corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#abf82babe866a0014516d861c843b7b20">More...</a><br /></td></tr>
<tr class="separator:abf82babe866a0014516d861c843b7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a8aa623ce7126d503778e5c6d95ea0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a20a8aa623ce7126d503778e5c6d95ea0">Get</a> (const <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &amp;expr_rv) const =0</td></tr>
<tr class="memdesc:a20a8aa623ce7126d503778e5c6d95ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expr corresponding to the specific random variable.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a20a8aa623ce7126d503778e5c6d95ea0">More...</a><br /></td></tr>
<tr class="separator:a20a8aa623ce7126d503778e5c6d95ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a722a948355a0a0c8a3f4cf39f731"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a306a722a948355a0a0c8a3f4cf39f731">GetSRef</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:a306a722a948355a0a0c8a3f4cf39f731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block sref corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a306a722a948355a0a0c8a3f4cf39f731">More...</a><br /></td></tr>
<tr class="separator:a306a722a948355a0a0c8a3f4cf39f731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5b846758c168ce8d525e28369a22f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#afa5b846758c168ce8d525e28369a22f5">GetSRef</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv) const =0</td></tr>
<tr class="memdesc:afa5b846758c168ce8d525e28369a22f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop sref corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#afa5b846758c168ce8d525e28369a22f5">More...</a><br /></td></tr>
<tr class="separator:afa5b846758c168ce8d525e28369a22f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aab584558f03480a00e7a7ccb20c07d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a4aab584558f03480a00e7a7ccb20c07d">HasBlock</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv) const =0</td></tr>
<tr class="memdesc:a4aab584558f03480a00e7a7ccb20c07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the existance of a specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a4aab584558f03480a00e7a7ccb20c07d">More...</a><br /></td></tr>
<tr class="separator:a4aab584558f03480a00e7a7ccb20c07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c26e0d6095ef6bb18bfb01275d6ee6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7c26e0d6095ef6bb18bfb01275d6ee6f">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *stmt) const</td></tr>
<tr class="memdesc:a7c26e0d6095ef6bb18bfb01275d6ee6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block/loop sref corresponding to the specific statement.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7c26e0d6095ef6bb18bfb01275d6ee6f">More...</a><br /></td></tr>
<tr class="separator:a7c26e0d6095ef6bb18bfb01275d6ee6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d45790bb1ed31b925d1b0e46ae1bb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a14d45790bb1ed31b925d1b0e46ae1bb1">GetSRef</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt) const</td></tr>
<tr class="memdesc:a14d45790bb1ed31b925d1b0e46ae1bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block/loop sref corresponding to the specific statement.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a14d45790bb1ed31b925d1b0e46ae1bb1">More...</a><br /></td></tr>
<tr class="separator:a14d45790bb1ed31b925d1b0e46ae1bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf570d65247ad55d4945ed86c5dd8b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a17bf570d65247ad55d4945ed86c5dd8b">RemoveRV</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a17bf570d65247ad55d4945ed86c5dd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block random variable from the symbol table.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a17bf570d65247ad55d4945ed86c5dd8b">More...</a><br /></td></tr>
<tr class="separator:a17bf570d65247ad55d4945ed86c5dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91003c91e2ae6a61d0cc9c073c183dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ab91003c91e2ae6a61d0cc9c073c183dd">RemoveRV</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:ab91003c91e2ae6a61d0cc9c073c183dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a loop random variable from the symbol table.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ab91003c91e2ae6a61d0cc9c073c183dd">More...</a><br /></td></tr>
<tr class="separator:ab91003c91e2ae6a61d0cc9c073c183dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0cbdfa41cdbbe77b778e2e5a10ec48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a5d0cbdfa41cdbbe77b778e2e5a10ec48">RemoveRV</a> (const <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &amp;expr_rv)=0</td></tr>
<tr class="memdesc:a5d0cbdfa41cdbbe77b778e2e5a10ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an integer random variable from the symbol table.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a5d0cbdfa41cdbbe77b778e2e5a10ec48">More...</a><br /></td></tr>
<tr class="separator:a5d0cbdfa41cdbbe77b778e2e5a10ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff790ac76b66d5c49f9167983b3c8f89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#aff790ac76b66d5c49f9167983b3c8f89">SampleCategorical</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;candidates, const ffi::Array&lt; <a class="el" href="classtvm_1_1FloatImm.html">FloatImm</a> &gt; &amp;probs, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; decision=std::nullopt)=0</td></tr>
<tr class="memdesc:aff790ac76b66d5c49f9167983b3c8f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample an integer given the probability distribution.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#aff790ac76b66d5c49f9167983b3c8f89">More...</a><br /></td></tr>
<tr class="separator:aff790ac76b66d5c49f9167983b3c8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e29d1e484b2cd359b5309170983ea1"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a81e29d1e484b2cd359b5309170983ea1">SamplePerfectTile</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, int n, int max_innermost_factor, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; decision=std::nullopt)=0</td></tr>
<tr class="memdesc:a81e29d1e484b2cd359b5309170983ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the factors to perfect tile a specific loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a81e29d1e484b2cd359b5309170983ea1">More...</a><br /></td></tr>
<tr class="separator:a81e29d1e484b2cd359b5309170983ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ce88cf32973fb389fd2eee83adf6b"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a352ce88cf32973fb389fd2eee83adf6b">SamplePartitionedTile</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, int n, int partition_pos, int innerpart_factor, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; decision=std::nullopt)=0</td></tr>
<tr class="memdesc:a352ce88cf32973fb389fd2eee83adf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the factors to a partitioned tile for a specific loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a352ce88cf32973fb389fd2eee83adf6b">More...</a><br /></td></tr>
<tr class="separator:a352ce88cf32973fb389fd2eee83adf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9418f76bb3155aa75a2750d4b5ceb5b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9418f76bb3155aa75a2750d4b5ceb5b5">SampleComputeLocation</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; decision=std::nullopt)=0</td></tr>
<tr class="memdesc:a9418f76bb3155aa75a2750d4b5ceb5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a compute-at location of the given block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9418f76bb3155aa75a2750d4b5ceb5b5">More...</a><br /></td></tr>
<tr class="separator:a9418f76bb3155aa75a2750d4b5ceb5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950c37d471059d3ccb6f1da8cf12c035"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a950c37d471059d3ccb6f1da8cf12c035">GetSBlock</a> (const ffi::String &amp;name, const ffi::Optional&lt; ffi::String &gt; &amp;func_name=std::nullopt)=0</td></tr>
<tr class="memdesc:a950c37d471059d3ccb6f1da8cf12c035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a block in a specific function with its name.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a950c37d471059d3ccb6f1da8cf12c035">More...</a><br /></td></tr>
<tr class="separator:a950c37d471059d3ccb6f1da8cf12c035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be2fbb5945c6e5b70c2020cf7b559c"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad7be2fbb5945c6e5b70c2020cf7b559c">GetLoops</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:ad7be2fbb5945c6e5b70c2020cf7b559c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent loops of the block in its scope, from outer to inner.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad7be2fbb5945c6e5b70c2020cf7b559c">More...</a><br /></td></tr>
<tr class="separator:ad7be2fbb5945c6e5b70c2020cf7b559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d92e43d047ac0ba0b4b526c88fdaf4"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a13d92e43d047ac0ba0b4b526c88fdaf4">GetChildBlocks</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a13d92e43d047ac0ba0b4b526c88fdaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf blocks of a specific scope.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a13d92e43d047ac0ba0b4b526c88fdaf4">More...</a><br /></td></tr>
<tr class="separator:a13d92e43d047ac0ba0b4b526c88fdaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008f00da98685280ff01f98a209ece5"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6008f00da98685280ff01f98a209ece5">GetChildBlocks</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a6008f00da98685280ff01f98a209ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf blocks of under a specific loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6008f00da98685280ff01f98a209ece5">More...</a><br /></td></tr>
<tr class="separator:a6008f00da98685280ff01f98a209ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4eb4d5ff6b3c6bd435e6dcec5d8a9"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a41b4eb4d5ff6b3c6bd435e6dcec5d8a9">GetProducers</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a41b4eb4d5ff6b3c6bd435e6dcec5d8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the producer of a specific block, under the same block scope.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a41b4eb4d5ff6b3c6bd435e6dcec5d8a9">More...</a><br /></td></tr>
<tr class="separator:a41b4eb4d5ff6b3c6bd435e6dcec5d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b444cb2e0ce585d4ae807641fd7d34f"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a3b444cb2e0ce585d4ae807641fd7d34f">GetConsumers</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a3b444cb2e0ce585d4ae807641fd7d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the consumers of a specific block, under the same block scope.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a3b444cb2e0ce585d4ae807641fd7d34f">More...</a><br /></td></tr>
<tr class="separator:a3b444cb2e0ce585d4ae807641fd7d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600c2b9d5f01c36d490a3cd52a8a684"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7600c2b9d5f01c36d490a3cd52a8a684">GetOutputBlocks</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;scope_block_rv)=0</td></tr>
<tr class="memdesc:a7600c2b9d5f01c36d490a3cd52a8a684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of output blocks within the given scope An output block is a block which has atleast one buffer being written to, but is not allocated within the PrimFunc.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7600c2b9d5f01c36d490a3cd52a8a684">More...</a><br /></td></tr>
<tr class="separator:a7600c2b9d5f01c36d490a3cd52a8a684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfe9dfb740fb8699694acd7adfb3234"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#adcfe9dfb740fb8699694acd7adfb3234">Merge</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;loop_rvs)=0</td></tr>
<tr class="memdesc:adcfe9dfb740fb8699694acd7adfb3234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a list of loops into one. The loops under their LCA requires: 1) Under the same scope 2) Can't have annotations or thread bindings 3) Start with 0 and have same extent and same nesting depth 4) From target loop to their LCA, the inner loop must be the only child of the outer loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#adcfe9dfb740fb8699694acd7adfb3234">More...</a><br /></td></tr>
<tr class="separator:adcfe9dfb740fb8699694acd7adfb3234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc24c9400a64559abad08a76ab47d71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6fc24c9400a64559abad08a76ab47d71">Fuse</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;loop_rvs, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a6fc24c9400a64559abad08a76ab47d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse a list of consecutive loops into one. It requires: 1) The loops can't have annotations or thread bindings. 2) The (i+1)-th loop must be the only child of the i-th loop. 3) All loops must start with 0. 4) The domain of a loop to be fused cannot depend on another loop to be fused.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6fc24c9400a64559abad08a76ab47d71">More...</a><br /></td></tr>
<tr class="separator:a6fc24c9400a64559abad08a76ab47d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b60d2fbcf2be3e8355c1063b64384a9"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a0b60d2fbcf2be3e8355c1063b64384a9">Split</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::Array&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&gt; &amp;factors, bool preserve_unit_iters=true, bool disable_predication=false)=0</td></tr>
<tr class="memdesc:a0b60d2fbcf2be3e8355c1063b64384a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a loop into a list of consecutive loops. It requires: 1) The loop can't have annotation or thread binding. 2) The loop must start with 0.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a0b60d2fbcf2be3e8355c1063b64384a9">More...</a><br /></td></tr>
<tr class="separator:a0b60d2fbcf2be3e8355c1063b64384a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0badef29b87678ee56faca893e2c5398"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a0badef29b87678ee56faca893e2c5398">LoopPartition</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::Array&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&gt; &amp;factors, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a0badef29b87678ee56faca893e2c5398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition the loops into sequence of multiple loops 1) The loop can't have annotation or thread binding.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a0badef29b87678ee56faca893e2c5398">More...</a><br /></td></tr>
<tr class="separator:a0badef29b87678ee56faca893e2c5398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1af398cb518f5d2d91e1ee878113f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#aad1af398cb518f5d2d91e1ee878113f3">Reorder</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;ordered_loop_rvs)=0</td></tr>
<tr class="memdesc:aad1af398cb518f5d2d91e1ee878113f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder a list of loops. It doesn't require the loops to be consecutive. It requires: 1) The loops are in the same chain. That means: the loops can be ordered to [l_1, l_2, ... , l_n] where l_i is an ancestor of l_{i+1} and there are only single-branch loops between l_1 and l_n (which also indicates they are under the same scope). 2) After reordering, the domain of an outer loop cannot depend on any of the inner loops. 3) For every block under the loop nests, its block binding must be affine, and the block variables must be either data parallel or reduction. 4) No duplicated loops are allowed in the arguments.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#aad1af398cb518f5d2d91e1ee878113f3">More...</a><br /></td></tr>
<tr class="separator:aad1af398cb518f5d2d91e1ee878113f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1bef7d6a0836736352572ac6ed5cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a14c1bef7d6a0836736352572ac6ed5cc">ReorderBlockIterVar</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; new_order)=0</td></tr>
<tr class="memdesc:a14c1bef7d6a0836736352572ac6ed5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the itervars inside a block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a14c1bef7d6a0836736352572ac6ed5cc">More...</a><br /></td></tr>
<tr class="separator:a14c1bef7d6a0836736352572ac6ed5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fb842c81336edaa67ca1aeba439d01"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a64fb842c81336edaa67ca1aeba439d01">AddUnitLoop</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv)=0</td></tr>
<tr class="memdesc:a64fb842c81336edaa67ca1aeba439d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unit loop on top of the specific block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a64fb842c81336edaa67ca1aeba439d01">More...</a><br /></td></tr>
<tr class="separator:a64fb842c81336edaa67ca1aeba439d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36931007b7140cf579c90e753411be1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad36931007b7140cf579c90e753411be1">AddUnitLoop</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:ad36931007b7140cf579c90e753411be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unit loop on top of the specific loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad36931007b7140cf579c90e753411be1">More...</a><br /></td></tr>
<tr class="separator:ad36931007b7140cf579c90e753411be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f37cbbb6add4fe12e9dd044c22a5792"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1f37cbbb6add4fe12e9dd044c22a5792">Parallel</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a1f37cbbb6add4fe12e9dd044c22a5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, the loop can only be contained in data-parallel block iters' bindings.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1f37cbbb6add4fe12e9dd044c22a5792">More...</a><br /></td></tr>
<tr class="separator:a1f37cbbb6add4fe12e9dd044c22a5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c127b633205af565427664a973a825c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2c127b633205af565427664a973a825c">Vectorize</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a2c127b633205af565427664a973a825c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, the loop can only be contained in data-parallel block iters' bindings.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2c127b633205af565427664a973a825c">More...</a><br /></td></tr>
<tr class="separator:a2c127b633205af565427664a973a825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d86fc44c3aa32773bd686a14cda533"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a06d86fc44c3aa32773bd686a14cda533">Bind</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::String &amp;thread_axis)=0</td></tr>
<tr class="memdesc:a06d86fc44c3aa32773bd686a14cda533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the input loop to the given thread axis. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, if the thread axis starts with "threadIdx&lsquo;, the loop can only be contained in data-parallel block iter and reduction block iters&rsquo; bindings. Otherwise the loop can only be contained in data-parallel block iters' bindings.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a06d86fc44c3aa32773bd686a14cda533">More...</a><br /></td></tr>
<tr class="separator:a06d86fc44c3aa32773bd686a14cda533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066ca595d9c1d73b650ccf0923c6fefc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a066ca595d9c1d73b650ccf0923c6fefc">Unroll</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:a066ca595d9c1d73b650ccf0923c6fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the input loop. It requires nothing.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a066ca595d9c1d73b650ccf0923c6fefc">More...</a><br /></td></tr>
<tr class="separator:a066ca595d9c1d73b650ccf0923c6fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1859bce31d9f5bed202ca90e9b6ab85d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1859bce31d9f5bed202ca90e9b6ab85d">CacheRead</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int read_buffer_index, const ffi::String &amp;storage_scope, const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt; consumer_blocks={})=0</td></tr>
<tr class="memdesc:a1859bce31d9f5bed202ca90e9b6ab85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1859bce31d9f5bed202ca90e9b6ab85d">More...</a><br /></td></tr>
<tr class="separator:a1859bce31d9f5bed202ca90e9b6ab85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8919ca972244ea4eb13e9e5e4063df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#adb8919ca972244ea4eb13e9e5e4063df">CacheWrite</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int write_buffer_index, const ffi::String &amp;storage_scope, const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt; consumer_blocks={})=0</td></tr>
<tr class="memdesc:adb8919ca972244ea4eb13e9e5e4063df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#adb8919ca972244ea4eb13e9e5e4063df">More...</a><br /></td></tr>
<tr class="separator:adb8919ca972244ea4eb13e9e5e4063df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae521878b0f82d4dcf4932b34c0f11476"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae521878b0f82d4dcf4932b34c0f11476">ReindexCacheRead</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int read_buffer_index, const ffi::String &amp;storage_scope, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map)=0</td></tr>
<tr class="memdesc:ae521878b0f82d4dcf4932b34c0f11476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property. Compared to cache read, the indices to access allocated cache buffer is customized by user.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae521878b0f82d4dcf4932b34c0f11476">More...</a><br /></td></tr>
<tr class="separator:ae521878b0f82d4dcf4932b34c0f11476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cdcd319867c595140eb958e28b4173"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ac2cdcd319867c595140eb958e28b4173">ReindexCacheWrite</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int write_buffer_index, const ffi::String &amp;storage_scope, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map)=0</td></tr>
<tr class="memdesc:ac2cdcd319867c595140eb958e28b4173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property. Compared to cache write, the indices to access allocated cache buffer is customized by user.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ac2cdcd319867c595140eb958e28b4173">More...</a><br /></td></tr>
<tr class="separator:ac2cdcd319867c595140eb958e28b4173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7eb8917a6e768dd862cea118d5cf70"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a8c7eb8917a6e768dd862cea118d5cf70">CacheInplace</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int read_buffer_index, const ffi::String &amp;storage_scope)=0</td></tr>
<tr class="memdesc:a8c7eb8917a6e768dd862cea118d5cf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create 2 blocks that read&amp;write a buffer region into a read/write cache. It requires the target block both read &amp; write the target buffer.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a8c7eb8917a6e768dd862cea118d5cf70">More...</a><br /></td></tr>
<tr class="separator:a8c7eb8917a6e768dd862cea118d5cf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bde1ca56624f36ad6e829e9170446cc"><td class="memItemLeft" align="right" valign="top">virtual ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2bde1ca56624f36ad6e829e9170446cc">CacheIndex</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::String &amp;storage_scope, int cse_thresh)=0</td></tr>
<tr class="memdesc:a2bde1ca56624f36ad6e829e9170446cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block to cache precomputed index for later use. if there is no index computation, keep unchanged.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2bde1ca56624f36ad6e829e9170446cc">More...</a><br /></td></tr>
<tr class="separator:a2bde1ca56624f36ad6e829e9170446cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb4cef0537e66429d40860594780aaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2cb4cef0537e66429d40860594780aaa">ReIndex</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a> buffer_index_type)=0</td></tr>
<tr class="memdesc:a2cb4cef0537e66429d40860594780aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a block that read/write a buffer region into a read/write cache with reindexing. The layout of the cache will be the same as by the iterators of the block that reads/writes the buffer. It requires: 1) There is only one block who reads/writes the target buffer 2) There is only one buffer load/store of this buffer in the block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a2cb4cef0537e66429d40860594780aaa">More...</a><br /></td></tr>
<tr class="separator:a2cb4cef0537e66429d40860594780aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab896b72924f22dbc9cf51b517d98ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7ab896b72924f22dbc9cf51b517d98ff">ReadAt</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int read_buffer_index, const ffi::String &amp;storage_scope)=0</td></tr>
<tr class="separator:a7ab896b72924f22dbc9cf51b517d98ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a6ba36b9a2b94906c9ba2b769953db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ac8a6ba36b9a2b94906c9ba2b769953db">WriteAt</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int write_buffer_index, const ffi::String &amp;storage_scope)=0</td></tr>
<tr class="separator:ac8a6ba36b9a2b94906c9ba2b769953db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7315a95c83d45376a31d36d778e0fc5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7315a95c83d45376a31d36d778e0fc5d">ComputeAt</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_loops, int index=-1)=0</td></tr>
<tr class="memdesc:a7315a95c83d45376a31d36d778e0fc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a producer block under the specific loop, and regenerate the loops induced by the block so that the buffer region produced by the producer block could cover those regions consumed by its consumer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) The block is not an output block with regard to the scope block, i.e. the buffers written by the block are allocated under the scope block 5) All the consumers of the block are under the given loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a7315a95c83d45376a31d36d778e0fc5d">More...</a><br /></td></tr>
<tr class="separator:a7315a95c83d45376a31d36d778e0fc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119d54c0e79404882988a19d33a52ff9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a119d54c0e79404882988a19d33a52ff9">ReverseComputeAt</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_loops, int index=-1)=0</td></tr>
<tr class="memdesc:a119d54c0e79404882988a19d33a52ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a consumer block under the specific loop, and regenerate the loops induced by the block so that the buffer region consumed by the consumer block could cover those regions produced by its producer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) All the producers of the block are under the given loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a119d54c0e79404882988a19d33a52ff9">More...</a><br /></td></tr>
<tr class="separator:a119d54c0e79404882988a19d33a52ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67024fc96588dbd35a43d333b0206274"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a67024fc96588dbd35a43d333b0206274">ComputeInline</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block)=0</td></tr>
<tr class="memdesc:a67024fc96588dbd35a43d333b0206274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a block into its consumer(s). It requires: 1) The block is a complete non-root block, which only produces one buffer 2) The block must not be the only leaf in the scope. 3) The body of the block must be a BufferStore statement in the form of, A[i, j, k, ...] = ... where the indices of the LHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a67024fc96588dbd35a43d333b0206274">More...</a><br /></td></tr>
<tr class="separator:a67024fc96588dbd35a43d333b0206274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c99b9a98e72413f302b3ae6d8bcb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a657c99b9a98e72413f302b3ae6d8bcb1">ReverseComputeInline</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block)=0</td></tr>
<tr class="memdesc:a657c99b9a98e72413f302b3ae6d8bcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a block into its only producer. It requires: 1) The block is a complete non-root block, which only produces and consumers one buffer 2) The block must not be the only leaf in the scope. 3) The only producer of the block is a read-after-write producer and a complete non-root block 4) The body of the block must be a BufferStore statement in the form of, B[f(i, j, k, ...)] = g(i, j, k, A[i, j, k, ...] ...) where the indices of each <code>BufferLoad</code> on the RHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a657c99b9a98e72413f302b3ae6d8bcb1">More...</a><br /></td></tr>
<tr class="separator:a657c99b9a98e72413f302b3ae6d8bcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f6c9324134dbab5a438fea66c4c7f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#aa7f6c9324134dbab5a438fea66c4c7f1">FuseReductionEpilogue</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;reduction_block, const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;epilogue_block)=0</td></tr>
<tr class="memdesc:aa7f6c9324134dbab5a438fea66c4c7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse an epilogue block into a reduction block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#aa7f6c9324134dbab5a438fea66c4c7f1">More...</a><br /></td></tr>
<tr class="separator:aa7f6c9324134dbab5a438fea66c4c7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cdc7c183922667d2fa9c515377384a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#af9cdc7c183922667d2fa9c515377384a">DecomposeReduction</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:af9cdc7c183922667d2fa9c515377384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a reduction block into two separate blocks. a) The init block, which is translated from the init statement of the reduction block; b) The update block, which is the original block without init statement.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#af9cdc7c183922667d2fa9c515377384a">More...</a><br /></td></tr>
<tr class="separator:af9cdc7c183922667d2fa9c515377384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048544cae8a79606f96a9639459867b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a048544cae8a79606f96a9639459867b4">RFactor</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, int factor_axis)=0</td></tr>
<tr class="memdesc:a048544cae8a79606f96a9639459867b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize an associative reduction block by the specified loop.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a048544cae8a79606f96a9639459867b4">More...</a><br /></td></tr>
<tr class="separator:a048544cae8a79606f96a9639459867b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a3d056e6be83a0a65a23141c745152"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a17a3d056e6be83a0a65a23141c745152">StorageAlign</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, int axis, int factor, int offset)=0</td></tr>
<tr class="memdesc:a17a3d056e6be83a0a65a23141c745152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set alignment requirement for specific dimension such that stride[axis] == k * factor + offset for some k. This is useful to set memory layout for more friendly memory access pattern. For example, we can set alignment to be factor=2, offset=1 to avoid bank conflict for thread access on higher dimension in GPU shared memory.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a17a3d056e6be83a0a65a23141c745152">More...</a><br /></td></tr>
<tr class="separator:a17a3d056e6be83a0a65a23141c745152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520878d937b2b5b873b2660ee4e59d33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a520878d937b2b5b873b2660ee4e59d33">SetScope</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, const ffi::String &amp;storage_scope)=0</td></tr>
<tr class="memdesc:a520878d937b2b5b873b2660ee4e59d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage scope of a buffer, where the buffer is specified by a block and a write-index.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a520878d937b2b5b873b2660ee4e59d33">More...</a><br /></td></tr>
<tr class="separator:a520878d937b2b5b873b2660ee4e59d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51e99b4ad58d1ed9be294c6118842f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1e51e99b4ad58d1ed9be294c6118842f">UnsafeSetDType</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, const ffi::String &amp;dtype)=0</td></tr>
<tr class="memdesc:a1e51e99b4ad58d1ed9be294c6118842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data type of a buffer, where the buffer is specified by a block and a write-index.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1e51e99b4ad58d1ed9be294c6118842f">More...</a><br /></td></tr>
<tr class="separator:a1e51e99b4ad58d1ed9be294c6118842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c674d0d8c096864759fc8f4e47b180d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1c674d0d8c096864759fc8f4e47b180d">Blockize</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a1c674d0d8c096864759fc8f4e47b180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the subtree rooted at a specific loop into a block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a1c674d0d8c096864759fc8f4e47b180d">More...</a><br /></td></tr>
<tr class="separator:a1c674d0d8c096864759fc8f4e47b180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d039e921b734b344d16bc97bdae223"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a72d039e921b734b344d16bc97bdae223">Blockize</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt; &amp;blocks, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:a72d039e921b734b344d16bc97bdae223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert specified blocks into a nested block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a72d039e921b734b344d16bc97bdae223">More...</a><br /></td></tr>
<tr class="separator:a72d039e921b734b344d16bc97bdae223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae17c106839bb20f74190e2ba4745f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#abae17c106839bb20f74190e2ba4745f3">Tensorize</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::String &amp;intrin, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:abae17c106839bb20f74190e2ba4745f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensorize the computation enclosed by loop with the tensor intrin.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#abae17c106839bb20f74190e2ba4745f3">More...</a><br /></td></tr>
<tr class="separator:abae17c106839bb20f74190e2ba4745f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3808006fe45a7b619f6639359c4ab54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae3808006fe45a7b619f6639359c4ab54">Tensorize</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::String &amp;intrin, bool preserve_unit_iters=true)=0</td></tr>
<tr class="memdesc:ae3808006fe45a7b619f6639359c4ab54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensorize the computation enclosed by loop with the tensor intrin.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ae3808006fe45a7b619f6639359c4ab54">More...</a><br /></td></tr>
<tr class="separator:ae3808006fe45a7b619f6639359c4ab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54076d59c43238501c609768448b8e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ac54076d59c43238501c609768448b8e6">Annotate</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::String &amp;ann_key, const Any &amp;ann_val)=0</td></tr>
<tr class="memdesc:ac54076d59c43238501c609768448b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate a loop with a key value pair.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ac54076d59c43238501c609768448b8e6">More...</a><br /></td></tr>
<tr class="separator:ac54076d59c43238501c609768448b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ef04767539fba1ace48af03a3bc6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#adc8ef04767539fba1ace48af03a3bc6b">Annotate</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::String &amp;ann_key, const Any &amp;ann_val)=0</td></tr>
<tr class="memdesc:adc8ef04767539fba1ace48af03a3bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate a block with a key value pair.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#adc8ef04767539fba1ace48af03a3bc6b">More...</a><br /></td></tr>
<tr class="separator:adc8ef04767539fba1ace48af03a3bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67abd48ef2be8fc4b1a1b64cb53dfba8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a67abd48ef2be8fc4b1a1b64cb53dfba8">Unannotate</a> (const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv, const ffi::String &amp;ann_key)=0</td></tr>
<tr class="memdesc:a67abd48ef2be8fc4b1a1b64cb53dfba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unannotate a loop's annotation with key ann_key.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a67abd48ef2be8fc4b1a1b64cb53dfba8">More...</a><br /></td></tr>
<tr class="separator:a67abd48ef2be8fc4b1a1b64cb53dfba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ea7ace885761d50b4ff0325d2d7194"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad0ea7ace885761d50b4ff0325d2d7194">Unannotate</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::String &amp;ann_key)=0</td></tr>
<tr class="memdesc:ad0ea7ace885761d50b4ff0325d2d7194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unannotate a block's annotation with key ann_key.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ad0ea7ace885761d50b4ff0325d2d7194">More...</a><br /></td></tr>
<tr class="separator:ad0ea7ace885761d50b4ff0325d2d7194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba248c3349835b6262b890743f73a05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#adba248c3349835b6262b890743f73a05">TransformLayout</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a> buffer_index_type, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map, const ffi::Optional&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &gt; &amp;pad_value=std::nullopt, bool assume_injective_transform=false)=0</td></tr>
<tr class="memdesc:adba248c3349835b6262b890743f73a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation represented by IndexMap to buffer.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#adba248c3349835b6262b890743f73a05">More...</a><br /></td></tr>
<tr class="separator:adba248c3349835b6262b890743f73a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804ffa32697098deb4d62faa557ae742"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a804ffa32697098deb4d62faa557ae742">TransformBlockLayout</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map)=0</td></tr>
<tr class="memdesc:a804ffa32697098deb4d62faa557ae742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation represented by IndexMap to block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a804ffa32697098deb4d62faa557ae742">More...</a><br /></td></tr>
<tr class="separator:a804ffa32697098deb4d62faa557ae742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe7a48f2986e979e4e4f663537fad1c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6fe7a48f2986e979e4e4f663537fad1c">SetAxisSeparator</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a> buffer_index_type, const ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;axis_separators)=0</td></tr>
<tr class="memdesc:a6fe7a48f2986e979e4e4f663537fad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the axis separator of a buffer, where the buffer is specified by a block and a read or write index.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a6fe7a48f2986e979e4e4f663537fad1c">More...</a><br /></td></tr>
<tr class="separator:a6fe7a48f2986e979e4e4f663537fad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6e9eee8add1303697c70a3036b6305"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#abb6e9eee8add1303697c70a3036b6305">DecomposePadding</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;loop_rv)=0</td></tr>
<tr class="memdesc:abb6e9eee8add1303697c70a3036b6305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a padding block into a block filling const pad values and a block writing in-bound values.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#abb6e9eee8add1303697c70a3036b6305">More...</a><br /></td></tr>
<tr class="separator:abb6e9eee8add1303697c70a3036b6305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca915ebb645daea7447bab9d926a95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#adaca915ebb645daea7447bab9d926a95">PadEinsum</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;padding)=0</td></tr>
<tr class="memdesc:adaca915ebb645daea7447bab9d926a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the computation of Einsum.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#adaca915ebb645daea7447bab9d926a95">More...</a><br /></td></tr>
<tr class="separator:adaca915ebb645daea7447bab9d926a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade004c879f9ea381bab34da5aeb3c165"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#ade004c879f9ea381bab34da5aeb3c165">RollingBuffer</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int write_buffer_index)=0</td></tr>
<tr class="memdesc:ade004c879f9ea381bab34da5aeb3c165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the target buffer via rolling buffering.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#ade004c879f9ea381bab34da5aeb3c165">More...</a><br /></td></tr>
<tr class="separator:ade004c879f9ea381bab34da5aeb3c165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f146a55cd86798bf80ca58bb90deaf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a3f146a55cd86798bf80ca58bb90deaf1">AnnotateBufferAccess</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, int buffer_index, <a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a> buffer_index_type, const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;index_map)=0</td></tr>
<tr class="memdesc:a3f146a55cd86798bf80ca58bb90deaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the buffer access of a block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a3f146a55cd86798bf80ca58bb90deaf1">More...</a><br /></td></tr>
<tr class="separator:a3f146a55cd86798bf80ca58bb90deaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8573edecfb7a76ea4075cbf8e756ddc4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a8573edecfb7a76ea4075cbf8e756ddc4">EnterPostproc</a> ()=0</td></tr>
<tr class="memdesc:a8573edecfb7a76ea4075cbf8e756ddc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op that marks the start of postprocessing phase of scheduling.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a8573edecfb7a76ea4075cbf8e756ddc4">More...</a><br /></td></tr>
<tr class="separator:a8573edecfb7a76ea4075cbf8e756ddc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4056d43eb6b342b6d0fa49a8398ae67c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a4056d43eb6b342b6d0fa49a8398ae67c">UnsafeHideBufferAccess</a> (const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;block_rv, const ffi::String &amp;buf_type, const ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;buf_index_array)=0</td></tr>
<tr class="memdesc:a4056d43eb6b342b6d0fa49a8398ae67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide some buffer access in the given block.  <a href="classtvm_1_1s__tir_1_1ScheduleNode.html#a4056d43eb6b342b6d0fa49a8398ae67c">More...</a><br /></td></tr>
<tr class="separator:a4056d43eb6b342b6d0fa49a8398ae67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9c825de8d2ea28ddb0256a29101f0bb9"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a9c825de8d2ea28ddb0256a29101f0bb9">_type_mutable</a> = true</td></tr>
<tr class="separator:a9c825de8d2ea28ddb0256a29101f0bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aae5808dc2e987bf17ef42196457a654d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#aae5808dc2e987bf17ef42196457a654d">Schedule</a></td></tr>
<tr class="separator:aae5808dc2e987bf17ef42196457a654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The user-facing schedule class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01e579d0811c9ae07614264109563127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e579d0811c9ae07614264109563127">&#9670;&nbsp;</a></span>~ScheduleNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual tvm::s_tir::ScheduleNode::~ScheduleNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad36931007b7140cf579c90e753411be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36931007b7140cf579c90e753411be1">&#9670;&nbsp;</a></span>AddUnitLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> tvm::s_tir::ScheduleNode::AddUnitLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new unit loop on top of the specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop above which the new loop is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop created </dd></dl>

</div>
</div>
<a id="a64fb842c81336edaa67ca1aeba439d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fb842c81336edaa67ca1aeba439d01">&#9670;&nbsp;</a></span>AddUnitLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> tvm::s_tir::ScheduleNode::AddUnitLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new unit loop on top of the specific block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block above which the new loop is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop created </dd></dl>

</div>
</div>
<a id="ac54076d59c43238501c609768448b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54076d59c43238501c609768448b8e6">&#9670;&nbsp;</a></span>Annotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Annotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Any &amp;&#160;</td>
          <td class="paramname"><em>ann_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate a loop with a key value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be annotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
    <tr><td class="paramname">ann_val</td><td>The annotation value, a string or a ExprRV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc8ef04767539fba1ace48af03a3bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ef04767539fba1ace48af03a3bc6b">&#9670;&nbsp;</a></span>Annotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Annotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Any &amp;&#160;</td>
          <td class="paramname"><em>ann_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate a block with a key value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be annotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
    <tr><td class="paramname">ann_val</td><td>The annotation value, a string or a ExprRV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f146a55cd86798bf80ca58bb90deaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f146a55cd86798bf80ca58bb90deaf1">&#9670;&nbsp;</a></span>AnnotateBufferAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::AnnotateBufferAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate the buffer access of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be annotated </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
    <tr><td class="paramname">index_map</td><td>The index map that defines the new read or write region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06d86fc44c3aa32773bd686a14cda533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d86fc44c3aa32773bd686a14cda533">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>thread_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the input loop to the given thread axis. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, if the thread axis starts with "threadIdx&lsquo;, the loop can only be contained in data-parallel block iter and reduction block iters&rsquo; bindings. Otherwise the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be bound to the thread axis </td></tr>
    <tr><td class="paramname">thread_axis</td><td>The thread axis to be bound to the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d039e921b734b344d16bc97bdae223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d039e921b734b344d16bc97bdae223">&#9670;&nbsp;</a></span>Blockize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::Blockize </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert specified blocks into a nested block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocks</td><td>the specified block to construct the new block </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new block </dd></dl>

</div>
</div>
<a id="a1c674d0d8c096864759fc8f4e47b180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c674d0d8c096864759fc8f4e47b180d">&#9670;&nbsp;</a></span>Blockize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::Blockize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the subtree rooted at a specific loop into a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>the root of the subtree </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new block </dd></dl>

</div>
</div>
<a id="a2bde1ca56624f36ad6e829e9170446cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bde1ca56624f36ad6e829e9170446cc">&#9670;&nbsp;</a></span>CacheIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::CacheIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cse_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block to cache precomputed index for later use. if there is no index computation, keep unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The target block </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope of cached block </td></tr>
    <tr><td class="paramname">cse_thresh</td><td>The repeat threshold that determines a common sub expr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage blocks. </dd></dl>

</div>
</div>
<a id="a8c7eb8917a6e768dd862cea118d5cf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7eb8917a6e768dd862cea118d5cf70">&#9670;&nbsp;</a></span>CacheInplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::CacheInplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create 2 blocks that read&amp;write a buffer region into a read/write cache. It requires the target block both read &amp; write the target buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The target block operates on the target buffer. </td></tr>
    <tr><td class="paramname">read_buffer_index</td><td>The index of the buffer in block's read region. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage blocks, cache read block together with cache write block. </dd></dl>

</div>
</div>
<a id="a1859bce31d9f5bed202ca90e9b6ab85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1859bce31d9f5bed202ca90e9b6ab85d">&#9670;&nbsp;</a></span>CacheRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::CacheRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td>
          <td class="paramname"><em>consumer_blocks</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The consumer block of the target buffer. </td></tr>
    <tr><td class="paramname">read_buffer_index</td><td>The index of the buffer in block's read region. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope. </td></tr>
    <tr><td class="paramname">consumer_blocks</td><td>An optional list of consumers of the cache to rewrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="adb8919ca972244ea4eb13e9e5e4063df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8919ca972244ea4eb13e9e5e4063df">&#9670;&nbsp;</a></span>CacheWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::CacheWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &gt;&#160;</td>
          <td class="paramname"><em>consumer_blocks</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer of the buffer </td></tr>
    <tr><td class="paramname">write_buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope </td></tr>
    <tr><td class="paramname">consumer_blocks</td><td>An optional list of consumers to read from cache directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="a7315a95c83d45376a31d36d778e0fc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7315a95c83d45376a31d36d778e0fc5d">&#9670;&nbsp;</a></span>ComputeAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::ComputeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a producer block under the specific loop, and regenerate the loops induced by the block so that the buffer region produced by the producer block could cover those regions consumed by its consumer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) The block is not an output block with regard to the scope block, i.e. the buffers written by the block are allocated under the scope block 5) All the consumers of the block are under the given loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be moved </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop where the block to be moved under </td></tr>
    <tr><td class="paramname">preserve_unit_loops</td><td>Whether to keep the trivial loops whose extents are 1 </td></tr>
    <tr><td class="paramname">index</td><td>The block index of the loop body subtree blocks:<ul>
<li><code>index = -1</code> means inserted into the last possible insertion point;</li>
<li><code>index = -2</code> means inserted into the first possible insertion point;</li>
<li>Otherwise, <code>index</code> is a nonnegative number that indicates the insertion point </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67024fc96588dbd35a43d333b0206274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67024fc96588dbd35a43d333b0206274">&#9670;&nbsp;</a></span>ComputeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::ComputeInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline a block into its consumer(s). It requires: 1) The block is a complete non-root block, which only produces one buffer 2) The block must not be the only leaf in the scope. 3) The body of the block must be a BufferStore statement in the form of, A[i, j, k, ...] = ... where the indices of the LHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be inlined to its consumer(s) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f97ca31fd603a33ac6d7e688f018201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f97ca31fd603a33ac6d7e688f018201">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1Schedule.html">Schedule</a> tvm::s_tir::ScheduleNode::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the schedule, including both its state and its symbol table, guaranteeing that 1) SRef tree is completely reconstructed; 2) The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> being scheduled is not modified; 3) All the random variables are valid in the copy, pointing to the corresponding sref reconstructed. </p>

</div>
</div>
<a id="abb6e9eee8add1303697c70a3036b6305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6e9eee8add1303697c70a3036b6305">&#9670;&nbsp;</a></span>DecomposePadding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::DecomposePadding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a padding block into a block filling const pad values and a block writing in-bound values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that match the padding pattern. </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop above which the const filling block is inserted before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const pad value filling block. </dd></dl>

</div>
</div>
<a id="af9cdc7c183922667d2fa9c515377384a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cdc7c183922667d2fa9c515377384a">&#9670;&nbsp;</a></span>DecomposeReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::DecomposeReduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a reduction block into two separate blocks. a) The init block, which is translated from the init statement of the reduction block; b) The update block, which is the original block without init statement. </p>
<p>The init block is inserted right before the given loop.</p>
<p>The schedule primitive requires: 1) The input block is a reduction block. 2) The input loop is the ancestor of the block. 3) The input loop is not lower than all the loops related to reduce block var. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The reduction block to be decomposed </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop above which the init block is inserted before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The init block </dd></dl>

</div>
</div>
<a id="a8573edecfb7a76ea4075cbf8e756ddc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8573edecfb7a76ea4075cbf8e756ddc4">&#9670;&nbsp;</a></span>EnterPostproc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::EnterPostproc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A no-op that marks the start of postprocessing phase of scheduling. </p>

</div>
</div>
<a id="ae64f89fdf19fc03dba0bcd46064324ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64f89fdf19fc03dba0bcd46064324ad">&#9670;&nbsp;</a></span>ForkSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a> tvm::s_tir::ScheduleNode::ForkSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fork the random state. </p>

</div>
</div>
<a id="a19864f350afeca30c16d3b249d9d8dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19864f350afeca30c16d3b249d9d8dd8">&#9670;&nbsp;</a></span>func_working_on()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Optional&lt;<a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a>&gt; tvm::s_tir::ScheduleNode::func_working_on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> of the func that the schedule is currently working on </dd></dl>

</div>
</div>
<a id="a6fc24c9400a64559abad08a76ab47d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc24c9400a64559abad08a76ab47d71">&#9670;&nbsp;</a></span>Fuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> tvm::s_tir::ScheduleNode::Fuse </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loop_rvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse a list of consecutive loops into one. It requires: 1) The loops can't have annotations or thread bindings. 2) The (i+1)-th loop must be the only child of the i-th loop. 3) All loops must start with 0. 4) The domain of a loop to be fused cannot depend on another loop to be fused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rvs</td><td>The loops to be fused </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop after fusion </dd></dl>

</div>
</div>
<a id="aa7f6c9324134dbab5a438fea66c4c7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f6c9324134dbab5a438fea66c4c7f1">&#9670;&nbsp;</a></span>FuseReductionEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::FuseReductionEpilogue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>reduction_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>epilogue_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse an epilogue block into a reduction block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduction_block</td><td>The reduction block (e.g., matmul) </td></tr>
    <tr><td class="paramname">epilogue_block</td><td>The epilogue block to be fused (e.g., bias add) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20a8aa623ce7126d503778e5c6d95ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a8aa623ce7126d503778e5c6d95ea0">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::s_tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &amp;&#160;</td>
          <td class="paramname"><em>expr_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expr corresponding to the specific random variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr_rv</td><td>The random variable to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding expr </dd></dl>

</div>
</div>
<a id="abf82babe866a0014516d861c843b7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf82babe866a0014516d861c843b7b20">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1For.html">For</a> tvm::s_tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the for loop corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding for loop </dd></dl>

</div>
</div>
<a id="a9bfa004e3d543d3ca16ed818624ac789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfa004e3d543d3ca16ed818624ac789">&#9670;&nbsp;</a></span>Get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1SBlock.html">SBlock</a> tvm::s_tir::ScheduleNode::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block </dd></dl>

</div>
</div>
<a id="a6008f00da98685280ff01f98a209ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008f00da98685280ff01f98a209ece5">&#9670;&nbsp;</a></span>GetChildBlocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::GetChildBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the leaf blocks of under a specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop under which collecting is conducted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of child blocks </dd></dl>

</div>
</div>
<a id="a13d92e43d047ac0ba0b4b526c88fdaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d92e43d047ac0ba0b4b526c88fdaf4">&#9670;&nbsp;</a></span>GetChildBlocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::GetChildBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the leaf blocks of a specific scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block where the scope is rooted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of child blocks </dd></dl>

</div>
</div>
<a id="a3b444cb2e0ce585d4ae807641fd7d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b444cb2e0ce585d4ae807641fd7d34f">&#9670;&nbsp;</a></span>GetConsumers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::GetConsumers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the consumers of a specific block, under the same block scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of blocks, the consumers of the given block under the same scope of the given block </dd></dl>

</div>
</div>
<a id="ad7be2fbb5945c6e5b70c2020cf7b559c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be2fbb5945c6e5b70c2020cf7b559c">&#9670;&nbsp;</a></span>GetLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&gt; tvm::s_tir::ScheduleNode::GetLoops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parent loops of the block in its scope, from outer to inner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The query block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of loops above the given block in its scope, from outer to inner </dd></dl>

</div>
</div>
<a id="a7600c2b9d5f01c36d490a3cd52a8a684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600c2b9d5f01c36d490a3cd52a8a684">&#9670;&nbsp;</a></span>GetOutputBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::GetOutputBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of output blocks within the given scope An output block is a block which has atleast one buffer being written to, but is not allocated within the PrimFunc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope_block_rv</td><td>The scope block from which output blocks are collected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of all blocks that write to some output buffer block </dd></dl>

</div>
</div>
<a id="a41b4eb4d5ff6b3c6bd435e6dcec5d8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4eb4d5ff6b3c6bd435e6dcec5d8a9">&#9670;&nbsp;</a></span>GetProducers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a>&gt; tvm::s_tir::ScheduleNode::GetProducers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the producer of a specific block, under the same block scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block in the query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of blocks, the producers of the given block under the same scope of the given block </dd></dl>

</div>
</div>
<a id="a950c37d471059d3ccb6f1da8cf12c035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950c37d471059d3ccb6f1da8cf12c035">&#9670;&nbsp;</a></span>GetSBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::GetSBlock </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Optional&lt; ffi::String &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_name</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a block in a specific function with its name. </p>
<p>By default, if <code>func_name</code> is not specified, the schedule will search for the block in the function that is currently being "worked on". To switch the function to be worked on, use <code>WorkOn</code> before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the block to be retrieved </td></tr>
    <tr><td class="paramname">func_name</td><td>The name of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block retrieved </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Indexing error is raised if 0 or multiple blocks exist with the specific name</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a98c7166dccb89aec6fefe6652ad7cd3f" title="Instruct the schedule to work on a function in the IRModule.">WorkOn</a> </dd></dl>

</div>
</div>
<a id="afa5b846758c168ce8d525e28369a22f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5b846758c168ce8d525e28369a22f5">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::s_tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop sref corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html" title="Managed reference to LoopRVNode.">LoopRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding loop sref </dd></dl>

</div>
</div>
<a id="a306a722a948355a0a0c8a3f4cf39f731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306a722a948355a0a0c8a3f4cf39f731">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::s_tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block sref corresponding to the specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block sref </dd></dl>

</div>
</div>
<a id="a14d45790bb1ed31b925d1b0e46ae1bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d45790bb1ed31b925d1b0e46ae1bb1">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::s_tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block/loop sref corresponding to the specific statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block/loop sref </dd></dl>

</div>
</div>
<a id="a7c26e0d6095ef6bb18bfb01275d6ee6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c26e0d6095ef6bb18bfb01275d6ee6f">&#9670;&nbsp;</a></span>GetSRef() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1tir_1_1StmtSRef.html">StmtSRef</a> tvm::s_tir::ScheduleNode::GetSRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a> *&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block/loop sref corresponding to the specific statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding block/loop sref </dd></dl>

</div>
</div>
<a id="a4aab584558f03480a00e7a7ccb20c07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aab584558f03480a00e7a7ccb20c07d">&#9670;&nbsp;</a></span>HasBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tvm::s_tir::ScheduleNode::HasBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the existance of a specific <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html" title="Managed reference to SBlockRVNode.">SBlockRV</a> to be looked up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the corresponding block exists </dd></dl>

</div>
</div>
<a id="a0badef29b87678ee56faca893e2c5398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0badef29b87678ee56faca893e2c5398">&#9670;&nbsp;</a></span>LoopPartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&gt; tvm::s_tir::ScheduleNode::LoopPartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition the loops into sequence of multiple loops 1) The loop can't have annotation or thread binding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be partition </td></tr>
    <tr><td class="paramname">factors</td><td>The positive integers, and at most one of which is <code>std::nullopt</code>, which means that factor is inferred. </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loops after partition </dd></dl>

</div>
</div>
<a id="adcfe9dfb740fb8699694acd7adfb3234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfe9dfb740fb8699694acd7adfb3234">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> tvm::s_tir::ScheduleNode::Merge </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loop_rvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge a list of loops into one. The loops under their LCA requires: 1) Under the same scope 2) Can't have annotations or thread bindings 3) Start with 0 and have same extent and same nesting depth 4) From target loop to their LCA, the inner loop must be the only child of the outer loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rvs</td><td>The loops to be merged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loop after merge </dd></dl>

</div>
</div>
<a id="a7692e40978563d72ac08192f5306528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7692e40978563d72ac08192f5306528b">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> tvm::s_tir::ScheduleNode::mod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> associated with this schedule. </p>

</div>
</div>
<a id="adaca915ebb645daea7447bab9d926a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca915ebb645daea7447bab9d926a95">&#9670;&nbsp;</a></span>PadEinsum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::PadEinsum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pad the computation of Einsum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that matches the Einsum pattern. </td></tr>
    <tr><td class="paramname">padding</td><td>The padding for each block iter.</td></tr>
  </table>
  </dd>
</dl>
<p>This schedule primitives identifies the Einsum pattern in the block body, and find its producer blocks. It then pads the computation of the Einsum pattern and its producer blocks. The output buffer and the producer buffer is resized according to the padding size. It requires the output buffer and the producer buffer to be allocated inside the PrimFunc.</p>
<p>The padding is a list of non-negative integers, each element corresponds to the padding for each block iter in the order of block iters. The block and its producer blocks should have trivial bindings, i.e. each block iter is bound to a single loop variable. After padding, the block iter extent and the corresponding outer loop is extended by the padding size.</p>
<p>The size of the producer buffers are infered from the padding size of the Einsum computation. The producer buffers are padded by the initial value of the corresponding reduction. </p>

</div>
</div>
<a id="a1f37cbbb6add4fe12e9dd044c22a5792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f37cbbb6add4fe12e9dd044c22a5792">&#9670;&nbsp;</a></span>Parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be parallelized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab896b72924f22dbc9cf51b517d98ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab896b72924f22dbc9cf51b517d98ff">&#9670;&nbsp;</a></span>ReadAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::ReadAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cb4cef0537e66429d40860594780aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb4cef0537e66429d40860594780aaa">&#9670;&nbsp;</a></span>ReIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::ReIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that read/write a buffer region into a read/write cache with reindexing. The layout of the cache will be the same as by the iterators of the block that reads/writes the buffer. It requires: 1) There is only one block who reads/writes the target buffer 2) There is only one buffer load/store of this buffer in the block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block operates on the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reindex stage block. </dd></dl>

</div>
</div>
<a id="ae521878b0f82d4dcf4932b34c0f11476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae521878b0f82d4dcf4932b34c0f11476">&#9670;&nbsp;</a></span>ReindexCacheRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::ReindexCacheRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that reads a buffer region into a read cache. It requires: 1) There is at most one block who writes the buffer in the scope. 2) The scope block have stage-pipeline property. Compared to cache read, the indices to access allocated cache buffer is customized by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The consumer block of the target buffer. </td></tr>
    <tr><td class="paramname">read_buffer_index</td><td>The index of the buffer in block's read region. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope. </td></tr>
    <tr><td class="paramname">index_map</td><td>User defined indices to access allocated cache buffer, maps from block iter vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="ac2cdcd319867c595140eb958e28b4173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cdcd319867c595140eb958e28b4173">&#9670;&nbsp;</a></span>ReindexCacheWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::ReindexCacheWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a block that writes a buffer region into a write cache. It requires: 1) There is only one block who writes the target buffer. 2) The scope block have stage-pipeline property. Compared to cache write, the indices to access allocated cache buffer is customized by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer of the buffer </td></tr>
    <tr><td class="paramname">write_buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The target storage scope </td></tr>
    <tr><td class="paramname">index_map</td><td>User defined indices to access allocated cache buffer, maps from block iter vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cache stage block. </dd></dl>

</div>
</div>
<a id="a5d0cbdfa41cdbbe77b778e2e5a10ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0cbdfa41cdbbe77b778e2e5a10ec48">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &amp;&#160;</td>
          <td class="paramname"><em>expr_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an integer random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab91003c91e2ae6a61d0cc9c073c183dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91003c91e2ae6a61d0cc9c073c183dd">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a loop random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17bf570d65247ad55d4945ed86c5dd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf570d65247ad55d4945ed86c5dd8b">&#9670;&nbsp;</a></span>RemoveRV() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::RemoveRV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a block random variable from the symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The random variable to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1af398cb518f5d2d91e1ee878113f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1af398cb518f5d2d91e1ee878113f3">&#9670;&nbsp;</a></span>Reorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Reorder </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ordered_loop_rvs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder a list of loops. It doesn't require the loops to be consecutive. It requires: 1) The loops are in the same chain. That means: the loops can be ordered to [l_1, l_2, ... , l_n] where l_i is an ancestor of l_{i+1} and there are only single-branch loops between l_1 and l_n (which also indicates they are under the same scope). 2) After reordering, the domain of an outer loop cannot depend on any of the inner loops. 3) For every block under the loop nests, its block binding must be affine, and the block variables must be either data parallel or reduction. 4) No duplicated loops are allowed in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ordered_loop_rvs</td><td>The loops in the new order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c1bef7d6a0836736352572ac6ed5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c1bef7d6a0836736352572ac6ed5cc">&#9670;&nbsp;</a></span>ReorderBlockIterVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::ReorderBlockIterVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>new_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder the itervars inside a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be transformed. </td></tr>
    <tr><td class="paramname">new_order</td><td>The new itervar order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a119d54c0e79404882988a19d33a52ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119d54c0e79404882988a19d33a52ff9">&#9670;&nbsp;</a></span>ReverseComputeAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::ReverseComputeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a consumer block under the specific loop, and regenerate the loops induced by the block so that the buffer region consumed by the consumer block could cover those regions produced by its producer blocks under the given loop. It requires: 1) <code>block</code> and <code>loop</code> are under the same scope, <code>loop</code> is not the ancestor of <code>block</code> 2) The scope block has stage-pipeline property 3) The subtree of the scope block, where the given block is in, satisfies the compact dataflow condition. i.e. all the blocks in the scope block's subtree must be either complete block or reduction block 4) All the producers of the block are under the given loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be moved </td></tr>
    <tr><td class="paramname">loop_rv</td><td>The loop where the block to be moved under </td></tr>
    <tr><td class="paramname">preserve_unit_loops</td><td>Whether to keep the trivial loops whose extents are 1 </td></tr>
    <tr><td class="paramname">index</td><td>The block index of the loop body subtree blocks:<ul>
<li><code>index = -1</code> means inserted into the last possible insertion point;</li>
<li><code>index = -2</code> means inserted into the first possible insertion point;</li>
<li>Otherwise, <code>index</code> is a nonnegative number that indicates the insertion point </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a657c99b9a98e72413f302b3ae6d8bcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657c99b9a98e72413f302b3ae6d8bcb1">&#9670;&nbsp;</a></span>ReverseComputeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::ReverseComputeInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline a block into its only producer. It requires: 1) The block is a complete non-root block, which only produces and consumers one buffer 2) The block must not be the only leaf in the scope. 3) The only producer of the block is a read-after-write producer and a complete non-root block 4) The body of the block must be a BufferStore statement in the form of, B[f(i, j, k, ...)] = g(i, j, k, A[i, j, k, ...] ...) where the indices of each <code>BufferLoad</code> on the RHS are all distinct atomic variables, and no variables other than those indexing variables are allowed in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be inlined to its producer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a048544cae8a79606f96a9639459867b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048544cae8a79606f96a9639459867b4">&#9670;&nbsp;</a></span>RFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::RFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorize an associative reduction block by the specified loop. </p>
<p>An associative reduction cannot be parallelized directly, because it leads to potential race condition during accumulation. Alternatively, the reduction could be factorized on a loop with the following steps:</p><ul>
<li>Step 1: evenly slice the reduction into <code>n</code> separate chunks, where <code>n</code> is the loop extent</li>
<li>Step 2: compute the chunks separately and write the result into <code>n</code> intermediate buffers;</li>
<li>Step 3: accumulate the <code>n</code> separate buffer into the result buffer. Note that the Step 2 above introduces opportunities for parallelization. RFactor is a schedule primitive that implements the transformation described above. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop outside block we want to do rfactor </td></tr>
    <tr><td class="paramname">factor_axis</td><td>The position where the new dimension is placed in the new introduced rfactor buffer. Suppose the original reduction block writes to buffer <code>B</code> with ndim(B) dimensions, then <code>factor_axis</code> should be in range <code>[-ndim(B) - 1, ndim(B)]</code>, and the negative index will be normalized to a non-negative one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rfactor block </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ade004c879f9ea381bab34da5aeb3c165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade004c879f9ea381bab34da5aeb3c165">&#9670;&nbsp;</a></span>RollingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::RollingBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the target buffer via rolling buffering. </p>
<p>This primitive selects the outermost rollable axis with a positive bound overlap that appears in the block's ancestor loops as <code>rolling axis</code>, fold and circularize the buffer along the rolling dimension, append block predicate to avoid recomputing overlapping elements. It requires: 1) The buffer to be an intermediate buffer defined via <code>alloc_buffer</code>. 2) The LCA of the producer and consumer of the buffer is a for loop, typically, the producer and consumer of the buffer are cascaded through compute_at. 3) The access region of the buffer has at least one dimension that contains a positive bound overlap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer. </td></tr>
    <tr><td class="paramname">write_buffer_index</td><td>The index of the buffer in block's write region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff790ac76b66d5c49f9167983b3c8f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff790ac76b66d5c49f9167983b3c8f89">&#9670;&nbsp;</a></span>SampleCategorical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> tvm::s_tir::ScheduleNode::SampleCategorical </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1FloatImm.html">FloatImm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample an integer given the probability distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>The candidates </td></tr>
    <tr><td class="paramname">probs</td><td>The probability distribution of the candidates </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The random variable sampled from candidates </dd></dl>

</div>
</div>
<a id="a9418f76bb3155aa75a2750d4b5ceb5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9418f76bb3155aa75a2750d4b5ceb5b5">&#9670;&nbsp;</a></span>SampleComputeLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> tvm::s_tir::ScheduleNode::SampleComputeLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a compute-at location of the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block whose compute-at location is to be sampled </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampled loop where the input block is to be computed at </dd></dl>

</div>
</div>
<a id="a352ce88cf32973fb389fd2eee83adf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352ce88cf32973fb389fd2eee83adf6b">&#9670;&nbsp;</a></span>SamplePartitionedTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a>&gt; tvm::s_tir::ScheduleNode::SamplePartitionedTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partition_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>innerpart_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample the factors to a partitioned tile for a specific loop. </p>
<p>The sampled tile size will be partitioned into two parts. The second part has a guarantee that their extent's product have a factor of <code>innerpart_factor</code>. The first part is loops at [0, partition_pos); the second part is loops at [partition_pos, n) and we will have <code>innerpart_factor</code> | (l[partition_pos].extent * ... * l[n-1].extent)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be tiled </td></tr>
    <tr><td class="paramname">n</td><td>The number of tiles to be sampled </td></tr>
    <tr><td class="paramname">partition_pos</td><td>The position to partition tiles to two parts </td></tr>
    <tr><td class="paramname">innerpart_factor</td><td>The factor of the second part </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of length <code>n</code>, the random partitioned tile sizes sampled </dd></dl>

</div>
</div>
<a id="a81e29d1e484b2cd359b5309170983ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e29d1e484b2cd359b5309170983ea1">&#9670;&nbsp;</a></span>SamplePerfectTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a>&gt; tvm::s_tir::ScheduleNode::SamplePerfectTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>decision</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample the factors to perfect tile a specific loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be tiled </td></tr>
    <tr><td class="paramname">n</td><td>The number of tiles to be sampled </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum tile size allowed to be sampled in the innermost loop </td></tr>
    <tr><td class="paramname">decision</td><td>The sampling decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of length <code>n</code>, the random perfect tile sizes sampled </dd></dl>

</div>
</div>
<a id="ad6d0699d3080e396206fa44d73134f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d0699d3080e396206fa44d73134f59">&#9670;&nbsp;</a></span>Seed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Seed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1support_1_1LinearCongruentialEngine.html#a4d3a3a94a3f3d2dfab4b5ccb1a7e97de">support::LinearCongruentialEngine::TRandState</a>&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seed the randomness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The new random seed, -1 if use device random, otherwise non-negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fe7a48f2986e979e4e4f663537fad1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe7a48f2986e979e4e4f663537fad1c">&#9670;&nbsp;</a></span>SetAxisSeparator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::SetAxisSeparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_separators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the axis separator of a buffer, where the buffer is specified by a block and a read or write index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that accesses the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
    <tr><td class="paramname">axis_separators</td><td>The axis separator of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520878d937b2b5b873b2660ee4e59d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520878d937b2b5b873b2660ee4e59d33">&#9670;&nbsp;</a></span>SetScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::SetScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the storage scope of a buffer, where the buffer is specified by a block and a write-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b60d2fbcf2be3e8355c1063b64384a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b60d2fbcf2be3e8355c1063b64384a9">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Array&lt;<a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a>&gt; tvm::s_tir::ScheduleNode::Split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; ffi::Optional&lt; <a class="el" href="namespacetvm_1_1s__tir.html#a974cb09c470621792d135adb5550c9e7">ExprRV</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable_predication</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a loop into a list of consecutive loops. It requires: 1) The loop can't have annotation or thread binding. 2) The loop must start with 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be split </td></tr>
    <tr><td class="paramname">factors</td><td>The positive tiling factors, and at most one of which is <code>std::nullopt</code>, which means that factor is inferred.</td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings.</td></tr>
    <tr><td class="paramname">disable_predication</td><td>If enabled, don't create a predicate for guarding the loop. This can be useful when splitting with scalable factors that the schedule writer knows are divisible by the loop bound. Warning: enabling this feature may result in incorrect code generation if not used carefully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new loops after split. </dd></dl>

</div>
</div>
<a id="a0bca9c3a1325808ed827e3ee0d457739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bca9c3a1325808ed827e3ee0d457739">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1ScheduleState.html">ScheduleState</a> tvm::s_tir::ScheduleNode::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The internal state of scheduling </dd></dl>

</div>
</div>
<a id="a17a3d056e6be83a0a65a23141c745152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a3d056e6be83a0a65a23141c745152">&#9670;&nbsp;</a></span>StorageAlign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::StorageAlign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set alignment requirement for specific dimension such that stride[axis] == k * factor + offset for some k. This is useful to set memory layout for more friendly memory access pattern. For example, we can set alignment to be factor=2, offset=1 to avoid bank conflict for thread access on higher dimension in GPU shared memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">axis</td><td>The dimension to be specified for alignment </td></tr>
    <tr><td class="paramname">factor</td><td>The factor multiple of alignment </td></tr>
    <tr><td class="paramname">offset</td><td>The required offset factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abae17c106839bb20f74190e2ba4745f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae17c106839bb20f74190e2ba4745f3">&#9670;&nbsp;</a></span>Tensorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Tensorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>intrin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tensorize the computation enclosed by loop with the tensor intrin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be tensorized </td></tr>
    <tr><td class="paramname">intrin</td><td>Name of the tensor intrinsic </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3808006fe45a7b619f6639359c4ab54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3808006fe45a7b619f6639359c4ab54">&#9670;&nbsp;</a></span>Tensorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Tensorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>intrin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_unit_iters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tensorize the computation enclosed by loop with the tensor intrin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be tensorized </td></tr>
    <tr><td class="paramname">intrin</td><td>Name of the tensor intrinsic </td></tr>
    <tr><td class="paramname">preserve_unit_iters</td><td>Whether or not to preserve unit iterators in block bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12fc6c0a3bf62b2bbbd7dad072713d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc6c0a3bf62b2bbbd7dad072713d7b">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ffi::Optional&lt;<a class="el" href="classtvm_1_1s__tir_1_1Trace.html">Trace</a>&gt; tvm::s_tir::ScheduleNode::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The internally maintained trace of scheduling program execution </dd></dl>

</div>
</div>
<a id="a804ffa32697098deb4d62faa557ae742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804ffa32697098deb4d62faa557ae742">&#9670;&nbsp;</a></span>TransformBlockLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::TransformBlockLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a transformation represented by IndexMap to block. </p>
<p>The block iters and the block body are transformed by the given index_map. Outer loops corresponding to each new block iter are regenerated. The index_map is required to be bijective affine since we need its inverse mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be transformed </td></tr>
    <tr><td class="paramname">index_map</td><td>The transformation to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adba248c3349835b6262b890743f73a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba248c3349835b6262b890743f73a05">&#9670;&nbsp;</a></span>TransformLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::TransformLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1s__tir.html#a974ea3394d3dd4fc47950c6f98329c16">BufferIndexType</a>&#160;</td>
          <td class="paramname"><em>buffer_index_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Optional&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">IndexMap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pad_value</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assume_injective_transform</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a transformation represented by IndexMap to buffer. </p>
<p>The indices and the access region to the target buffer is transformed by the given index_map. The index_map is used to infer the new shape of the buffer. Buffer must be either a function parameter, or allocated in a block (it cannot be a buffer subregion created via 'match_buffer'). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block that accesses the target buffer. </td></tr>
    <tr><td class="paramname">buffer_index</td><td>The index of the buffer in block's read or write region. </td></tr>
    <tr><td class="paramname">buffer_index_type</td><td>The type of the buffer index, kRead or kWrite. </td></tr>
    <tr><td class="paramname">index_map</td><td>The transformation to apply.</td></tr>
    <tr><td class="paramname">pad_value</td><td>The value to write into padding introduced by the transformation. If the schedule contains a producer block for the specified buffer, the pad value will be written as part of the producer block if possible, or after the producer block otherwise. Otherwise, if the buffer is an input, will insert an annotation block to state that the padding contains the known value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: If applied to an input buffer, the calling scope is responsible for ensuring that the pad_value is present. Algebraic symplifications, branch elimination, and other optimizations may assume that this precondition is met, and may result in incorrect results being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assume_injective_transform</td><td>If set to true, the schedule primitive will assume the index_map is injective and skip checking overlapping of the mapped indices. This can be useful for complicated index_map that the analysis does not cover. It is the callers' responsibility to ensure the index map is injective, otherwise, the correctness of the schedule is not guaranteed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682023d489a0657cc0f228df5df37498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682023d489a0657cc0f228df5df37498">&#9670;&nbsp;</a></span>TVM_FFI_DECLARE_OBJECT_INFO_FINAL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::s_tir::ScheduleNode::TVM_FFI_DECLARE_OBJECT_INFO_FINAL </td>
          <td>(</td>
          <td class="paramtype">&quot;s_tir.Schedule&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html">ScheduleNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">runtime::Object&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67abd48ef2be8fc4b1a1b64cb53dfba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67abd48ef2be8fc4b1a1b64cb53dfba8">&#9670;&nbsp;</a></span>Unannotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Unannotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unannotate a loop's annotation with key ann_key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be unannotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0ea7ace885761d50b4ff0325d2d7194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ea7ace885761d50b4ff0325d2d7194">&#9670;&nbsp;</a></span>Unannotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Unannotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>ann_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unannotate a block's annotation with key ann_key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block to be unannotated </td></tr>
    <tr><td class="paramname">ann_key</td><td>The annotation key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066ca595d9c1d73b650ccf0923c6fefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066ca595d9c1d73b650ccf0923c6fefc">&#9670;&nbsp;</a></span>Unroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unroll the input loop. It requires nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be unrolled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4056d43eb6b342b6d0fa49a8398ae67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4056d43eb6b342b6d0fa49a8398ae67c">&#9670;&nbsp;</a></span>UnsafeHideBufferAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::UnsafeHideBufferAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>buf_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf_index_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hide some buffer access in the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The block where we hide buffer access. </td></tr>
    <tr><td class="paramname">buf_type</td><td>The buffer type: read/write </td></tr>
    <tr><td class="paramname">buf_index_array</td><td>The array of buffer indices we hide access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e51e99b4ad58d1ed9be294c6118842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e51e99b4ad58d1ed9be294c6118842f">&#9670;&nbsp;</a></span>UnsafeSetDType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::UnsafeSetDType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the data type of a buffer, where the buffer is specified by a block and a write-index. </p>
<dl class="section note"><dt>Note</dt><dd>This schedule primitive is unsafe and may change correctness of program because of type conversion, please use with caution. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_rv</td><td>The producer block of the buffer </td></tr>
    <tr><td class="paramname">buffer_index</td><td>the index of the buffer in block's write region </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c127b633205af565427664a973a825c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c127b633205af565427664a973a825c">&#9670;&nbsp;</a></span>Vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::Vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize the input loop. It requires: 1) The scope block that the loop is in should have stage-pipeline property 2) All the blocks under the loop are complete blocks or reduction blocks, and have affine bindings 3) For each block under the loop, the loop can only be contained in data-parallel block iters' bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_rv</td><td>The loop to be vectorized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98c7166dccb89aec6fefe6652ad7cd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c7166dccb89aec6fefe6652ad7cd3f">&#9670;&nbsp;</a></span>WorkOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tvm::s_tir::ScheduleNode::WorkOn </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>func_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the schedule to work on a function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>. </p>
<p>By default, the schedule works on the function with the name "main", or the only function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> if there is only one. If there is multiple functions in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>, and none of their names are "main", users will have to call this method to explicitly specify which function to work on.</p>
<p>This sugar function will guide the <code>GetSBlock</code> method if its <code>func_name</code> is not specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the function to be working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1s__tir_1_1ScheduleNode.html#a950c37d471059d3ccb6f1da8cf12c035" title="Retrieve a block in a specific function with its name.">GetSBlock</a> </dd></dl>

</div>
</div>
<a id="ac8a6ba36b9a2b94906c9ba2b769953db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a6ba36b9a2b94906c9ba2b769953db">&#9670;&nbsp;</a></span>WriteAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> tvm::s_tir::ScheduleNode::WriteAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1LoopRV.html">LoopRV</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1s__tir_1_1SBlockRV.html">SBlockRV</a> &amp;&#160;</td>
          <td class="paramname"><em>block_rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aae5808dc2e987bf17ef42196457a654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5808dc2e987bf17ef42196457a654d">&#9670;&nbsp;</a></span>Schedule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classtvm_1_1s__tir_1_1Schedule.html">Schedule</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c825de8d2ea28ddb0256a29101f0bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c825de8d2ea28ddb0256a29101f0bb9">&#9670;&nbsp;</a></span>_type_mutable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool tvm::s_tir::ScheduleNode::_type_mutable = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/s_tir/schedule/<a class="el" href="schedule_8h_source.html">schedule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
