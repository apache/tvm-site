<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::arith Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1arith.html">arith</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::arith Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace of arithmetic analysis.  
<a href="namespacetvm_1_1arith.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBoundNode.html">ConstIntBoundNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant integer up and lower bound(inclusive). Useful for value bound analysis.  <a href="classtvm_1_1arith_1_1ConstIntBoundNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBound.html">ConstIntBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference class to <a class="el" href="classtvm_1_1arith_1_1ConstIntBoundNode.html" title="Constant integer up and lower bound(inclusive). Useful for value bound analysis.">ConstIntBoundNode</a>  <a href="classtvm_1_1arith_1_1ConstIntBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBoundAnalyzer.html">ConstIntBoundAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> to get constant integer bound over expression.  <a href="classtvm_1_1arith_1_1ConstIntBoundAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSetNode.html">ModularSetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Range.html" title="Range container">Range</a> of a linear integer function. Use to do specify the possible index values.  <a href="classtvm_1_1arith_1_1ModularSetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSet.html">ModularSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference of <a class="el" href="classtvm_1_1arith_1_1ModularSetNode.html" title="Range of a linear integer function. Use to do specify the possible index values.">ModularSetNode</a>  <a href="classtvm_1_1arith_1_1ModularSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSetAnalyzer.html">ModularSetAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> to get modular information over expression.  <a href="classtvm_1_1arith_1_1ModularSetAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1RewriteSimplifier.html">RewriteSimplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite-rule based simplifier.  <a href="classtvm_1_1arith_1_1RewriteSimplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1CanonicalSimplifier.html">CanonicalSimplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical-form based simplifier.  <a href="classtvm_1_1arith_1_1CanonicalSimplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1TransitiveComparisonAnalyzer.html">TransitiveComparisonAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using previously specified knowns, compare the expressions provided.  <a href="classtvm_1_1arith_1_1TransitiveComparisonAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstraintContext.html">ConstraintContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint context.  <a href="classtvm_1_1arith_1_1ConstraintContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSetAnalyzer.html">IntSetAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors.">Integer</a> set analyzer.  <a href="classtvm_1_1arith_1_1IntSetAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">Analyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> that contains bunch of sub-analyzers.  <a href="classtvm_1_1arith_1_1Analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSetNode.html">IntSetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors.">Integer</a> set containers. represent a set of integers in one dimension.  <a href="classtvm_1_1arith_1_1IntSetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntSetNode.html" title="Base class of all Integer set containers. represent a set of integers in one dimension.">IntSetNode</a>.  <a href="classtvm_1_1arith_1_1IntSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntGroupBoundsNode.html">IntGroupBoundsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent integer grouped bounds which are classified into lower bounds (inclusive), upper bounds (inclusive) and equalities. It also contains coefficient as a multiplier for the bounds, i.e., coef * var &gt;= lower coef * var == equal coef * var &lt;= upper.  <a href="classtvm_1_1arith_1_1IntGroupBoundsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntGroupBoundsNode.html" title="Represent integer grouped bounds which are classified into lower bounds (inclusive),...">IntGroupBoundsNode</a>.  <a href="classtvm_1_1arith_1_1IntGroupBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsNode.html">IntConstraintsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent integer constrains including (integer) variables, their ranges and the relations between them (either equations or inequalities).  <a href="classtvm_1_1arith_1_1IntConstraintsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntConstraintsNode.html" title="Represent integer constrains including (integer) variables, their ranges and the relations between th...">IntConstraintsNode</a>.  <a href="classtvm_1_1arith_1_1IntConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html">IntConstraintsTransformNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can have different set of variables to represent the same constraints. For example, the following two systems are equivalent, {a + b = 0 | a &gt;= 0, b &gt;= 0} and {m - n = 0 | m &gt;= 0, n &lt;= 0} This data structure represents the transformation between two equivalent linear systems. In the above example, src : {a + b = 0 | a &gt;= 0, b &gt;= 0} dst : {m - n = 0 | m &gt;= 0, n &lt;= 0} src_to_dst : {a -&gt; m, b -&gt; -n} dst_to_src : {m -&gt; a, n -&gt; -b}.  <a href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html" title="We can have different set of variables to represent the same constraints. For example,...">IntConstraintsTransformNode</a>.  <a href="classtvm_1_1arith_1_1IntConstraintsTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapExprNode.html">IterMapExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all iter map expressions.  <a href="classtvm_1_1arith_1_1IterMapExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html">IterMapExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterMapExprNode.html" title="Base class of all iter map expressions.">IterMapExprNode</a>.  <a href="classtvm_1_1arith_1_1IterMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMarkNode.html">IterMarkNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the source as an iterator in [0, extent).  <a href="classtvm_1_1arith_1_1IterMarkNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to IterMarkExprNode.  <a href="classtvm_1_1arith_1_1IterMark.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSplitExprNode.html">IterSplitExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split of an iterator.  <a href="classtvm_1_1arith_1_1IterSplitExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSplitExpr.html">IterSplitExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterSplitExprNode.html" title="Split of an iterator.">IterSplitExprNode</a>.  <a href="classtvm_1_1arith_1_1IterSplitExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSumExprNode.html">IterSumExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse multiple iterators by summing them with scaling.  <a href="classtvm_1_1arith_1_1IterSumExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterSumExprNode.html" title="Fuse multiple iterators by summing them with scaling.">IterSumExprNode</a>.  <a href="classtvm_1_1arith_1_1IterSumExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapResultNode.html">IterMapResultNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of DetectIterMap.  <a href="classtvm_1_1arith_1_1IterMapResultNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapResult.html">IterMapResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterMapResultNode.html" title="Result of DetectIterMap.">IterMapResultNode</a>.  <a href="classtvm_1_1arith_1_1IterMapResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0f148f1a1b469a3819e0fe6633b674e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a> = std::unordered_map&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>, ObjectPtrHash, ObjectPtrEqual &gt;</td></tr>
<tr class="memdesc:a0f148f1a1b469a3819e0fe6633b674e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from Expr to <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">IntSet</a>.  <a href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">More...</a><br /></td></tr>
<tr class="separator:a0f148f1a1b469a3819e0fe6633b674e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d0cf9322415e30f8519e46eab99287"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt;, ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a52d0cf9322415e30f8519e46eab99287">PartialSolvedInequalities</a></td></tr>
<tr class="separator:a52d0cf9322415e30f8519e46eab99287"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac6a38da661cd3681eb85abe1cd810422"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422">DivMode</a> { <a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422aa6da1e276448319d25de8fe181872432">kTruncDiv</a>
, <a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422aad0250170b362173e1e2a2e3a6f13d20">kFloorDiv</a>
 }</td></tr>
<tr class="separator:ac6a38da661cd3681eb85abe1cd810422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038b0205b1c66d27c9dff7703e359339"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a038b0205b1c66d27c9dff7703e359339">ProofStrength</a> : int { <a class="el" href="namespacetvm_1_1arith.html#a038b0205b1c66d27c9dff7703e359339a6867faeaa475fda467e48267db2bb8a8">kDefault</a> = 0
, <a class="el" href="namespacetvm_1_1arith.html#a038b0205b1c66d27c9dff7703e359339a3f67e3bf6c5ae9efc290f80011f65b80">kSymbolicBound</a> = 1
 }</td></tr>
<tr class="memdesc:a038b0205b1c66d27c9dff7703e359339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strength used in top-level condition proves.  <a href="namespacetvm_1_1arith.html#a038b0205b1c66d27c9dff7703e359339">More...</a><br /></td></tr>
<tr class="separator:a038b0205b1c66d27c9dff7703e359339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d555a0cc363f669a49fad7e5f7d69d0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0af9f8d006118de5ad04dd7c000b8f3b91">kInconsistent</a> = 0
, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0a7db2fe13b438b1005c70fcc9ab826b3b">kEQ</a> = 1
, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0add0f23f162dcf68bf7bc761ac13040ae">kLT</a> = 2
, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0a1893df55d7fc768f2336fdcb7c7b9c37">kLE</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0aa3d18adb9a64157d6708f8ba39dfcdbc">kGT</a> = 4
, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0ac0275be4f85005f8ef340d3d5be8d361">kGE</a> = 5
, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0a03e3ad128c41e04acc6a0e59fdf11a58">kNE</a> = 6
, <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da25c2dc47991b3df171ed5192bcf70390">kUnknown</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a1d555a0cc363f669a49fad7e5f7d69d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for representing result of known.  <a href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">More...</a><br /></td></tr>
<tr class="separator:a1d555a0cc363f669a49fad7e5f7d69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">SignType</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da5eb70f55e8952b4484fe6c652138ae00">kPositive</a>
, <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da56331fd0b2625f7ce83b369b8a0a6f2a">kNegative</a>
, <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9dab2f22d68a809adead1caf5ec7c61bf67">kZero</a>
, <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da8812c1a077255594d23bc1c2f3af3979">kUnknown</a>
, <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da25c2dc47991b3df171ed5192bcf70390">kUnknown</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign type of an integer expression.  <a href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">More...</a><br /></td></tr>
<tr class="separator:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243b60bbe2d3852099eb65454b240c63"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a> { <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63add09a1312b40f018ee4714799cdb0c81">Bijective</a> = 0
, <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63ae76680d0048f5c8d7160cac340cb53c9">Surjective</a> = 1
, <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63a850e59cdf8cc0407bf13366b876a0def">NoCheck</a> = 3
 }</td></tr>
<tr class="memdesc:a243b60bbe2d3852099eb65454b240c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping level for iterators.  <a href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">More...</a><br /></td></tr>
<tr class="separator:a243b60bbe2d3852099eb65454b240c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae300654bf1788008de90f1e77fbaa7fe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae300654bf1788008de90f1e77fbaa7fe">operator&amp;</a> (<a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> lhs, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> rhs)</td></tr>
<tr class="separator:ae300654bf1788008de90f1e77fbaa7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660ff1fdbb08fea19a922157cadad7a7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a660ff1fdbb08fea19a922157cadad7a7">operator|</a> (<a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> lhs, <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> rhs)</td></tr>
<tr class="separator:a660ff1fdbb08fea19a922157cadad7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7959263b3cd452d41fd114c763ba16ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a7959263b3cd452d41fd114c763ba16ca">DeduceBound</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> v, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> cond, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;hint_map, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;relax_map)</td></tr>
<tr class="memdesc:a7959263b3cd452d41fd114c763ba16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the bound of the target variable in a expression, give the domain of each variables. Return undefined <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">IntSet</a> to represent failure.  <a href="namespacetvm_1_1arith.html#a7959263b3cd452d41fd114c763ba16ca">More...</a><br /></td></tr>
<tr class="separator:a7959263b3cd452d41fd114c763ba16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3658d391f2333f405abdd54a9f174c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a3658d391f2333f405abdd54a9f174c9f">DeduceBound</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> v, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> cond, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;hint_map, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;relax_map)</td></tr>
<tr class="memdesc:a3658d391f2333f405abdd54a9f174c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as DeduceBound with unordered_map signature.  <a href="namespacetvm_1_1arith.html#a3658d391f2333f405abdd54a9f174c9f">More...</a><br /></td></tr>
<tr class="separator:a3658d391f2333f405abdd54a9f174c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7641fa29ca6d8941f2696aacccf23998"><td class="memItemLeft" align="right" valign="top">Region&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a7641fa29ca6d8941f2696aacccf23998">DomainTouched</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;body, const <a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> &amp;buffer, bool consider_loads, bool consider_stores)</td></tr>
<tr class="memdesc:a7641fa29ca6d8941f2696aacccf23998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer a regular domain that covers all the calls or provides within the given statement.  <a href="namespacetvm_1_1arith.html#a7641fa29ca6d8941f2696aacccf23998">More...</a><br /></td></tr>
<tr class="separator:a7641fa29ca6d8941f2696aacccf23998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae032e518304ba50a61aa77c1caca25d3"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae032e518304ba50a61aa77c1caca25d3">ConvertDomMap</a> (const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:ae032e518304ba50a61aa77c1caca25d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert std::unordered_map&lt;const VarNode*, IntSet&gt; to ffi::Map&lt;Var, IntSet&gt;  <a href="namespacetvm_1_1arith.html#ae032e518304ba50a61aa77c1caca25d3">More...</a><br /></td></tr>
<tr class="separator:ae032e518304ba50a61aa77c1caca25d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc2d38e3e689108a509990debf1415a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#afbc2d38e3e689108a509990debf1415a">EvalSet</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:afbc2d38e3e689108a509990debf1415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains all possible values of e given the domain of each iteration variables.  <a href="namespacetvm_1_1arith.html#afbc2d38e3e689108a509990debf1415a">More...</a><br /></td></tr>
<tr class="separator:afbc2d38e3e689108a509990debf1415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1fbcdcd311ff21256c72bb68efcde9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#acb1fbcdcd311ff21256c72bb68efcde9">EvalSet</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:acb1fbcdcd311ff21256c72bb68efcde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains all possible values of e given the domain of each variables.  <a href="namespacetvm_1_1arith.html#acb1fbcdcd311ff21256c72bb68efcde9">More...</a><br /></td></tr>
<tr class="separator:acb1fbcdcd311ff21256c72bb68efcde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a9d0d0f69e5f98e935d2bd4058d74bcfa">EvalSet</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">tir::VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes unordered_map.  <a href="namespacetvm_1_1arith.html#a9d0d0f69e5f98e935d2bd4058d74bcfa">More...</a><br /></td></tr>
<tr class="separator:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6570592cfc3e1f37ea902a83cc4754f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a6570592cfc3e1f37ea902a83cc4754f8">EvalSet</a> (<a class="el" href="classtvm_1_1Range.html">Range</a> r, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a6570592cfc3e1f37ea902a83cc4754f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains is union over all the possible conditional values in dom_map.  <a href="namespacetvm_1_1arith.html#a6570592cfc3e1f37ea902a83cc4754f8">More...</a><br /></td></tr>
<tr class="separator:a6570592cfc3e1f37ea902a83cc4754f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aa30b03ba03ff9cad2cad7320194dfcbe">EvalSet</a> (<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> s, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains is union over all the possible conditional values in dom_map.  <a href="namespacetvm_1_1arith.html#aa30b03ba03ff9cad2cad7320194dfcbe">More...</a><br /></td></tr>
<tr class="separator:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf945fe43afafbedffad6d5633efad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a4bf945fe43afafbedffad6d5633efad7">EvalSet</a> (<a class="el" href="classtvm_1_1Range.html">Range</a> r, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a4bf945fe43afafbedffad6d5633efad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes unordered_map.  <a href="namespacetvm_1_1arith.html#a4bf945fe43afafbedffad6d5633efad7">More...</a><br /></td></tr>
<tr class="separator:a4bf945fe43afafbedffad6d5633efad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db77eb9f69c694d8832b028022fc66"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a13db77eb9f69c694d8832b028022fc66">EvalSet</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a13db77eb9f69c694d8832b028022fc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes ffi::Array&lt;Range&gt;  <a href="namespacetvm_1_1arith.html#a13db77eb9f69c694d8832b028022fc66">More...</a><br /></td></tr>
<tr class="separator:a13db77eb9f69c694d8832b028022fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a112f07411c5e1237b0c045ff276ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a8a112f07411c5e1237b0c045ff276ac6">EvalSetForEachSubExpr</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a8a112f07411c5e1237b0c045ff276ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the integer set of every sub-expression, given the domain of each iteration variables.  <a href="namespacetvm_1_1arith.html#a8a112f07411c5e1237b0c045ff276ac6">More...</a><br /></td></tr>
<tr class="separator:a8a112f07411c5e1237b0c045ff276ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3f4113c4787a5690ab0effae42016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aa8b3f4113c4787a5690ab0effae42016">Union</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:aa8b3f4113c4787a5690ab0effae42016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a union set of all sets, possibly relaxed.  <a href="namespacetvm_1_1arith.html#aa8b3f4113c4787a5690ab0effae42016">More...</a><br /></td></tr>
<tr class="separator:aa8b3f4113c4787a5690ab0effae42016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87ada4b7f9ebeab9b180c91be8613fe"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#af87ada4b7f9ebeab9b180c91be8613fe">UnionRegion</a> (const ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;nd_int_sets)</td></tr>
<tr class="memdesc:af87ada4b7f9ebeab9b180c91be8613fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of N-dimensional integer sets.  <a href="namespacetvm_1_1arith.html#af87ada4b7f9ebeab9b180c91be8613fe">More...</a><br /></td></tr>
<tr class="separator:af87ada4b7f9ebeab9b180c91be8613fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edc54e86676992ac2d981140f6fbbd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a4edc54e86676992ac2d981140f6fbbd5">UnionLowerBound</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:a4edc54e86676992ac2d981140f6fbbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower-bound of union set, where some of the segments may be dropped.  <a href="namespacetvm_1_1arith.html#a4edc54e86676992ac2d981140f6fbbd5">More...</a><br /></td></tr>
<tr class="separator:a4edc54e86676992ac2d981140f6fbbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563257e54d150a96b33063019b7a734b"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a563257e54d150a96b33063019b7a734b">UnionRegionLowerBound</a> (const ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;nd_int_sets)</td></tr>
<tr class="memdesc:a563257e54d150a96b33063019b7a734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of N-dimensional integer sets.  <a href="namespacetvm_1_1arith.html#a563257e54d150a96b33063019b7a734b">More...</a><br /></td></tr>
<tr class="separator:a563257e54d150a96b33063019b7a734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff24e927e564e713db4c6a08f7b5838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aaff24e927e564e713db4c6a08f7b5838">Intersect</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:aaff24e927e564e713db4c6a08f7b5838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an intersected set of all sets.  <a href="namespacetvm_1_1arith.html#aaff24e927e564e713db4c6a08f7b5838">More...</a><br /></td></tr>
<tr class="separator:aaff24e927e564e713db4c6a08f7b5838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a3f58d040b0e570e4d540d68fbc2d"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">arith::IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a316a3f58d040b0e570e4d540d68fbc2d">AsIntSet</a> (const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;var_dom)</td></tr>
<tr class="memdesc:a316a3f58d040b0e570e4d540d68fbc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Ranges to IntSets.  <a href="namespacetvm_1_1arith.html#a316a3f58d040b0e570e4d540d68fbc2d">More...</a><br /></td></tr>
<tr class="separator:a316a3f58d040b0e570e4d540d68fbc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c79f8135bc14c942a604cb63f37c1"><td class="memItemLeft" align="right" valign="top">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ac67c79f8135bc14c942a604cb63f37c1">EstimateRegionStrictBound</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;var_dom, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:ac67c79f8135bc14c942a604cb63f37c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the region with affine map, given the domain of variables and their predicate. The result should be strict, i.e. no region is discarded or relaxed.  <a href="namespacetvm_1_1arith.html#ac67c79f8135bc14c942a604cb63f37c1">More...</a><br /></td></tr>
<tr class="separator:ac67c79f8135bc14c942a604cb63f37c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be463691ea4481a8432faeedef27bf3"><td class="memItemLeft" align="right" valign="top">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a4be463691ea4481a8432faeedef27bf3">EstimateRegionLowerBound</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;var_dom, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:a4be463691ea4481a8432faeedef27bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the region with affine map, given the domain of variables and their predicate. Some subregion may be discarded during the lower-bound analysis.  <a href="namespacetvm_1_1arith.html#a4be463691ea4481a8432faeedef27bf3">More...</a><br /></td></tr>
<tr class="separator:a4be463691ea4481a8432faeedef27bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc974926ecec19cd3b874949643a6c1"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a7cc974926ecec19cd3b874949643a6c1">EstimateRegionUpperBound</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;var_dom, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:a7cc974926ecec19cd3b874949643a6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the region with affine map, given the domain of variables and their predicate Relaxation of the region may be used in upper-bound analysis, i.e. some extra region may be added to the result.  <a href="namespacetvm_1_1arith.html#a7cc974926ecec19cd3b874949643a6c1">More...</a><br /></td></tr>
<tr class="separator:a7cc974926ecec19cd3b874949643a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f821e7f25de9769c5733cfacbe132d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a5f821e7f25de9769c5733cfacbe132d6">SmithNormalFormDiag</a> (std::vector&lt; std::vector&lt; int64_t &gt;&gt; *S, std::vector&lt; std::vector&lt; int64_t &gt;&gt; *V, std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *x, std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *y)</td></tr>
<tr class="memdesc:a5f821e7f25de9769c5733cfacbe132d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain Smith Normal Form of linear equation A x = y. Smith Normal Form of matrix A_{mxn} is S_{mxn} = U_{mxm} A_{mxn} V_{nxn}, in which S_{mxn} is diag(s1, s2, ..., sr, 0, ..., 0) and r is the rank of A. NOTE: Although in standard Smith Normal Form the diagonal elements satisfy s_i | s_{i+1} (| means divides), the implement here does not guarantee it. TODO(yzhliu): From sergei-grechanik: computing the proper Smith normal form may improve stability of automatic differentiation (generating the same gradient code for slightly different but equivalent input code U_{mxm} and V_{nxn} are invertible matrices. This function modifies <code>S</code> to be S_{mxn}, <code>V</code> to be V_{nxn}, <code>y</code> to be U_{mxm} y_{mx1} and <code>x</code> to be V^{-1} x.  <a href="namespacetvm_1_1arith.html#a5f821e7f25de9769c5733cfacbe132d6">More...</a><br /></td></tr>
<tr class="separator:a5f821e7f25de9769c5733cfacbe132d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0290f04432523ab8e5f76edde80071a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae0290f04432523ab8e5f76edde80071a">SolveLinearEquations</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ae0290f04432523ab8e5f76edde80071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear equations.  <a href="namespacetvm_1_1arith.html#ae0290f04432523ab8e5f76edde80071a">More...</a><br /></td></tr>
<tr class="separator:ae0290f04432523ab8e5f76edde80071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59d63560e04431f108e81457b212fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1arith.html#a52d0cf9322415e30f8519e46eab99287">PartialSolvedInequalities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ac59d63560e04431f108e81457b212fdc">SolveLinearInequalities</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ac59d63560e04431f108e81457b212fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities.  <a href="namespacetvm_1_1arith.html#ac59d63560e04431f108e81457b212fdc">More...</a><br /></td></tr>
<tr class="separator:ac59d63560e04431f108e81457b212fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e67442f7b96f06fea6520bf1330f944"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a1e67442f7b96f06fea6520bf1330f944">AsConditions</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;variables, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt; &amp;bounds, const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;relations)</td></tr>
<tr class="memdesc:a1e67442f7b96f06fea6520bf1330f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the information into an array of (in)equalities.  <a href="namespacetvm_1_1arith.html#a1e67442f7b96f06fea6520bf1330f944">More...</a><br /></td></tr>
<tr class="separator:a1e67442f7b96f06fea6520bf1330f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6277cb1deea497e60474e5bf83dfc636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a6277cb1deea497e60474e5bf83dfc636">SolveInequalitiesToRange</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:a6277cb1deea497e60474e5bf83dfc636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities and infer the range of each variable.  <a href="namespacetvm_1_1arith.html#a6277cb1deea497e60474e5bf83dfc636">More...</a><br /></td></tr>
<tr class="separator:a6277cb1deea497e60474e5bf83dfc636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667739c074bb7bf1e63302904c78176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ab667739c074bb7bf1e63302904c78176">SolveInequalitiesDeskewRange</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ab667739c074bb7bf1e63302904c78176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities and deskew the ranges towards zero.  <a href="namespacetvm_1_1arith.html#ab667739c074bb7bf1e63302904c78176">More...</a><br /></td></tr>
<tr class="separator:ab667739c074bb7bf1e63302904c78176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddf1dc836a934cfcaee8ab5be1a815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IterMapResult.html">IterMapResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a38ddf1dc836a934cfcaee8ab5be1a815">DetectIterMap</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;indices, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a> check_level, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer, bool simplify_trivial_iterators=true)</td></tr>
<tr class="memdesc:a38ddf1dc836a934cfcaee8ab5be1a815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n].  <a href="namespacetvm_1_1arith.html#a38ddf1dc836a934cfcaee8ab5be1a815">More...</a><br /></td></tr>
<tr class="separator:a38ddf1dc836a934cfcaee8ab5be1a815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f897e685d310654b9dec8cf4ebd67"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a497f897e685d310654b9dec8cf4ebd67">IterMapSimplify</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;indices, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;input_pred, <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a> check_level, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer, bool simplify_trivial_iterators=true)</td></tr>
<tr class="memdesc:a497f897e685d310654b9dec8cf4ebd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use IterVarMap detector to rewrite and simplify the indices.  <a href="namespacetvm_1_1arith.html#a497f897e685d310654b9dec8cf4ebd67">More...</a><br /></td></tr>
<tr class="separator:a497f897e685d310654b9dec8cf4ebd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65908ecf72e52afd2ef5c28dfa5516c6"><td class="memItemLeft" align="right" valign="top">ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a65908ecf72e52afd2ef5c28dfa5516c6">InverseAffineIterMap</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> &gt; &amp;iter_map, const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; outputs)</td></tr>
<tr class="memdesc:a65908ecf72e52afd2ef5c28dfa5516c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse of the affine transformation to the outputs.  <a href="namespacetvm_1_1arith.html#a65908ecf72e52afd2ef5c28dfa5516c6">More...</a><br /></td></tr>
<tr class="separator:a65908ecf72e52afd2ef5c28dfa5516c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e91bb223f6f2c8ac18e0d82fe4be18"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a06e91bb223f6f2c8ac18e0d82fe4be18">SubspaceDivide</a> (const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;bindings, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;sub_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a> check_level, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer, bool simplify_trivial_iterators=true)</td></tr>
<tr class="memdesc:a06e91bb223f6f2c8ac18e0d82fe4be18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if bindings can be written as [a_0*e_0 + b_0 + c_0, a_1*e_1 + b_1, ..., a_n*e_n + b_n].  <a href="namespacetvm_1_1arith.html#a06e91bb223f6f2c8ac18e0d82fe4be18">More...</a><br /></td></tr>
<tr class="separator:a06e91bb223f6f2c8ac18e0d82fe4be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec2f0c15f6e42cc49a414146b39d0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a5ec2f0c15f6e42cc49a414146b39d0b5">NormalizeIterMapToExpr</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:a5ec2f0c15f6e42cc49a414146b39d0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression that may contain <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode.">IterMapExpr</a>, transform it to normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a>.  <a href="namespacetvm_1_1arith.html#a5ec2f0c15f6e42cc49a414146b39d0b5">More...</a><br /></td></tr>
<tr class="separator:a5ec2f0c15f6e42cc49a414146b39d0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6e7a3cc69f1bc1e61f546d2e226ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ade6e7a3cc69f1bc1e61f546d2e226ef6">NormalizeToIterSum</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> index, const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:ade6e7a3cc69f1bc1e61f546d2e226ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite index as <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html" title="Managed reference to IterSumExprNode.">IterSumExpr</a>.  <a href="namespacetvm_1_1arith.html#ade6e7a3cc69f1bc1e61f546d2e226ef6">More...</a><br /></td></tr>
<tr class="separator:ade6e7a3cc69f1bc1e61f546d2e226ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a00ecf173e619bc91dbb63b21430cb2"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a5a00ecf173e619bc91dbb63b21430cb2">DetectLinearEquation</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a5a00ecf173e619bc91dbb63b21430cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if e can be rewritten as e = sum_{i=0}^{n-1} var[i] * coeff[i] + coeff[n] Where coeff[i] and base are invariant of var[j] for all i and j.  <a href="namespacetvm_1_1arith.html#a5a00ecf173e619bc91dbb63b21430cb2">More...</a><br /></td></tr>
<tr class="separator:a5a00ecf173e619bc91dbb63b21430cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00de4604e225962f71c03e0e4afcbc"><td class="memItemLeft" align="right" valign="top">ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#abc00de4604e225962f71c03e0e4afcbc">DetectClipBound</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:abc00de4604e225962f71c03e0e4afcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if expression corresponds to clip bound of the vars.  <a href="namespacetvm_1_1arith.html#abc00de4604e225962f71c03e0e4afcbc">More...</a><br /></td></tr>
<tr class="separator:abc00de4604e225962f71c03e0e4afcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a76835a091e20acfbce65f678114c0291"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a76835a091e20acfbce65f678114c0291">kSimplifyRewriteCanonicalRewrite</a> = 3</td></tr>
<tr class="separator:a76835a091e20acfbce65f678114c0291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of arithmetic analysis. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0f148f1a1b469a3819e0fe6633b674e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f148f1a1b469a3819e0fe6633b674e4">&#9670;&nbsp;</a></span>ExprIntSetMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">tvm::arith::ExprIntSetMap</a> = typedef std::unordered_map&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>, ObjectPtrHash, ObjectPtrEqual&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map from Expr to <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">IntSet</a>. </p>

</div>
</div>
<a id="a52d0cf9322415e30f8519e46eab99287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d0cf9322415e30f8519e46eab99287">&#9670;&nbsp;</a></span>PartialSolvedInequalities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a>&gt;, ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; &gt; <a class="el" href="namespacetvm_1_1arith.html#a52d0cf9322415e30f8519e46eab99287">tvm::arith::PartialSolvedInequalities</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1d555a0cc363f669a49fad7e5f7d69d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d555a0cc363f669a49fad7e5f7d69d0">&#9670;&nbsp;</a></span>CompareResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">tvm::arith::CompareResult</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Structure for representing result of known. </p>
<p>Values are assigned to allow these flags to be used in bitwise operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0af9f8d006118de5ad04dd7c000b8f3b91"></a>kInconsistent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0a7db2fe13b438b1005c70fcc9ab826b3b"></a>kEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0add0f23f162dcf68bf7bc761ac13040ae"></a>kLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0a1893df55d7fc768f2336fdcb7c7b9c37"></a>kLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0aa3d18adb9a64157d6708f8ba39dfcdbc"></a>kGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0ac0275be4f85005f8ef340d3d5be8d361"></a>kGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d555a0cc363f669a49fad7e5f7d69d0a03e3ad128c41e04acc6a0e59fdf11a58"></a>kNE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da25c2dc47991b3df171ed5192bcf70390"></a>kUnknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac6a38da661cd3681eb85abe1cd810422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a38da661cd3681eb85abe1cd810422">&#9670;&nbsp;</a></span>DivMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422">tvm::arith::DivMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac6a38da661cd3681eb85abe1cd810422aa6da1e276448319d25de8fe181872432"></a>kTruncDiv&#160;</td><td class="fielddoc"><p>Truncated division. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac6a38da661cd3681eb85abe1cd810422aad0250170b362173e1e2a2e3a6f13d20"></a>kFloorDiv&#160;</td><td class="fielddoc"><p>Floor division. </p>
</td></tr>
</table>

</div>
</div>
<a id="a243b60bbe2d3852099eb65454b240c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243b60bbe2d3852099eb65454b240c63">&#9670;&nbsp;</a></span>IterMapLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">tvm::arith::IterMapLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping level for iterators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a243b60bbe2d3852099eb65454b240c63add09a1312b40f018ee4714799cdb0c81"></a>Bijective&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a243b60bbe2d3852099eb65454b240c63ae76680d0048f5c8d7160cac340cb53c9"></a>Surjective&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a243b60bbe2d3852099eb65454b240c63a850e59cdf8cc0407bf13366b876a0def"></a>NoCheck&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a038b0205b1c66d27c9dff7703e359339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038b0205b1c66d27c9dff7703e359339">&#9670;&nbsp;</a></span>ProofStrength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#a038b0205b1c66d27c9dff7703e359339">tvm::arith::ProofStrength</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The strength used in top-level condition proves. </p>
<dl class="section note"><dt>Note</dt><dd>The higher, the more time consuming it can be.</dd></dl>
<p>Do not use level beyond kDefault in internal recursive rewriting in arith analysis and only use it at top-level simplification to avoid speed issues. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a038b0205b1c66d27c9dff7703e359339a6867faeaa475fda467e48267db2bb8a8"></a>kDefault&#160;</td><td class="fielddoc"><p>default strength, can be used in. </p>
</td></tr>
<tr><td class="fieldname"><a id="a038b0205b1c66d27c9dff7703e359339a3f67e3bf6c5ae9efc290f80011f65b80"></a>kSymbolicBound&#160;</td><td class="fielddoc"><p>Prove using symbolic bound analysis. </p>
</td></tr>
</table>

</div>
</div>
<a id="aca8806e355ad3dd5f1df9c1eca9aac9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8806e355ad3dd5f1df9c1eca9aac9d">&#9670;&nbsp;</a></span>SignType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">tvm::arith::SignType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign type of an integer expression. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da5eb70f55e8952b4484fe6c652138ae00"></a>kPositive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da56331fd0b2625f7ce83b369b8a0a6f2a"></a>kNegative&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9dab2f22d68a809adead1caf5ec7c61bf67"></a>kZero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da8812c1a077255594d23bc1c2f3af3979"></a>kUnknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da25c2dc47991b3df171ed5192bcf70390"></a>kUnknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e67442f7b96f06fea6520bf1330f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e67442f7b96f06fea6520bf1330f944">&#9670;&nbsp;</a></span>AsConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::AsConditions </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the information into an array of (in)equalities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>The variables in <code>bounds</code>. It is used to determine the iteration order to avoid indeterministic results. </td></tr>
    <tr><td class="paramname">bounds</td><td>grouped boundary of the variables. </td></tr>
    <tr><td class="paramname">relations</td><td>other relations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a316a3f58d040b0e570e4d540d68fbc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316a3f58d040b0e570e4d540d68fbc2d">&#9670;&nbsp;</a></span>AsIntSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">arith::IntSet</a>&gt; tvm::arith::AsIntSet </td>
          <td>(</td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_dom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the Ranges to IntSets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_dom</td><td>The ranges of variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer sets of the variables </dd></dl>

</div>
</div>
<a id="ae032e518304ba50a61aa77c1caca25d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032e518304ba50a61aa77c1caca25d3">&#9670;&nbsp;</a></span>ConvertDomMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::ConvertDomMap </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert std::unordered_map&lt;const VarNode*, IntSet&gt; to ffi::Map&lt;Var, IntSet&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dom_map</td><td>The domain map to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted map. </dd></dl>

</div>
</div>
<a id="a7959263b3cd452d41fd114c763ba16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7959263b3cd452d41fd114c763ba16ca">&#9670;&nbsp;</a></span>DeduceBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::DeduceBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relax_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce the bound of the target variable in a expression, give the domain of each variables. Return undefined <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">IntSet</a> to represent failure. </p>
<dl class="section note"><dt>Note</dt><dd>The returned set may be smaller than set that contains all possible values of v that satisfies the bound.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The target variable to be deduced. </td></tr>
    <tr><td class="paramname">cond</td><td>The conditional expression. </td></tr>
    <tr><td class="paramname">hint_map</td><td>The domain of variable, used to help deduce. </td></tr>
    <tr><td class="paramname">relax_map</td><td>The domain of each variable, used to relax the domain, The deduce bound must implies e for all value in relax_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that always satisfies the condition. </dd></dl>

</div>
</div>
<a id="a3658d391f2333f405abdd54a9f174c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3658d391f2333f405abdd54a9f174c9f">&#9670;&nbsp;</a></span>DeduceBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::DeduceBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relax_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as DeduceBound with unordered_map signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The target variable to be deduced. </td></tr>
    <tr><td class="paramname">cond</td><td>The conditional expression. </td></tr>
    <tr><td class="paramname">hint_map</td><td>The domain of variable, used to help deduce. </td></tr>
    <tr><td class="paramname">relax_map</td><td>The domain of each variable, used to relax the domain, The deduce bound mush implies e for all value in relax_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that always satisfies the condition. </dd></dl>

</div>
</div>
<a id="abc00de4604e225962f71c03e0e4afcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc00de4604e225962f71c03e0e4afcbc">&#9670;&nbsp;</a></span>DetectClipBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::DetectClipBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if expression corresponds to clip bound of the vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be detected. </td></tr>
    <tr><td class="paramname">vars</td><td>List of variables to be used in detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concat([min_value[i], max_value[i]]), None is returned if there is no min or max value return empty if the e does not match the pattern. </dd></dl>

</div>
</div>
<a id="a38ddf1dc836a934cfcaee8ab5be1a815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddf1dc836a934cfcaee8ab5be1a815">&#9670;&nbsp;</a></span>DetectIterMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IterMapResult.html">IterMapResult</a> tvm::arith::DetectIterMap </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a>&#160;</td>
          <td class="paramname"><em>check_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_trivial_iterators</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n]. </p>
<p>Here y = some-quasi-affine-iter-map(input_iters) and c are symbolic constants.</p>
<p>We also requires that y_i and y_j to be independent for i != j.</p>
<p>For returned value rv, the following is always true:</p><ul>
<li>rv[i]-&gt;args.size() &lt;=1: only one iterator per element.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to detect pattern for. </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">check_level</td><td>The iter mapping checking level. </td></tr>
    <tr><td class="paramname">analyzer</td><td><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> used to get context information. </td></tr>
    <tr><td class="paramname">simplify_trivial_iterators</td><td>If true, iterators with extent of 1 will be replaced with a constant value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detected iteration result. The return object's .indices is empty on failure. </dd></dl>

</div>
</div>
<a id="a5a00ecf173e619bc91dbb63b21430cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a00ecf173e619bc91dbb63b21430cb2">&#9670;&nbsp;</a></span>DetectLinearEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::DetectLinearEquation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if e can be rewritten as e = sum_{i=0}^{n-1} var[i] * coeff[i] + coeff[n] Where coeff[i] and base are invariant of var[j] for all i and j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be detected. </td></tr>
    <tr><td class="paramname">vars</td><td>List of variables to be used in detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[coeff[i]] if it is possible, empty array if it is not. </dd></dl>

</div>
</div>
<a id="a7641fa29ca6d8941f2696aacccf23998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7641fa29ca6d8941f2696aacccf23998">&#9670;&nbsp;</a></span>DomainTouched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Region tvm::arith::DomainTouched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_stores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer a regular domain that covers all the calls or provides within the given statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The given statement. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to check the access info. </td></tr>
    <tr><td class="paramname">consider_loads</td><td>If loads are considered. </td></tr>
    <tr><td class="paramname">consider_stores</td><td>If stores are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The domain that covers all the calls or provides within the given statement. </dd></dl>

</div>
</div>
<a id="a4be463691ea4481a8432faeedef27bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be463691ea4481a8432faeedef27bf3">&#9670;&nbsp;</a></span>EstimateRegionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; &gt; tvm::arith::EstimateRegionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the region with affine map, given the domain of variables and their predicate. Some subregion may be discarded during the lower-bound analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The region to be analyzed </td></tr>
    <tr><td class="paramname">var_dom</td><td>The ranges of the variables </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate for the affine map </td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::nullopt if the detection fails, or an array of <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">arith::IntSet</a> as the result of analysis </dd></dl>

</div>
</div>
<a id="ac67c79f8135bc14c942a604cb63f37c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67c79f8135bc14c942a604cb63f37c1">&#9670;&nbsp;</a></span>EstimateRegionStrictBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Optional&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; &gt; tvm::arith::EstimateRegionStrictBound </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the region with affine map, given the domain of variables and their predicate. The result should be strict, i.e. no region is discarded or relaxed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The region to be analyzed </td></tr>
    <tr><td class="paramname">var_dom</td><td>The ranges of the variables </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate for the affine map </td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::nullopt if the detection fails, or an array of <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">arith::IntSet</a> as the result of analysis </dd></dl>

</div>
</div>
<a id="a7cc974926ecec19cd3b874949643a6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc974926ecec19cd3b874949643a6c1">&#9670;&nbsp;</a></span>EstimateRegionUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::EstimateRegionUpperBound </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the region with affine map, given the domain of variables and their predicate Relaxation of the region may be used in upper-bound analysis, i.e. some extra region may be added to the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The region to be analyzed </td></tr>
    <tr><td class="paramname">var_dom</td><td>The ranges of the variables </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate for the affine map </td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode.">arith::IntSet</a> as the result of analysis </dd></dl>

</div>
</div>
<a id="a13db77eb9f69c694d8832b028022fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13db77eb9f69c694d8832b028022fc66">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes ffi::Array&lt;Range&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The range to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of integer sets that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="aa30b03ba03ff9cad2cad7320194dfcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30b03ba03ff9cad2cad7320194dfcbe">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains is union over all the possible conditional values in dom_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The initial set. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="afbc2d38e3e689108a509990debf1415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc2d38e3e689108a509990debf1415a">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains all possible values of e given the domain of each iteration variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="acb1fbcdcd311ff21256c72bb68efcde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1fbcdcd311ff21256c72bb68efcde9">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains all possible values of e given the domain of each variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a9d0d0f69e5f98e935d2bd4058d74bcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0d0f69e5f98e935d2bd4058d74bcfa">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">tir::VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a6570592cfc3e1f37ea902a83cc4754f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6570592cfc3e1f37ea902a83cc4754f8">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains is union over all the possible conditional values in dom_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The initial range. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="a4bf945fe43afafbedffad6d5633efad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf945fe43afafbedffad6d5633efad7">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The range to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a8a112f07411c5e1237b0c045ff276ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a112f07411c5e1237b0c045ff276ac6">&#9670;&nbsp;</a></span>EvalSetForEachSubExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a> tvm::arith::EvalSetForEachSubExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the integer set of every sub-expression, given the domain of each iteration variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from the expression to its possible value. </dd></dl>

</div>
</div>
<a id="aaff24e927e564e713db4c6a08f7b5838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff24e927e564e713db4c6a08f7b5838">&#9670;&nbsp;</a></span>Intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::Intersect </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an intersected set of all sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be intersected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after intersected </dd></dl>

</div>
</div>
<a id="a65908ecf72e52afd2ef5c28dfa5516c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65908ecf72e52afd2ef5c28dfa5516c6">&#9670;&nbsp;</a></span>InverseAffineIterMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Map&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::InverseAffineIterMap </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>iter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the inverse of the affine transformation to the outputs. </p>
<p>Similar to the back-propagation, starting from the outputs, it visits the DAG of the expressions in reverse topology order and applies the inverse of the affine transformation until it reaches the input. The affine iter map is required to be bijective.</p>
<p>For example, iter_map = [l0 // 16, l0 % 16], outputs = [output_0, output_1], the affine transformation specified by <code>iter_map</code> will be applied to <code>outputs</code> and the result will be {l0: ((output_0*16) + output_1)}.</p>
<p>The range of <code>outputs</code> should be the same as the output range of the affine transmation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1arith.html#a38ddf1dc836a934cfcaee8ab5be1a815" title="Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n].">DetectIterMap</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter_map</td><td>The bijective affine iter map. </td></tr>
    <tr><td class="paramname">outputs</td><td>The outputs of the affine transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The map from the input to the transformed result. </dd></dl>

</div>
</div>
<a id="a497f897e685d310654b9dec8cf4ebd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497f897e685d310654b9dec8cf4ebd67">&#9670;&nbsp;</a></span>IterMapSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::IterMapSimplify </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>input_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a>&#160;</td>
          <td class="paramname"><em>check_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_trivial_iterators</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use IterVarMap detector to rewrite and simplify the indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to detect pattern for. </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">input_pred</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">check_level</td><td>The iter mapping checking level. </td></tr>
    <tr><td class="paramname">analyzer</td><td><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> used to get context information. </td></tr>
    <tr><td class="paramname">simplify_trivial_iterators</td><td>If true, iterators with unit extents are simplified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices after rewrite </dd></dl>

</div>
</div>
<a id="a5ec2f0c15f6e42cc49a414146b39d0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec2f0c15f6e42cc49a414146b39d0b5">&#9670;&nbsp;</a></span>NormalizeIterMapToExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::arith::NormalizeIterMapToExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression that may contain <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode.">IterMapExpr</a>, transform it to normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression, which may contain <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode.">IterMapExpr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode.">PrimExpr</a>. </dd></dl>

</div>
</div>
<a id="ade6e7a3cc69f1bc1e61f546d2e226ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6e7a3cc69f1bc1e61f546d2e226ef6">&#9670;&nbsp;</a></span>NormalizeToIterSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> tvm::arith::NormalizeToIterSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite index as <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html" title="Managed reference to IterSumExprNode.">IterSumExpr</a>. </p>
<p>((i0 // b0) % a0) * s0 + ((i0 // b1) % a1) * s1 ... + base</p>
<p>The iterators are ordered such that s0 &gt; s1 ... if we can prove the relation.</p>
<p>Note that base may contain expressions that cannot be detected as the right pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The input index </td></tr>
    <tr><td class="paramname">input_iters</td><td>The input iterators. </td></tr>
    <tr><td class="paramname">analyzer</td><td>The input analyzer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is useful to detect iterator stride patterns. </dd></dl>

</div>
</div>
<a id="ae300654bf1788008de90f1e77fbaa7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae300654bf1788008de90f1e77fbaa7fe">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> tvm::arith::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a660ff1fdbb08fea19a922157cadad7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660ff1fdbb08fea19a922157cadad7a7">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a> tvm::arith::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a1d555a0cc363f669a49fad7e5f7d69d0">CompareResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f821e7f25de9769c5733cfacbe132d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f821e7f25de9769c5733cfacbe132d6">&#9670;&nbsp;</a></span>SmithNormalFormDiag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::arith::SmithNormalFormDiag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt;&gt; *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt;&gt; *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain Smith Normal Form of linear equation A x = y. Smith Normal Form of matrix A_{mxn} is S_{mxn} = U_{mxm} A_{mxn} V_{nxn}, in which S_{mxn} is diag(s1, s2, ..., sr, 0, ..., 0) and r is the rank of A. NOTE: Although in standard Smith Normal Form the diagonal elements satisfy s_i | s_{i+1} (| means divides), the implement here does not guarantee it. TODO(yzhliu): From sergei-grechanik: computing the proper Smith normal form may improve stability of automatic differentiation (generating the same gradient code for slightly different but equivalent input code U_{mxm} and V_{nxn} are invertible matrices. This function modifies <code>S</code> to be S_{mxn}, <code>V</code> to be V_{nxn}, <code>y</code> to be U_{mxm} y_{mx1} and <code>x</code> to be V^{-1} x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the original A_{mxn}, it will be modified to S_{mxn}</td></tr>
    <tr><td class="paramname">V</td><td>an identity matrix, it will be modified to V_{nxn}</td></tr>
    <tr><td class="paramname">x</td><td>the x in A x = y. it will be modified to V^{-1}_{nxn} x_{nx1}</td></tr>
    <tr><td class="paramname">y</td><td>the y in A x = y. it will be modified to U_{mxm} y_{mx1} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab667739c074bb7bf1e63302904c78176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667739c074bb7bf1e63302904c78176">&#9670;&nbsp;</a></span>SolveInequalitiesDeskewRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a> tvm::arith::SolveInequalitiesDeskewRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities and deskew the ranges towards zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transform (src <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode.">IntConstraints</a> -&gt; dst <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode.">IntConstraints</a>) from original variables to a set of new variables. The ranges of new variables always start from zero, their extents are solved from <code>system_to_solve</code>. src <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode.">IntConstraints</a> is the same as <code>system_to_solve</code>. dst IntConstraints(variables, ranges, relations) contains,<ol type="1">
<li>variables - the variables that have been solved.</li>
<li>ranges - the best range (start from zero) of each variable.</li>
<li>relations - constraints that cannot be transformed to <a class="el" href="classtvm_1_1Range.html" title="Range container">Range</a> will be stored in relations. Variable mapping can be obtained from IntConstraintsTransform.src_to_dst and IntConstraintsTransform.dst_to_src. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a6277cb1deea497e60474e5bf83dfc636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6277cb1deea497e60474e5bf83dfc636">&#9670;&nbsp;</a></span>SolveInequalitiesToRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> tvm::arith::SolveInequalitiesToRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities and infer the range of each variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result ranges for each variables. The returned IntConstraints(variables, ranges, relations) contains,<ol type="1">
<li>variables - the variables that have been solved.</li>
<li>ranges - the best range of each variable.</li>
<li>relations - constraints that cannot be transformed to <a class="el" href="classtvm_1_1Range.html" title="Range container">Range</a> will be stored in relations. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ae0290f04432523ab8e5f76edde80071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0290f04432523ab8e5f76edde80071a">&#9670;&nbsp;</a></span>SolveLinearEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a> tvm::arith::SolveLinearEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of equations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new linear system, with less variables (if <code>system_to_solve</code> is NOT of full rank), or no variable (if <code>system_to_solve</code> is of full rank), or an empty linear system (if <code>system_to_solve</code> is unsolvable). It also provides the ranges of the variables in the new system, as well as inequalities inferred from the <code>system_to_solve</code>. You can get the mapping from the original variables to the solution via ret-&gt;src_to_dst. </dd></dl>

</div>
</div>
<a id="ac59d63560e04431f108e81457b212fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59d63560e04431f108e81457b212fdc">&#9670;&nbsp;</a></span>SolveLinearInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1arith.html#a52d0cf9322415e30f8519e46eab99287">PartialSolvedInequalities</a> tvm::arith::SolveLinearInequalities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. The inequalities are rewritten using Fourier-Motzkin elimination. This function takes an array of (in)equalities and an array of variables, and essentially rewrites the (in)equalities into an array of (in)equalities of the following form,</td></tr>
  </table>
  </dd>
</dl>
<p>x0 &gt;= f0(x1, x2, ..., xn) x0 &lt;= g0(x1, x2, ..., xn) x1 &gt;= f1(x2, ..., xn) x1 &lt;= g1(x2, ..., xn) ... xn &gt;= fn() // just a constant xn &lt;= gn() // just a constant</p>
<dl class="section return"><dt>Returns</dt><dd>A map of variables and their solved bounds, and constrains that cannot be solved to bounds. </dd></dl>

</div>
</div>
<a id="a06e91bb223f6f2c8ac18e0d82fe4be18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e91bb223f6f2c8ac18e0d82fe4be18">&#9670;&nbsp;</a></span>SubspaceDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a>&gt; &gt; tvm::arith::SubspaceDivide </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1arith.html#a243b60bbe2d3852099eb65454b240c63">IterMapLevel</a>&#160;</td>
          <td class="paramname"><em>check_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_trivial_iterators</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if bindings can be written as [a_0*e_0 + b_0 + c_0, a_1*e_1 + b_1, ..., a_n*e_n + b_n]. </p>
<p>where a = some-quasi-affine-iter-map(input_iters set_minus sub_iters) b = some-quasi-affine-iter-map(sub_iters) c is constant symbols e is the extent of b</p>
<p>For example, z*12 + y*3 + x + c = (z*4+y)*3 + x, if sub_iters={x}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>The input bindings </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">sub_iters</td><td>Iterators of subspace. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">check_level</td><td>The iter mapping checking level. </td></tr>
    <tr><td class="paramname">analyzer</td><td><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers.">Analyzer</a> used to get context information. </td></tr>
    <tr><td class="paramname">simplify_trivial_iterators</td><td>If true, iterators with extent of 1 will be replaced with a constant value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list has length len(bindings) + 1 [0, len(bindings)): The iter map matching result. The inner list is of length 2. The first expr is the basis of the quotient space. The second expr is the basis of the subspace. len(bindings): the predicate of outer space and inner space Empty array if no match can be found. </dd></dl>

</div>
</div>
<a id="aa8b3f4113c4787a5690ab0effae42016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b3f4113c4787a5690ab0effae42016">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::Union </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a union set of all sets, possibly relaxed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be combined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after union </dd></dl>

</div>
</div>
<a id="a4edc54e86676992ac2d981140f6fbbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edc54e86676992ac2d981140f6fbbd5">&#9670;&nbsp;</a></span>UnionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::UnionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower-bound of union set, where some of the segments may be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be combined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after union </dd></dl>

</div>
</div>
<a id="af87ada4b7f9ebeab9b180c91be8613fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87ada4b7f9ebeab9b180c91be8613fe">&#9670;&nbsp;</a></span>UnionRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::UnionRegion </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nd_int_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of N-dimensional integer sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd_int_sets</td><td>A list of N-dimensional integer sets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An N-dimensional integer set as the result of union </dd></dl>

</div>
</div>
<a id="a563257e54d150a96b33063019b7a734b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563257e54d150a96b33063019b7a734b">&#9670;&nbsp;</a></span>UnionRegionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ffi::Array&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::UnionRegionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nd_int_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of N-dimensional integer sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd_int_sets</td><td>A list of N-dimensional integer sets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An N-dimensional integer set as the result of union </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a76835a091e20acfbce65f678114c0291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76835a091e20acfbce65f678114c0291">&#9670;&nbsp;</a></span>kSimplifyRewriteCanonicalRewrite</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::arith::kSimplifyRewriteCanonicalRewrite = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
