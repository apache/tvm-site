<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::arith Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1arith.html">arith</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::arith Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace of arithmetic analysis.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">Analyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers. ">Analyzer</a> that contains bunch of sub-analyzers.  <a href="classtvm_1_1arith_1_1Analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1CanonicalSimplifier.html">CanonicalSimplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical-form based simplifier.  <a href="classtvm_1_1arith_1_1CanonicalSimplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBound.html">ConstIntBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference class to <a class="el" href="classtvm_1_1arith_1_1ConstIntBoundNode.html" title="Constant integer up and lower bound(inclusive). Useful for value bound analysis. ">ConstIntBoundNode</a>  <a href="classtvm_1_1arith_1_1ConstIntBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBoundAnalyzer.html">ConstIntBoundAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers. ">Analyzer</a> to get constant integer bound over expression.  <a href="classtvm_1_1arith_1_1ConstIntBoundAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstIntBoundNode.html">ConstIntBoundNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant integer up and lower bound(inclusive). Useful for value bound analysis.  <a href="classtvm_1_1arith_1_1ConstIntBoundNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ConstraintContext.html">ConstraintContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint context.  <a href="classtvm_1_1arith_1_1ConstraintContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntConstraintsNode.html" title="Represent integer constrains including (integer) variables, their ranges and the relations between th...">IntConstraintsNode</a>.  <a href="classtvm_1_1arith_1_1IntConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsNode.html">IntConstraintsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent integer constrains including (integer) variables, their ranges and the relations between them (either equations or inequalities).  <a href="classtvm_1_1arith_1_1IntConstraintsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html" title="We can have different set of variables to represent the same constraints. For example, the following two systems are equivalent, {a + b = 0 | a &gt;= 0, b &gt;= 0} and {m - n = 0 | m &gt;= 0, n &lt;= 0} This data structure represents the transformation between two equivalent linear systems. In the above example, src : {a + b = 0 | a &gt;= 0, b &gt;= 0} dst : {m - n = 0 | m &gt;= 0, n &lt;= 0} src_to_dst : {a -&gt; m, b -&gt; -n} dst_to_src : {m -&gt; a, n -&gt; -b}. ">IntConstraintsTransformNode</a>.  <a href="classtvm_1_1arith_1_1IntConstraintsTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html">IntConstraintsTransformNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can have different set of variables to represent the same constraints. For example, the following two systems are equivalent, {a + b = 0 | a &gt;= 0, b &gt;= 0} and {m - n = 0 | m &gt;= 0, n &lt;= 0} This data structure represents the transformation between two equivalent linear systems. In the above example, src : {a + b = 0 | a &gt;= 0, b &gt;= 0} dst : {m - n = 0 | m &gt;= 0, n &lt;= 0} src_to_dst : {a -&gt; m, b -&gt; -n} dst_to_src : {m -&gt; a, n -&gt; -b}.  <a href="classtvm_1_1arith_1_1IntConstraintsTransformNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntGroupBoundsNode.html" title="Represent integer grouped bounds which are classified into lower bounds (inclusive), upper bounds (inclusive) and equalities. It also contains coefficient as a multiplier for the bounds, i.e., coef * var &gt;= lower coef * var == equal coef * var &lt;= upper. ">IntGroupBoundsNode</a>.  <a href="classtvm_1_1arith_1_1IntGroupBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntGroupBoundsNode.html">IntGroupBoundsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent integer grouped bounds which are classified into lower bounds (inclusive), upper bounds (inclusive) and equalities. It also contains coefficient as a multiplier for the bounds, i.e., coef * var &gt;= lower coef * var == equal coef * var &lt;= upper.  <a href="classtvm_1_1arith_1_1IntGroupBoundsNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IntSetNode.html" title="Base class of all Integer set containers. represent a set of integers in one dimension. ">IntSetNode</a>.  <a href="classtvm_1_1arith_1_1IntSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSetAnalyzer.html">IntSetAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> set analyzer.  <a href="classtvm_1_1arith_1_1IntSetAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IntSetNode.html">IntSetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> set containers. represent a set of integers in one dimension.  <a href="classtvm_1_1arith_1_1IntSetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html">IterMapExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterMapExprNode.html" title="Base class of all iter map expressions. ">IterMapExprNode</a>.  <a href="classtvm_1_1arith_1_1IterMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMapExprNode.html">IterMapExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all iter map expressions.  <a href="classtvm_1_1arith_1_1IterMapExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to IterMarkExprNode.  <a href="classtvm_1_1arith_1_1IterMark.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterMarkNode.html">IterMarkNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the source as an iterator in [0, extent).  <a href="classtvm_1_1arith_1_1IterMarkNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSplitExpr.html">IterSplitExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterSplitExprNode.html" title="Split of an iterator. ">IterSplitExprNode</a>.  <a href="classtvm_1_1arith_1_1IterSplitExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSplitExprNode.html">IterSplitExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split of an iterator.  <a href="classtvm_1_1arith_1_1IterSplitExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1arith_1_1IterSumExprNode.html" title="Fuse multiple iterators by summing them with scaling. ">IterSumExprNode</a>.  <a href="classtvm_1_1arith_1_1IterSumExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1IterSumExprNode.html">IterSumExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse multiple iterators by summing them with scaling.  <a href="classtvm_1_1arith_1_1IterSumExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSet.html">ModularSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference of <a class="el" href="classtvm_1_1arith_1_1ModularSetNode.html" title="Range of a linear integer function. Use to do specify the possible index values. ">ModularSetNode</a>  <a href="classtvm_1_1arith_1_1ModularSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSetAnalyzer.html">ModularSetAnalyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers. ">Analyzer</a> to get modular information over expression.  <a href="classtvm_1_1arith_1_1ModularSetAnalyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1ModularSetNode.html">ModularSetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Range.html" title="Range constainer. ">Range</a> of a linear integer function. Use to do specify the possible index values.  <a href="classtvm_1_1arith_1_1ModularSetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1arith_1_1RewriteSimplifier.html">RewriteSimplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite-rule based simplifier.  <a href="classtvm_1_1arith_1_1RewriteSimplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0f148f1a1b469a3819e0fe6633b674e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a> = std::unordered_map&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectPtrHash.html">ObjectPtrHash</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectPtrEqual.html">ObjectPtrEqual</a> &gt;</td></tr>
<tr class="memdesc:a0f148f1a1b469a3819e0fe6633b674e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from Expr to <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode. ">IntSet</a>.  <a href="#a0f148f1a1b469a3819e0fe6633b674e4">More...</a><br /></td></tr>
<tr class="separator:a0f148f1a1b469a3819e0fe6633b674e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7450490c4a53f62bab4463cdb5e9c8"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt;, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#adf7450490c4a53f62bab4463cdb5e9c8">PartialSolvedInequalities</a></td></tr>
<tr class="separator:adf7450490c4a53f62bab4463cdb5e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac6a38da661cd3681eb85abe1cd810422"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422">DivMode</a> { <a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422aa6da1e276448319d25de8fe181872432">kTruncDiv</a>, 
<a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422aad0250170b362173e1e2a2e3a6f13d20">kFloorDiv</a>
 }</td></tr>
<tr class="separator:ac6a38da661cd3681eb85abe1cd810422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">SignType</a> { <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da5eb70f55e8952b4484fe6c652138ae00">kPositive</a>, 
<a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da56331fd0b2625f7ce83b369b8a0a6f2a">kNegative</a>, 
<a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9dab2f22d68a809adead1caf5ec7c61bf67">kZero</a>, 
<a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9da8812c1a077255594d23bc1c2f3af3979">kUnknown</a>
 }<tr class="memdesc:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign type of an integer expression.  <a href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aca8806e355ad3dd5f1df9c1eca9aac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0860828b70ea8ff0d2f7c036c37afd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#af0860828b70ea8ff0d2f7c036c37afd5">DeduceBound</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> v, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> cond, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;hint_map, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;relax_map)</td></tr>
<tr class="memdesc:af0860828b70ea8ff0d2f7c036c37afd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the bound of the target variable in a expression, give the domain of each variables. Return undefined <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode. ">IntSet</a> to represent failure.  <a href="#af0860828b70ea8ff0d2f7c036c37afd5">More...</a><br /></td></tr>
<tr class="separator:af0860828b70ea8ff0d2f7c036c37afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3658d391f2333f405abdd54a9f174c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a3658d391f2333f405abdd54a9f174c9f">DeduceBound</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> v, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> cond, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;hint_map, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;relax_map)</td></tr>
<tr class="memdesc:a3658d391f2333f405abdd54a9f174c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as DeduceBound with unordered_map signature.  <a href="#a3658d391f2333f405abdd54a9f174c9f">More...</a><br /></td></tr>
<tr class="separator:a3658d391f2333f405abdd54a9f174c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7641fa29ca6d8941f2696aacccf23998"><td class="memItemLeft" align="right" valign="top">Region&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a7641fa29ca6d8941f2696aacccf23998">DomainTouched</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;body, const <a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> &amp;buffer, bool consider_loads, bool consider_stores)</td></tr>
<tr class="memdesc:a7641fa29ca6d8941f2696aacccf23998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer a regular domain that covers all the calls or provides within the given statement.  <a href="#a7641fa29ca6d8941f2696aacccf23998">More...</a><br /></td></tr>
<tr class="separator:a7641fa29ca6d8941f2696aacccf23998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c10274dba2e8367f902ad4bb0e152a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a32c10274dba2e8367f902ad4bb0e152a">ConvertDomMap</a> (const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a32c10274dba2e8367f902ad4bb0e152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert std::unordered_map&lt;const VarNode*, IntSet&gt; to Map&lt;Var, IntSet&gt;  <a href="#a32c10274dba2e8367f902ad4bb0e152a">More...</a><br /></td></tr>
<tr class="separator:a32c10274dba2e8367f902ad4bb0e152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73160d1f944121ad2ef22205dd496fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a73160d1f944121ad2ef22205dd496fdc">EvalSet</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a73160d1f944121ad2ef22205dd496fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains all possible values of e given the domain of each iteration variables.  <a href="#a73160d1f944121ad2ef22205dd496fdc">More...</a><br /></td></tr>
<tr class="separator:a73160d1f944121ad2ef22205dd496fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a9d0d0f69e5f98e935d2bd4058d74bcfa">EvalSet</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">tir::VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes unordered_map.  <a href="#a9d0d0f69e5f98e935d2bd4058d74bcfa">More...</a><br /></td></tr>
<tr class="separator:a9d0d0f69e5f98e935d2bd4058d74bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74234ce6f7733b3d8055d781cc782df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a74234ce6f7733b3d8055d781cc782df7">EvalSet</a> (<a class="el" href="classtvm_1_1Range.html">Range</a> r, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a74234ce6f7733b3d8055d781cc782df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains is union over all the possible conditional values in dom_map.  <a href="#a74234ce6f7733b3d8055d781cc782df7">More...</a><br /></td></tr>
<tr class="separator:a74234ce6f7733b3d8055d781cc782df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aa30b03ba03ff9cad2cad7320194dfcbe">EvalSet</a> (<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> s, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an symbolic integer set that contains is union over all the possible conditional values in dom_map.  <a href="#aa30b03ba03ff9cad2cad7320194dfcbe">More...</a><br /></td></tr>
<tr class="separator:aa30b03ba03ff9cad2cad7320194dfcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf945fe43afafbedffad6d5633efad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a4bf945fe43afafbedffad6d5633efad7">EvalSet</a> (<a class="el" href="classtvm_1_1Range.html">Range</a> r, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a4bf945fe43afafbedffad6d5633efad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes unordered_map.  <a href="#a4bf945fe43afafbedffad6d5633efad7">More...</a><br /></td></tr>
<tr class="separator:a4bf945fe43afafbedffad6d5633efad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79359af75db0286bfe975b9828e971e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a79359af75db0286bfe975b9828e971e4">EvalSet</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a79359af75db0286bfe975b9828e971e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as EvalSet, but takes <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array&lt;Range&gt;</a>  <a href="#a79359af75db0286bfe975b9828e971e4">More...</a><br /></td></tr>
<tr class="separator:a79359af75db0286bfe975b9828e971e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a112f07411c5e1237b0c045ff276ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a8a112f07411c5e1237b0c045ff276ac6">EvalSetForEachSubExpr</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> e, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;dom_map)</td></tr>
<tr class="memdesc:a8a112f07411c5e1237b0c045ff276ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the integer set of every sub-expression, given the domain of each iteration variables.  <a href="#a8a112f07411c5e1237b0c045ff276ac6">More...</a><br /></td></tr>
<tr class="separator:a8a112f07411c5e1237b0c045ff276ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a0523bf0384e492ab222d30be9160e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a68a0523bf0384e492ab222d30be9160e">Union</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:a68a0523bf0384e492ab222d30be9160e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a union set of all sets, possibly relaxed.  <a href="#a68a0523bf0384e492ab222d30be9160e">More...</a><br /></td></tr>
<tr class="separator:a68a0523bf0384e492ab222d30be9160e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27c4f216e41eb8e81296fb7ec4b9453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ad27c4f216e41eb8e81296fb7ec4b9453">UnionRegion</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;nd_int_sets)</td></tr>
<tr class="memdesc:ad27c4f216e41eb8e81296fb7ec4b9453"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of N-dimensional integer sets.  <a href="#ad27c4f216e41eb8e81296fb7ec4b9453">More...</a><br /></td></tr>
<tr class="separator:ad27c4f216e41eb8e81296fb7ec4b9453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d7fd95abb5fa372843a40e19d80c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ab22d7fd95abb5fa372843a40e19d80c5">UnionLowerBound</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:ab22d7fd95abb5fa372843a40e19d80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower-bound of union set, where some of the segments may be dropped.  <a href="#ab22d7fd95abb5fa372843a40e19d80c5">More...</a><br /></td></tr>
<tr class="separator:ab22d7fd95abb5fa372843a40e19d80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3dedfa4cba4ad39c953eb51eb83e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a4c3dedfa4cba4ad39c953eb51eb83e4d">UnionRegionLowerBound</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;nd_int_sets)</td></tr>
<tr class="memdesc:a4c3dedfa4cba4ad39c953eb51eb83e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of N-dimensional integer sets.  <a href="#a4c3dedfa4cba4ad39c953eb51eb83e4d">More...</a><br /></td></tr>
<tr class="separator:a4c3dedfa4cba4ad39c953eb51eb83e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66a987ddb3d8aee69f9175bf412eb8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ad66a987ddb3d8aee69f9175bf412eb8a">Intersect</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:ad66a987ddb3d8aee69f9175bf412eb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an intersected set of all sets.  <a href="#ad66a987ddb3d8aee69f9175bf412eb8a">More...</a><br /></td></tr>
<tr class="separator:ad66a987ddb3d8aee69f9175bf412eb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31262f87a37f9f847ace3c5c8e81dcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a31262f87a37f9f847ace3c5c8e81dcf5">EstimateRegionLowerBound</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;region, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;var_dom, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer)</td></tr>
<tr class="memdesc:a31262f87a37f9f847ace3c5c8e81dcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the region with affine map, given the domain of variables and their predicate.  <a href="#a31262f87a37f9f847ace3c5c8e81dcf5">More...</a><br /></td></tr>
<tr class="separator:a31262f87a37f9f847ace3c5c8e81dcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f821e7f25de9769c5733cfacbe132d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a5f821e7f25de9769c5733cfacbe132d6">SmithNormalFormDiag</a> (std::vector&lt; std::vector&lt; int64_t &gt;&gt; *S, std::vector&lt; std::vector&lt; int64_t &gt;&gt; *V, std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *x, std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *y)</td></tr>
<tr class="memdesc:a5f821e7f25de9769c5733cfacbe132d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain Smith Normal Form of linear equation A x = y. Smith Normal Form of matrix A_{mxn} is S_{mxn} = U_{mxm} A_{mxn} V_{nxn}, in which S_{mxn} is diag(s1, s2, ..., sr, 0, ..., 0) and r is the rank of A. NOTE: Although in standard Smith Normal Form the diagonal elements satisfy s_i | s_{i+1} (| means divides), the implement here does not guarantee it. TODO(yzhliu): From sergei-grechanik: computing the proper Smith normal form may improve stability of automatic differentiation (generating the same gradient code for slightly different but equivalent input code U_{mxm} and V_{nxn} are invertible matrices. This function modifies <code>S</code> to be S_{mxn}, <code>V</code> to be V_{nxn}, <code>y</code> to be U_{mxm} y_{mx1} and <code>x</code> to be V^{-1} x.  <a href="#a5f821e7f25de9769c5733cfacbe132d6">More...</a><br /></td></tr>
<tr class="separator:a5f821e7f25de9769c5733cfacbe132d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0290f04432523ab8e5f76edde80071a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae0290f04432523ab8e5f76edde80071a">SolveLinearEquations</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ae0290f04432523ab8e5f76edde80071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear equations.  <a href="#ae0290f04432523ab8e5f76edde80071a">More...</a><br /></td></tr>
<tr class="separator:ae0290f04432523ab8e5f76edde80071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59d63560e04431f108e81457b212fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1arith.html#adf7450490c4a53f62bab4463cdb5e9c8">PartialSolvedInequalities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ac59d63560e04431f108e81457b212fdc">SolveLinearInequalities</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ac59d63560e04431f108e81457b212fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities.  <a href="#ac59d63560e04431f108e81457b212fdc">More...</a><br /></td></tr>
<tr class="separator:ac59d63560e04431f108e81457b212fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b593dc5d590eab7df2abdca7271b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aa4b593dc5d590eab7df2abdca7271b34">AsConditions</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;variables, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt; &amp;bounds, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;relations)</td></tr>
<tr class="memdesc:aa4b593dc5d590eab7df2abdca7271b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the information into an array of (in)equalities.  <a href="#aa4b593dc5d590eab7df2abdca7271b34">More...</a><br /></td></tr>
<tr class="separator:aa4b593dc5d590eab7df2abdca7271b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6277cb1deea497e60474e5bf83dfc636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a6277cb1deea497e60474e5bf83dfc636">SolveInequalitiesToRange</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:a6277cb1deea497e60474e5bf83dfc636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities and infer the range of each variable.  <a href="#a6277cb1deea497e60474e5bf83dfc636">More...</a><br /></td></tr>
<tr class="separator:a6277cb1deea497e60474e5bf83dfc636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667739c074bb7bf1e63302904c78176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ab667739c074bb7bf1e63302904c78176">SolveInequalitiesDeskewRange</a> (const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;system_to_solve)</td></tr>
<tr class="memdesc:ab667739c074bb7bf1e63302904c78176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear inequalities and deskew the ranges towards zero.  <a href="#ab667739c074bb7bf1e63302904c78176">More...</a><br /></td></tr>
<tr class="separator:ab667739c074bb7bf1e63302904c78176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aededb94795b43959bb4c0b07d5f77d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#aededb94795b43959bb4c0b07d5f77d2a">DetectIterMap</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;indices, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, bool require_bijective, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer, <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> diag_ctx)</td></tr>
<tr class="memdesc:aededb94795b43959bb4c0b07d5f77d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n].  <a href="#aededb94795b43959bb4c0b07d5f77d2a">More...</a><br /></td></tr>
<tr class="separator:aededb94795b43959bb4c0b07d5f77d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26374719c9dc2fe371f684ff8a33474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ab26374719c9dc2fe371f684ff8a33474">IterMapSimplify</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;indices, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;input_pred, bool require_bijective)</td></tr>
<tr class="memdesc:ab26374719c9dc2fe371f684ff8a33474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use IterVarMap detector to rewrite and simplify the indices.  <a href="#ab26374719c9dc2fe371f684ff8a33474">More...</a><br /></td></tr>
<tr class="separator:ab26374719c9dc2fe371f684ff8a33474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e8be2bde49ccbe7025f4d7a730e694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae8e8be2bde49ccbe7025f4d7a730e694">InverseAffineIterMap</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> &gt; &amp;iter_map, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; outputs)</td></tr>
<tr class="memdesc:ae8e8be2bde49ccbe7025f4d7a730e694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse of the affine transformation to the outputs.  <a href="#ae8e8be2bde49ccbe7025f4d7a730e694">More...</a><br /></td></tr>
<tr class="separator:ae8e8be2bde49ccbe7025f4d7a730e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae153bfade4c3084d59811b6cb846900f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#ae153bfade4c3084d59811b6cb846900f">SubspaceDivide</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;bindings, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;input_iters, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;sub_iters, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;predicate, bool require_bijective, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *analyzer, <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> diag_ctx)</td></tr>
<tr class="memdesc:ae153bfade4c3084d59811b6cb846900f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if bindings can be written as [a_0*e_0 + b_0 + c_0, a_1*e_1 + b_1, ..., a_n*e_n + b_n].  <a href="#ae153bfade4c3084d59811b6cb846900f">More...</a><br /></td></tr>
<tr class="separator:ae153bfade4c3084d59811b6cb846900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4b93476f56fc5d68dbba17859660e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#af5e4b93476f56fc5d68dbba17859660e">NormalizeIterMapToExpr</a> (const <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html">IterMapExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:af5e4b93476f56fc5d68dbba17859660e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode. ">IterMapExpr</a>, transform it to normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>.  <a href="#af5e4b93476f56fc5d68dbba17859660e">More...</a><br /></td></tr>
<tr class="separator:af5e4b93476f56fc5d68dbba17859660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a12ee0854469b04329a961ef261559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a87a12ee0854469b04329a961ef261559">DetectLinearEquation</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a87a12ee0854469b04329a961ef261559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if e can be rewritten as e = sum_{i=0}^{n-1} var[i] * coeff[i] + coeff[n] Where coeff[i] and base are invariant of var[j] for all i and j.  <a href="#a87a12ee0854469b04329a961ef261559">More...</a><br /></td></tr>
<tr class="separator:a87a12ee0854469b04329a961ef261559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739616342876c2633b87ed16c649bc91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a739616342876c2633b87ed16c649bc91">DetectClipBound</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a739616342876c2633b87ed16c649bc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if expression corresponds to clip bound of the vars.  <a href="#a739616342876c2633b87ed16c649bc91">More...</a><br /></td></tr>
<tr class="separator:a739616342876c2633b87ed16c649bc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a76835a091e20acfbce65f678114c0291"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1arith.html#a76835a091e20acfbce65f678114c0291">kSimplifyRewriteCanonicalRewrite</a> = 3</td></tr>
<tr class="separator:a76835a091e20acfbce65f678114c0291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of arithmetic analysis. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0f148f1a1b469a3819e0fe6633b674e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f148f1a1b469a3819e0fe6633b674e4">&#9670;&nbsp;</a></span>ExprIntSetMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">tvm::arith::ExprIntSetMap</a> = typedef std::unordered_map&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectPtrHash.html">ObjectPtrHash</a>, <a class="el" href="structtvm_1_1runtime_1_1ObjectPtrEqual.html">ObjectPtrEqual</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map from Expr to <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode. ">IntSet</a>. </p>

</div>
</div>
<a id="adf7450490c4a53f62bab4463cdb5e9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7450490c4a53f62bab4463cdb5e9c8">&#9670;&nbsp;</a></span>PartialSolvedInequalities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a>&gt;, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; &gt; <a class="el" href="namespacetvm_1_1arith.html#adf7450490c4a53f62bab4463cdb5e9c8">tvm::arith::PartialSolvedInequalities</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac6a38da661cd3681eb85abe1cd810422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a38da661cd3681eb85abe1cd810422">&#9670;&nbsp;</a></span>DivMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#ac6a38da661cd3681eb85abe1cd810422">tvm::arith::DivMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac6a38da661cd3681eb85abe1cd810422aa6da1e276448319d25de8fe181872432"></a>kTruncDiv&#160;</td><td class="fielddoc"><p>Truncated division. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac6a38da661cd3681eb85abe1cd810422aad0250170b362173e1e2a2e3a6f13d20"></a>kFloorDiv&#160;</td><td class="fielddoc"><p>Floor division. </p>
</td></tr>
</table>

</div>
</div>
<a id="aca8806e355ad3dd5f1df9c1eca9aac9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8806e355ad3dd5f1df9c1eca9aac9d">&#9670;&nbsp;</a></span>SignType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1arith.html#aca8806e355ad3dd5f1df9c1eca9aac9d">tvm::arith::SignType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign type of an integer expression. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da5eb70f55e8952b4484fe6c652138ae00"></a>kPositive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da56331fd0b2625f7ce83b369b8a0a6f2a"></a>kNegative&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9dab2f22d68a809adead1caf5ec7c61bf67"></a>kZero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca8806e355ad3dd5f1df9c1eca9aac9da8812c1a077255594d23bc1c2f3af3979"></a>kUnknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa4b593dc5d590eab7df2abdca7271b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b593dc5d590eab7df2abdca7271b34">&#9670;&nbsp;</a></span>AsConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::AsConditions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntGroupBounds.html">IntGroupBounds</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the information into an array of (in)equalities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>The variables in <code>bounds</code>. It is used to determine the iteration order to avoid indeterministic results. </td></tr>
    <tr><td class="paramname">bounds</td><td>grouped boundary of the variables. </td></tr>
    <tr><td class="paramname">relations</td><td>other relations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32c10274dba2e8367f902ad4bb0e152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c10274dba2e8367f902ad4bb0e152a">&#9670;&nbsp;</a></span>ConvertDomMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::ConvertDomMap </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert std::unordered_map&lt;const VarNode*, IntSet&gt; to Map&lt;Var, IntSet&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dom_map</td><td>The domain map to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted map. </dd></dl>

</div>
</div>
<a id="af0860828b70ea8ff0d2f7c036c37afd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0860828b70ea8ff0d2f7c036c37afd5">&#9670;&nbsp;</a></span>DeduceBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::DeduceBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relax_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce the bound of the target variable in a expression, give the domain of each variables. Return undefined <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode. ">IntSet</a> to represent failure. </p>
<dl class="section note"><dt>Note</dt><dd>The returned set may be smaller than set that contains all possible values of v that satisfies the bound.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The target variable to be deduced. </td></tr>
    <tr><td class="paramname">cond</td><td>The conditional expression. </td></tr>
    <tr><td class="paramname">hint_map</td><td>The domain of variable, used to help deduce. </td></tr>
    <tr><td class="paramname">relax_map</td><td>The domain of each variable, used to relax the domain, The deduce bound must implies e for all value in relax_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that always satisfies the condition. </dd></dl>

</div>
</div>
<a id="a3658d391f2333f405abdd54a9f174c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3658d391f2333f405abdd54a9f174c9f">&#9670;&nbsp;</a></span>DeduceBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::DeduceBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relax_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as DeduceBound with unordered_map signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The target variable to be deduced. </td></tr>
    <tr><td class="paramname">cond</td><td>The conditional expression. </td></tr>
    <tr><td class="paramname">hint_map</td><td>The domain of variable, used to help deduce. </td></tr>
    <tr><td class="paramname">relax_map</td><td>The domain of each variable, used to relax the domain, The deduce bound mush implies e for all value in relax_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that always satisfies the condition. </dd></dl>

</div>
</div>
<a id="a739616342876c2633b87ed16c649bc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739616342876c2633b87ed16c649bc91">&#9670;&nbsp;</a></span>DetectClipBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::DetectClipBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if expression corresponds to clip bound of the vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be detected. </td></tr>
    <tr><td class="paramname">vars</td><td>List of variables to be used in detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concat([min_value[i], max_value[i]]), None is returned if there is no min or max value return empty if the e does not match the pattern. </dd></dl>

</div>
</div>
<a id="aededb94795b43959bb4c0b07d5f77d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aededb94795b43959bb4c0b07d5f77d2a">&#9670;&nbsp;</a></span>DetectIterMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a>&gt; tvm::arith::DetectIterMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_bijective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a>&#160;</td>
          <td class="paramname"><em>diag_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n]. </p>
<p>Here y = some-quasi-affine-iter-map(input_iters) and c are symbolic constants.</p>
<p>We also requires that y_i and y_j to be independent for i != j.</p>
<p>For returned value rv, the following is always true:</p><ul>
<li>rv[i]-&gt;args.size() &lt;=1: only one iterator per element.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to detect pattern for. </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">require_bijective</td><td>A boolean flag that indicates whether the mapping should be bijective. </td></tr>
    <tr><td class="paramname">analyzer</td><td><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers. ">Analyzer</a> used to get context information. </td></tr>
    <tr><td class="paramname">diag_ctx</td><td><a class="el" href="classtvm_1_1Diagnostic.html">Diagnostic</a> context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detected pattern if a match exists, otherwise return an empty array. </dd></dl>

</div>
</div>
<a id="a87a12ee0854469b04329a961ef261559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a12ee0854469b04329a961ef261559">&#9670;&nbsp;</a></span>DetectLinearEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::DetectLinearEquation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if e can be rewritten as e = sum_{i=0}^{n-1} var[i] * coeff[i] + coeff[n] Where coeff[i] and base are invariant of var[j] for all i and j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be detected. </td></tr>
    <tr><td class="paramname">vars</td><td>List of variables to be used in detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[coeff[i]] if it is possible, empty array if it is not. </dd></dl>

</div>
</div>
<a id="a7641fa29ca6d8941f2696aacccf23998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7641fa29ca6d8941f2696aacccf23998">&#9670;&nbsp;</a></span>DomainTouched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Region tvm::arith::DomainTouched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Buffer.html">tir::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_stores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer a regular domain that covers all the calls or provides within the given statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The given statement. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to check the access info. </td></tr>
    <tr><td class="paramname">consider_loads</td><td>If loads are considered. </td></tr>
    <tr><td class="paramname">consider_stores</td><td>If stores are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The domain that covers all the calls or provides within the given statement. </dd></dl>

</div>
</div>
<a id="a31262f87a37f9f847ace3c5c8e81dcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31262f87a37f9f847ace3c5c8e81dcf5">&#9670;&nbsp;</a></span>EstimateRegionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; &gt; tvm::arith::EstimateRegionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the region with affine map, given the domain of variables and their predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The region to be analyzed </td></tr>
    <tr><td class="paramname">var_dom</td><td>The ranges of the variables </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate for the affine map </td></tr>
    <tr><td class="paramname">analyzer</td><td>The analyzer used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NullOpt if the detection fails, or an array of <a class="el" href="classtvm_1_1arith_1_1IntSet.html" title="Managed reference to IntSetNode. ">arith::IntSet</a> as the result of analysis </dd></dl>

</div>
</div>
<a id="a73160d1f944121ad2ef22205dd496fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73160d1f944121ad2ef22205dd496fdc">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains all possible values of e given the domain of each iteration variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a9d0d0f69e5f98e935d2bd4058d74bcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0d0f69e5f98e935d2bd4058d74bcfa">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">tir::VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a74234ce6f7733b3d8055d781cc782df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74234ce6f7733b3d8055d781cc782df7">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains is union over all the possible conditional values in dom_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The initial range. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="aa30b03ba03ff9cad2cad7320194dfcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30b03ba03ff9cad2cad7320194dfcbe">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an symbolic integer set that contains is union over all the possible conditional values in dom_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The initial set. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="a4bf945fe43afafbedffad6d5633efad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf945fe43afafbedffad6d5633efad7">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The range to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer set that can cover all the possible values of e. </dd></dl>

</div>
</div>
<a id="a79359af75db0286bfe975b9828e971e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79359af75db0286bfe975b9828e971e4">&#9670;&nbsp;</a></span>EvalSet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::EvalSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as EvalSet, but takes <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array&lt;Range&gt;</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The range to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of integer sets that can cover all the possible values. </dd></dl>

</div>
</div>
<a id="a8a112f07411c5e1237b0c045ff276ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a112f07411c5e1237b0c045ff276ac6">&#9670;&nbsp;</a></span>EvalSetForEachSubExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1arith.html#a0f148f1a1b469a3819e0fe6633b674e4">ExprIntSetMap</a> tvm::arith::EvalSetForEachSubExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dom_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the integer set of every sub-expression, given the domain of each iteration variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be evaluated. </td></tr>
    <tr><td class="paramname">dom_map</td><td>The domain of each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from the expression to its possible value. </dd></dl>

</div>
</div>
<a id="ad66a987ddb3d8aee69f9175bf412eb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66a987ddb3d8aee69f9175bf412eb8a">&#9670;&nbsp;</a></span>Intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an intersected set of all sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be intersected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after intersected </dd></dl>

</div>
</div>
<a id="ae8e8be2bde49ccbe7025f4d7a730e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e8be2bde49ccbe7025f4d7a730e694">&#9670;&nbsp;</a></span>InverseAffineIterMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::InverseAffineIterMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IterSumExpr.html">IterSumExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>iter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the inverse of the affine transformation to the outputs. </p>
<p>Similar to the back-propagation, starting from the outputs, it visits the DAG of the expressions in reverse topology order and applies the inverse of the affine transformation until it reaches the input. The affine iter map is required to be bijective.</p>
<p>For example, iter_map = [l0 // 16, l0 % 16], outputs = [output_0, output_1], the affine transformation specified by <code>iter_map</code> will be applied to <code>outputs</code> and the result will be {l0: ((output_0*16) + output_1)}.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1arith.html#aededb94795b43959bb4c0b07d5f77d2a" title="Detect if indices can be written as [y_0 + c_0, y_1 + c_1, ..., y_n + c_n]. ">DetectIterMap</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter_map</td><td>The bijective affine iter map. </td></tr>
    <tr><td class="paramname">outputs</td><td>The outputs of the affine transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The map from the input to the transformed result. </dd></dl>

</div>
</div>
<a id="ab26374719c9dc2fe371f684ff8a33474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26374719c9dc2fe371f684ff8a33474">&#9670;&nbsp;</a></span>IterMapSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&gt; tvm::arith::IterMapSimplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>input_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_bijective</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use IterVarMap detector to rewrite and simplify the indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to detect pattern for. </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">input_pred</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">require_bijective</td><td>A boolean flag that indicates whether the mapping should be bijective.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices after rewrite </dd></dl>

</div>
</div>
<a id="af5e4b93476f56fc5d68dbba17859660e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e4b93476f56fc5d68dbba17859660e">&#9670;&nbsp;</a></span>NormalizeIterMapToExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::arith::NormalizeIterMapToExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html">IterMapExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode. ">IterMapExpr</a>, transform it to normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input <a class="el" href="classtvm_1_1arith_1_1IterMapExpr.html" title="Managed reference to IterMapExprNode. ">IterMapExpr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding normal <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>. </dd></dl>

</div>
</div>
<a id="a5f821e7f25de9769c5733cfacbe132d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f821e7f25de9769c5733cfacbe132d6">&#9670;&nbsp;</a></span>SmithNormalFormDiag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::arith::SmithNormalFormDiag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt;&gt; *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt;&gt; *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain Smith Normal Form of linear equation A x = y. Smith Normal Form of matrix A_{mxn} is S_{mxn} = U_{mxm} A_{mxn} V_{nxn}, in which S_{mxn} is diag(s1, s2, ..., sr, 0, ..., 0) and r is the rank of A. NOTE: Although in standard Smith Normal Form the diagonal elements satisfy s_i | s_{i+1} (| means divides), the implement here does not guarantee it. TODO(yzhliu): From sergei-grechanik: computing the proper Smith normal form may improve stability of automatic differentiation (generating the same gradient code for slightly different but equivalent input code U_{mxm} and V_{nxn} are invertible matrices. This function modifies <code>S</code> to be S_{mxn}, <code>V</code> to be V_{nxn}, <code>y</code> to be U_{mxm} y_{mx1} and <code>x</code> to be V^{-1} x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the original A_{mxn}, it will be modified to S_{mxn} </td></tr>
    <tr><td class="paramname">V</td><td>an identity matrix, it will be modified to V_{nxn} </td></tr>
    <tr><td class="paramname">x</td><td>the x in A x = y. it will be modified to V^{-1}_{nxn} x_{nx1} </td></tr>
    <tr><td class="paramname">y</td><td>the y in A x = y. it will be modified to U_{mxm} y_{mx1} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab667739c074bb7bf1e63302904c78176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667739c074bb7bf1e63302904c78176">&#9670;&nbsp;</a></span>SolveInequalitiesDeskewRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a> tvm::arith::SolveInequalitiesDeskewRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities and deskew the ranges towards zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transform (src <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode. ">IntConstraints</a> -&gt; dst <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode. ">IntConstraints</a>) from original variables to a set of new variables. The ranges of new variables always start from zero, their extents are solved from <code>system_to_solve</code>. src <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html" title="Managed reference to IntConstraintsNode. ">IntConstraints</a> is the same as <code>system_to_solve</code>. dst IntConstraints(variables, ranges, relations) contains,<ol type="1">
<li>variables - the variables that have been solved.</li>
<li>ranges - the best range (start from zero) of each variable.</li>
<li>relations - constraints that cannot be transformed to <a class="el" href="classtvm_1_1Range.html" title="Range constainer. ">Range</a> will be stored in relations. Variable mapping can be obtained from IntConstraintsTransform.src_to_dst and IntConstraintsTransform.dst_to_src. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a6277cb1deea497e60474e5bf83dfc636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6277cb1deea497e60474e5bf83dfc636">&#9670;&nbsp;</a></span>SolveInequalitiesToRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> tvm::arith::SolveInequalitiesToRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities and infer the range of each variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result ranges for each variables. The returned IntConstraints(variables, ranges, relations) contains,<ol type="1">
<li>variables - the variables that have been solved.</li>
<li>ranges - the best range of each variable.</li>
<li>relations - constraints that cannot be transformed to <a class="el" href="classtvm_1_1Range.html" title="Range constainer. ">Range</a> will be stored in relations. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ae0290f04432523ab8e5f76edde80071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0290f04432523ab8e5f76edde80071a">&#9670;&nbsp;</a></span>SolveLinearEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntConstraintsTransform.html">IntConstraintsTransform</a> tvm::arith::SolveLinearEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of equations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new linear system, with less variables (if <code>system_to_solve</code> is NOT of full rank), or no variable (if <code>system_to_solve</code> is of full rank), or an empty linear system (if <code>system_to_solve</code> is unsolvable). It also provides the ranges of the variables in the new system, as well as inequalities inferred from the <code>system_to_solve</code>. You can get the mapping from the original variables to the solution via ret-&gt;src_to_dst. </dd></dl>

</div>
</div>
<a id="ac59d63560e04431f108e81457b212fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59d63560e04431f108e81457b212fdc">&#9670;&nbsp;</a></span>SolveLinearInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1arith.html#adf7450490c4a53f62bab4463cdb5e9c8">PartialSolvedInequalities</a> tvm::arith::SolveLinearInequalities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1arith_1_1IntConstraints.html">IntConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>system_to_solve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear inequalities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_to_solve</td><td>the variables to solve, their ranges, and a list of inequalities. The inequalities are rewritten using Fourier-Motzkin elimination. This function takes an array of (in)equalities and an array of variables, and essentially rewrites the (in)equalities into an array of (in)equalities of the following form,</td></tr>
  </table>
  </dd>
</dl>
<p>x0 &gt;= f0(x1, x2, ..., xn) x0 &lt;= g0(x1, x2, ..., xn) x1 &gt;= f1(x2, ..., xn) x1 &lt;= g1(x2, ..., xn) ... xn &gt;= fn() // just a constant xn &lt;= gn() // just a constant</p>
<dl class="section return"><dt>Returns</dt><dd>A map of variables and their solved bounds, and constrains that cannot be solved to bounds. </dd></dl>

</div>
</div>
<a id="ae153bfade4c3084d59811b6cb846900f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae153bfade4c3084d59811b6cb846900f">&#9670;&nbsp;</a></span>SubspaceDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IterMark.html">IterMark</a>&gt; &gt; tvm::arith::SubspaceDivide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_bijective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a>&#160;</td>
          <td class="paramname"><em>diag_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if bindings can be written as [a_0*e_0 + b_0 + c_0, a_1*e_1 + b_1, ..., a_n*e_n + b_n]. </p>
<p>where a = some-quasi-affine-iter-map(input_iters set_minus sub_iters) b = some-quasi-affine-iter-map(sub_iters) c is constant symbols e is the extent of b</p>
<p>For example, z*12 + y*3 + x + c = (z*4+y)*3 + x, if sub_iters={x}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>The input bindings </td></tr>
    <tr><td class="paramname">input_iters</td><td>Map from variable to iterator's range. </td></tr>
    <tr><td class="paramname">sub_iters</td><td>Iterators of subspace. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate constraints on the input iterators </td></tr>
    <tr><td class="paramname">require_bijective</td><td>A boolean flag that indicates whether the mapping should be bijective. </td></tr>
    <tr><td class="paramname">analyzer</td><td><a class="el" href="classtvm_1_1arith_1_1Analyzer.html" title="Analyzer that contains bunch of sub-analyzers. ">Analyzer</a> used to get context information. </td></tr>
    <tr><td class="paramname">diag_ctx</td><td><a class="el" href="classtvm_1_1Diagnostic.html">Diagnostic</a> context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list has length len(bindings) + 1 [0, len(bindings)): The iter map matching result. The inner list is of length 2. The first expr is the basis of the quotient space. The second expr is the basis of the subspace. len(bindings): the predicate of outer space and inner space Empty array if no match can be found. </dd></dl>

</div>
</div>
<a id="a68a0523bf0384e492ab222d30be9160e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a0523bf0384e492ab222d30be9160e">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a union set of all sets, possibly relaxed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be combined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after union </dd></dl>

</div>
</div>
<a id="ab22d7fd95abb5fa372843a40e19d80c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d7fd95abb5fa372843a40e19d80c5">&#9670;&nbsp;</a></span>UnionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> tvm::arith::UnionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower-bound of union set, where some of the segments may be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The sets to be combined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set after union </dd></dl>

</div>
</div>
<a id="ad27c4f216e41eb8e81296fb7ec4b9453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27c4f216e41eb8e81296fb7ec4b9453">&#9670;&nbsp;</a></span>UnionRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::UnionRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nd_int_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of N-dimensional integer sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd_int_sets</td><td>A list of N-dimensional integer sets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An N-dimensional integer set as the result of union </dd></dl>

</div>
</div>
<a id="a4c3dedfa4cba4ad39c953eb51eb83e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3dedfa4cba4ad39c953eb51eb83e4d">&#9670;&nbsp;</a></span>UnionRegionLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a>&gt; tvm::arith::UnionRegionLowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1arith_1_1IntSet.html">IntSet</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nd_int_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of N-dimensional integer sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd_int_sets</td><td>A list of N-dimensional integer sets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An N-dimensional integer set as the result of union </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a76835a091e20acfbce65f678114c0291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76835a091e20acfbce65f678114c0291">&#9670;&nbsp;</a></span>kSimplifyRewriteCanonicalRewrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::arith::kSimplifyRewriteCanonicalRewrite = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
