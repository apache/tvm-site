<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::meta_schedule::ScheduleRule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1meta__schedule.html">meta_schedule</a></li><li class="navelem"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtvm_1_1meta__schedule_1_1ScheduleRule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::meta_schedule::ScheduleRule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed reference to <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule.">ScheduleRuleNode</a>.  
 <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="schedule__rule_8h_source.html">schedule_rule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::meta_schedule::ScheduleRule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1meta__schedule_1_1ScheduleRule__inherit__graph.svg" width="236" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::meta_schedule::ScheduleRule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1meta__schedule_1_1ScheduleRule__coll__graph.svg" width="236" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a50db66ec969db619daa71f0fda7c4c84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a50db66ec969db619daa71f0fda7c4c84">FInitializeWithTuneContext</a> = ffi::TypedFunction&lt; void(const <a class="el" href="classtvm_1_1meta__schedule_1_1TuneContext.html">TuneContext</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a50db66ec969db619daa71f0fda7c4c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>InitializeWithTuneContext</code> method.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a50db66ec969db619daa71f0fda7c4c84">More...</a><br /></td></tr>
<tr class="separator:a50db66ec969db619daa71f0fda7c4c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb8b703c33e1ad7fb9c5c56b68c20d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bb8b703c33e1ad7fb9c5c56b68c20d0">FApply</a> = ffi::TypedFunction&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a> &amp;, const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">tir::BlockRV</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a1bb8b703c33e1ad7fb9c5c56b68c20d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>Apply</code> method.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bb8b703c33e1ad7fb9c5c56b68c20d0">More...</a><br /></td></tr>
<tr class="separator:a1bb8b703c33e1ad7fb9c5c56b68c20d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bbc7ff86bc44585431c4608708899f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa4bbc7ff86bc44585431c4608708899f">FAsString</a> = ffi::TypedFunction&lt; ffi::String()&gt;</td></tr>
<tr class="memdesc:aa4bbc7ff86bc44585431c4608708899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the schedule rule as string with name.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa4bbc7ff86bc44585431c4608708899f">More...</a><br /></td></tr>
<tr class="separator:aa4bbc7ff86bc44585431c4608708899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fad579144744c63ddd299fa193fe150"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7fad579144744c63ddd299fa193fe150">FClone</a> = ffi::TypedFunction&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>()&gt;</td></tr>
<tr class="memdesc:a7fad579144744c63ddd299fa193fe150"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>Clone</code> method.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7fad579144744c63ddd299fa193fe150">More...</a><br /></td></tr>
<tr class="separator:a7fad579144744c63ddd299fa193fe150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a157a6c0605c6ee1851128dbece136d51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a157a6c0605c6ee1851128dbece136d51">TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS</a> (<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, ObjectRef, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html">ScheduleRuleNode</a>)</td></tr>
<tr class="separator:a157a6c0605c6ee1851128dbece136d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4f50de278ec0889780dc9d7066cda499"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4f50de278ec0889780dc9d7066cda499">ApplyCustomRule</a> ()</td></tr>
<tr class="memdesc:a4f50de278ec0889780dc9d7066cda499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rule that applies customized rules registered using block attribute <code>schedule_rule</code>. The rule will be dispatched according to target keys.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4f50de278ec0889780dc9d7066cda499">More...</a><br /></td></tr>
<tr class="separator:a4f50de278ec0889780dc9d7066cda499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#abebbe9b3c71f3c7f0346641e0b7e96ad">IsApplyCustomRule</a> (const <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> &amp;rule)</td></tr>
<tr class="memdesc:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the rule is <code>ApplyCustomRule</code>  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#abebbe9b3c71f3c7f0346641e0b7e96ad">More...</a><br /></td></tr>
<tr class="separator:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6536b732efcc6b314cc37f2d76459809"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a6536b732efcc6b314cc37f2d76459809">AutoInline</a> (bool into_producer, bool into_consumer, bool inline_const_tensor, bool disallow_if_then_else, bool require_injective, bool require_ordered, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; disallow_op)</td></tr>
<tr class="memdesc:a6536b732efcc6b314cc37f2d76459809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an auto-inline rule that inlines spatial blocks if it satisfies some conditions.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a6536b732efcc6b314cc37f2d76459809">More...</a><br /></td></tr>
<tr class="separator:a6536b732efcc6b314cc37f2d76459809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d48f7fce5c1c7a913688361787e854"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a56d48f7fce5c1c7a913688361787e854">InlineConstantScalars</a> ()</td></tr>
<tr class="memdesc:a56d48f7fce5c1c7a913688361787e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline blocks that produce a constant scalar. Such blocks get in the way of ReverseComputeInline during AutoInline, since they are also counted as a producer block unless they are inlined first. So it is recommended to run InlineConstantScalars before AutoInline.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a56d48f7fce5c1c7a913688361787e854">More...</a><br /></td></tr>
<tr class="separator:a56d48f7fce5c1c7a913688361787e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a0473b312e653866a59e676162a0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa68a0473b312e653866a59e676162a0d">MultiLevelTiling</a> (ffi::String structure, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; tile_binds, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_read, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_write, ffi::Optional&lt; ffi::Function &gt; filter_fn=std::nullopt)</td></tr>
<tr class="memdesc:aa68a0473b312e653866a59e676162a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mega rule: multi-level tiling with data reuse.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa68a0473b312e653866a59e676162a0d">More...</a><br /></td></tr>
<tr class="separator:aa68a0473b312e653866a59e676162a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaab71f980c723eea927bc79c270f1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aacaab71f980c723eea927bc79c270f1f">MultiLevelTilingWithIntrin</a> (ffi::String intrin_name, ffi::String structure, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; tile_binds, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_read, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_write)</td></tr>
<tr class="memdesc:aacaab71f980c723eea927bc79c270f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for auto-tensorization with a single intrinsic.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aacaab71f980c723eea927bc79c270f1f">More...</a><br /></td></tr>
<tr class="separator:aacaab71f980c723eea927bc79c270f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a7033a199ab203aee76fe8f73d095"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aea1a7033a199ab203aee76fe8f73d095">MultiLevelTilingTensorCore</a> (ffi::Array&lt; ffi::Map&lt; ffi::String, ffi::String &gt;&gt; intrin_groups, ffi::String structure, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; tile_binds, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_read, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_write, bool use_software_pipeline)</td></tr>
<tr class="memdesc:aea1a7033a199ab203aee76fe8f73d095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for auto-tensorization with multiple groups of candidate tensor core intrinsics.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aea1a7033a199ab203aee76fe8f73d095">More...</a><br /></td></tr>
<tr class="separator:aea1a7033a199ab203aee76fe8f73d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b69b07a75cc08f2182c1d0768d5265"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a33b69b07a75cc08f2182c1d0768d5265">MultiLevelTilingWideVector</a> (ffi::String structure, <a class="el" href="classtvm_1_1Integer.html">Integer</a> vector_length_in_bits, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_read, ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt; reuse_write)</td></tr>
<tr class="memdesc:a33b69b07a75cc08f2182c1d0768d5265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for backends with wide vectors. The loop over the innermost spatial axis of the output buffer is always vectorized with the maximum vector length.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a33b69b07a75cc08f2182c1d0768d5265">More...</a><br /></td></tr>
<tr class="separator:a33b69b07a75cc08f2182c1d0768d5265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c65eb79b754ea74fd200142fe0019e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a13c65eb79b754ea74fd200142fe0019e">AddRFactor</a> (int max_jobs_per_core, ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor)</td></tr>
<tr class="memdesc:a13c65eb79b754ea74fd200142fe0019e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rule: add-rfactor to some blocks if needed.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a13c65eb79b754ea74fd200142fe0019e">More...</a><br /></td></tr>
<tr class="separator:a13c65eb79b754ea74fd200142fe0019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e9569447c97cfabfda282a926e9593"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a80e9569447c97cfabfda282a926e9593">CrossThreadReduction</a> (ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; thread_extents)</td></tr>
<tr class="memdesc:a80e9569447c97cfabfda282a926e9593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a schedule rule which applies cross-thread reduction to some reduction blocks correspondingly when needed.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a80e9569447c97cfabfda282a926e9593">More...</a><br /></td></tr>
<tr class="separator:a80e9569447c97cfabfda282a926e9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf485537817533eaf711226f687778c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bf485537817533eaf711226f687778c">RandomComputeLocation</a> ()</td></tr>
<tr class="memdesc:a1bf485537817533eaf711226f687778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rule that randomly select a compute-at location for a free block.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bf485537817533eaf711226f687778c">More...</a><br /></td></tr>
<tr class="separator:a1bf485537817533eaf711226f687778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1692e80d562ad1da0d1bb40a0a3ab2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ae1692e80d562ad1da0d1bb40a0a3ab2a">ParallelizeVectorizeUnroll</a> (int max_jobs_per_core, int max_vectorize_extent, ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; unroll_max_steps, bool unroll_explicit)</td></tr>
<tr class="memdesc:ae1692e80d562ad1da0d1bb40a0a3ab2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark parallelize, vectorize and unroll to the root block. The mark will be applied to each block in a follow-up post processor.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ae1692e80d562ad1da0d1bb40a0a3ab2a">More...</a><br /></td></tr>
<tr class="separator:ae1692e80d562ad1da0d1bb40a0a3ab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2884050b7200a069f141d6d6f3283"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a3ef2884050b7200a069f141d6d6f3283">AutoBind</a> (int max_threadblocks, ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; thread_extents, int max_threads_per_block=-1)</td></tr>
<tr class="memdesc:a3ef2884050b7200a069f141d6d6f3283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto bind loops around the block to BlockIdx and ThreadIdx.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a3ef2884050b7200a069f141d6d6f3283">More...</a><br /></td></tr>
<tr class="separator:a3ef2884050b7200a069f141d6d6f3283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812a72ff2ad145247b0f9dc7954340d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac812a72ff2ad145247b0f9dc7954340d">PyScheduleRule</a> (<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a50db66ec969db619daa71f0fda7c4c84">FInitializeWithTuneContext</a> f_initialize_with_tune_context, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bb8b703c33e1ad7fb9c5c56b68c20d0">FApply</a> f_apply, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7fad579144744c63ddd299fa193fe150">FClone</a> f_clone, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa4bbc7ff86bc44585431c4608708899f">FAsString</a> f_as_string)</td></tr>
<tr class="memdesc:ac812a72ff2ad145247b0f9dc7954340d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a schedule rule with customized methods on the python-side.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac812a72ff2ad145247b0f9dc7954340d">More...</a><br /></td></tr>
<tr class="separator:ac812a72ff2ad145247b0f9dc7954340d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f85774981324d08e1bfa6fcbd7b739"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a14f85774981324d08e1bfa6fcbd7b739">DefaultLLVM</a> ()</td></tr>
<tr class="memdesc:a14f85774981324d08e1bfa6fcbd7b739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for LLVM.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a14f85774981324d08e1bfa6fcbd7b739">More...</a><br /></td></tr>
<tr class="separator:a14f85774981324d08e1bfa6fcbd7b739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfad9f360f3ac2a642a3c2c53b7dad81"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#adfad9f360f3ac2a642a3c2c53b7dad81">DefaultX86</a> (const ffi::String &amp;type)</td></tr>
<tr class="memdesc:adfad9f360f3ac2a642a3c2c53b7dad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for x86 (AVX512 and VNNI)  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#adfad9f360f3ac2a642a3c2c53b7dad81">More...</a><br /></td></tr>
<tr class="separator:adfad9f360f3ac2a642a3c2c53b7dad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48144ce7b8483594214739b5f74b1192"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a48144ce7b8483594214739b5f74b1192">DefaultCUDA</a> ()</td></tr>
<tr class="memdesc:a48144ce7b8483594214739b5f74b1192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for CUDA.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a48144ce7b8483594214739b5f74b1192">More...</a><br /></td></tr>
<tr class="separator:a48144ce7b8483594214739b5f74b1192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18429ae89d3fc967bef223603743208"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac18429ae89d3fc967bef223603743208">DefaultCUDATensorCore</a> ()</td></tr>
<tr class="memdesc:ac18429ae89d3fc967bef223603743208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default postprocessors for CUDA with TensorCore.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac18429ae89d3fc967bef223603743208">More...</a><br /></td></tr>
<tr class="separator:ac18429ae89d3fc967bef223603743208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa846c463dcf2bde0de0c81c7af4a0bd0"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa846c463dcf2bde0de0c81c7af4a0bd0">DefaultHexagon</a> ()</td></tr>
<tr class="memdesc:aa846c463dcf2bde0de0c81c7af4a0bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for Hexagon.  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa846c463dcf2bde0de0c81c7af4a0bd0">More...</a><br /></td></tr>
<tr class="separator:aa846c463dcf2bde0de0c81c7af4a0bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c442a6917497308438ad95a9b8d6d9e"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a8c442a6917497308438ad95a9b8d6d9e">DefaultARM</a> (const ffi::String &amp;type)</td></tr>
<tr class="memdesc:a8c442a6917497308438ad95a9b8d6d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for ARM CPU (NEON and DOTPROD)  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a8c442a6917497308438ad95a9b8d6d9e">More...</a><br /></td></tr>
<tr class="separator:a8c442a6917497308438ad95a9b8d6d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c787e6301a011c9a7b17c1cb4da1872"><td class="memItemLeft" align="right" valign="top">static ffi::Array&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7c787e6301a011c9a7b17c1cb4da1872">DefaultRISCV</a> (int vlen)</td></tr>
<tr class="memdesc:a7c787e6301a011c9a7b17c1cb4da1872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for RISCV CPU (RVV)  <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7c787e6301a011c9a7b17c1cb4da1872">More...</a><br /></td></tr>
<tr class="separator:a7c787e6301a011c9a7b17c1cb4da1872"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed reference to <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule.">ScheduleRuleNode</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule.">ScheduleRuleNode</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1bb8b703c33e1ad7fb9c5c56b68c20d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb8b703c33e1ad7fb9c5c56b68c20d0">&#9670;&nbsp;</a></span>FApply</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bb8b703c33e1ad7fb9c5c56b68c20d0">tvm::meta_schedule::ScheduleRule::FApply</a> =  ffi::TypedFunction&lt;ffi::Array&lt;<a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a>&gt;(const <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a>&amp;, const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">tir::BlockRV</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>Apply</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sch</td><td>The schedule to be modified. </td></tr>
    <tr><td class="paramname">block</td><td>The specific block to apply the schedule rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of schedules generated by applying the schedule rule. </dd></dl>

</div>
</div>
<a id="aa4bbc7ff86bc44585431c4608708899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bbc7ff86bc44585431c4608708899f">&#9670;&nbsp;</a></span>FAsString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa4bbc7ff86bc44585431c4608708899f">tvm::meta_schedule::ScheduleRule::FAsString</a> =  ffi::TypedFunction&lt;ffi::String()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the schedule rule as string with name. </p>
<dl class="section return"><dt>Returns</dt><dd>The string of the schedule rule. </dd></dl>

</div>
</div>
<a id="a7fad579144744c63ddd299fa193fe150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fad579144744c63ddd299fa193fe150">&#9670;&nbsp;</a></span>FClone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7fad579144744c63ddd299fa193fe150">tvm::meta_schedule::ScheduleRule::FClone</a> =  ffi::TypedFunction&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>Clone</code> method. </p>
<dl class="section return"><dt>Returns</dt><dd>The cloned schedule rule. </dd></dl>

</div>
</div>
<a id="a50db66ec969db619daa71f0fda7c4c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50db66ec969db619daa71f0fda7c4c84">&#9670;&nbsp;</a></span>FInitializeWithTuneContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a50db66ec969db619daa71f0fda7c4c84">tvm::meta_schedule::ScheduleRule::FInitializeWithTuneContext</a> =  ffi::TypedFunction&lt;void(const <a class="el" href="classtvm_1_1meta__schedule_1_1TuneContext.html">TuneContext</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>InitializeWithTuneContext</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The tuning context for initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a13c65eb79b754ea74fd200142fe0019e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c65eb79b754ea74fd200142fe0019e">&#9670;&nbsp;</a></span>AddRFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AddRFactor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_jobs_per_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rule: add-rfactor to some blocks if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_jobs_per_core</td><td>The maximum number of jobs to be launched per CPU core. It sets the uplimit of CPU parallelism, i.e. <code>num_cores * max_jobs_per_core</code>. Use -1 to disable parallelism. </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. std::nullopt means no limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a4f50de278ec0889780dc9d7066cda499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f50de278ec0889780dc9d7066cda499">&#9670;&nbsp;</a></span>ApplyCustomRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::ApplyCustomRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rule that applies customized rules registered using block attribute <code>schedule_rule</code>. The rule will be dispatched according to target keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The created schedule rule. </dd></dl>

</div>
</div>
<a id="a3ef2884050b7200a069f141d6d6f3283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef2884050b7200a069f141d6d6f3283">&#9670;&nbsp;</a></span>AutoBind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AutoBind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threadblocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>thread_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads_per_block</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto bind loops around the block to BlockIdx and ThreadIdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threadblocks</td><td>The maximum number of threadblock on GPU </td></tr>
    <tr><td class="paramname">thread_extents</td><td>Candidates of thread axis extent. </td></tr>
    <tr><td class="paramname">max_threads_per_block</td><td>The maximum number of threads per block, if it is known when this schedule rule is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a6536b732efcc6b314cc37f2d76459809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6536b732efcc6b314cc37f2d76459809">&#9670;&nbsp;</a></span>AutoInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AutoInline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>into_producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>into_consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inline_const_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disallow_if_then_else</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_injective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_ordered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>disallow_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an auto-inline rule that inlines spatial blocks if it satisfies some conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into_producer</td><td>If allows to inline a block into its producer </td></tr>
    <tr><td class="paramname">into_consumer</td><td>If allows to inline a block into its consumer </td></tr>
    <tr><td class="paramname">inline_const_tensor</td><td>Always inline constant tensors </td></tr>
    <tr><td class="paramname">disallow_if_then_else</td><td>Always disallow if-then-else-like constructs </td></tr>
    <tr><td class="paramname">require_ordered</td><td>Always require the read-to-write mapping to be ordered </td></tr>
    <tr><td class="paramname">require_injective</td><td>Always require the read-to-write mapping to be injective </td></tr>
    <tr><td class="paramname">disallow_op</td><td>The operators that are disallowed in auto inline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a80e9569447c97cfabfda282a926e9593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e9569447c97cfabfda282a926e9593">&#9670;&nbsp;</a></span>CrossThreadReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::CrossThreadReduction </td>
          <td>(</td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>thread_extents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a schedule rule which applies cross-thread reduction to some reduction blocks correspondingly when needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_extents</td><td>Candidates of thread axis extent (values are required to be positive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a8c442a6917497308438ad95a9b8d6d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c442a6917497308438ad95a9b8d6d9e">&#9670;&nbsp;</a></span>DefaultARM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultARM </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for ARM CPU (NEON and DOTPROD) </p>

</div>
</div>
<a id="a48144ce7b8483594214739b5f74b1192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48144ce7b8483594214739b5f74b1192">&#9670;&nbsp;</a></span>DefaultCUDA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultCUDA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for CUDA. </p>

</div>
</div>
<a id="ac18429ae89d3fc967bef223603743208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18429ae89d3fc967bef223603743208">&#9670;&nbsp;</a></span>DefaultCUDATensorCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultCUDATensorCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default postprocessors for CUDA with TensorCore. </p>

</div>
</div>
<a id="aa846c463dcf2bde0de0c81c7af4a0bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa846c463dcf2bde0de0c81c7af4a0bd0">&#9670;&nbsp;</a></span>DefaultHexagon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultHexagon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for Hexagon. </p>

</div>
</div>
<a id="a14f85774981324d08e1bfa6fcbd7b739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f85774981324d08e1bfa6fcbd7b739">&#9670;&nbsp;</a></span>DefaultLLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultLLVM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for LLVM. </p>

</div>
</div>
<a id="a7c787e6301a011c9a7b17c1cb4da1872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c787e6301a011c9a7b17c1cb4da1872">&#9670;&nbsp;</a></span>DefaultRISCV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultRISCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vlen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for RISCV CPU (RVV) </p>

</div>
</div>
<a id="adfad9f360f3ac2a642a3c2c53b7dad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfad9f360f3ac2a642a3c2c53b7dad81">&#9670;&nbsp;</a></span>DefaultX86()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ffi::Array&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultX86 </td>
          <td>(</td>
          <td class="paramtype">const ffi::String &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for x86 (AVX512 and VNNI) </p>

</div>
</div>
<a id="a56d48f7fce5c1c7a913688361787e854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d48f7fce5c1c7a913688361787e854">&#9670;&nbsp;</a></span>InlineConstantScalars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::InlineConstantScalars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline blocks that produce a constant scalar. Such blocks get in the way of ReverseComputeInline during AutoInline, since they are also counted as a producer block unless they are inlined first. So it is recommended to run InlineConstantScalars before AutoInline. </p>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="abebbe9b3c71f3c7f0346641e0b7e96ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebbe9b3c71f3c7f0346641e0b7e96ad">&#9670;&nbsp;</a></span>IsApplyCustomRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tvm::meta_schedule::ScheduleRule::IsApplyCustomRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the rule is <code>ApplyCustomRule</code> </p>

</div>
</div>
<a id="aa68a0473b312e653866a59e676162a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68a0473b312e653866a59e676162a0d">&#9670;&nbsp;</a></span>MultiLevelTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTiling </td>
          <td>(</td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Function &gt;&#160;</td>
          <td class="paramname"><em>filter_fn</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mega rule: multi-level tiling with data reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSRSRS' on CPU</li>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>std::nullopt on CPU</li>
<li>[blockIdx.x, vthread.x, threadIdx.x] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. std::nullopt means no limit</td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. std::nullopt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">filter_fn</td><td>A function that can be passed to overwrite the default condition for applying MultiLevelTiling to a block. Its signature must be (Schedule, BlockRV) -&gt; bool. This is useful if there is a need to apply MultiLevelTiling to an operation / block which is ignored by default. This function should return True for a block that should be tiled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="aea1a7033a199ab203aee76fe8f73d095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1a7033a199ab203aee76fe8f73d095">&#9670;&nbsp;</a></span>MultiLevelTilingTensorCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingTensorCore </td>
          <td>(</td>
          <td class="paramtype">ffi::Array&lt; ffi::Map&lt; ffi::String, ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>intrin_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_software_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for auto-tensorization with multiple groups of candidate tensor core intrinsics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrin_groups</td><td>A list of groups of tensor core intrinsics. The map should contains key "init", "load_a", "load_b", "compute", "store", which represent the tensor intrin for initialization, loading operand A, loading operand B, tensor core computation, storing the result. The value of the map should be names of tensor intrinsics, must be registered via TensorIntrin.register(...) beforehand </td></tr>
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>[blockIdx.y, blockIdx.x, threadIdx.y] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. std::nullopt means no limit</td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. std::nullopt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">use_software_pipeline</td><td>Whether use the software pipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a33b69b07a75cc08f2182c1d0768d5265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b69b07a75cc08f2182c1d0768d5265">&#9670;&nbsp;</a></span>MultiLevelTilingWideVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingWideVector </td>
          <td>(</td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Integer.html">Integer</a>&#160;</td>
          <td class="paramname"><em>vector_length_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for backends with wide vectors. The loop over the innermost spatial axis of the output buffer is always vectorized with the maximum vector length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure</td><td>The tiling structure. 'SSRSRS' is recommended. </td></tr>
    <tr><td class="paramname">vector_length_in_bits</td><td>The length of a vector register in bits. </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. std::nullopt means no limit</td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. std::nullopt means no reuse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="aacaab71f980c723eea927bc79c270f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaab71f980c723eea927bc79c270f1f">&#9670;&nbsp;</a></span>MultiLevelTilingWithIntrin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingWithIntrin </td>
          <td>(</td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>intrin_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for auto-tensorization with a single intrinsic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrin_name</td><td>The name of a tensor intrinsic, must be registered via TensorIntrin.register(...) beforehand </td></tr>
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSRSRS' on CPU</li>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>std::nullopt on CPU</li>
<li>[blockIdx.x, vthread.x, threadIdx.x] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. std::nullopt means no limit</td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. std::nullopt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. std::nullopt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. std::nullopt means no reuse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="ae1692e80d562ad1da0d1bb40a0a3ab2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1692e80d562ad1da0d1bb40a0a3ab2a">&#9670;&nbsp;</a></span>ParallelizeVectorizeUnroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::ParallelizeVectorizeUnroll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_jobs_per_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_vectorize_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>unroll_max_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unroll_explicit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark parallelize, vectorize and unroll to the root block. The mark will be applied to each block in a follow-up post processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_jobs_per_core</td><td>The maximum number of jobs to be launched per CPU core. It sets the upper limit of CPU parallelism, i.e. <code>num_cores * max_jobs_per_core</code>. Use -1 to disable parallelism. </td></tr>
    <tr><td class="paramname">max_vectorize_extent</td><td>The maximum extent to be vectorized. It sets the upper limit of the hardware target vectorization. Use -1 to disable vectorization. </td></tr>
    <tr><td class="paramname">unroll_max_steps</td><td>The options of the maximum number of unroll steps to be done. Use an empty array to disable unroll. </td></tr>
    <tr><td class="paramname">unroll_explicit</td><td>Whether to explicitly unroll the loop, or just add an "unroll" pragma. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="ac812a72ff2ad145247b0f9dc7954340d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac812a72ff2ad145247b0f9dc7954340d">&#9670;&nbsp;</a></span>PyScheduleRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::PyScheduleRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a50db66ec969db619daa71f0fda7c4c84">FInitializeWithTuneContext</a>&#160;</td>
          <td class="paramname"><em>f_initialize_with_tune_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bb8b703c33e1ad7fb9c5c56b68c20d0">FApply</a>&#160;</td>
          <td class="paramname"><em>f_apply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7fad579144744c63ddd299fa193fe150">FClone</a>&#160;</td>
          <td class="paramname"><em>f_clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#aa4bbc7ff86bc44585431c4608708899f">FAsString</a>&#160;</td>
          <td class="paramname"><em>f_as_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a schedule rule with customized methods on the python-side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_initialize_with_tune_context</td><td>The packed function of <code>InitializeWithTuneContext</code>. </td></tr>
    <tr><td class="paramname">f_apply</td><td>The packed function of <code>Apply</code>. </td></tr>
    <tr><td class="paramname">f_clone</td><td>The packed function of <code>Clone</code>. </td></tr>
    <tr><td class="paramname">f_as_string</td><td>The packed function of <code>AsString</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created. </dd></dl>

</div>
</div>
<a id="a1bf485537817533eaf711226f687778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf485537817533eaf711226f687778c">&#9670;&nbsp;</a></span>RandomComputeLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::RandomComputeLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A rule that randomly select a compute-at location for a free block. </p>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a157a6c0605c6ee1851128dbece136d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157a6c0605c6ee1851128dbece136d51">&#9670;&nbsp;</a></span>TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::meta_schedule::ScheduleRule::TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectRef&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html">ScheduleRuleNode</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/meta_schedule/<a class="el" href="schedule__rule_8h_source.html">schedule_rule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
