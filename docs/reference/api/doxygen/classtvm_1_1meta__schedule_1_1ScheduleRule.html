<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::meta_schedule::ScheduleRule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1meta__schedule.html">meta_schedule</a></li><li class="navelem"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtvm_1_1meta__schedule_1_1ScheduleRule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::meta_schedule::ScheduleRule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed reference to <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule. ">ScheduleRuleNode</a>.  
 <a href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="schedule__rule_8h_source.html">schedule_rule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::meta_schedule::ScheduleRule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1meta__schedule_1_1ScheduleRule__inherit__graph.svg" width="235" height="639"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::meta_schedule::ScheduleRule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1meta__schedule_1_1ScheduleRule__coll__graph.svg" width="235" height="927"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a19b2fb7007e375c8fc39168b7ee071aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a19b2fb7007e375c8fc39168b7ee071aa">FInitializeWithTuneContext</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; void(const <a class="el" href="classtvm_1_1meta__schedule_1_1TuneContext.html">TuneContext</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a19b2fb7007e375c8fc39168b7ee071aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>InitializeWithTuneContext</code> method.  <a href="#a19b2fb7007e375c8fc39168b7ee071aa">More...</a><br /></td></tr>
<tr class="separator:a19b2fb7007e375c8fc39168b7ee071aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c558d23de2ff6bf298bc7167a210859"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a2c558d23de2ff6bf298bc7167a210859">FApply</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a> &amp;, const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">tir::BlockRV</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a2c558d23de2ff6bf298bc7167a210859"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>Apply</code> method.  <a href="#a2c558d23de2ff6bf298bc7167a210859">More...</a><br /></td></tr>
<tr class="separator:a2c558d23de2ff6bf298bc7167a210859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c02153b06f9c5577114d719747a7b1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4c02153b06f9c5577114d719747a7b1a">FAsString</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>()&gt;</td></tr>
<tr class="memdesc:a4c02153b06f9c5577114d719747a7b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the schedule rule as string with name.  <a href="#a4c02153b06f9c5577114d719747a7b1a">More...</a><br /></td></tr>
<tr class="separator:a4c02153b06f9c5577114d719747a7b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed37c51b09c7e58ce8f25d601bc24f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7bed37c51b09c7e58ce8f25d601bc24f">FClone</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>()&gt;</td></tr>
<tr class="memdesc:a7bed37c51b09c7e58ce8f25d601bc24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function type of <code>Clone</code> method.  <a href="#a7bed37c51b09c7e58ce8f25d601bc24f">More...</a><br /></td></tr>
<tr class="separator:a7bed37c51b09c7e58ce8f25d601bc24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">ContainerType</a> = <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">type indicate the container type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa5c355fbb7d2f7402ee360dba8a52cdd">More...</a><br /></td></tr>
<tr class="separator:aa5c355fbb7d2f7402ee360dba8a52cdd inherit pub_types_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a157a6c0605c6ee1851128dbece136d51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a157a6c0605c6ee1851128dbece136d51">TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS</a> (<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html">ScheduleRuleNode</a>)</td></tr>
<tr class="separator:a157a6c0605c6ee1851128dbece136d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">ObjectRef</a> ()=default</td></tr>
<tr class="memdesc:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa07c1f6d66a438ea950637d13ed09471">More...</a><br /></td></tr>
<tr class="separator:aa07c1f6d66a438ea950637d13ed09471 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">ObjectRef</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt; data)</td></tr>
<tr class="memdesc:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> from existing object ptr.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a6a7dd7404edf1c26f8dbd9bd92d03a02">More...</a><br /></td></tr>
<tr class="separator:a6a7dd7404edf1c26f8dbd9bd92d03a02 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">same_as</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ae31a5b9f40781d60a2901994ead700e8">More...</a><br /></td></tr>
<tr class="separator:ae31a5b9f40781d60a2901994ead700e8 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">operator==</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#affdf1b8cdb36e140de7b3ad7064e4617">More...</a><br /></td></tr>
<tr class="separator:affdf1b8cdb36e140de7b3ad7064e4617 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">operator!=</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aa1bd13a7185cb4b2b6bdde49416e8aa4">More...</a><br /></td></tr>
<tr class="separator:aa1bd13a7185cb4b2b6bdde49416e8aa4 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">operator&lt;</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;other) const</td></tr>
<tr class="memdesc:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a4744bf4a1b48f202d41b51dc5e08e6ee">More...</a><br /></td></tr>
<tr class="separator:a4744bf4a1b48f202d41b51dc5e08e6ee inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a17d8d5ad92691f9e18e3e0ae8ef69e4f">defined</a> () const</td></tr>
<tr class="separator:a17d8d5ad92691f9e18e3e0ae8ef69e4f inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aadbc0886ffa80162ff31eefd0431ba09">get</a> () const</td></tr>
<tr class="separator:aadbc0886ffa80162ff31eefd0431ba09 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3deeeac5827a88f375b8c6ae1039c219">operator-&gt;</a> () const</td></tr>
<tr class="separator:a3deeeac5827a88f375b8c6ae1039c219 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a4e7cdb1574b93a59e784d70aa47b8da7">unique</a> () const</td></tr>
<tr class="separator:a4e7cdb1574b93a59e784d70aa47b8da7 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a0ae0da21d247cd87ea94fe3777c4405e">use_count</a> () const</td></tr>
<tr class="separator:a0ae0da21d247cd87ea94fe3777c4405e inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">const ObjectType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">as</a> () const</td></tr>
<tr class="memdesc:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to downcast the internal <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a> to a raw pointer of a corresponding type.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a2d76fa1fb628ff276a284e61123589c5">More...</a><br /></td></tr>
<tr class="separator:a2d76fa1fb628ff276a284e61123589c5 inherit pub_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4f50de278ec0889780dc9d7066cda499"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4f50de278ec0889780dc9d7066cda499">ApplyCustomRule</a> ()</td></tr>
<tr class="memdesc:a4f50de278ec0889780dc9d7066cda499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rule that applies customized rules registered using block attribute <code>schedule_rule</code>. The rule will be dispatched according to target keys.  <a href="#a4f50de278ec0889780dc9d7066cda499">More...</a><br /></td></tr>
<tr class="separator:a4f50de278ec0889780dc9d7066cda499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#abebbe9b3c71f3c7f0346641e0b7e96ad">IsApplyCustomRule</a> (const <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> &amp;rule)</td></tr>
<tr class="memdesc:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the rule is <code>ApplyCustomRule</code>  <a href="#abebbe9b3c71f3c7f0346641e0b7e96ad">More...</a><br /></td></tr>
<tr class="separator:abebbe9b3c71f3c7f0346641e0b7e96ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a8c07ad4fa26d5c3e28f33c2215f1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a73a8c07ad4fa26d5c3e28f33c2215f1d">AutoInline</a> (bool into_producer, bool into_consumer, bool inline_const_tensor, bool disallow_if_then_else, bool require_injective, bool require_ordered, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; disallow_op)</td></tr>
<tr class="memdesc:a73a8c07ad4fa26d5c3e28f33c2215f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an auto-inline rule that inlines spatial blocks if it satisfies some conditions.  <a href="#a73a8c07ad4fa26d5c3e28f33c2215f1d">More...</a><br /></td></tr>
<tr class="separator:a73a8c07ad4fa26d5c3e28f33c2215f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d48f7fce5c1c7a913688361787e854"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a56d48f7fce5c1c7a913688361787e854">InlineConstantScalars</a> ()</td></tr>
<tr class="memdesc:a56d48f7fce5c1c7a913688361787e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline blocks that produce a constant scalar. Such blocks get in the way of ReverseComputeInline during AutoInline, since they are also counted as a producer block unless they are inlined first. So it is recommended to run InlineConstantScalars before AutoInline.  <a href="#a56d48f7fce5c1c7a913688361787e854">More...</a><br /></td></tr>
<tr class="separator:a56d48f7fce5c1c7a913688361787e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386b9a8b7dbb83666f47a2fc65df3a66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a386b9a8b7dbb83666f47a2fc65df3a66">MultiLevelTiling</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> structure, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; tile_binds, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_read, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_write, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &gt; filter_fn=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="memdesc:a386b9a8b7dbb83666f47a2fc65df3a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mega rule: multi-level tiling with data reuse.  <a href="#a386b9a8b7dbb83666f47a2fc65df3a66">More...</a><br /></td></tr>
<tr class="separator:a386b9a8b7dbb83666f47a2fc65df3a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f027aecba3832b89f0769acd145ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a9e2f027aecba3832b89f0769acd145ef">MultiLevelTilingWithIntrin</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> intrin_name, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> structure, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; tile_binds, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_read, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_write)</td></tr>
<tr class="memdesc:a9e2f027aecba3832b89f0769acd145ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for auto-tensorization with a single intrinsic.  <a href="#a9e2f027aecba3832b89f0769acd145ef">More...</a><br /></td></tr>
<tr class="separator:a9e2f027aecba3832b89f0769acd145ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a6551c51df77b91de6b89661f0e7c9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a57a6551c51df77b91de6b89661f0e7c9">MultiLevelTilingTensorCore</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; intrin_groups, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> structure, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; tile_binds, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; vector_load_lens, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_read, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_write, bool use_software_pipeline)</td></tr>
<tr class="memdesc:a57a6551c51df77b91de6b89661f0e7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for auto-tensorization with multiple groups of candidate tensor core intrinsics.  <a href="#a57a6551c51df77b91de6b89661f0e7c9">More...</a><br /></td></tr>
<tr class="separator:a57a6551c51df77b91de6b89661f0e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08251350067dc524a1362ec723691a18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a08251350067dc524a1362ec723691a18">MultiLevelTilingWideVector</a> (<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> structure, <a class="el" href="classtvm_1_1Integer.html">Integer</a> vector_length_in_bits, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_read, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt; reuse_write)</td></tr>
<tr class="memdesc:a08251350067dc524a1362ec723691a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of MultiLevelTiling for backends with wide vectors. The loop over the innermost spatial axis of the output buffer is always vectorized with the maximum vector length.  <a href="#a08251350067dc524a1362ec723691a18">More...</a><br /></td></tr>
<tr class="separator:a08251350067dc524a1362ec723691a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88a36846b8653f9ad41218a44bec110"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac88a36846b8653f9ad41218a44bec110">AddRFactor</a> (int max_jobs_per_core, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; max_innermost_factor)</td></tr>
<tr class="memdesc:ac88a36846b8653f9ad41218a44bec110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rule: add-rfactor to some blocks if needed.  <a href="#ac88a36846b8653f9ad41218a44bec110">More...</a><br /></td></tr>
<tr class="separator:ac88a36846b8653f9ad41218a44bec110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14acfc5ea272e2e53f9ac3e1110e53ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a14acfc5ea272e2e53f9ac3e1110e53ea">CrossThreadReduction</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; thread_extents)</td></tr>
<tr class="memdesc:a14acfc5ea272e2e53f9ac3e1110e53ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a schedule rule which applies cross-thread reduction to some reduction blocks correspondingly when needed.  <a href="#a14acfc5ea272e2e53f9ac3e1110e53ea">More...</a><br /></td></tr>
<tr class="separator:a14acfc5ea272e2e53f9ac3e1110e53ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf485537817533eaf711226f687778c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a1bf485537817533eaf711226f687778c">RandomComputeLocation</a> ()</td></tr>
<tr class="memdesc:a1bf485537817533eaf711226f687778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rule that randomly select a compute-at location for a free block.  <a href="#a1bf485537817533eaf711226f687778c">More...</a><br /></td></tr>
<tr class="separator:a1bf485537817533eaf711226f687778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef9b604081db7a8bf960f3fbfd3a804"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a0ef9b604081db7a8bf960f3fbfd3a804">ParallelizeVectorizeUnroll</a> (int max_jobs_per_core, int max_vectorize_extent, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; unroll_max_steps, bool unroll_explicit)</td></tr>
<tr class="memdesc:a0ef9b604081db7a8bf960f3fbfd3a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark parallelize, vectorize and unroll to the root block. The mark will be applied to each block in a follow-up post processor.  <a href="#a0ef9b604081db7a8bf960f3fbfd3a804">More...</a><br /></td></tr>
<tr class="separator:a0ef9b604081db7a8bf960f3fbfd3a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8ddfecce77dae00b9c958c2d514f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a96f8ddfecce77dae00b9c958c2d514f5">AutoBind</a> (int max_threadblocks, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; thread_extents, int max_threads_per_block=-1)</td></tr>
<tr class="memdesc:a96f8ddfecce77dae00b9c958c2d514f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto bind loops around the block to BlockIdx and ThreadIdx.  <a href="#a96f8ddfecce77dae00b9c958c2d514f5">More...</a><br /></td></tr>
<tr class="separator:a96f8ddfecce77dae00b9c958c2d514f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812a72ff2ad145247b0f9dc7954340d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ac812a72ff2ad145247b0f9dc7954340d">PyScheduleRule</a> (<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a19b2fb7007e375c8fc39168b7ee071aa">FInitializeWithTuneContext</a> f_initialize_with_tune_context, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a2c558d23de2ff6bf298bc7167a210859">FApply</a> f_apply, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7bed37c51b09c7e58ce8f25d601bc24f">FClone</a> f_clone, <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4c02153b06f9c5577114d719747a7b1a">FAsString</a> f_as_string)</td></tr>
<tr class="memdesc:ac812a72ff2ad145247b0f9dc7954340d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a schedule rule with customized methods on the python-side.  <a href="#ac812a72ff2ad145247b0f9dc7954340d">More...</a><br /></td></tr>
<tr class="separator:ac812a72ff2ad145247b0f9dc7954340d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031b6dcad67f1d985aa30adb13e2b6e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a031b6dcad67f1d985aa30adb13e2b6e8">DefaultLLVM</a> ()</td></tr>
<tr class="memdesc:a031b6dcad67f1d985aa30adb13e2b6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for LLVM.  <a href="#a031b6dcad67f1d985aa30adb13e2b6e8">More...</a><br /></td></tr>
<tr class="separator:a031b6dcad67f1d985aa30adb13e2b6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5342931a76e2269970f132d0921e2f45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a5342931a76e2269970f132d0921e2f45">DefaultX86</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;type)</td></tr>
<tr class="memdesc:a5342931a76e2269970f132d0921e2f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for x86 (AVX512 and VNNI)  <a href="#a5342931a76e2269970f132d0921e2f45">More...</a><br /></td></tr>
<tr class="separator:a5342931a76e2269970f132d0921e2f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ab3dd14cbfcec7ed059559f7afc372"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a77ab3dd14cbfcec7ed059559f7afc372">DefaultCUDA</a> ()</td></tr>
<tr class="memdesc:a77ab3dd14cbfcec7ed059559f7afc372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for CUDA.  <a href="#a77ab3dd14cbfcec7ed059559f7afc372">More...</a><br /></td></tr>
<tr class="separator:a77ab3dd14cbfcec7ed059559f7afc372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abd71c2f3600573784d855d3cd63814"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a2abd71c2f3600573784d855d3cd63814">DefaultCUDATensorCore</a> ()</td></tr>
<tr class="memdesc:a2abd71c2f3600573784d855d3cd63814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default postprocessors for CUDA with TensorCore.  <a href="#a2abd71c2f3600573784d855d3cd63814">More...</a><br /></td></tr>
<tr class="separator:a2abd71c2f3600573784d855d3cd63814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4de1f7ace3a34603f8832ae1b3180b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#acd4de1f7ace3a34603f8832ae1b3180b">DefaultHexagon</a> ()</td></tr>
<tr class="memdesc:acd4de1f7ace3a34603f8832ae1b3180b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for Hexagon.  <a href="#acd4de1f7ace3a34603f8832ae1b3180b">More...</a><br /></td></tr>
<tr class="separator:acd4de1f7ace3a34603f8832ae1b3180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad181358bf6ca1951f0038f0691308bee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#ad181358bf6ca1951f0038f0691308bee">DefaultMicro</a> ()</td></tr>
<tr class="memdesc:ad181358bf6ca1951f0038f0691308bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create default schedule rules for Micro.  <a href="#ad181358bf6ca1951f0038f0691308bee">More...</a><br /></td></tr>
<tr class="separator:ad181358bf6ca1951f0038f0691308bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a3e9b0901b6e01257b060a45e159cc37e">_type_is_nullable</a> = true</td></tr>
<tr class="separator:a3e9b0901b6e01257b060a45e159cc37e inherit pub_static_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ae423057ecf93c18714d17f53cd1d318f">get_mutable</a> () const</td></tr>
<tr class="separator:ae423057ecf93c18714d17f53cd1d318f inherit pro_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">DowncastNoCheck</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> ref)</td></tr>
<tr class="memdesc:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function downcast a ref without check.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#acd04bb22a6861e9952c344ee8547411f">More...</a><br /></td></tr>
<tr class="separator:acd04bb22a6861e9952c344ee8547411f inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">FFIClearAfterMove</a> (<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> *ref)</td></tr>
<tr class="memdesc:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the object ref data field without DecRef after we successfully moved the field.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#a22e5bb9d64dbc773bb9263b70882239e">More...</a><br /></td></tr>
<tr class="separator:a22e5bb9d64dbc773bb9263b70882239e inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ObjectType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">GetDataPtr</a> (const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ref)</td></tr>
<tr class="memdesc:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper function get data_ as <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> of ObjectType.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#aed593996e4076632450de8fde776707c">More...</a><br /></td></tr>
<tr class="separator:aed593996e4076632450de8fde776707c inherit pro_static_methods_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtvm_1_1runtime_1_1ObjectRef')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">tvm::runtime::ObjectRef</a></td></tr>
<tr class="memitem:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">data_</a></td></tr>
<tr class="memdesc:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal pointer that backs the reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#ac261cdb80487fb29ac42b28678f8cbef">More...</a><br /></td></tr>
<tr class="separator:ac261cdb80487fb29ac42b28678f8cbef inherit pro_attribs_classtvm_1_1runtime_1_1ObjectRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed reference to <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule. ">ScheduleRuleNode</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html" title="Rules to modify a block in a schedule. ">ScheduleRuleNode</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2c558d23de2ff6bf298bc7167a210859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c558d23de2ff6bf298bc7167a210859">&#9670;&nbsp;</a></span>FApply</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a2c558d23de2ff6bf298bc7167a210859">tvm::meta_schedule::ScheduleRule::FApply</a> =  <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a>&gt;(const <a class="el" href="classtvm_1_1tir_1_1Schedule.html">tir::Schedule</a>&amp;, const <a class="el" href="classtvm_1_1tir_1_1BlockRV.html">tir::BlockRV</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>Apply</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sch</td><td>The schedule to be modified. </td></tr>
    <tr><td class="paramname">block</td><td>The specific block to apply the schedule rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of schedules generated by applying the schedule rule. </dd></dl>

</div>
</div>
<a id="a4c02153b06f9c5577114d719747a7b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02153b06f9c5577114d719747a7b1a">&#9670;&nbsp;</a></span>FAsString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4c02153b06f9c5577114d719747a7b1a">tvm::meta_schedule::ScheduleRule::FAsString</a> =  <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the schedule rule as string with name. </p>
<dl class="section return"><dt>Returns</dt><dd>The string of the schedule rule. </dd></dl>

</div>
</div>
<a id="a7bed37c51b09c7e58ce8f25d601bc24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bed37c51b09c7e58ce8f25d601bc24f">&#9670;&nbsp;</a></span>FClone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7bed37c51b09c7e58ce8f25d601bc24f">tvm::meta_schedule::ScheduleRule::FClone</a> =  <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>Clone</code> method. </p>
<dl class="section return"><dt>Returns</dt><dd>The cloned schedule rule. </dd></dl>

</div>
</div>
<a id="a19b2fb7007e375c8fc39168b7ee071aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b2fb7007e375c8fc39168b7ee071aa">&#9670;&nbsp;</a></span>FInitializeWithTuneContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a19b2fb7007e375c8fc39168b7ee071aa">tvm::meta_schedule::ScheduleRule::FInitializeWithTuneContext</a> =  <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;void(const <a class="el" href="classtvm_1_1meta__schedule_1_1TuneContext.html">TuneContext</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function type of <code>InitializeWithTuneContext</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The tuning context for initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac88a36846b8653f9ad41218a44bec110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88a36846b8653f9ad41218a44bec110">&#9670;&nbsp;</a></span>AddRFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AddRFactor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_jobs_per_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rule: add-rfactor to some blocks if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_jobs_per_core</td><td>The maximum number of jobs to be launched per CPU core. It sets the uplimit of CPU parallelism, i.e. <code>num_cores * max_jobs_per_core</code>. Use -1 to disable parallelism. </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. NullOpt means no limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a4f50de278ec0889780dc9d7066cda499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f50de278ec0889780dc9d7066cda499">&#9670;&nbsp;</a></span>ApplyCustomRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::ApplyCustomRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rule that applies customized rules registered using block attribute <code>schedule_rule</code>. The rule will be dispatched according to target keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The created schedule rule. </dd></dl>

</div>
</div>
<a id="a96f8ddfecce77dae00b9c958c2d514f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f8ddfecce77dae00b9c958c2d514f5">&#9670;&nbsp;</a></span>AutoBind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AutoBind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threadblocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>thread_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads_per_block</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto bind loops around the block to BlockIdx and ThreadIdx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threadblocks</td><td>The maximum number of threadblock on GPU </td></tr>
    <tr><td class="paramname">thread_extents</td><td>Candidates of thread axis extent. </td></tr>
    <tr><td class="paramname">max_threads_per_block</td><td>The maximum number of threads per block, if it is known when this schedule rule is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a73a8c07ad4fa26d5c3e28f33c2215f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a8c07ad4fa26d5c3e28f33c2215f1d">&#9670;&nbsp;</a></span>AutoInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::AutoInline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>into_producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>into_consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inline_const_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disallow_if_then_else</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_injective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_ordered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>disallow_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an auto-inline rule that inlines spatial blocks if it satisfies some conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into_producer</td><td>If allows to inline a block into its producer </td></tr>
    <tr><td class="paramname">into_consumer</td><td>If allows to inline a block into its consumer </td></tr>
    <tr><td class="paramname">inline_const_tensor</td><td>Always inline constant tensors </td></tr>
    <tr><td class="paramname">disallow_if_then_else</td><td>Always disallow if-then-else-like constructs </td></tr>
    <tr><td class="paramname">require_ordered</td><td>Always require the read-to-write mapping to be ordered </td></tr>
    <tr><td class="paramname">require_injective</td><td>Always require the read-to-write mapping to be injective </td></tr>
    <tr><td class="paramname">disallow_op</td><td>The operators that are disallowed in auto inline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a14acfc5ea272e2e53f9ac3e1110e53ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14acfc5ea272e2e53f9ac3e1110e53ea">&#9670;&nbsp;</a></span>CrossThreadReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::CrossThreadReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>thread_extents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a schedule rule which applies cross-thread reduction to some reduction blocks correspondingly when needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_extents</td><td>Candidates of thread axis extent (values are required to be positive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a77ab3dd14cbfcec7ed059559f7afc372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ab3dd14cbfcec7ed059559f7afc372">&#9670;&nbsp;</a></span>DefaultCUDA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultCUDA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for CUDA. </p>

</div>
</div>
<a id="a2abd71c2f3600573784d855d3cd63814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abd71c2f3600573784d855d3cd63814">&#9670;&nbsp;</a></span>DefaultCUDATensorCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultCUDATensorCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default postprocessors for CUDA with TensorCore. </p>

</div>
</div>
<a id="acd4de1f7ace3a34603f8832ae1b3180b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4de1f7ace3a34603f8832ae1b3180b">&#9670;&nbsp;</a></span>DefaultHexagon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultHexagon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for Hexagon. </p>

</div>
</div>
<a id="a031b6dcad67f1d985aa30adb13e2b6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031b6dcad67f1d985aa30adb13e2b6e8">&#9670;&nbsp;</a></span>DefaultLLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultLLVM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for LLVM. </p>

</div>
</div>
<a id="ad181358bf6ca1951f0038f0691308bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad181358bf6ca1951f0038f0691308bee">&#9670;&nbsp;</a></span>DefaultMicro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultMicro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for Micro. </p>

</div>
</div>
<a id="a5342931a76e2269970f132d0921e2f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5342931a76e2269970f132d0921e2f45">&#9670;&nbsp;</a></span>DefaultX86()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>, void&gt; tvm::meta_schedule::ScheduleRule::DefaultX86 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create default schedule rules for x86 (AVX512 and VNNI) </p>

</div>
</div>
<a id="a56d48f7fce5c1c7a913688361787e854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d48f7fce5c1c7a913688361787e854">&#9670;&nbsp;</a></span>InlineConstantScalars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::InlineConstantScalars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline blocks that produce a constant scalar. Such blocks get in the way of ReverseComputeInline during AutoInline, since they are also counted as a producer block unless they are inlined first. So it is recommended to run InlineConstantScalars before AutoInline. </p>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="abebbe9b3c71f3c7f0346641e0b7e96ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebbe9b3c71f3c7f0346641e0b7e96ad">&#9670;&nbsp;</a></span>IsApplyCustomRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tvm::meta_schedule::ScheduleRule::IsApplyCustomRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the rule is <code>ApplyCustomRule</code> </p>

</div>
</div>
<a id="a386b9a8b7dbb83666f47a2fc65df3a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386b9a8b7dbb83666f47a2fc65df3a66">&#9670;&nbsp;</a></span>MultiLevelTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &gt;&#160;</td>
          <td class="paramname"><em>filter_fn</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mega rule: multi-level tiling with data reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSRSRS' on CPU</li>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>NullOpt on CPU</li>
<li>[blockIdx.x, vthread.x, threadIdx.x] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. NullOpt means no limit </td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. NullOpt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">filter_fn</td><td>A function that can be passed to overwrite the default condition for applying MultiLevelTiling to a block. Its signature must be (Schedule, BlockRV) -&gt; bool. This is useful if there is a need to apply MultiLevelTiling to an operation / block which is ignored by default. This function should return True for a block that should be tiled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a57a6551c51df77b91de6b89661f0e7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a6551c51df77b91de6b89661f0e7c9">&#9670;&nbsp;</a></span>MultiLevelTilingTensorCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingTensorCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>intrin_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_software_pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for auto-tensorization with multiple groups of candidate tensor core intrinsics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrin_groups</td><td>A list of groups of tensor core intrinsics. The map should contains key "init", "load_a", "load_b", "compute", "store", which represent the tensor intrin for initialization, loading operand A, loading operand B, tensor core computation, storing the result. The value of the map should be names of tensor intrinsics, must be registered via TensorIntrin.register(...) beforehand </td></tr>
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>[blockIdx.y, blockIdx.x, threadIdx.y] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. NullOpt means no limit </td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. NullOpt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">use_software_pipeline</td><td>Whether use the software pipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a08251350067dc524a1362ec723691a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08251350067dc524a1362ec723691a18">&#9670;&nbsp;</a></span>MultiLevelTilingWideVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingWideVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Integer.html">Integer</a>&#160;</td>
          <td class="paramname"><em>vector_length_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for backends with wide vectors. The loop over the innermost spatial axis of the output buffer is always vectorized with the maximum vector length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure</td><td>The tiling structure. 'SSRSRS' is recommended. </td></tr>
    <tr><td class="paramname">vector_length_in_bits</td><td>The length of a vector register in bits. </td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. NullOpt means no limit </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. NullOpt means no reuse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a9e2f027aecba3832b89f0769acd145ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2f027aecba3832b89f0769acd145ef">&#9670;&nbsp;</a></span>MultiLevelTilingWithIntrin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::MultiLevelTilingWithIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>intrin_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>tile_binds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>max_innermost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vector_load_lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reuse_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extension of MultiLevelTiling for auto-tensorization with a single intrinsic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrin_name</td><td>The name of a tensor intrinsic, must be registered via TensorIntrin.register(...) beforehand </td></tr>
    <tr><td class="paramname">structure</td><td>The tiling structure. Recommended:<ul>
<li>'SSRSRS' on CPU</li>
<li>'SSSRRSRS' on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">tile_binds</td><td>For each level of tiles, which thread axis it is bound to. Recommended:<ul>
<li>NullOpt on CPU</li>
<li>[blockIdx.x, vthread.x, threadIdx.x] on GPU </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_innermost_factor</td><td>The maximum size of the innermost factor. NullOpt means no limit </td></tr>
    <tr><td class="paramname">vector_load_lens</td><td>The length of vector lane in vectorized cooperative fetching. NullOpt means disable vectorization </td></tr>
    <tr><td class="paramname">reuse_read</td><td>Data reuse configuration for reading. NullOpt means no reuse. </td></tr>
    <tr><td class="paramname">reuse_write</td><td>Data reuse configuration for writing. NullOpt means no reuse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a0ef9b604081db7a8bf960f3fbfd3a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef9b604081db7a8bf960f3fbfd3a804">&#9670;&nbsp;</a></span>ParallelizeVectorizeUnroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::ParallelizeVectorizeUnroll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_jobs_per_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_vectorize_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>unroll_max_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unroll_explicit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark parallelize, vectorize and unroll to the root block. The mark will be applied to each block in a follow-up post processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_jobs_per_core</td><td>The maximum number of jobs to be launched per CPU core. It sets the upper limit of CPU parallelism, i.e. <code>num_cores * max_jobs_per_core</code>. Use -1 to disable parallelism. </td></tr>
    <tr><td class="paramname">max_vectorize_extent</td><td>The maximum extent to be vectorized. It sets the upper limit of the hardware target vectorization. Use -1 to disable vectorization. </td></tr>
    <tr><td class="paramname">unroll_max_steps</td><td>The options of the maximum number of unroll steps to be done. Use an empty array to disable unroll. </td></tr>
    <tr><td class="paramname">unroll_explicit</td><td>Whether to explicitly unroll the loop, or just add an "unroll" pragma. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="ac812a72ff2ad145247b0f9dc7954340d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac812a72ff2ad145247b0f9dc7954340d">&#9670;&nbsp;</a></span>PyScheduleRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::PyScheduleRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a19b2fb7007e375c8fc39168b7ee071aa">FInitializeWithTuneContext</a>&#160;</td>
          <td class="paramname"><em>f_initialize_with_tune_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a2c558d23de2ff6bf298bc7167a210859">FApply</a>&#160;</td>
          <td class="paramname"><em>f_apply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a7bed37c51b09c7e58ce8f25d601bc24f">FClone</a>&#160;</td>
          <td class="paramname"><em>f_clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html#a4c02153b06f9c5577114d719747a7b1a">FAsString</a>&#160;</td>
          <td class="paramname"><em>f_as_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a schedule rule with customized methods on the python-side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_initialize_with_tune_context</td><td>The packed function of <code>InitializeWithTuneContext</code>. </td></tr>
    <tr><td class="paramname">f_apply</td><td>The packed function of <code>Apply</code>. </td></tr>
    <tr><td class="paramname">f_clone</td><td>The packed function of <code>Clone</code>. </td></tr>
    <tr><td class="paramname">f_as_string</td><td>The packed function of <code>AsString</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created. </dd></dl>

</div>
</div>
<a id="a1bf485537817533eaf711226f687778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf485537817533eaf711226f687778c">&#9670;&nbsp;</a></span>RandomComputeLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a> tvm::meta_schedule::ScheduleRule::RandomComputeLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A rule that randomly select a compute-at location for a free block. </p>
<dl class="section return"><dt>Returns</dt><dd>The schedule rule created </dd></dl>

</div>
</div>
<a id="a157a6c0605c6ee1851128dbece136d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157a6c0605c6ee1851128dbece136d51">&#9670;&nbsp;</a></span>TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::meta_schedule::ScheduleRule::TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRule.html">ScheduleRule</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1meta__schedule_1_1ScheduleRuleNode.html">ScheduleRuleNode</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/meta_schedule/<a class="el" href="schedule__rule_8h_source.html">schedule_rule.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
