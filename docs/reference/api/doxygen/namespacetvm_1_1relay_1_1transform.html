<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relay::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afa666ade112e9955059095d695238a9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> = <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td></tr>
<tr class="separator:afa666ade112e9955059095d695238a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">PassNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td></tr>
<tr class="separator:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">PassInfo</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td></tr>
<tr class="separator:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">PassInfoNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td></tr>
<tr class="separator:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744a05f8bba3c2ac238ba4569d926184"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a> = <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td></tr>
<tr class="separator:a744a05f8bba3c2ac238ba4569d926184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72900733e0d3510ae61a1c287c2ec125"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">PassContextNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td></tr>
<tr class="separator:a72900733e0d3510ae61a1c287c2ec125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae923037d22b4640b450c06e6c1e33e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">Sequential</a> = <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td></tr>
<tr class="separator:a3ae923037d22b4640b450c06e6c1e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2101aa797e69d398012ef94b63db51da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2101aa797e69d398012ef94b63db51da">CreateFunctionPass</a> (const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;pass_func, int opt_level, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> name, <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; required)</td></tr>
<tr class="separator:a2101aa797e69d398012ef94b63db51da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441963a144dae58b7633d0a674cf20cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a441963a144dae58b7633d0a674cf20cc">DeadCodeElimination</a> (bool inline_once=false, bool ignore_purity=false)</td></tr>
<tr class="memdesc:a441963a144dae58b7633d0a674cf20cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let-bound expressions which do not effect the program result.  <a href="#a441963a144dae58b7633d0a674cf20cc">More...</a><br /></td></tr>
<tr class="separator:a441963a144dae58b7633d0a674cf20cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e60251741cca1e811564b2f03a4a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab6e60251741cca1e811564b2f03a4a5d">LazyGradientInit</a> ()</td></tr>
<tr class="memdesc:ab6e60251741cca1e811564b2f03a4a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly.  <a href="#ab6e60251741cca1e811564b2f03a4a5d">More...</a><br /></td></tr>
<tr class="separator:ab6e60251741cca1e811564b2f03a4a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41656c71a440f1f9c9eae0aa409d2b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a41656c71a440f1f9c9eae0aa409d2b22">FoldConstant</a> ()</td></tr>
<tr class="memdesc:a41656c71a440f1f9c9eae0aa409d2b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions.  <a href="#a41656c71a440f1f9c9eae0aa409d2b22">More...</a><br /></td></tr>
<tr class="separator:a41656c71a440f1f9c9eae0aa409d2b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2425d757b896168a109498e8d34ba960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2425d757b896168a109498e8d34ba960">SplitArgs</a> (int max_function_args)</td></tr>
<tr class="memdesc:a2425d757b896168a109498e8d34ba960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split function with huge number of arguments to smaller pieces.  <a href="#a2425d757b896168a109498e8d34ba960">More...</a><br /></td></tr>
<tr class="separator:a2425d757b896168a109498e8d34ba960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6be6024a96a84f7230faa2519f1a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2a6be6024a96a84f7230faa2519f1a97">FuseOps</a> (int fuse_opt_level=-1)</td></tr>
<tr class="memdesc:a2a6be6024a96a84f7230faa2519f1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse operations into expr into seperate functions.  <a href="#a2a6be6024a96a84f7230faa2519f1a97">More...</a><br /></td></tr>
<tr class="separator:a2a6be6024a96a84f7230faa2519f1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a8f3eee7092f7e3e58e1c76f4498e32e7">DefuseOps</a> ()</td></tr>
<tr class="memdesc:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse operation of FuseOps. It transforms a fused program returned by FuseOps into the program before FuseOps. (i.e. x == DefuseOps(FuseOps(x)))  <a href="#a8f3eee7092f7e3e58e1c76f4498e32e7">More...</a><br /></td></tr>
<tr class="separator:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a03b053f3d99d5c420ddc8492e6b987bf">RewriteAnnotatedOps</a> (int fallback_device)</td></tr>
<tr class="memdesc:a03b053f3d99d5c420ddc8492e6b987bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a03b053f3d99d5c420ddc8492e6b987bf">More...</a><br /></td></tr>
<tr class="separator:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185cc89297d9216551db7a3816d5180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6185cc89297d9216551db7a3816d5180">ToBasicBlockNormalForm</a> ()</td></tr>
<tr class="memdesc:a6185cc89297d9216551db7a3816d5180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression to Basic Block Normal Form.  <a href="#a6185cc89297d9216551db7a3816d5180">More...</a><br /></td></tr>
<tr class="separator:a6185cc89297d9216551db7a3816d5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a8cb03cf00b2ddf25f183ab837cde713c">ToANormalForm</a> ()</td></tr>
<tr class="memdesc:a8cb03cf00b2ddf25f183ab837cde713c"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF).  <a href="#a8cb03cf00b2ddf25f183ab837cde713c">More...</a><br /></td></tr>
<tr class="separator:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d361d98e061197dd5d9d1d457fb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a256d361d98e061197dd5d9d1d457fb19">ToANormalForm</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a256d361d98e061197dd5d9d1d457fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">ToANormalForm but on incomplete graph.  <a href="#a256d361d98e061197dd5d9d1d457fb19">More...</a><br /></td></tr>
<tr class="separator:a256d361d98e061197dd5d9d1d457fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e4d6ac08b62ef553755e759d398fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ad90e4d6ac08b62ef553755e759d398fa">ToCPS</a> ()</td></tr>
<tr class="memdesc:ad90e4d6ac08b62ef553755e759d398fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression into continuation passing style(CPS).  <a href="#ad90e4d6ac08b62ef553755e759d398fa">More...</a><br /></td></tr>
<tr class="separator:ad90e4d6ac08b62ef553755e759d398fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2cfef0e02cca22f3e0e85e0a10a82f5b">ToGraphNormalForm</a> ()</td></tr>
<tr class="memdesc:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let binding and directly share via pointer instead.  <a href="#a2cfef0e02cca22f3e0e85e0a10a82f5b">More...</a><br /></td></tr>
<tr class="separator:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa270d98da5518969e005c7e30d6eb6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa270d98da5518969e005c7e30d6eb6fe">PartialEval</a> ()</td></tr>
<tr class="memdesc:aa270d98da5518969e005c7e30d6eb6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressive constant propagation/constant folding/inlining.  <a href="#aa270d98da5518969e005c7e30d6eb6fe">More...</a><br /></td></tr>
<tr class="separator:aa270d98da5518969e005c7e30d6eb6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add13a2ad7b216ad4683141bbbb4f6943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#add13a2ad7b216ad4683141bbbb4f6943">SimplifyInference</a> ()</td></tr>
<tr class="memdesc:add13a2ad7b216ad4683141bbbb4f6943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify certain operators during inference. For example, the result of a batch norm which is indexed at tuple index 0 will be unpacked into a number of simplified operators.  <a href="#add13a2ad7b216ad4683141bbbb4f6943">More...</a><br /></td></tr>
<tr class="separator:add13a2ad7b216ad4683141bbbb4f6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a22870dd16693b2e3edb5fba7cb5dc3e8">FastMath</a> ()</td></tr>
<tr class="memdesc:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces non linear activation functions with their fast but approximate counterparts.  <a href="#a22870dd16693b2e3edb5fba7cb5dc3e8">More...</a><br /></td></tr>
<tr class="separator:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab533a050ab0d54b41e543fb1fd369fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab533a050ab0d54b41e543fb1fd369fb6">DynamicToStatic</a> ()</td></tr>
<tr class="memdesc:ab533a050ab0d54b41e543fb1fd369fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Dynamic ops and make them static.  <a href="#ab533a050ab0d54b41e543fb1fd369fb6">More...</a><br /></td></tr>
<tr class="separator:ab533a050ab0d54b41e543fb1fd369fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a1a4fe2161bf32a60bc2e57debab083ee">InferType</a> ()</td></tr>
<tr class="memdesc:a1a4fe2161bf32a60bc2e57debab083ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="#a1a4fe2161bf32a60bc2e57debab083ee">More...</a><br /></td></tr>
<tr class="separator:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a00e0adf2a7410c4794f8f4f2d4831dc7">InferTypeLocal</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression, reusing existing type information.  <a href="#a00e0adf2a7410c4794f8f4f2d4831dc7">More...</a><br /></td></tr>
<tr class="separator:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21ade01969835b155241d277a94d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adf21ade01969835b155241d277a94d1c">EliminateCommonSubexpr</a> (<a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> fskip=nullptr)</td></tr>
<tr class="memdesc:adf21ade01969835b155241d277a94d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable.  <a href="#adf21ade01969835b155241d277a94d1c">More...</a><br /></td></tr>
<tr class="separator:adf21ade01969835b155241d277a94d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3b8f4cbf0bd699d2ca0ab92c534c867d">CombineParallelConv2D</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>.  <a href="#a3b8f4cbf0bd699d2ca0ab92c534c867d">More...</a><br /></td></tr>
<tr class="separator:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61517368427f429e784b4b128cb6351d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a61517368427f429e784b4b128cb6351d">CombineParallelDense</a> (uint64_t min_num_branches=3, bool to_batch_matmul=true)</td></tr>
<tr class="memdesc:a61517368427f429e784b4b128cb6351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>.  <a href="#a61517368427f429e784b4b128cb6351d">More...</a><br /></td></tr>
<tr class="separator:a61517368427f429e784b4b128cb6351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97a0ec61929f58aefff5da83a73e1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa97a0ec61929f58aefff5da83a73e1cd">CombineParallelBatchMatmul</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:aa97a0ec61929f58aefff5da83a73e1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel batch_matmul ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>.  <a href="#aa97a0ec61929f58aefff5da83a73e1cd">More...</a><br /></td></tr>
<tr class="separator:aa97a0ec61929f58aefff5da83a73e1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3bde64d7774dcda7735f73a4e2ebecf7">BackwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward fold axis scaling into weights of conv/dense operators.  <a href="#a3bde64d7774dcda7735f73a4e2ebecf7">More...</a><br /></td></tr>
<tr class="separator:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f62610e05ed0211f17d452ee37f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aab7f62610e05ed0211f17d452ee37f5f">ForwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:aab7f62610e05ed0211f17d452ee37f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward fold axis scaling into weights of conv/dense operators.  <a href="#aab7f62610e05ed0211f17d452ee37f5f">More...</a><br /></td></tr>
<tr class="separator:aab7f62610e05ed0211f17d452ee37f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73946a29efe8cf6f186a681296c8e943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a73946a29efe8cf6f186a681296c8e943">FoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a73946a29efe8cf6f186a681296c8e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes.  <a href="#a73946a29efe8cf6f186a681296c8e943">More...</a><br /></td></tr>
<tr class="separator:a73946a29efe8cf6f186a681296c8e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcddf150ca7da40e20408928421b0086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adcddf150ca7da40e20408928421b0086">CanonicalizeOps</a> ()</td></tr>
<tr class="memdesc:adcddf150ca7da40e20408928421b0086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add.  <a href="#adcddf150ca7da40e20408928421b0086">More...</a><br /></td></tr>
<tr class="separator:adcddf150ca7da40e20408928421b0086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e0426cfa5887f11769a057c09ce8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a64e0426cfa5887f11769a057c09ce8ba">AlterOpLayout</a> ()</td></tr>
<tr class="memdesc:a64e0426cfa5887f11769a057c09ce8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layouts of operators or replace primitive operators with other expressions.  <a href="#a64e0426cfa5887f11769a057c09ce8ba">More...</a><br /></td></tr>
<tr class="separator:a64e0426cfa5887f11769a057c09ce8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a55b337ffaa1ad7a1e2e727329b2c9951">AutoSchedulerLayoutRewrite</a> ()</td></tr>
<tr class="memdesc:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do layout rewrite according to the tile structure created by auto-scheduler.  <a href="#a55b337ffaa1ad7a1e2e727329b2c9951">More...</a><br /></td></tr>
<tr class="separator:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b49e82dd73b05bfac14040ee2fbdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a40b49e82dd73b05bfac14040ee2fbdee">ConvertLayout</a> (const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; &amp;desired_layouts)</td></tr>
<tr class="memdesc:a40b49e82dd73b05bfac14040ee2fbdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end.  <a href="#a40b49e82dd73b05bfac14040ee2fbdee">More...</a><br /></td></tr>
<tr class="separator:a40b49e82dd73b05bfac14040ee2fbdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae623a28eda64b60c6ee90edde103891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae623a28eda64b60c6ee90edde103891">Legalize</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;legalize_map_attr_name=&quot;FTVMLegalize&quot;)</td></tr>
<tr class="memdesc:aae623a28eda64b60c6ee90edde103891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalizes an expr with another expression.  <a href="#aae623a28eda64b60c6ee90edde103891">More...</a><br /></td></tr>
<tr class="separator:aae623a28eda64b60c6ee90edde103891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a93bbf7ab3f612d4f38a6832d6b53b4fd">CanonicalizeCast</a> ()</td></tr>
<tr class="memdesc:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize cast expressions to make operator fusion more efficient.  <a href="#a93bbf7ab3f612d4f38a6832d6b53b4fd">More...</a><br /></td></tr>
<tr class="separator:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e515696ecc9ff4222af99fef361de4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6e515696ecc9ff4222af99fef361de4e">EtaExpand</a> (bool expand_constructor, bool expand_global_var)</td></tr>
<tr class="memdesc:a6e515696ecc9ff4222af99fef361de4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add abstraction over a constructor or global variable bound to a function.  <a href="#a6e515696ecc9ff4222af99fef361de4e">More...</a><br /></td></tr>
<tr class="separator:a6e515696ecc9ff4222af99fef361de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0bfdaf6d09b360602243c81abe05a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aac0bfdaf6d09b360602243c81abe05a1">PartitionGraph</a> ()</td></tr>
<tr class="memdesc:aac0bfdaf6d09b360602243c81abe05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a Relay program into regions that can be executed on different backends.  <a href="#aac0bfdaf6d09b360602243c81abe05a1">More...</a><br /></td></tr>
<tr class="separator:aac0bfdaf6d09b360602243c81abe05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5e588279a3b19a119c9aa28c364bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aba5e588279a3b19a119c9aa28c364bbe">Inline</a> ()</td></tr>
<tr class="memdesc:aba5e588279a3b19a119c9aa28c364bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#aba5e588279a3b19a119c9aa28c364bbe">More...</a><br /></td></tr>
<tr class="separator:aba5e588279a3b19a119c9aa28c364bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afbbf5f3e5ffb775fafb9c48473dbfa24">RemoveUnusedFunctions</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">runtime::String</a> &gt; entry_functions)</td></tr>
<tr class="memdesc:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#afbbf5f3e5ffb775fafb9c48473dbfa24">More...</a><br /></td></tr>
<tr class="separator:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4de119382b9457742433bc7109ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a42d4de119382b9457742433bc7109ffe">SimplifyExpr</a> ()</td></tr>
<tr class="memdesc:a42d4de119382b9457742433bc7109ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the Relay expression.  <a href="#a42d4de119382b9457742433bc7109ffe">More...</a><br /></td></tr>
<tr class="separator:a42d4de119382b9457742433bc7109ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ba08c6a7a2c99c82bf72dfc6be77e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a91ba08c6a7a2c99c82bf72dfc6be77e1">RelayToTIRTargetHook</a> ()</td></tr>
<tr class="memdesc:a91ba08c6a7a2c99c82bf72dfc6be77e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run any registered RelayToTIR passes registered on the functions in a module.  <a href="#a91ba08c6a7a2c99c82bf72dfc6be77e1">More...</a><br /></td></tr>
<tr class="separator:a91ba08c6a7a2c99c82bf72dfc6be77e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473c64deec00aaf5636cc12f844b1e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a473c64deec00aaf5636cc12f844b1e42">ManifestAlloc</a> (<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> cpu_virtual_device)</td></tr>
<tr class="memdesc:a473c64deec00aaf5636cc12f844b1e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass for manifesting explicit memory allocations and rewriting specific dialects.  <a href="#a473c64deec00aaf5636cc12f844b1e42">More...</a><br /></td></tr>
<tr class="separator:a473c64deec00aaf5636cc12f844b1e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a0a8228f5fdbc269477d7456aadcc7c3d">ManifestLifetimes</a> ()</td></tr>
<tr class="memdesc:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass for manifesting variable lifetimes by inserting kill operations when variables become dead. This pass should be run after ManifestAlloc, and should not be run more than once.  <a href="#a0a8228f5fdbc269477d7456aadcc7c3d">More...</a><br /></td></tr>
<tr class="separator:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176ece3eac49470d18b174cfa196e0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a176ece3eac49470d18b174cfa196e0f0">PlanDevices</a> (<a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a> config)</td></tr>
<tr class="memdesc:a176ece3eac49470d18b174cfa196e0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses existing "on_device" and "device_copy" CallNodes to infer the <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> on which every Relay sub-expression should run and the result stored. Captures the result of that analysis using new "on_device" and "device_copy" CallNodes.  <a href="#a176ece3eac49470d18b174cfa196e0f0">More...</a><br /></td></tr>
<tr class="separator:a176ece3eac49470d18b174cfa196e0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afa666ade112e9955059095d695238a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa666ade112e9955059095d695238a9a">&#9670;&nbsp;</a></span>Pass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">tvm::relay::transform::Pass</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a744a05f8bba3c2ac238ba4569d926184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744a05f8bba3c2ac238ba4569d926184">&#9670;&nbsp;</a></span>PassContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">tvm::relay::transform::PassContext</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72900733e0d3510ae61a1c287c2ec125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72900733e0d3510ae61a1c287c2ec125">&#9670;&nbsp;</a></span>PassContextNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">tvm::relay::transform::PassContextNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa405b5f11938fb8c4fa2ca21926edc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa405b5f11938fb8c4fa2ca21926edc9d">&#9670;&nbsp;</a></span>PassInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">tvm::relay::transform::PassInfo</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae88cd0ad69cf64c7e9caf0a0c8ebb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88cd0ad69cf64c7e9caf0a0c8ebb45">&#9670;&nbsp;</a></span>PassInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">tvm::relay::transform::PassInfoNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa695a8dfc3d5b087018ddd4ef1eb2487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa695a8dfc3d5b087018ddd4ef1eb2487">&#9670;&nbsp;</a></span>PassNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">tvm::relay::transform::PassNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae923037d22b4640b450c06e6c1e33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae923037d22b4640b450c06e6c1e33e">&#9670;&nbsp;</a></span>Sequential</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">tvm::relay::transform::Sequential</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a64e0426cfa5887f11769a057c09ce8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e0426cfa5887f11769a057c09ce8ba">&#9670;&nbsp;</a></span>AlterOpLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AlterOpLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layouts of operators or replace primitive operators with other expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a55b337ffaa1ad7a1e2e727329b2c9951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b337ffaa1ad7a1e2e727329b2c9951">&#9670;&nbsp;</a></span>AutoSchedulerLayoutRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AutoSchedulerLayoutRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do layout rewrite according to the tile structure created by auto-scheduler. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass </dd></dl>

</div>
</div>
<a id="a3bde64d7774dcda7735f73a4e2ebecf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde64d7774dcda7735f73a4e2ebecf7">&#9670;&nbsp;</a></span>BackwardFoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::BackwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a93bbf7ab3f612d4f38a6832d6b53b4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bbf7ab3f612d4f38a6832d6b53b4fd">&#9670;&nbsp;</a></span>CanonicalizeCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize cast expressions to make operator fusion more efficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="adcddf150ca7da40e20408928421b0086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcddf150ca7da40e20408928421b0086">&#9670;&nbsp;</a></span>CanonicalizeOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aa97a0ec61929f58aefff5da83a73e1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97a0ec61929f58aefff5da83a73e1cd">&#9670;&nbsp;</a></span>CombineParallelBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelBatchMatmul </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel batch_matmul ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a3b8f4cbf0bd699d2ca0ab92c534c867d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f4cbf0bd699d2ca0ab92c534c867d">&#9670;&nbsp;</a></span>CombineParallelConv2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelConv2D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a61517368427f429e784b4b128cb6351d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61517368427f429e784b4b128cb6351d">&#9670;&nbsp;</a></span>CombineParallelDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelDense </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_batch_matmul</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches. </td></tr>
    <tr><td class="paramname">to_batch_matmul</td><td>Whether to combine parallel dense ops to batch matmul. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> set false, combine dense ops to single dense op.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a40b49e82dd73b05bfac14040ee2fbdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b49e82dd73b05bfac14040ee2fbdee">&#9670;&nbsp;</a></span>ConvertLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ConvertLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>desired_layouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end. </p>
<p>This pass is not a part of relay.build and is expected to be called between framework-relay parser and relay.build call. This is very helpful for hardware backends that support/prefer only type of data layout.</p>
<p>RFC - <a href="https://discuss.tvm.ai/t/layout-conversion-pass/4009">https://discuss.tvm.ai/t/layout-conversion-pass/4009</a></p>
<p>This pass uses most of the AlterOpLayout and InferCorrectLayout infrastructure. We can define new layouts for conv2d ops for now. Most of the other operators try to adapt to their input layout using the InferCorrectLayout infrastructure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_layouts</td><td>Specify mapping of op_name to array of desired layouts for each input. For example: Map("nn.conv2d", Array("NHWC", "OHWI")), this specifies the desired layout for data then kernel for nn.conv2d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a2101aa797e69d398012ef94b63db51da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2101aa797e69d398012ef94b63db51da">&#9670;&nbsp;</a></span>CreateFunctionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CreateFunctionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a441963a144dae58b7633d0a674cf20cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441963a144dae58b7633d0a674cf20cc">&#9670;&nbsp;</a></span>DeadCodeElimination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DeadCodeElimination </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inline_once</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_purity</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let-bound expressions which do not effect the program result. </p>
<p>This pass will remove let bindings which are not referenced. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> inline_once is True, let bindings which are only referenced once will also be inlined.</p>
<p>For example, this pass should turn <code>let a = 1; 2</code> into <code>2</code>, as the value of the expression does not depend on a.</p>
<p>As another example, <code>let a = 1; a</code> will be optimized into 1 if inline_once is True.</p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> ignore_purity is False, possibly side-effecting expressions (such as memory allocation, random number generation, reading/writing references, or calls to primitive or external functions) are never elided or inlined. This is sound, but ignore_purity can be set to True to suppress this check.</p>
<p>The analysis is fairly conservative, for example it assumes all local functions may be called more than once, any functions passed as arguments have side effects, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inline_once</td><td>whether or not to inline bindings used exactly once. </td></tr>
    <tr><td class="paramname">ignore_purity</td><td>whether to ignore whether expressions have side-effects</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a id="a8f3eee7092f7e3e58e1c76f4498e32e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3eee7092f7e3e58e1c76f4498e32e7">&#9670;&nbsp;</a></span>DefuseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DefuseOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inverse operation of FuseOps. It transforms a fused program returned by FuseOps into the program before FuseOps. (i.e. x == DefuseOps(FuseOps(x))) </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab533a050ab0d54b41e543fb1fd369fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab533a050ab0d54b41e543fb1fd369fb6">&#9670;&nbsp;</a></span>DynamicToStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DynamicToStatic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Dynamic ops and make them static. </p>
<p>Searches the graph for dynamic ops. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the dynamic inputs to those ops are constants, it replaces them with static ops and re-performs type inference and constant folding. The pass repeats itself until the graph stops changing or we run too many iterations.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="adf21ade01969835b155241d277a94d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf21ade01969835b155241d277a94d1c">&#9670;&nbsp;</a></span>EliminateCommonSubexpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EliminateCommonSubexpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a>&#160;</td>
          <td class="paramname"><em>fskip</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fskip</td><td>The callback argument that allows to skip certain expressions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a6e515696ecc9ff4222af99fef361de4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e515696ecc9ff4222af99fef361de4e">&#9670;&nbsp;</a></span>EtaExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EtaExpand </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_global_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add abstraction over a constructor or global variable bound to a function. </p>
<p>For example: <code>square</code> is transformed to <code>fn (x: int32) -&gt; int32 { square(x) }</code>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion">https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expand_constructor</td><td>Whether to expand constructors. </td></tr>
    <tr><td class="paramname">expand_global_var</td><td>Whether to expand global variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a22870dd16693b2e3edb5fba7cb5dc3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22870dd16693b2e3edb5fba7cb5dc3e8">&#9670;&nbsp;</a></span>FastMath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FastMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces non linear activation functions with their fast but approximate counterparts. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a41656c71a440f1f9c9eae0aa409d2b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41656c71a440f1f9c9eae0aa409d2b22">&#9670;&nbsp;</a></span>FoldConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold constant expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a73946a29efe8cf6f186a681296c8e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73946a29efe8cf6f186a681296c8e943">&#9670;&nbsp;</a></span>FoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aab7f62610e05ed0211f17d452ee37f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7f62610e05ed0211f17d452ee37f5f">&#9670;&nbsp;</a></span>ForwardFoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ForwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a2a6be6024a96a84f7230faa2519f1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6be6024a96a84f7230faa2519f1a97">&#9670;&nbsp;</a></span>FuseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FuseOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuse_opt_level</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse operations into expr into seperate functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse_opt_level</td><td>Optimization level. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> it is -1 it will be inferred from pass context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1a4fe2161bf32a60bc2e57debab083ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4fe2161bf32a60bc2e57debab083ee">&#9670;&nbsp;</a></span>InferType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::InferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression. </p>
<p>The result of type checking is a new expression with unambiguous type information filled in, as well as it's checked type field populated with the result type.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a00e0adf2a7410c4794f8f4f2d4831dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e0adf2a7410c4794f8f4f2d4831dc7">&#9670;&nbsp;</a></span>InferTypeLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> tvm::relay::transform::InferTypeLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression, reusing existing type information. </p>
<p>The result of type checking is a new expression with unambiguous type information filled in for the given node only. The local version can use existing type information populated throughout the expression and assumes this information is correct. The local version also avoids examining large amounts of the graph assuming type information is filled in properly which makes it much faster if we iteratively call type inference.</p>
<dl class="section return"><dt>Returns</dt><dd>The type of the expression. </dd></dl>

</div>
</div>
<a id="aba5e588279a3b19a119c9aa28c364bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5e588279a3b19a119c9aa28c364bbe">&#9670;&nbsp;</a></span>Inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Inline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab6e60251741cca1e811564b2f03a4a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e60251741cca1e811564b2f03a4a5d">&#9670;&nbsp;</a></span>LazyGradientInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::LazyGradientInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly. </p>
<p>This will delay or decrease memory usage. All calls to ones, ones_like, zeros, zeros_like will not immediately instantiate a tensor in memory, rather only instantiate if needed. It also defines + and * operation between GradCell types which can increase performance when using zero-filled or one-filled tensors, which is the case in reverse mode ad.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass </dd></dl>

</div>
</div>
<a id="aae623a28eda64b60c6ee90edde103891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae623a28eda64b60c6ee90edde103891">&#9670;&nbsp;</a></span>Legalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Legalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>legalize_map_attr_name</em> = <code>&quot;FTVMLegalize&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalizes an expr with another expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">legalize_map_attr_name</td><td>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>'s attr name which corresponds to the legalize rule function. One can collect and isolate similar type of legalize transformations using this param. For example, transformations that only apply to Dialects can be isolated into a FTVMDialectLegalize string. This pass calls only those transformations that have been registered using the supplied legalize_map_attr_name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a473c64deec00aaf5636cc12f844b1e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473c64deec00aaf5636cc12f844b1e42">&#9670;&nbsp;</a></span>ManifestAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ManifestAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;</td>
          <td class="paramname"><em>cpu_virtual_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pass for manifesting explicit memory allocations and rewriting specific dialects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_virtual_device</td><td><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a> for computations and data which must reside on a CPU, such as shapes and shape functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0a8228f5fdbc269477d7456aadcc7c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8228f5fdbc269477d7456aadcc7c3d">&#9670;&nbsp;</a></span>ManifestLifetimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ManifestLifetimes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pass for manifesting variable lifetimes by inserting kill operations when variables become dead. This pass should be run after ManifestAlloc, and should not be run more than once. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aa270d98da5518969e005c7e30d6eb6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa270d98da5518969e005c7e30d6eb6fe">&#9670;&nbsp;</a></span>PartialEval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartialEval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggressive constant propagation/constant folding/inlining. </p>
<p>It will do as much computation in compile time as possible. It has two benefit: remove runtime overhead, and allow more optimization (typically fusion). As a side effect, code size will explode.</p>
<dl class="section return"><dt>Returns</dt><dd>the optimized expression. </dd></dl>

</div>
</div>
<a id="aac0bfdaf6d09b360602243c81abe05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0bfdaf6d09b360602243c81abe05a1">&#9670;&nbsp;</a></span>PartitionGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartitionGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a Relay program into regions that can be executed on different backends. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a176ece3eac49470d18b174cfa196e0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176ece3eac49470d18b174cfa196e0f0">&#9670;&nbsp;</a></span>PlanDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PlanDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a>&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses existing "on_device" and "device_copy" CallNodes to infer the <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> on which every Relay sub-expression should run and the result stored. Captures the result of that analysis using new "on_device" and "device_copy" CallNodes. </p>
<p>See <a class="el" href="namespacetvm_1_1relay_1_1transform.html">tvm::relay::transform</a>::{LexicalOnDeviceMixin,DeviceAwareExprVisitor,DeviceAwareExprMutator} for help recovering the device for an arbitrary sub-expression in downstream transformations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Describes the targets and default <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> for all primitive operators and host sub-expressions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a91ba08c6a7a2c99c82bf72dfc6be77e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ba08c6a7a2c99c82bf72dfc6be77e1">&#9670;&nbsp;</a></span>RelayToTIRTargetHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RelayToTIRTargetHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run any registered RelayToTIR passes registered on the functions in a module. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="afbbf5f3e5ffb775fafb9c48473dbfa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf5f3e5ffb775fafb9c48473dbfa24">&#9670;&nbsp;</a></span>RemoveUnusedFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RemoveUnusedFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">runtime::String</a> &gt;&#160;</td>
          <td class="paramname"><em>entry_functions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_functions</td><td>The entry functions used to search the functions that are being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a03b053f3d99d5c420ddc8492e6b987bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b053f3d99d5c420ddc8492e6b987bf">&#9670;&nbsp;</a></span>RewriteAnnotatedOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a42d4de119382b9457742433bc7109ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4de119382b9457742433bc7109ffe">&#9670;&nbsp;</a></span>SimplifyExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the Relay expression. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="add13a2ad7b216ad4683141bbbb4f6943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add13a2ad7b216ad4683141bbbb4f6943">&#9670;&nbsp;</a></span>SimplifyInference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyInference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify certain operators during inference. For example, the result of a batch norm which is indexed at tuple index 0 will be unpacked into a number of simplified operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a2425d757b896168a109498e8d34ba960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2425d757b896168a109498e8d34ba960">&#9670;&nbsp;</a></span>SplitArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SplitArgs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_function_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split function with huge number of arguments to smaller pieces. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8cb03cf00b2ddf25f183ab837cde713c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb03cf00b2ddf25f183ab837cde713c">&#9670;&nbsp;</a></span>ToANormalForm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToANormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF). </p>
<p>It will turn an expression that is in a graph form (with sharing implicit), to an expression with explicit sharing (A-Normal Form).</p>
<p>The scope of the root expression is the global scope.</p>
<p>The scope of any non root expression is the least common ancestor of all it's scope.</p>
<p>Values are ordered by post-DFS order in each scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a256d361d98e061197dd5d9d1d457fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256d361d98e061197dd5d9d1d457fb19">&#9670;&nbsp;</a></span>ToANormalForm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::transform::ToANormalForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ToANormalForm but on incomplete graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed program. </dd></dl>

</div>
</div>
<a id="a6185cc89297d9216551db7a3816d5180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185cc89297d9216551db7a3816d5180">&#9670;&nbsp;</a></span>ToBasicBlockNormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToBasicBlockNormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression to Basic Block Normal Form. </p>
<p>We define a block as a group of expressions implied by the scope structure.</p>
<p>Each graph node can only belong to a single block.</p>
<p>For any value that is being used in multiple blocks, it has to be referred by a <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> which is defined in a block, whose scope is the least common ancestor of blocks this value is used.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ad90e4d6ac08b62ef553755e759d398fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90e4d6ac08b62ef553755e759d398fa">&#9670;&nbsp;</a></span>ToCPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToCPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression into continuation passing style(CPS). </p>
<p>CPS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.</p>
<p>Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).</p>
<p>Similarly, all other compute will be wrapped and call the continuation as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a id="a2cfef0e02cca22f3e0e85e0a10a82f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfef0e02cca22f3e0e85e0a10a82f5b">&#9670;&nbsp;</a></span>ToGraphNormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToGraphNormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let binding and directly share via pointer instead. </p>
<p>It will remove all let binding, and turn all of the variable bound by let into direct pointer reference.</p>
<dl class="section return"><dt>Returns</dt><dd>the expression in graph normal form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
