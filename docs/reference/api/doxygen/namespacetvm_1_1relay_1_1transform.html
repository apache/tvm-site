<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relay::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afa666ade112e9955059095d695238a9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> = <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td></tr>
<tr class="separator:afa666ade112e9955059095d695238a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">PassNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td></tr>
<tr class="separator:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">PassInfo</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td></tr>
<tr class="separator:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">PassInfoNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td></tr>
<tr class="separator:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744a05f8bba3c2ac238ba4569d926184"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a> = <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td></tr>
<tr class="separator:a744a05f8bba3c2ac238ba4569d926184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72900733e0d3510ae61a1c287c2ec125"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">PassContextNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td></tr>
<tr class="separator:a72900733e0d3510ae61a1c287c2ec125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae923037d22b4640b450c06e6c1e33e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">Sequential</a> = <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td></tr>
<tr class="separator:a3ae923037d22b4640b450c06e6c1e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2101aa797e69d398012ef94b63db51da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2101aa797e69d398012ef94b63db51da">CreateFunctionPass</a> (const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;pass_func, int opt_level, <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> name, <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; required)</td></tr>
<tr class="separator:a2101aa797e69d398012ef94b63db51da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441963a144dae58b7633d0a674cf20cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a441963a144dae58b7633d0a674cf20cc">DeadCodeElimination</a> (bool inline_once=false, bool ignore_purity=false)</td></tr>
<tr class="memdesc:a441963a144dae58b7633d0a674cf20cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let-bound expressions which do not effect the program result.  <a href="#a441963a144dae58b7633d0a674cf20cc">More...</a><br /></td></tr>
<tr class="separator:a441963a144dae58b7633d0a674cf20cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e60251741cca1e811564b2f03a4a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab6e60251741cca1e811564b2f03a4a5d">LazyGradientInit</a> ()</td></tr>
<tr class="memdesc:ab6e60251741cca1e811564b2f03a4a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly.  <a href="#ab6e60251741cca1e811564b2f03a4a5d">More...</a><br /></td></tr>
<tr class="separator:ab6e60251741cca1e811564b2f03a4a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6983a69fe1e802a7878279e265de37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a0d6983a69fe1e802a7878279e265de37">FoldConstant</a> (bool fold_qnn=false)</td></tr>
<tr class="memdesc:a0d6983a69fe1e802a7878279e265de37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions.  <a href="#a0d6983a69fe1e802a7878279e265de37">More...</a><br /></td></tr>
<tr class="separator:a0d6983a69fe1e802a7878279e265de37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2425d757b896168a109498e8d34ba960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2425d757b896168a109498e8d34ba960">SplitArgs</a> (int max_function_args)</td></tr>
<tr class="memdesc:a2425d757b896168a109498e8d34ba960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split function with huge number of arguments to smaller pieces.  <a href="#a2425d757b896168a109498e8d34ba960">More...</a><br /></td></tr>
<tr class="separator:a2425d757b896168a109498e8d34ba960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6be6024a96a84f7230faa2519f1a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2a6be6024a96a84f7230faa2519f1a97">FuseOps</a> (int fuse_opt_level=-1)</td></tr>
<tr class="memdesc:a2a6be6024a96a84f7230faa2519f1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse operations into expr into separate functions.  <a href="#a2a6be6024a96a84f7230faa2519f1a97">More...</a><br /></td></tr>
<tr class="separator:a2a6be6024a96a84f7230faa2519f1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a8f3eee7092f7e3e58e1c76f4498e32e7">DefuseOps</a> ()</td></tr>
<tr class="memdesc:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse operation of FuseOps. It transforms a fused program returned by FuseOps into the program before FuseOps. (i.e. x == DefuseOps(FuseOps(x)))  <a href="#a8f3eee7092f7e3e58e1c76f4498e32e7">More...</a><br /></td></tr>
<tr class="separator:a8f3eee7092f7e3e58e1c76f4498e32e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a03b053f3d99d5c420ddc8492e6b987bf">RewriteAnnotatedOps</a> (int fallback_device)</td></tr>
<tr class="memdesc:a03b053f3d99d5c420ddc8492e6b987bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a03b053f3d99d5c420ddc8492e6b987bf">More...</a><br /></td></tr>
<tr class="separator:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185cc89297d9216551db7a3816d5180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6185cc89297d9216551db7a3816d5180">ToBasicBlockNormalForm</a> ()</td></tr>
<tr class="memdesc:a6185cc89297d9216551db7a3816d5180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression to Basic Block Normal Form.  <a href="#a6185cc89297d9216551db7a3816d5180">More...</a><br /></td></tr>
<tr class="separator:a6185cc89297d9216551db7a3816d5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a8cb03cf00b2ddf25f183ab837cde713c">ToANormalForm</a> ()</td></tr>
<tr class="memdesc:a8cb03cf00b2ddf25f183ab837cde713c"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF).  <a href="#a8cb03cf00b2ddf25f183ab837cde713c">More...</a><br /></td></tr>
<tr class="separator:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d361d98e061197dd5d9d1d457fb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a256d361d98e061197dd5d9d1d457fb19">ToANormalForm</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a256d361d98e061197dd5d9d1d457fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">ToANormalForm but on incomplete graph.  <a href="#a256d361d98e061197dd5d9d1d457fb19">More...</a><br /></td></tr>
<tr class="separator:a256d361d98e061197dd5d9d1d457fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e4d6ac08b62ef553755e759d398fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ad90e4d6ac08b62ef553755e759d398fa">ToCPS</a> ()</td></tr>
<tr class="memdesc:ad90e4d6ac08b62ef553755e759d398fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression into continuation passing style(CPS).  <a href="#ad90e4d6ac08b62ef553755e759d398fa">More...</a><br /></td></tr>
<tr class="separator:ad90e4d6ac08b62ef553755e759d398fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2cfef0e02cca22f3e0e85e0a10a82f5b">ToGraphNormalForm</a> ()</td></tr>
<tr class="memdesc:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let binding and directly share via pointer instead.  <a href="#a2cfef0e02cca22f3e0e85e0a10a82f5b">More...</a><br /></td></tr>
<tr class="separator:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa270d98da5518969e005c7e30d6eb6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa270d98da5518969e005c7e30d6eb6fe">PartialEval</a> ()</td></tr>
<tr class="memdesc:aa270d98da5518969e005c7e30d6eb6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressive constant propagation/constant folding/inlining.  <a href="#aa270d98da5518969e005c7e30d6eb6fe">More...</a><br /></td></tr>
<tr class="separator:aa270d98da5518969e005c7e30d6eb6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add13a2ad7b216ad4683141bbbb4f6943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#add13a2ad7b216ad4683141bbbb4f6943">SimplifyInference</a> ()</td></tr>
<tr class="memdesc:add13a2ad7b216ad4683141bbbb4f6943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify certain operators during inference. For example, the result of a batch norm which is indexed at tuple index 0 will be unpacked into a number of simplified operators.  <a href="#add13a2ad7b216ad4683141bbbb4f6943">More...</a><br /></td></tr>
<tr class="separator:add13a2ad7b216ad4683141bbbb4f6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a22870dd16693b2e3edb5fba7cb5dc3e8">FastMath</a> ()</td></tr>
<tr class="memdesc:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces non linear activation functions with their fast but approximate counterparts.  <a href="#a22870dd16693b2e3edb5fba7cb5dc3e8">More...</a><br /></td></tr>
<tr class="separator:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab533a050ab0d54b41e543fb1fd369fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab533a050ab0d54b41e543fb1fd369fb6">DynamicToStatic</a> ()</td></tr>
<tr class="memdesc:ab533a050ab0d54b41e543fb1fd369fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Dynamic ops and make them static.  <a href="#ab533a050ab0d54b41e543fb1fd369fb6">More...</a><br /></td></tr>
<tr class="separator:ab533a050ab0d54b41e543fb1fd369fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a1a4fe2161bf32a60bc2e57debab083ee">InferType</a> ()</td></tr>
<tr class="memdesc:a1a4fe2161bf32a60bc2e57debab083ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="#a1a4fe2161bf32a60bc2e57debab083ee">More...</a><br /></td></tr>
<tr class="separator:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a00e0adf2a7410c4794f8f4f2d4831dc7">InferTypeLocal</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression, reusing existing type information.  <a href="#a00e0adf2a7410c4794f8f4f2d4831dc7">More...</a><br /></td></tr>
<tr class="separator:a00e0adf2a7410c4794f8f4f2d4831dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21ade01969835b155241d277a94d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adf21ade01969835b155241d277a94d1c">EliminateCommonSubexpr</a> (<a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> fskip=nullptr)</td></tr>
<tr class="memdesc:adf21ade01969835b155241d277a94d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable.  <a href="#adf21ade01969835b155241d277a94d1c">More...</a><br /></td></tr>
<tr class="separator:adf21ade01969835b155241d277a94d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3b8f4cbf0bd699d2ca0ab92c534c867d">CombineParallelConv2D</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>.  <a href="#a3b8f4cbf0bd699d2ca0ab92c534c867d">More...</a><br /></td></tr>
<tr class="separator:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61517368427f429e784b4b128cb6351d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a61517368427f429e784b4b128cb6351d">CombineParallelDense</a> (uint64_t min_num_branches=3, bool to_batch_matmul=true)</td></tr>
<tr class="memdesc:a61517368427f429e784b4b128cb6351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>.  <a href="#a61517368427f429e784b4b128cb6351d">More...</a><br /></td></tr>
<tr class="separator:a61517368427f429e784b4b128cb6351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97a0ec61929f58aefff5da83a73e1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa97a0ec61929f58aefff5da83a73e1cd">CombineParallelBatchMatmul</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:aa97a0ec61929f58aefff5da83a73e1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel batch_matmul ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>.  <a href="#aa97a0ec61929f58aefff5da83a73e1cd">More...</a><br /></td></tr>
<tr class="separator:aa97a0ec61929f58aefff5da83a73e1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3bde64d7774dcda7735f73a4e2ebecf7">BackwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward fold axis scaling into weights of conv/dense operators.  <a href="#a3bde64d7774dcda7735f73a4e2ebecf7">More...</a><br /></td></tr>
<tr class="separator:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f62610e05ed0211f17d452ee37f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aab7f62610e05ed0211f17d452ee37f5f">ForwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:aab7f62610e05ed0211f17d452ee37f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward fold axis scaling into weights of conv/dense operators.  <a href="#aab7f62610e05ed0211f17d452ee37f5f">More...</a><br /></td></tr>
<tr class="separator:aab7f62610e05ed0211f17d452ee37f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73946a29efe8cf6f186a681296c8e943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a73946a29efe8cf6f186a681296c8e943">FoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a73946a29efe8cf6f186a681296c8e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes.  <a href="#a73946a29efe8cf6f186a681296c8e943">More...</a><br /></td></tr>
<tr class="separator:a73946a29efe8cf6f186a681296c8e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcddf150ca7da40e20408928421b0086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adcddf150ca7da40e20408928421b0086">CanonicalizeOps</a> ()</td></tr>
<tr class="memdesc:adcddf150ca7da40e20408928421b0086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add.  <a href="#adcddf150ca7da40e20408928421b0086">More...</a><br /></td></tr>
<tr class="separator:adcddf150ca7da40e20408928421b0086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e0426cfa5887f11769a057c09ce8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a64e0426cfa5887f11769a057c09ce8ba">AlterOpLayout</a> ()</td></tr>
<tr class="memdesc:a64e0426cfa5887f11769a057c09ce8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layouts of operators or replace primitive operators with other expressions.  <a href="#a64e0426cfa5887f11769a057c09ce8ba">More...</a><br /></td></tr>
<tr class="separator:a64e0426cfa5887f11769a057c09ce8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a55b337ffaa1ad7a1e2e727329b2c9951">AutoSchedulerLayoutRewrite</a> ()</td></tr>
<tr class="memdesc:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do layout rewrite according to the tile structure created by auto-scheduler.  <a href="#a55b337ffaa1ad7a1e2e727329b2c9951">More...</a><br /></td></tr>
<tr class="separator:a55b337ffaa1ad7a1e2e727329b2c9951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ad9422e60b1e2c7b211dfd3209959f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab6ad9422e60b1e2c7b211dfd3209959f">MetaScheduleLayoutRewrite</a> ()</td></tr>
<tr class="memdesc:ab6ad9422e60b1e2c7b211dfd3209959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do layout rewrite according to the tile structure created by meta-schedule.  <a href="#ab6ad9422e60b1e2c7b211dfd3209959f">More...</a><br /></td></tr>
<tr class="separator:ab6ad9422e60b1e2c7b211dfd3209959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b49e82dd73b05bfac14040ee2fbdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a40b49e82dd73b05bfac14040ee2fbdee">ConvertLayout</a> (const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; &amp;desired_layouts)</td></tr>
<tr class="memdesc:a40b49e82dd73b05bfac14040ee2fbdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end.  <a href="#a40b49e82dd73b05bfac14040ee2fbdee">More...</a><br /></td></tr>
<tr class="separator:a40b49e82dd73b05bfac14040ee2fbdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae623a28eda64b60c6ee90edde103891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae623a28eda64b60c6ee90edde103891">Legalize</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;legalize_map_attr_name=&quot;FTVMLegalize&quot;)</td></tr>
<tr class="memdesc:aae623a28eda64b60c6ee90edde103891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalizes an expr with another expression.  <a href="#aae623a28eda64b60c6ee90edde103891">More...</a><br /></td></tr>
<tr class="separator:aae623a28eda64b60c6ee90edde103891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a93bbf7ab3f612d4f38a6832d6b53b4fd">CanonicalizeCast</a> ()</td></tr>
<tr class="memdesc:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize cast expressions to make operator fusion more efficient.  <a href="#a93bbf7ab3f612d4f38a6832d6b53b4fd">More...</a><br /></td></tr>
<tr class="separator:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e515696ecc9ff4222af99fef361de4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6e515696ecc9ff4222af99fef361de4e">EtaExpand</a> (bool expand_constructor, bool expand_global_var)</td></tr>
<tr class="memdesc:a6e515696ecc9ff4222af99fef361de4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add abstraction over a constructor or global variable bound to a function.  <a href="#a6e515696ecc9ff4222af99fef361de4e">More...</a><br /></td></tr>
<tr class="separator:a6e515696ecc9ff4222af99fef361de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0bfdaf6d09b360602243c81abe05a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aac0bfdaf6d09b360602243c81abe05a1">PartitionGraph</a> ()</td></tr>
<tr class="memdesc:aac0bfdaf6d09b360602243c81abe05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a Relay program into regions that can be executed on different backends.  <a href="#aac0bfdaf6d09b360602243c81abe05a1">More...</a><br /></td></tr>
<tr class="separator:aac0bfdaf6d09b360602243c81abe05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5e588279a3b19a119c9aa28c364bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aba5e588279a3b19a119c9aa28c364bbe">Inline</a> ()</td></tr>
<tr class="memdesc:aba5e588279a3b19a119c9aa28c364bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#aba5e588279a3b19a119c9aa28c364bbe">More...</a><br /></td></tr>
<tr class="separator:aba5e588279a3b19a119c9aa28c364bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afbbf5f3e5ffb775fafb9c48473dbfa24">RemoveUnusedFunctions</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">runtime::String</a> &gt; entry_functions)</td></tr>
<tr class="memdesc:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#afbbf5f3e5ffb775fafb9c48473dbfa24">More...</a><br /></td></tr>
<tr class="separator:afbbf5f3e5ffb775fafb9c48473dbfa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4de119382b9457742433bc7109ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a42d4de119382b9457742433bc7109ffe">SimplifyExpr</a> ()</td></tr>
<tr class="memdesc:a42d4de119382b9457742433bc7109ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the Relay expression.  <a href="#a42d4de119382b9457742433bc7109ffe">More...</a><br /></td></tr>
<tr class="separator:a42d4de119382b9457742433bc7109ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d53204853b9d77afcda3d83756a11aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a5d53204853b9d77afcda3d83756a11aa">SimplifyExprPostAlterOp</a> ()</td></tr>
<tr class="memdesc:a5d53204853b9d77afcda3d83756a11aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stripped down version of SimplifyExpr which is run after AlterOpLayout.  <a href="#a5d53204853b9d77afcda3d83756a11aa">More...</a><br /></td></tr>
<tr class="separator:a5d53204853b9d77afcda3d83756a11aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153ef0a87fd83343b4855b78e376bd66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a153ef0a87fd83343b4855b78e376bd66">RelayToTIRTargetHook</a> (<a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a> config)</td></tr>
<tr class="memdesc:a153ef0a87fd83343b4855b78e376bd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run any custom passes registered under "RelayToTIR" attributes on TargetKinds.  <a href="#a153ef0a87fd83343b4855b78e376bd66">More...</a><br /></td></tr>
<tr class="separator:a153ef0a87fd83343b4855b78e376bd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473c64deec00aaf5636cc12f844b1e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a473c64deec00aaf5636cc12f844b1e42">ManifestAlloc</a> (<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> cpu_virtual_device)</td></tr>
<tr class="memdesc:a473c64deec00aaf5636cc12f844b1e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass for manifesting explicit memory allocations and rewriting specific dialects.  <a href="#a473c64deec00aaf5636cc12f844b1e42">More...</a><br /></td></tr>
<tr class="separator:a473c64deec00aaf5636cc12f844b1e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a0a8228f5fdbc269477d7456aadcc7c3d">ManifestLifetimes</a> ()</td></tr>
<tr class="memdesc:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass for manifesting variable lifetimes by inserting kill operations when variables become dead. This pass should be run after ManifestAlloc, and should not be run more than once.  <a href="#a0a8228f5fdbc269477d7456aadcc7c3d">More...</a><br /></td></tr>
<tr class="separator:a0a8228f5fdbc269477d7456aadcc7c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176ece3eac49470d18b174cfa196e0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a176ece3eac49470d18b174cfa196e0f0">PlanDevices</a> (<a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a> config)</td></tr>
<tr class="memdesc:a176ece3eac49470d18b174cfa196e0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses existing "on_device" and "device_copy" CallNodes to infer the <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> on which every Relay sub-expression should run and the result stored. Captures the result of that analysis using new "on_device" and "device_copy" CallNodes.  <a href="#a176ece3eac49470d18b174cfa196e0f0">More...</a><br /></td></tr>
<tr class="separator:a176ece3eac49470d18b174cfa196e0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af719f05ee653ea465589a38747b35e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#af719f05ee653ea465589a38747b35e22">FlattenAtrousConv</a> ()</td></tr>
<tr class="memdesc:af719f05ee653ea465589a38747b35e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform flattens atrous convolution, which corresponds to the sequence of operations: "space_to_batch_nd"-&gt;"conv2d"-&gt;"batch_to_space_nd" and convert them into subgraphs with a convolution with the modified "dilation" and recalculated "padding" parameters.  <a href="#af719f05ee653ea465589a38747b35e22">More...</a><br /></td></tr>
<tr class="separator:af719f05ee653ea465589a38747b35e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adb5ecf3c0fbe3c91d37e90795d91de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6adb5ecf3c0fbe3c91d37e90795d91de">AnnotateUsedMemory</a> ()</td></tr>
<tr class="memdesc:a6adb5ecf3c0fbe3c91d37e90795d91de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates the minimum required memory of each primitive function callsite by analyzing the liveness of the input/output tensors at each function callsite and calculating the total amount of memory these tensors require. This is added as a "used_memory" annotation to the function in question as a list of the number of bytes for each callsite. In addition, the containing function is annotated with an "io_used_memory" annotation which refers to the total memory required for the IO tensors.  <a href="#a6adb5ecf3c0fbe3c91d37e90795d91de">More...</a><br /></td></tr>
<tr class="separator:a6adb5ecf3c0fbe3c91d37e90795d91de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d850ee9bfb41de42cf3a2bb25586528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a0d850ee9bfb41de42cf3a2bb25586528">CapturePostDfsIndexInSpans</a> ()</td></tr>
<tr class="memdesc:a0d850ee9bfb41de42cf3a2bb25586528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures the post-dfs index and dominator post-dfs index of (most) expression nodes in their span, in the form "index:&lt;post-dfs index&gt;:&lt;dominator post-dfs index&gt;". This is useful for debugging since a) it helps identify pretty-printed sub-expressions within the overall model and b) the indexes are heavily used by Collage for its compact representation of sub-graphs.  <a href="#a0d850ee9bfb41de42cf3a2bb25586528">More...</a><br /></td></tr>
<tr class="separator:a0d850ee9bfb41de42cf3a2bb25586528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971fc90bf1386bbbfc5466b4618746cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a971fc90bf1386bbbfc5466b4618746cb">AnnotateMemoryScope</a> ()</td></tr>
<tr class="memdesc:a971fc90bf1386bbbfc5466b4618746cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls device dependent memory scope analysis pass, collects mapping of desirable expr-&gt;memory_scope and annotates expressions by <a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a> with required memory_scope.  <a href="#a971fc90bf1386bbbfc5466b4618746cb">More...</a><br /></td></tr>
<tr class="separator:a971fc90bf1386bbbfc5466b4618746cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8753e6152a3ce13488eea22827cac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#abf8753e6152a3ce13488eea22827cac9">RemoveStandaloneReshapes</a> ()</td></tr>
<tr class="memdesc:abf8753e6152a3ce13488eea22827cac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes non-fused reshapes after lowering the graph. <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a1a4fe2161bf32a60bc2e57debab083ee" title="Infer the type of an expression. ">InferType()</a> cannot be invoked after calling this pass as it removes reshapes from the call graph. Many targets only need buffer addresses irrespective of the shapes of them. This makes reshapes symbolic once the graph has been lowered. Reshape removal results into smaller code size and reduced buffer allocations. It opens up opportunities of operator fusion in the target backend. Thus, consequently, it improves the performance of the inference.  <a href="#abf8753e6152a3ce13488eea22827cac9">More...</a><br /></td></tr>
<tr class="separator:abf8753e6152a3ce13488eea22827cac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afa666ade112e9955059095d695238a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa666ade112e9955059095d695238a9a">&#9670;&nbsp;</a></span>Pass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">tvm::relay::transform::Pass</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a744a05f8bba3c2ac238ba4569d926184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744a05f8bba3c2ac238ba4569d926184">&#9670;&nbsp;</a></span>PassContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">tvm::relay::transform::PassContext</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72900733e0d3510ae61a1c287c2ec125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72900733e0d3510ae61a1c287c2ec125">&#9670;&nbsp;</a></span>PassContextNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">tvm::relay::transform::PassContextNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa405b5f11938fb8c4fa2ca21926edc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa405b5f11938fb8c4fa2ca21926edc9d">&#9670;&nbsp;</a></span>PassInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">tvm::relay::transform::PassInfo</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae88cd0ad69cf64c7e9caf0a0c8ebb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88cd0ad69cf64c7e9caf0a0c8ebb45">&#9670;&nbsp;</a></span>PassInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">tvm::relay::transform::PassInfoNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa695a8dfc3d5b087018ddd4ef1eb2487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa695a8dfc3d5b087018ddd4ef1eb2487">&#9670;&nbsp;</a></span>PassNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">tvm::relay::transform::PassNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae923037d22b4640b450c06e6c1e33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae923037d22b4640b450c06e6c1e33e">&#9670;&nbsp;</a></span>Sequential</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">tvm::relay::transform::Sequential</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a64e0426cfa5887f11769a057c09ce8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e0426cfa5887f11769a057c09ce8ba">&#9670;&nbsp;</a></span>AlterOpLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AlterOpLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layouts of operators or replace primitive operators with other expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a971fc90bf1386bbbfc5466b4618746cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971fc90bf1386bbbfc5466b4618746cb">&#9670;&nbsp;</a></span>AnnotateMemoryScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AnnotateMemoryScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls device dependent memory scope analysis pass, collects mapping of desirable expr-&gt;memory_scope and annotates expressions by <a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a> with required memory_scope. </p>

</div>
</div>
<a id="a6adb5ecf3c0fbe3c91d37e90795d91de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adb5ecf3c0fbe3c91d37e90795d91de">&#9670;&nbsp;</a></span>AnnotateUsedMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AnnotateUsedMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotates the minimum required memory of each primitive function callsite by analyzing the liveness of the input/output tensors at each function callsite and calculating the total amount of memory these tensors require. This is added as a "used_memory" annotation to the function in question as a list of the number of bytes for each callsite. In addition, the containing function is annotated with an "io_used_memory" annotation which refers to the total memory required for the IO tensors. </p>
<p>Note: This pass does not support dynamic shapes, it is the users responsibility to check this pass isn't applied where dynamic shapes may be input. </p>

</div>
</div>
<a id="a55b337ffaa1ad7a1e2e727329b2c9951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b337ffaa1ad7a1e2e727329b2c9951">&#9670;&nbsp;</a></span>AutoSchedulerLayoutRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AutoSchedulerLayoutRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do layout rewrite according to the tile structure created by auto-scheduler. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass </dd></dl>

</div>
</div>
<a id="a3bde64d7774dcda7735f73a4e2ebecf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde64d7774dcda7735f73a4e2ebecf7">&#9670;&nbsp;</a></span>BackwardFoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::BackwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a93bbf7ab3f612d4f38a6832d6b53b4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bbf7ab3f612d4f38a6832d6b53b4fd">&#9670;&nbsp;</a></span>CanonicalizeCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize cast expressions to make operator fusion more efficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="adcddf150ca7da40e20408928421b0086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcddf150ca7da40e20408928421b0086">&#9670;&nbsp;</a></span>CanonicalizeOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0d850ee9bfb41de42cf3a2bb25586528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d850ee9bfb41de42cf3a2bb25586528">&#9670;&nbsp;</a></span>CapturePostDfsIndexInSpans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CapturePostDfsIndexInSpans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Captures the post-dfs index and dominator post-dfs index of (most) expression nodes in their span, in the form "index:&lt;post-dfs index&gt;:&lt;dominator post-dfs index&gt;". This is useful for debugging since a) it helps identify pretty-printed sub-expressions within the overall model and b) the indexes are heavily used by Collage for its compact representation of sub-graphs. </p>
<p>Note that <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> and <a class="el" href="classtvm_1_1Constructor.html" title="Managed reference to ConstructorNode. ">Constructor</a> nodes are not changed even though they are assigned an post-dfs index. </p>

</div>
</div>
<a id="aa97a0ec61929f58aefff5da83a73e1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97a0ec61929f58aefff5da83a73e1cd">&#9670;&nbsp;</a></span>CombineParallelBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelBatchMatmul </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel batch_matmul ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a3b8f4cbf0bd699d2ca0ab92c534c867d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f4cbf0bd699d2ca0ab92c534c867d">&#9670;&nbsp;</a></span>CombineParallelConv2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelConv2D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a61517368427f429e784b4b128cb6351d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61517368427f429e784b4b128cb6351d">&#9670;&nbsp;</a></span>CombineParallelDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelDense </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_batch_matmul</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches. </td></tr>
    <tr><td class="paramname">to_batch_matmul</td><td>Whether to combine parallel dense ops to batch matmul. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> set false, combine dense ops to single dense op.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a40b49e82dd73b05bfac14040ee2fbdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b49e82dd73b05bfac14040ee2fbdee">&#9670;&nbsp;</a></span>ConvertLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ConvertLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>desired_layouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end. </p>
<p>This pass is not a part of relay.build and is expected to be called between framework-relay parser and relay.build call. This is very helpful for hardware backends that support/prefer only type of data layout.</p>
<p>RFC - <a href="https://discuss.tvm.ai/t/layout-conversion-pass/4009">https://discuss.tvm.ai/t/layout-conversion-pass/4009</a></p>
<p>This pass uses most of the AlterOpLayout and InferCorrectLayout infrastructure. We can define new layouts for conv2d ops for now. Most of the other operators try to adapt to their input layout using the InferCorrectLayout infrastructure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_layouts</td><td>Specify mapping of op_name to array of desired layouts for each input. For example: Map("nn.conv2d", Array("NHWC", "OHWI")), this specifies the desired layout for data then kernel for nn.conv2d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a2101aa797e69d398012ef94b63db51da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2101aa797e69d398012ef94b63db51da">&#9670;&nbsp;</a></span>CreateFunctionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CreateFunctionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a441963a144dae58b7633d0a674cf20cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441963a144dae58b7633d0a674cf20cc">&#9670;&nbsp;</a></span>DeadCodeElimination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DeadCodeElimination </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inline_once</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_purity</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let-bound expressions which do not effect the program result. </p>
<p>This pass will remove let bindings which are not referenced. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> inline_once is True, let bindings which are only referenced once will also be inlined.</p>
<p>For example, this pass should turn <code>let a = 1; 2</code> into <code>2</code>, as the value of the expression does not depend on a.</p>
<p>As another example, <code>let a = 1; a</code> will be optimized into 1 if inline_once is True.</p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> ignore_purity is False, possibly side-effecting expressions (such as memory allocation, random number generation, reading/writing references, or calls to primitive or external functions) are never elided or inlined. This is sound, but ignore_purity can be set to True to suppress this check.</p>
<p>The analysis is fairly conservative, for example it assumes all local functions may be called more than once, any functions passed as arguments have side effects, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inline_once</td><td>whether or not to inline bindings used exactly once. </td></tr>
    <tr><td class="paramname">ignore_purity</td><td>whether to ignore whether expressions have side-effects</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a id="a8f3eee7092f7e3e58e1c76f4498e32e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3eee7092f7e3e58e1c76f4498e32e7">&#9670;&nbsp;</a></span>DefuseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DefuseOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inverse operation of FuseOps. It transforms a fused program returned by FuseOps into the program before FuseOps. (i.e. x == DefuseOps(FuseOps(x))) </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab533a050ab0d54b41e543fb1fd369fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab533a050ab0d54b41e543fb1fd369fb6">&#9670;&nbsp;</a></span>DynamicToStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DynamicToStatic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Dynamic ops and make them static. </p>
<p>Searches the graph for dynamic ops. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the dynamic inputs to those ops are constants, it replaces them with static ops and re-performs type inference and constant folding. The pass repeats itself until the graph stops changing or we run too many iterations.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="adf21ade01969835b155241d277a94d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf21ade01969835b155241d277a94d1c">&#9670;&nbsp;</a></span>EliminateCommonSubexpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EliminateCommonSubexpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a>&#160;</td>
          <td class="paramname"><em>fskip</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fskip</td><td>The callback argument that allows to skip certain expressions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a6e515696ecc9ff4222af99fef361de4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e515696ecc9ff4222af99fef361de4e">&#9670;&nbsp;</a></span>EtaExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EtaExpand </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_global_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add abstraction over a constructor or global variable bound to a function. </p>
<p>For example: <code>square</code> is transformed to <code>fn (x: int32) -&gt; int32 { square(x) }</code>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion">https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expand_constructor</td><td>Whether to expand constructors. </td></tr>
    <tr><td class="paramname">expand_global_var</td><td>Whether to expand global variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a22870dd16693b2e3edb5fba7cb5dc3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22870dd16693b2e3edb5fba7cb5dc3e8">&#9670;&nbsp;</a></span>FastMath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FastMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces non linear activation functions with their fast but approximate counterparts. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="af719f05ee653ea465589a38747b35e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af719f05ee653ea465589a38747b35e22">&#9670;&nbsp;</a></span>FlattenAtrousConv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FlattenAtrousConv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform flattens atrous convolution, which corresponds to the sequence of operations: "space_to_batch_nd"-&gt;"conv2d"-&gt;"batch_to_space_nd" and convert them into subgraphs with a convolution with the modified "dilation" and recalculated "padding" parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0d6983a69fe1e802a7878279e265de37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6983a69fe1e802a7878279e265de37">&#9670;&nbsp;</a></span>FoldConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldConstant </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fold_qnn</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold constant expressions. </p>
<p>Because of backward compatibility reason it skips QNN primitives from folding by default. There are some transformation passes like FakeQuantizationToInteger, which requires to keep QNN primitives for constant subgraphs. Uncontrolled constant folding of QNN primitives may break applicability of FakeQuantizationToInteger. We suggest to use FoldConstant pass with none default fold_qnn=True value only when all other QNN sensitive passes were already applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold_qnn</td><td>Whether to fold constants for QNN operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a73946a29efe8cf6f186a681296c8e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73946a29efe8cf6f186a681296c8e943">&#9670;&nbsp;</a></span>FoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="aab7f62610e05ed0211f17d452ee37f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7f62610e05ed0211f17d452ee37f5f">&#9670;&nbsp;</a></span>ForwardFoldScaleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ForwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a2a6be6024a96a84f7230faa2519f1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6be6024a96a84f7230faa2519f1a97">&#9670;&nbsp;</a></span>FuseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FuseOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuse_opt_level</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse operations into expr into separate functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse_opt_level</td><td>Optimization level. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> it is -1 it will be inferred from pass context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a1a4fe2161bf32a60bc2e57debab083ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4fe2161bf32a60bc2e57debab083ee">&#9670;&nbsp;</a></span>InferType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::InferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression. </p>
<p>The result of type checking is a new expression with unambiguous type information filled in, as well as it's checked type field populated with the result type.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a00e0adf2a7410c4794f8f4f2d4831dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e0adf2a7410c4794f8f4f2d4831dc7">&#9670;&nbsp;</a></span>InferTypeLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> tvm::relay::transform::InferTypeLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression, reusing existing type information. </p>
<p>The result of type checking is a new expression with unambiguous type information filled in for the given node only. The local version can use existing type information populated throughout the expression and assumes this information is correct. The local version also avoids examining large amounts of the graph assuming type information is filled in properly which makes it much faster if we iteratively call type inference.</p>
<dl class="section return"><dt>Returns</dt><dd>The type of the expression. </dd></dl>

</div>
</div>
<a id="aba5e588279a3b19a119c9aa28c364bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5e588279a3b19a119c9aa28c364bbe">&#9670;&nbsp;</a></span>Inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Inline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab6e60251741cca1e811564b2f03a4a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e60251741cca1e811564b2f03a4a5d">&#9670;&nbsp;</a></span>LazyGradientInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::LazyGradientInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly. </p>
<p>This will delay or decrease memory usage. All calls to ones, ones_like, zeros, zeros_like will not immediately instantiate a tensor in memory, rather only instantiate if needed. It also defines + and * operation between GradCell types which can increase performance when using zero-filled or one-filled tensors, which is the case in reverse mode ad.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass </dd></dl>

</div>
</div>
<a id="aae623a28eda64b60c6ee90edde103891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae623a28eda64b60c6ee90edde103891">&#9670;&nbsp;</a></span>Legalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Legalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>legalize_map_attr_name</em> = <code>&quot;FTVMLegalize&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalizes an expr with another expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">legalize_map_attr_name</td><td>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>'s attr name which corresponds to the legalize rule function. One can collect and isolate similar type of legalize transformations using this param. For example, transformations that only apply to Dialects can be isolated into a FTVMDialectLegalize string. This pass calls only those transformations that have been registered using the supplied legalize_map_attr_name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a473c64deec00aaf5636cc12f844b1e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473c64deec00aaf5636cc12f844b1e42">&#9670;&nbsp;</a></span>ManifestAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ManifestAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;</td>
          <td class="paramname"><em>cpu_virtual_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pass for manifesting explicit memory allocations and rewriting specific dialects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_virtual_device</td><td><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a> for computations and data which must reside on a CPU, such as shapes and shape functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a0a8228f5fdbc269477d7456aadcc7c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8228f5fdbc269477d7456aadcc7c3d">&#9670;&nbsp;</a></span>ManifestLifetimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ManifestLifetimes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pass for manifesting variable lifetimes by inserting kill operations when variables become dead. This pass should be run after ManifestAlloc, and should not be run more than once. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ab6ad9422e60b1e2c7b211dfd3209959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ad9422e60b1e2c7b211dfd3209959f">&#9670;&nbsp;</a></span>MetaScheduleLayoutRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::MetaScheduleLayoutRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do layout rewrite according to the tile structure created by meta-schedule. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass </dd></dl>

</div>
</div>
<a id="aa270d98da5518969e005c7e30d6eb6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa270d98da5518969e005c7e30d6eb6fe">&#9670;&nbsp;</a></span>PartialEval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartialEval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggressive constant propagation/constant folding/inlining. </p>
<p>It will do as much computation in compile time as possible. It has two benefit: remove runtime overhead, and allow more optimization (typically fusion). As a side effect, code size will explode.</p>
<dl class="section return"><dt>Returns</dt><dd>the optimized expression. </dd></dl>

</div>
</div>
<a id="aac0bfdaf6d09b360602243c81abe05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0bfdaf6d09b360602243c81abe05a1">&#9670;&nbsp;</a></span>PartitionGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartitionGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a Relay program into regions that can be executed on different backends. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a176ece3eac49470d18b174cfa196e0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176ece3eac49470d18b174cfa196e0f0">&#9670;&nbsp;</a></span>PlanDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PlanDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a>&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses existing "on_device" and "device_copy" CallNodes to infer the <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> on which every Relay sub-expression should run and the result stored. Captures the result of that analysis using new "on_device" and "device_copy" CallNodes. </p>
<p>See <a class="el" href="namespacetvm_1_1relay_1_1transform.html">tvm::relay::transform</a>::{LexicalOnDeviceMixin,DeviceAwareExprVisitor,DeviceAwareExprMutator} for help recovering the device for an arbitrary sub-expression in downstream transformations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Describes the targets and default <code><a class="el" href="classtvm_1_1VirtualDevice.html" title="Managed reference class to VirtualDeviceNode. ">VirtualDevice</a></code> for all primitive operators and host sub-expressions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a153ef0a87fd83343b4855b78e376bd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153ef0a87fd83343b4855b78e376bd66">&#9670;&nbsp;</a></span>RelayToTIRTargetHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RelayToTIRTargetHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1CompilationConfig.html">CompilationConfig</a>&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run any custom passes registered under "RelayToTIR" attributes on TargetKinds. </p>
<p>This pass looks for inline, let-bound or global functions which have a "Compiler" attribute. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the attribute value corresponds to a <a class="el" href="classtvm_1_1TargetKind.html" title="Managed reference class to TargetKindNode. ">TargetKind</a> with a "RelayToTIR" attribute, then the 'custom' pass bound to that attribute is run (at most once) on the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> as a whole.</p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a>, in addition, the <code>config</code> has a <a class="el" href="classtvm_1_1Target.html" title="Managed reference class to TargetNode. ">Target</a> with a matching <a class="el" href="classtvm_1_1TargetKind.html" title="Managed reference class to TargetKindNode. ">TargetKind</a>, that <a class="el" href="classtvm_1_1Target.html" title="Managed reference class to TargetNode. ">Target</a> is set as the 'current' target before the custom pass is executed. In this way it is possible for custom passes to pick up target options which may guide how they transform the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. (Those targets are referred to as 'extern codegen targets' elsewhere).</p>
<p>A typical custom pass will:</p><ul>
<li>Find calls to "Compiler" attributes functions with matching compiler name.</li>
<li>Lower those function to TIR PrimFuncs.</li>
<li>Bind those functions into the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> under the the functions' "global_symbol" attribute.</li>
<li>Replace all calls to those functions with 'call_lowered' to the matching global. Care should be taken to handle multiple calls to the same function. See src/relay/backend/contrib/example_target_hooks/relay_to_tir.cc for an example custom pass.</li>
</ul>
<p>It is also possible (despite the pass and attribute names!) for the custom pass to proceed directly to a <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM. ">runtime::Module</a>, which can be attached to the output IRModules "external_mods" attribute (taking care not to clobber any existing modules). In this case the flow is as above, except:</p><ul>
<li>The <a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM. ">runtime::Module</a> must contain a binding for each compiled function under their "global_symbol" (ie runtime::Module::ImplementsFunction should return true).</li>
<li>A Relay <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> must be bound (or re-bound) into the result <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>, again with the same "global_symbol", but with only the "Extern" attribute set to Integer(1). The function body should be the original function body. In this way we always have a TVM definition matching every global function name.</li>
</ul>
<p>There are many existing runtime::Modules, ranging from source to object to dynamic libaries to entirely custom implementations. Some of those may require additional compilation using 'export_library' on the final build artifact.</p>
<p>The OutlineCompilerFunctionsWithExistingGlobalSymbols and MarkCompilerFunctionsAsExtern utility passes can be used by custom passes to take care of some of the boilerplate.</p>
<p>TODO(mbs): Rename PreLoweringTargetHooks?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>All available targets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="abf8753e6152a3ce13488eea22827cac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8753e6152a3ce13488eea22827cac9">&#9670;&nbsp;</a></span>RemoveStandaloneReshapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RemoveStandaloneReshapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes non-fused reshapes after lowering the graph. <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a1a4fe2161bf32a60bc2e57debab083ee" title="Infer the type of an expression. ">InferType()</a> cannot be invoked after calling this pass as it removes reshapes from the call graph. Many targets only need buffer addresses irrespective of the shapes of them. This makes reshapes symbolic once the graph has been lowered. Reshape removal results into smaller code size and reduced buffer allocations. It opens up opportunities of operator fusion in the target backend. Thus, consequently, it improves the performance of the inference. </p>

</div>
</div>
<a id="afbbf5f3e5ffb775fafb9c48473dbfa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf5f3e5ffb775fafb9c48473dbfa24">&#9670;&nbsp;</a></span>RemoveUnusedFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RemoveUnusedFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">runtime::String</a> &gt;&#160;</td>
          <td class="paramname"><em>entry_functions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_functions</td><td>The entry functions used to search the functions that are being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a03b053f3d99d5c420ddc8492e6b987bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b053f3d99d5c420ddc8492e6b987bf">&#9670;&nbsp;</a></span>RewriteAnnotatedOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a42d4de119382b9457742433bc7109ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4de119382b9457742433bc7109ffe">&#9670;&nbsp;</a></span>SimplifyExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the Relay expression. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a5d53204853b9d77afcda3d83756a11aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d53204853b9d77afcda3d83756a11aa">&#9670;&nbsp;</a></span>SimplifyExprPostAlterOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyExprPostAlterOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stripped down version of SimplifyExpr which is run after AlterOpLayout. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="add13a2ad7b216ad4683141bbbb4f6943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add13a2ad7b216ad4683141bbbb4f6943">&#9670;&nbsp;</a></span>SimplifyInference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyInference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify certain operators during inference. For example, the result of a batch norm which is indexed at tuple index 0 will be unpacked into a number of simplified operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a2425d757b896168a109498e8d34ba960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2425d757b896168a109498e8d34ba960">&#9670;&nbsp;</a></span>SplitArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SplitArgs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_function_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split function with huge number of arguments to smaller pieces. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a8cb03cf00b2ddf25f183ab837cde713c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb03cf00b2ddf25f183ab837cde713c">&#9670;&nbsp;</a></span>ToANormalForm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToANormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF). </p>
<p>It will turn an expression that is in a graph form (with sharing implicit), to an expression with explicit sharing (A-Normal Form).</p>
<p>The scope of the root expression is the global scope.</p>
<p>The scope of any non root expression is the least common ancestor of all it's scope.</p>
<p>Values are ordered by post-DFS order in each scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a256d361d98e061197dd5d9d1d457fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256d361d98e061197dd5d9d1d457fb19">&#9670;&nbsp;</a></span>ToANormalForm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::transform::ToANormalForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ToANormalForm but on incomplete graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed program. </dd></dl>

</div>
</div>
<a id="a6185cc89297d9216551db7a3816d5180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185cc89297d9216551db7a3816d5180">&#9670;&nbsp;</a></span>ToBasicBlockNormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToBasicBlockNormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression to Basic Block Normal Form. </p>
<p>We define a block as a group of expressions implied by the scope structure.</p>
<p>Each graph node can only belong to a single block.</p>
<p>For any value that is being used in multiple blocks, it has to be referred by a <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> which is defined in a block, whose scope is the least common ancestor of blocks this value is used.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="ad90e4d6ac08b62ef553755e759d398fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90e4d6ac08b62ef553755e759d398fa">&#9670;&nbsp;</a></span>ToCPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToCPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression into continuation passing style(CPS). </p>
<p>CPS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.</p>
<p>Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).</p>
<p>Similarly, all other compute will be wrapped and call the continuation as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a id="a2cfef0e02cca22f3e0e85e0a10a82f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfef0e02cca22f3e0e85e0a10a82f5b">&#9670;&nbsp;</a></span>ToGraphNormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToGraphNormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let binding and directly share via pointer instead. </p>
<p>It will remove all let binding, and turn all of the variable bound by let into direct pointer reference.</p>
<dl class="section return"><dt>Returns</dt><dd>the expression in graph normal form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
