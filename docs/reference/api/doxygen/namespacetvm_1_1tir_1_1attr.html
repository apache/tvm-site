<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::tir::attr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir::attr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a385e883a7cecc309d063786e5fdf2c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a385e883a7cecc309d063786e5fdf2c4b">IsPragmaKey</a> (const std::string &amp;attr_key)</td></tr>
<tr class="memdesc:a385e883a7cecc309d063786e5fdf2c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if attr_key is a pragma key extension.  <a href="#a385e883a7cecc309d063786e5fdf2c4b">More...</a><br /></td></tr>
<tr class="separator:a385e883a7cecc309d063786e5fdf2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4933845b75cf4f08fb66f55fdd94986f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4933845b75cf4f08fb66f55fdd94986f">kDeviceThreadAxis</a> = &quot;tir.device_thread_axis&quot;</td></tr>
<tr class="memdesc:a4933845b75cf4f08fb66f55fdd94986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to.  <a href="#a4933845b75cf4f08fb66f55fdd94986f">More...</a><br /></td></tr>
<tr class="separator:a4933845b75cf4f08fb66f55fdd94986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a6644dc9ce51ba96b0364f7f891dcad9a">kDeviceUseDynSharedMemory</a> = &quot;tir.device_use_dyn_shared_memory&quot;</td></tr>
<tr class="memdesc:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not use dynamic shared memory.  <a href="#a6644dc9ce51ba96b0364f7f891dcad9a">More...</a><br /></td></tr>
<tr class="separator:a6644dc9ce51ba96b0364f7f891dcad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac74386674da85bc4b4dd1ee28a97ff63">kNoAlias</a> = &quot;tir.noalias&quot;</td></tr>
<tr class="memdesc:ac74386674da85bc4b4dd1ee28a97ff63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to set noalias rule on the function arguments.  <a href="#ac74386674da85bc4b4dd1ee28a97ff63">More...</a><br /></td></tr>
<tr class="separator:ac74386674da85bc4b4dd1ee28a97ff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a489d0cebd2820025bc3d6c5a9011cdd4">kIsEntryFunc</a> = &quot;tir.is_entry_func&quot;</td></tr>
<tr class="memdesc:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the function as the entry function of the final generated runtime module.  <a href="#a489d0cebd2820025bc3d6c5a9011cdd4">More...</a><br /></td></tr>
<tr class="separator:a489d0cebd2820025bc3d6c5a9011cdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166c6d41ff1816ab01e398be07bac20"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a3166c6d41ff1816ab01e398be07bac20">kIsGlobalFunc</a> = &quot;tir.is_global_func&quot;</td></tr>
<tr class="memdesc:a3166c6d41ff1816ab01e398be07bac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the function as the global function called from the host.  <a href="#a3166c6d41ff1816ab01e398be07bac20">More...</a><br /></td></tr>
<tr class="separator:a3166c6d41ff1816ab01e398be07bac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91a41e0c0292462e91affae45b12db5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ab91a41e0c0292462e91affae45b12db5">kIsHostFunc</a> = &quot;tir.is_host_func&quot;</td></tr>
<tr class="memdesc:ab91a41e0c0292462e91affae45b12db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the function as run on the host, mutually exclusive with kTarget.  <a href="#ab91a41e0c0292462e91affae45b12db5">More...</a><br /></td></tr>
<tr class="separator:ab91a41e0c0292462e91affae45b12db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399eed804ecc482a607f0f65f07b78dd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a399eed804ecc482a607f0f65f07b78dd">thread_extent</a> = &quot;thread_extent&quot;</td></tr>
<tr class="memdesc:a399eed804ecc482a607f0f65f07b78dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching extent of thread, used by device API.  <a href="#a399eed804ecc482a607f0f65f07b78dd">More...</a><br /></td></tr>
<tr class="separator:a399eed804ecc482a607f0f65f07b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464533c1560ace5e0b5071ba6902482e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a464533c1560ace5e0b5071ba6902482e">virtual_thread</a> = &quot;virtual_thread&quot;</td></tr>
<tr class="memdesc:a464533c1560ace5e0b5071ba6902482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching of a virtual thread.  <a href="#a464533c1560ace5e0b5071ba6902482e">More...</a><br /></td></tr>
<tr class="separator:a464533c1560ace5e0b5071ba6902482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a341bfebe5448f290aa54b0f84cac"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac62a341bfebe5448f290aa54b0f84cac">coproc_scope</a> = &quot;coproc_scope&quot;</td></tr>
<tr class="memdesc:ac62a341bfebe5448f290aa54b0f84cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is processed by a co-proccesor.  <a href="#ac62a341bfebe5448f290aa54b0f84cac">More...</a><br /></td></tr>
<tr class="separator:ac62a341bfebe5448f290aa54b0f84cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d3379e8d6486e79853e254ea9a724e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae1d3379e8d6486e79853e254ea9a724e">coproc_uop_scope</a> = &quot;coproc_uop_scope&quot;</td></tr>
<tr class="memdesc:ae1d3379e8d6486e79853e254ea9a724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent.  <a href="#ae1d3379e8d6486e79853e254ea9a724e">More...</a><br /></td></tr>
<tr class="separator:ae1d3379e8d6486e79853e254ea9a724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14c2370f3a08792a6aaf70d7a3c773e4">volatile_scope</a> = &quot;volatile_scope&quot;</td></tr>
<tr class="memdesc:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as volatile access for certain handle.  <a href="#a14c2370f3a08792a6aaf70d7a3c773e4">More...</a><br /></td></tr>
<tr class="separator:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd38b620e1e9907216f3e583839dea3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4bd38b620e1e9907216f3e583839dea3">extern_scope</a> = &quot;extern_scope&quot;</td></tr>
<tr class="memdesc:a4bd38b620e1e9907216f3e583839dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program.  <a href="#a4bd38b620e1e9907216f3e583839dea3">More...</a><br /></td></tr>
<tr class="separator:a4bd38b620e1e9907216f3e583839dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a6b89838348f152d844cead81b5016"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a00a6b89838348f152d844cead81b5016">compute_scope</a> = &quot;compute_scope&quot;</td></tr>
<tr class="memdesc:a00a6b89838348f152d844cead81b5016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute.  <a href="#a00a6b89838348f152d844cead81b5016">More...</a><br /></td></tr>
<tr class="separator:a00a6b89838348f152d844cead81b5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d464f2065dc5f77408df7b94d4bb6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af27d464f2065dc5f77408df7b94d4bb6">storage_alignment</a> = &quot;storage_alignment&quot;</td></tr>
<tr class="memdesc:af27d464f2065dc5f77408df7b94d4bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage alignment requirement of buffers.  <a href="#af27d464f2065dc5f77408df7b94d4bb6">More...</a><br /></td></tr>
<tr class="separator:af27d464f2065dc5f77408df7b94d4bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70bbdafa7344811d336422bf95cdc5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acf70bbdafa7344811d336422bf95cdc5">realize_scope</a> = &quot;realize_scope&quot;</td></tr>
<tr class="memdesc:acf70bbdafa7344811d336422bf95cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of realization.  <a href="#acf70bbdafa7344811d336422bf95cdc5">More...</a><br /></td></tr>
<tr class="separator:acf70bbdafa7344811d336422bf95cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a61b1ef1047fb722a4e5ec2167c9963d7">device_id</a> = &quot;device_id&quot;</td></tr>
<tr class="memdesc:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation device for global malloc in host.  <a href="#a61b1ef1047fb722a4e5ec2167c9963d7">More...</a><br /></td></tr>
<tr class="separator:a61b1ef1047fb722a4e5ec2167c9963d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e7cd47471a9089022214d63d24206"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7e4e7cd47471a9089022214d63d24206">device_type</a> = &quot;device_type&quot;</td></tr>
<tr class="memdesc:a7e4e7cd47471a9089022214d63d24206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type.  <a href="#a7e4e7cd47471a9089022214d63d24206">More...</a><br /></td></tr>
<tr class="separator:a7e4e7cd47471a9089022214d63d24206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9125ab905a93924ee79269aa808ed517"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9125ab905a93924ee79269aa808ed517">loop_scope</a> = &quot;loop_scope&quot;</td></tr>
<tr class="memdesc:a9125ab905a93924ee79269aa808ed517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of loop scope.  <a href="#a9125ab905a93924ee79269aa808ed517">More...</a><br /></td></tr>
<tr class="separator:a9125ab905a93924ee79269aa808ed517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a50fc9633b9cfbcefa2393dbb2ece1846">reduce_scope</a> = &quot;reduce_scope&quot;</td></tr>
<tr class="memdesc:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of reduce scope.  <a href="#a50fc9633b9cfbcefa2393dbb2ece1846">More...</a><br /></td></tr>
<tr class="separator:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8b8af5c21a3c26954d0ae482e7230e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a8a8b8af5c21a3c26954d0ae482e7230e">pragma_auto_unroll_max_step</a> = &quot;pragma_auto_unroll_max_step&quot;</td></tr>
<tr class="memdesc:a8a8b8af5c21a3c26954d0ae482e7230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pragma: auto-unroll, max_step.  <a href="#a8a8b8af5c21a3c26954d0ae482e7230e">More...</a><br /></td></tr>
<tr class="separator:a8a8b8af5c21a3c26954d0ae482e7230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288b5c4a7961450f4007d684a9098010"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a288b5c4a7961450f4007d684a9098010">pragma_unroll_explicit</a> = &quot;pragma_unroll_explicit&quot;</td></tr>
<tr class="memdesc:a288b5c4a7961450f4007d684a9098010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pragma: unroll explicit.  <a href="#a288b5c4a7961450f4007d684a9098010">More...</a><br /></td></tr>
<tr class="separator:a288b5c4a7961450f4007d684a9098010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af08d3d2b645a914f1a64d81e45f3b86a">pragma_scope_prefix</a> = &quot;pragma_&quot;</td></tr>
<tr class="memdesc:af08d3d2b645a914f1a64d81e45f3b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is guarded by the pragma extension.  <a href="#af08d3d2b645a914f1a64d81e45f3b86a">More...</a><br /></td></tr>
<tr class="separator:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a2823f2e8c3ae9eec6c8f797752d1f9b5">pragma_import_c</a> = &quot;pragma_import_c&quot;</td></tr>
<tr class="memdesc:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import C source or file into the final code gen module.  <a href="#a2823f2e8c3ae9eec6c8f797752d1f9b5">More...</a><br /></td></tr>
<tr class="separator:a2823f2e8c3ae9eec6c8f797752d1f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ba402645b1def7c543af3c48be80d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af00ba402645b1def7c543af3c48be80d">pragma_import_llvm</a> = &quot;pragma_import_llvm&quot;</td></tr>
<tr class="memdesc:af00ba402645b1def7c543af3c48be80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import llvm source or file into the final code gen module.  <a href="#af00ba402645b1def7c543af3c48be80d">More...</a><br /></td></tr>
<tr class="separator:af00ba402645b1def7c543af3c48be80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96774004fd5b6411f6c37b8923b71834"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a96774004fd5b6411f6c37b8923b71834">pragma_tensor_core</a> = &quot;pragma_tensor_core&quot;</td></tr>
<tr class="memdesc:a96774004fd5b6411f6c37b8923b71834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to modify the AST to support Tensor Core.  <a href="#a96774004fd5b6411f6c37b8923b71834">More...</a><br /></td></tr>
<tr class="separator:a96774004fd5b6411f6c37b8923b71834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac95fbd1c09a60b10c7a5d07f6c4b68a6">prefetch_scope</a> = &quot;prefetch_scope&quot;</td></tr>
<tr class="memdesc:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope.  <a href="#ac95fbd1c09a60b10c7a5d07f6c4b68a6">More...</a><br /></td></tr>
<tr class="separator:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6dc58c76a20757b54c5afd76bdbf53"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ace6dc58c76a20757b54c5afd76bdbf53">layout_transforms</a> = &quot;layout_transforms&quot;</td></tr>
<tr class="memdesc:ace6dc58c76a20757b54c5afd76bdbf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the layout transforms to be used for a tensor.  <a href="#ace6dc58c76a20757b54c5afd76bdbf53">More...</a><br /></td></tr>
<tr class="separator:ace6dc58c76a20757b54c5afd76bdbf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf23614bc95ff92e0aa41a519eec08e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acf23614bc95ff92e0aa41a519eec08e4">axis_separators</a> = &quot;axis_separators&quot;</td></tr>
<tr class="memdesc:acf23614bc95ff92e0aa41a519eec08e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the physical axis separators.  <a href="#acf23614bc95ff92e0aa41a519eec08e4">More...</a><br /></td></tr>
<tr class="separator:acf23614bc95ff92e0aa41a519eec08e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9231fc0afe37a8d46a90a1c5fdf522bb">double_buffer_scope</a> = &quot;double_buffer_scope&quot;</td></tr>
<tr class="memdesc:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks production of double buffer data.  <a href="#a9231fc0afe37a8d46a90a1c5fdf522bb">More...</a><br /></td></tr>
<tr class="separator:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84871a6d841168f8501f141676dfaeb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af84871a6d841168f8501f141676dfaeb">double_buffer_write</a> = &quot;double_buffer_write&quot;</td></tr>
<tr class="memdesc:af84871a6d841168f8501f141676dfaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks region used by double buffer write.  <a href="#af84871a6d841168f8501f141676dfaeb">More...</a><br /></td></tr>
<tr class="separator:af84871a6d841168f8501f141676dfaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0392acd85eb3cd406315d3c02eadd8"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a5d0392acd85eb3cd406315d3c02eadd8">rolling_buffer_scope</a> = &quot;rolling_buffer_scope&quot;</td></tr>
<tr class="memdesc:a5d0392acd85eb3cd406315d3c02eadd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark realization for rolling buffer optimization.  <a href="#a5d0392acd85eb3cd406315d3c02eadd8">More...</a><br /></td></tr>
<tr class="separator:a5d0392acd85eb3cd406315d3c02eadd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a84f5d42e968fd8f4cdd7a4aac7ba2137">scan_update_scope</a> = &quot;scan_update_scope&quot;</td></tr>
<tr class="memdesc:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan update scope.  <a href="#a84f5d42e968fd8f4cdd7a4aac7ba2137">More...</a><br /></td></tr>
<tr class="separator:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e3a9ba11d436e02b55e420647b22b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af18e3a9ba11d436e02b55e420647b22b">scan_init_scope</a> = &quot;scan_init_scope&quot;</td></tr>
<tr class="memdesc:af18e3a9ba11d436e02b55e420647b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan init scope.  <a href="#af18e3a9ba11d436e02b55e420647b22b">More...</a><br /></td></tr>
<tr class="separator:af18e3a9ba11d436e02b55e420647b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0ff3c4642eebe20842b1c26e98288a5d">buffer_dim_align</a> = &quot;buffer_dim_align&quot;</td></tr>
<tr class="memdesc:a0ff3c4642eebe20842b1c26e98288a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset.  <a href="#a0ff3c4642eebe20842b1c26e98288a5d">More...</a><br /></td></tr>
<tr class="separator:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac76fd8d0227265617e2f2bb8402d1e19">buffer_bound</a> = &quot;buffer_bound&quot;</td></tr>
<tr class="memdesc:ac76fd8d0227265617e2f2bb8402d1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark stores/loads with theirs bounds.  <a href="#ac76fd8d0227265617e2f2bb8402d1e19">More...</a><br /></td></tr>
<tr class="separator:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497d7cff1d672920c2fbd4d92869e62"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0497d7cff1d672920c2fbd4d92869e62">buffer_bind_scope</a> = &quot;buffer_bind_scope&quot;</td></tr>
<tr class="memdesc:a0497d7cff1d672920c2fbd4d92869e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase.  <a href="#a0497d7cff1d672920c2fbd4d92869e62">More...</a><br /></td></tr>
<tr class="separator:a0497d7cff1d672920c2fbd4d92869e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad39d05bd13aeed7af51e9f8e323d263b">channel_read_scope</a> = &quot;channel_read_scope&quot;</td></tr>
<tr class="memdesc:ad39d05bd13aeed7af51e9f8e323d263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel read scope  <a href="#ad39d05bd13aeed7af51e9f8e323d263b">More...</a><br /></td></tr>
<tr class="separator:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14632ed9597f1c21a0dbd23949e5916e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14632ed9597f1c21a0dbd23949e5916e">channel_read_advance</a> = &quot;channel_read_advance&quot;</td></tr>
<tr class="memdesc:a14632ed9597f1c21a0dbd23949e5916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#a14632ed9597f1c21a0dbd23949e5916e">More...</a><br /></td></tr>
<tr class="separator:a14632ed9597f1c21a0dbd23949e5916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a52f378fc437bd4f7f6508c8e2e9b3e05">channel_write_scope</a> = &quot;channel_write_scope&quot;</td></tr>
<tr class="memdesc:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel write scope  <a href="#a52f378fc437bd4f7f6508c8e2e9b3e05">More...</a><br /></td></tr>
<tr class="separator:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad8886f0bca07d9fa56db9edea67b1a8d">channel_write_advance</a> = &quot;channel_write_advance&quot;</td></tr>
<tr class="memdesc:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#ad8886f0bca07d9fa56db9edea67b1a8d">More...</a><br /></td></tr>
<tr class="separator:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ecbf068afc115a2282e533c0fe518d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a19ecbf068afc115a2282e533c0fe518d">pipeline_stage_scope</a> = &quot;pipeline_stage_scope&quot;</td></tr>
<tr class="memdesc:a19ecbf068afc115a2282e533c0fe518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline stage scope, implies always execution  <a href="#a19ecbf068afc115a2282e533c0fe518d">More...</a><br /></td></tr>
<tr class="separator:a19ecbf068afc115a2282e533c0fe518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14d4d24b86179fd19938a02bc15512"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#aee14d4d24b86179fd19938a02bc15512">pipeline_exec_scope</a> = &quot;pipeline_exec_scope&quot;</td></tr>
<tr class="memdesc:aee14d4d24b86179fd19938a02bc15512"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline execution scope, implies the scope can be pipelined.  <a href="#aee14d4d24b86179fd19938a02bc15512">More...</a><br /></td></tr>
<tr class="separator:aee14d4d24b86179fd19938a02bc15512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db026f638ad3d951c302796ddcae24"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a36db026f638ad3d951c302796ddcae24">device_scope</a> = &quot;device_scope&quot;</td></tr>
<tr class="memdesc:a36db026f638ad3d951c302796ddcae24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that it is in the device scope.  <a href="#a36db026f638ad3d951c302796ddcae24">More...</a><br /></td></tr>
<tr class="separator:a36db026f638ad3d951c302796ddcae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86552e1cc4180ec1c8e14b582e49c16"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af86552e1cc4180ec1c8e14b582e49c16">async_scope</a> = &quot;async_scope&quot;</td></tr>
<tr class="memdesc:af86552e1cc4180ec1c8e14b582e49c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the attached statement runs asynchronously.  <a href="#af86552e1cc4180ec1c8e14b582e49c16">More...</a><br /></td></tr>
<tr class="separator:af86552e1cc4180ec1c8e14b582e49c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f02d8d6218ac28f5a4cee86173c9131"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a5f02d8d6218ac28f5a4cee86173c9131">async_commit_queue_scope</a> = &quot;async_commit_queue_scope&quot;</td></tr>
<tr class="memdesc:a5f02d8d6218ac28f5a4cee86173c9131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotations for invoking and synchronizing asynchronous operations.  <a href="#a5f02d8d6218ac28f5a4cee86173c9131">More...</a><br /></td></tr>
<tr class="separator:a5f02d8d6218ac28f5a4cee86173c9131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2304828e489c908f0b1f08d7384b711"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#aa2304828e489c908f0b1f08d7384b711">async_wait_queue_scope</a> = &quot;async_wait_queue_scope&quot;</td></tr>
<tr class="separator:aa2304828e489c908f0b1f08d7384b711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb4f6108d157e56396592097f6ac12f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acdb4f6108d157e56396592097f6ac12f">async_wait_inflight_count</a> = &quot;async_wait_inflight_count&quot;</td></tr>
<tr class="separator:acdb4f6108d157e56396592097f6ac12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d76d80fd7252d66991dc650693c0ef"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a93d76d80fd7252d66991dc650693c0ef">fragment_shape</a> = &quot;fragment_shape&quot;</td></tr>
<tr class="memdesc:a93d76d80fd7252d66991dc650693c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the shape of TensorCore fragment.  <a href="#a93d76d80fd7252d66991dc650693c0ef">More...</a><br /></td></tr>
<tr class="separator:a93d76d80fd7252d66991dc650693c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cc65f756817e691b49782ee103bd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9b33cc65f756817e691b49782ee103bd">fragment_layout</a> = &quot;fragment_layout&quot;</td></tr>
<tr class="memdesc:a9b33cc65f756817e691b49782ee103bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the layout of TensorCore fragment.  <a href="#a9b33cc65f756817e691b49782ee103bd">More...</a><br /></td></tr>
<tr class="separator:a9b33cc65f756817e691b49782ee103bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d026645d3f86d9cc2e693fa232fddec"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0d026645d3f86d9cc2e693fa232fddec">hand_threaded</a> = &quot;hand_threaded&quot;</td></tr>
<tr class="memdesc:a0d026645d3f86d9cc2e693fa232fddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the kernel is hand threaded and doesn't need syncs inserted.  <a href="#a0d026645d3f86d9cc2e693fa232fddec">More...</a><br /></td></tr>
<tr class="separator:a0d026645d3f86d9cc2e693fa232fddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66b2c968e985c3f4264979c18622e8"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a3c66b2c968e985c3f4264979c18622e8">script_parsing_detect_access</a> = &quot;tir.script_parsing_detect_access&quot;</td></tr>
<tr class="memdesc:a3c66b2c968e985c3f4264979c18622e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark whether the script-completer need to fill in missing access region during script parsing.  <a href="#a3c66b2c968e985c3f4264979c18622e8">More...</a><br /></td></tr>
<tr class="separator:a3c66b2c968e985c3f4264979c18622e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae6bb4bdf780d88ac330ad27c6c94e0f7">pragma_loop_partition_hint</a> = &quot;pragma_loop_partition_hint&quot;</td></tr>
<tr class="memdesc:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the loop should be partitioned.  <a href="#ae6bb4bdf780d88ac330ad27c6c94e0f7">More...</a><br /></td></tr>
<tr class="separator:ae6bb4bdf780d88ac330ad27c6c94e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e695603b89f78f4a481817dbaf7a082"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a2e695603b89f78f4a481817dbaf7a082">software_pipeline_stage</a> = &quot;software_pipeline_stage&quot;</td></tr>
<tr class="memdesc:a2e695603b89f78f4a481817dbaf7a082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the stage of a statement in the software pipeline.  <a href="#a2e695603b89f78f4a481817dbaf7a082">More...</a><br /></td></tr>
<tr class="separator:a2e695603b89f78f4a481817dbaf7a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064b547bf5b0579f9b42906c6a9c581d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a064b547bf5b0579f9b42906c6a9c581d">software_pipeline_order</a> = &quot;software_pipeline_order&quot;</td></tr>
<tr class="memdesc:a064b547bf5b0579f9b42906c6a9c581d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the order of a statement in the software pipeline.  <a href="#a064b547bf5b0579f9b42906c6a9c581d">More...</a><br /></td></tr>
<tr class="separator:a064b547bf5b0579f9b42906c6a9c581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff3ec02ce6acef9dd5c20f1aacc19bc"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7ff3ec02ce6acef9dd5c20f1aacc19bc">software_pipeline_async_stages</a> = &quot;software_pipeline_async_stages&quot;</td></tr>
<tr class="memdesc:a7ff3ec02ce6acef9dd5c20f1aacc19bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">List stages in the software pipeline that should run asynchronously.  <a href="#a7ff3ec02ce6acef9dd5c20f1aacc19bc">More...</a><br /></td></tr>
<tr class="separator:a7ff3ec02ce6acef9dd5c20f1aacc19bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf212844cfa05381db84b0c470318e3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9cf212844cfa05381db84b0c470318e3">layout_free_buffers</a> = &quot;layout_free_buffers&quot;</td></tr>
<tr class="memdesc:a9cf212844cfa05381db84b0c470318e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the buffers which is const access and can be transformed layout.  <a href="#a9cf212844cfa05381db84b0c470318e3">More...</a><br /></td></tr>
<tr class="separator:a9cf212844cfa05381db84b0c470318e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a992522880c3206e3c5ca39f2524906"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a1a992522880c3206e3c5ca39f2524906">manifest_shared_memory_local_stage</a> = &quot;tir.manifest_shared_memory_local_stage&quot;</td></tr>
<tr class="memdesc:a1a992522880c3206e3c5ca39f2524906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the local stage for the shared memory access should be added.  <a href="#a1a992522880c3206e3c5ca39f2524906">More...</a><br /></td></tr>
<tr class="separator:a1a992522880c3206e3c5ca39f2524906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa4a05a037f033dfdf56f8d19dd7f3d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a2aa4a05a037f033dfdf56f8d19dd7f3d">meta_schedule_tiling_structure</a> = &quot;meta_schedule.tiling_structure&quot;</td></tr>
<tr class="memdesc:a2aa4a05a037f033dfdf56f8d19dd7f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the tiling structure of blocks that are applied by rule Multi-Level-Tiling.  <a href="#a2aa4a05a037f033dfdf56f8d19dd7f3d">More...</a><br /></td></tr>
<tr class="separator:a2aa4a05a037f033dfdf56f8d19dd7f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bba3064a40ce62c958db4b120471a7"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a82bba3064a40ce62c958db4b120471a7">meta_schedule_cooperative_fetch</a> = &quot;meta_schedule.cooperative_fetch&quot;</td></tr>
<tr class="memdesc:a82bba3064a40ce62c958db4b120471a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the loop should be further skip and bound to environment threads to enable cooperative fetching.  <a href="#a82bba3064a40ce62c958db4b120471a7">More...</a><br /></td></tr>
<tr class="separator:a82bba3064a40ce62c958db4b120471a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694f6b5653f5e1ee916abf107462cd7b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a694f6b5653f5e1ee916abf107462cd7b">meta_schedule_thread_extent_low_inclusive</a></td></tr>
<tr class="memdesc:a694f6b5653f5e1ee916abf107462cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allowed range of thread extent in thread bindings.  <a href="#a694f6b5653f5e1ee916abf107462cd7b">More...</a><br /></td></tr>
<tr class="separator:a694f6b5653f5e1ee916abf107462cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73f6ad441e1be3b2e71dead1e89f4bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad73f6ad441e1be3b2e71dead1e89f4bb">meta_schedule_thread_extent_high_inclusive</a></td></tr>
<tr class="memdesc:ad73f6ad441e1be3b2e71dead1e89f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allowed range of thread extent in thread bindings.  <a href="#ad73f6ad441e1be3b2e71dead1e89f4bb">More...</a><br /></td></tr>
<tr class="separator:ad73f6ad441e1be3b2e71dead1e89f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350918383cf7d7c9a95114ab7fda7781"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a350918383cf7d7c9a95114ab7fda7781">meta_schedule_random_compute_producer</a></td></tr>
<tr class="memdesc:a350918383cf7d7c9a95114ab7fda7781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the block whose producer needs to be applied by rule Random-Compute-Location.  <a href="#a350918383cf7d7c9a95114ab7fda7781">More...</a><br /></td></tr>
<tr class="separator:a350918383cf7d7c9a95114ab7fda7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8510abcf9d0c3b3dd9f30046b5c0f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#afdc8510abcf9d0c3b3dd9f30046b5c0f">meta_schedule_parallel</a> = &quot;meta_schedule.parallel&quot;</td></tr>
<tr class="memdesc:afdc8510abcf9d0c3b3dd9f30046b5c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark auto-parallel setting on the block.  <a href="#afdc8510abcf9d0c3b3dd9f30046b5c0f">More...</a><br /></td></tr>
<tr class="separator:afdc8510abcf9d0c3b3dd9f30046b5c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d82995b58b837ac941af54bb70afec"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af7d82995b58b837ac941af54bb70afec">meta_schedule_vectorize</a> = &quot;meta_schedule.vectorize&quot;</td></tr>
<tr class="memdesc:af7d82995b58b837ac941af54bb70afec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark auto-vectorize setting on the block.  <a href="#af7d82995b58b837ac941af54bb70afec">More...</a><br /></td></tr>
<tr class="separator:af7d82995b58b837ac941af54bb70afec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e62a6db9189700e996599541506e7c"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a07e62a6db9189700e996599541506e7c">meta_schedule_unroll_explicit</a> = &quot;meta_schedule.unroll_explicit&quot;</td></tr>
<tr class="memdesc:a07e62a6db9189700e996599541506e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark auto-unroll setting on the block.  <a href="#a07e62a6db9189700e996599541506e7c">More...</a><br /></td></tr>
<tr class="separator:a07e62a6db9189700e996599541506e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5267857a903d20285f4e0af38d2d9004"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a5267857a903d20285f4e0af38d2d9004">meta_schedule_unroll_implicit</a> = &quot;meta_schedule.unroll_implicit&quot;</td></tr>
<tr class="memdesc:a5267857a903d20285f4e0af38d2d9004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark auto-unroll setting on the block.  <a href="#a5267857a903d20285f4e0af38d2d9004">More...</a><br /></td></tr>
<tr class="separator:a5267857a903d20285f4e0af38d2d9004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f0de00900235f9c158f20f345604a4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a16f0de00900235f9c158f20f345604a4">meta_schedule_auto_tensorize</a> = &quot;meta_schedule.auto_tensorize&quot;</td></tr>
<tr class="memdesc:a16f0de00900235f9c158f20f345604a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that a block should be further rewritten using tensorization.  <a href="#a16f0de00900235f9c158f20f345604a4">More...</a><br /></td></tr>
<tr class="separator:a16f0de00900235f9c158f20f345604a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763184e47fc7f1423d12e5f919d932be"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a763184e47fc7f1423d12e5f919d932be">meta_schedule_layout_rewrite_preproc</a> = &quot;meta_schedule.layout_rewrite_preproc&quot;</td></tr>
<tr class="memdesc:a763184e47fc7f1423d12e5f919d932be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that a block is a preprocessor block for layout rewrite.  <a href="#a763184e47fc7f1423d12e5f919d932be">More...</a><br /></td></tr>
<tr class="separator:a763184e47fc7f1423d12e5f919d932be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82af28d290971bb889ea37caca78ff46"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a82af28d290971bb889ea37caca78ff46">meta_schedule_auto_tensorize_init</a> = &quot;meta_schedule.auto_tensorize_init&quot;</td></tr>
<tr class="memdesc:a82af28d290971bb889ea37caca78ff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the init statement of a block should be further rewritten using tensorization.  <a href="#a82af28d290971bb889ea37caca78ff46">More...</a><br /></td></tr>
<tr class="separator:a82af28d290971bb889ea37caca78ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b654a57098d16dd2d08efaa949ffe3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af1b654a57098d16dd2d08efaa949ffe3">require_block_var_bound_predicate</a> = &quot;require_bound_predicate&quot;</td></tr>
<tr class="memdesc:af1b654a57098d16dd2d08efaa949ffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the block need to add predicate for block var bounds during lowering.  <a href="#af1b654a57098d16dd2d08efaa949ffe3">More...</a><br /></td></tr>
<tr class="separator:af1b654a57098d16dd2d08efaa949ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa5e8f47d3ce634be6091cdb2fb8348"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a3fa5e8f47d3ce634be6091cdb2fb8348">meta_schedule_tensor_core_enabled</a> = &quot;meta_schedule.tensor_core_enabled&quot;</td></tr>
<tr class="memdesc:a3fa5e8f47d3ce634be6091cdb2fb8348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that tensor core is enabled in the <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>.  <a href="#a3fa5e8f47d3ce634be6091cdb2fb8348">More...</a><br /></td></tr>
<tr class="separator:a3fa5e8f47d3ce634be6091cdb2fb8348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca5c5953b2047c177c627b794822f04"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4ca5c5953b2047c177c627b794822f04">meta_schedule_cache_type</a> = &quot;meta_schedule.cache_type&quot;</td></tr>
<tr class="memdesc:a4ca5c5953b2047c177c627b794822f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a block as generated by cache_read or cache_write block. 0 means cache_read; 1 means cache_write.  <a href="#a4ca5c5953b2047c177c627b794822f04">More...</a><br /></td></tr>
<tr class="separator:a4ca5c5953b2047c177c627b794822f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5af02ec48a1be0f1162e2e1bdf7153"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7f5af02ec48a1be0f1162e2e1bdf7153">meta_schedule_cache_type_read</a> = 0</td></tr>
<tr class="separator:a7f5af02ec48a1be0f1162e2e1bdf7153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e77542dd6c4d86f8d7d3d1881daa7f"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ab6e77542dd6c4d86f8d7d3d1881daa7f">meta_schedule_cache_type_write</a> = 1</td></tr>
<tr class="separator:ab6e77542dd6c4d86f8d7d3d1881daa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54930cf29f25fa3d67b0f983858fa467"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a54930cf29f25fa3d67b0f983858fa467">auto_copy</a> = &quot;auto_copy&quot;</td></tr>
<tr class="memdesc:a54930cf29f25fa3d67b0f983858fa467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark auto copy for memhammer.  <a href="#a54930cf29f25fa3d67b0f983858fa467">More...</a><br /></td></tr>
<tr class="separator:a54930cf29f25fa3d67b0f983858fa467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c36a3dd1f599b1fc641784f3020796"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af3c36a3dd1f599b1fc641784f3020796">local_stage</a> = &quot;local_stage&quot;</td></tr>
<tr class="memdesc:af3c36a3dd1f599b1fc641784f3020796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark local stage constraint on data copy.  <a href="#af3c36a3dd1f599b1fc641784f3020796">More...</a><br /></td></tr>
<tr class="separator:af3c36a3dd1f599b1fc641784f3020796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5ec1a12abbc199795176f1da4f9fb9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7a5ec1a12abbc199795176f1da4f9fb9">vector_bytes</a> = &quot;vector_bytes&quot;</td></tr>
<tr class="memdesc:a7a5ec1a12abbc199795176f1da4f9fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark vectorization length constraint on block.  <a href="#a7a5ec1a12abbc199795176f1da4f9fb9">More...</a><br /></td></tr>
<tr class="separator:a7a5ec1a12abbc199795176f1da4f9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350f417c4c3ed61f4578c5e5cb72d667"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a350f417c4c3ed61f4578c5e5cb72d667">warp_execution</a> = &quot;warp_execution&quot;</td></tr>
<tr class="memdesc:a350f417c4c3ed61f4578c5e5cb72d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that a block is executed by a warp. This implies the extend of threadIdx.x is warp size.  <a href="#a350f417c4c3ed61f4578c5e5cb72d667">More...</a><br /></td></tr>
<tr class="separator:a350f417c4c3ed61f4578c5e5cb72d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1468e0d830201631fd97e1f944e07"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae4b1468e0d830201631fd97e1f944e07">meta_schedule_inline_rule</a> = &quot;meta_schedule.inline_rule&quot;</td></tr>
<tr class="memdesc:ae4b1468e0d830201631fd97e1f944e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that a block is disallowed in auto inline.  <a href="#ae4b1468e0d830201631fd97e1f944e07">More...</a><br /></td></tr>
<tr class="separator:ae4b1468e0d830201631fd97e1f944e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. </p>
<p>namespace of possible attributes in AttrStmt.attr_key</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1attr.html" title="Generic attribute names that can be attached to any function. ">tvm::attr</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a385e883a7cecc309d063786e5fdf2c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385e883a7cecc309d063786e5fdf2c4b">&#9670;&nbsp;</a></span>IsPragmaKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::attr::IsPragmaKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if attr_key is a pragma key extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>The attr key to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a pragma key </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5f02d8d6218ac28f5a4cee86173c9131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f02d8d6218ac28f5a4cee86173c9131">&#9670;&nbsp;</a></span>async_commit_queue_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::async_commit_queue_scope = &quot;async_commit_queue_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotations for invoking and synchronizing asynchronous operations. </p>
<p>Synchronization is done in terms of "queue": It is an abstract entity associated with each asynchronous unit, and it tracks invocations and completions of asynchronous operations in the FIFO order.</p>
<p>Similarly to PTX instructions commit_group and wait_group, these annotations express synchronization by "counting":</p>
<p>async_commit_queue(i): Group one or more invocations of async operations in the given scope, and "commit" (or push) them to the queue i. A group of operations committed together is awaited as one chunk. Groups committed to the same queue complete in the FIFO order.</p>
<p>async_wait_queue(i, N): <a class="el" href="classtvm_1_1tir_1_1Block.html" title="Managed reference to BlockNode. ">Block</a> until only N most recent committed groups are still in-flight at the queue i. N does not have to be a constant, but some backends may require a constant count. </p>

</div>
</div>
<a id="af86552e1cc4180ec1c8e14b582e49c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86552e1cc4180ec1c8e14b582e49c16">&#9670;&nbsp;</a></span>async_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::async_scope = &quot;async_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the attached statement runs asynchronously. </p>

</div>
</div>
<a id="acdb4f6108d157e56396592097f6ac12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb4f6108d157e56396592097f6ac12f">&#9670;&nbsp;</a></span>async_wait_inflight_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::async_wait_inflight_count = &quot;async_wait_inflight_count&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2304828e489c908f0b1f08d7384b711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2304828e489c908f0b1f08d7384b711">&#9670;&nbsp;</a></span>async_wait_queue_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::async_wait_queue_scope = &quot;async_wait_queue_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54930cf29f25fa3d67b0f983858fa467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54930cf29f25fa3d67b0f983858fa467">&#9670;&nbsp;</a></span>auto_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::auto_copy = &quot;auto_copy&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark auto copy for memhammer. </p>

</div>
</div>
<a id="acf23614bc95ff92e0aa41a519eec08e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf23614bc95ff92e0aa41a519eec08e4">&#9670;&nbsp;</a></span>axis_separators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::axis_separators = &quot;axis_separators&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the physical axis separators. </p>
<p>Only applies to a <a class="el" href="classtvm_1_1tir_1_1DataProducer.html" title="Managed reference to DataProducerNode. ">DataProducer</a>, as it should be made part of the <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> definition in a <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a>. See <code><a class="el" href="classtvm_1_1tir_1_1BufferNode.html#aac10249c16d06aa926a3504aaf0207da" title="Separators between input axes when generating flattened output axes. ">BufferNode::axis_separators</a></code> for more details. </p>

</div>
</div>
<a id="a0497d7cff1d672920c2fbd4d92869e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497d7cff1d672920c2fbd4d92869e62">&#9670;&nbsp;</a></span>buffer_bind_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bind_scope = &quot;buffer_bind_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. </p>

</div>
</div>
<a id="ac76fd8d0227265617e2f2bb8402d1e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76fd8d0227265617e2f2bb8402d1e19">&#9670;&nbsp;</a></span>buffer_bound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_bound = &quot;buffer_bound&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark stores/loads with theirs bounds. </p>

</div>
</div>
<a id="a0ff3c4642eebe20842b1c26e98288a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c4642eebe20842b1c26e98288a5d">&#9670;&nbsp;</a></span>buffer_dim_align</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::buffer_dim_align = &quot;buffer_dim_align&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset. </p>

</div>
</div>
<a id="a14632ed9597f1c21a0dbd23949e5916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14632ed9597f1c21a0dbd23949e5916e">&#9670;&nbsp;</a></span>channel_read_advance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_advance = &quot;channel_read_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a id="ad39d05bd13aeed7af51e9f8e323d263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d05bd13aeed7af51e9f8e323d263b">&#9670;&nbsp;</a></span>channel_read_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_read_scope = &quot;channel_read_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel read scope </p>

</div>
</div>
<a id="ad8886f0bca07d9fa56db9edea67b1a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8886f0bca07d9fa56db9edea67b1a8d">&#9670;&nbsp;</a></span>channel_write_advance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_advance = &quot;channel_write_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a id="a52f378fc437bd4f7f6508c8e2e9b3e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f378fc437bd4f7f6508c8e2e9b3e05">&#9670;&nbsp;</a></span>channel_write_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::channel_write_scope = &quot;channel_write_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel write scope </p>

</div>
</div>
<a id="a00a6b89838348f152d844cead81b5016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a6b89838348f152d844cead81b5016">&#9670;&nbsp;</a></span>compute_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::compute_scope = &quot;compute_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. </p>

</div>
</div>
<a id="ac62a341bfebe5448f290aa54b0f84cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62a341bfebe5448f290aa54b0f84cac">&#9670;&nbsp;</a></span>coproc_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_scope = &quot;coproc_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is processed by a co-proccesor. </p>

</div>
</div>
<a id="ae1d3379e8d6486e79853e254ea9a724e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d3379e8d6486e79853e254ea9a724e">&#9670;&nbsp;</a></span>coproc_uop_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::coproc_uop_scope = &quot;coproc_uop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. </p>

</div>
</div>
<a id="a61b1ef1047fb722a4e5ec2167c9963d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b1ef1047fb722a4e5ec2167c9963d7">&#9670;&nbsp;</a></span>device_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_id = &quot;device_id&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The allocation device for global malloc in host. </p>

</div>
</div>
<a id="a36db026f638ad3d951c302796ddcae24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db026f638ad3d951c302796ddcae24">&#9670;&nbsp;</a></span>device_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_scope = &quot;device_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that it is in the device scope. </p>

</div>
</div>
<a id="a7e4e7cd47471a9089022214d63d24206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4e7cd47471a9089022214d63d24206">&#9670;&nbsp;</a></span>device_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::device_type = &quot;device_type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type. </p>

</div>
</div>
<a id="a9231fc0afe37a8d46a90a1c5fdf522bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231fc0afe37a8d46a90a1c5fdf522bb">&#9670;&nbsp;</a></span>double_buffer_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_scope = &quot;double_buffer_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks production of double buffer data. </p>

</div>
</div>
<a id="af84871a6d841168f8501f141676dfaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84871a6d841168f8501f141676dfaeb">&#9670;&nbsp;</a></span>double_buffer_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::double_buffer_write = &quot;double_buffer_write&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks region used by double buffer write. </p>

</div>
</div>
<a id="a4bd38b620e1e9907216f3e583839dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd38b620e1e9907216f3e583839dea3">&#9670;&nbsp;</a></span>extern_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::extern_scope = &quot;extern_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. </p>

</div>
</div>
<a id="a9b33cc65f756817e691b49782ee103bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b33cc65f756817e691b49782ee103bd">&#9670;&nbsp;</a></span>fragment_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_layout = &quot;fragment_layout&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the layout of TensorCore fragment. </p>

</div>
</div>
<a id="a93d76d80fd7252d66991dc650693c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d76d80fd7252d66991dc650693c0ef">&#9670;&nbsp;</a></span>fragment_shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::fragment_shape = &quot;fragment_shape&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the shape of TensorCore fragment. </p>

</div>
</div>
<a id="a0d026645d3f86d9cc2e693fa232fddec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d026645d3f86d9cc2e693fa232fddec">&#9670;&nbsp;</a></span>hand_threaded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::hand_threaded = &quot;hand_threaded&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the kernel is hand threaded and doesn't need syncs inserted. </p>

</div>
</div>
<a id="a4933845b75cf4f08fb66f55fdd94986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4933845b75cf4f08fb66f55fdd94986f">&#9670;&nbsp;</a></span>kDeviceThreadAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kDeviceThreadAxis = &quot;tir.device_thread_axis&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of thread <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> that a DeviceLaunch function corresponds to. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: Array&lt;tir::IterVar&gt;</p>
<p>We call a device kernel launch function f using the following convention:</p>
<p><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a>(f, [arg1, arg2, ..., arg_n, work_size_1, work_size_2, ... work_size_m, dyn_shmem_size])</p>
<p>Here n = len(arg), m = len(work_size) = len(device_thread_axis).</p>
<p>When kDeviceUseDynSharedMemory is not set, dyn_shmem_size argument is omitted.</p>
<p>The list of device_thread_axis indicates how can be bind the work_size arguments to the corresponding threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm.html#a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc" title="Device kernel launch. ">tvm::CallingConv::kDeviceKernelLaunch</a> </dd></dl>

</div>
</div>
<a id="a6644dc9ce51ba96b0364f7f891dcad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6644dc9ce51ba96b0364f7f891dcad9a">&#9670;&nbsp;</a></span>kDeviceUseDynSharedMemory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kDeviceUseDynSharedMemory = &quot;tir.device_use_dyn_shared_memory&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not use dynamic shared memory. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="a489d0cebd2820025bc3d6c5a9011cdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489d0cebd2820025bc3d6c5a9011cdd4">&#9670;&nbsp;</a></span>kIsEntryFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kIsEntryFunc = &quot;tir.is_entry_func&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the function as the entry function of the final generated runtime module. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a></p>
<dl class="section note"><dt>Note</dt><dd>There can only be one entry function per module. </dd></dl>

</div>
</div>
<a id="a3166c6d41ff1816ab01e398be07bac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3166c6d41ff1816ab01e398be07bac20">&#9670;&nbsp;</a></span>kIsGlobalFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kIsGlobalFunc = &quot;tir.is_global_func&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the function as the global function called from the host. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="ab91a41e0c0292462e91affae45b12db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91a41e0c0292462e91affae45b12db5">&#9670;&nbsp;</a></span>kIsHostFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kIsHostFunc = &quot;tir.is_host_func&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the function as run on the host, mutually exclusive with kTarget. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="ac74386674da85bc4b4dd1ee28a97ff63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74386674da85bc4b4dd1ee28a97ff63">&#9670;&nbsp;</a></span>kNoAlias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::kNoAlias = &quot;tir.noalias&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to set noalias rule on the function arguments. </p>
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>: <a class="el" href="classtvm_1_1Integer.html" title="Container of constant int that adds more constructors. ">Integer</a> </p>

</div>
</div>
<a id="a9cf212844cfa05381db84b0c470318e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf212844cfa05381db84b0c470318e3">&#9670;&nbsp;</a></span>layout_free_buffers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::layout_free_buffers = &quot;layout_free_buffers&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the buffers which is const access and can be transformed layout. </p>

</div>
</div>
<a id="ace6dc58c76a20757b54c5afd76bdbf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6dc58c76a20757b54c5afd76bdbf53">&#9670;&nbsp;</a></span>layout_transforms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::layout_transforms = &quot;layout_transforms&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the layout transforms to be used for a tensor. </p>
<p>Only applies to a <a class="el" href="classtvm_1_1tir_1_1DataProducer.html" title="Managed reference to DataProducerNode. ">DataProducer</a>, as it should be made part of the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> attributes for TIR. </p>

</div>
</div>
<a id="af3c36a3dd1f599b1fc641784f3020796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c36a3dd1f599b1fc641784f3020796">&#9670;&nbsp;</a></span>local_stage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::local_stage = &quot;local_stage&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark local stage constraint on data copy. </p>

</div>
</div>
<a id="a9125ab905a93924ee79269aa808ed517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9125ab905a93924ee79269aa808ed517">&#9670;&nbsp;</a></span>loop_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::loop_scope = &quot;loop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of loop scope. </p>

</div>
</div>
<a id="a1a992522880c3206e3c5ca39f2524906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a992522880c3206e3c5ca39f2524906">&#9670;&nbsp;</a></span>manifest_shared_memory_local_stage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::manifest_shared_memory_local_stage = &quot;tir.manifest_shared_memory_local_stage&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the local stage for the shared memory access should be added. </p>

</div>
</div>
<a id="a16f0de00900235f9c158f20f345604a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f0de00900235f9c158f20f345604a4">&#9670;&nbsp;</a></span>meta_schedule_auto_tensorize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_auto_tensorize = &quot;meta_schedule.auto_tensorize&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that a block should be further rewritten using tensorization. </p>

</div>
</div>
<a id="a82af28d290971bb889ea37caca78ff46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82af28d290971bb889ea37caca78ff46">&#9670;&nbsp;</a></span>meta_schedule_auto_tensorize_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_auto_tensorize_init = &quot;meta_schedule.auto_tensorize_init&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the init statement of a block should be further rewritten using tensorization. </p>

</div>
</div>
<a id="a4ca5c5953b2047c177c627b794822f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca5c5953b2047c177c627b794822f04">&#9670;&nbsp;</a></span>meta_schedule_cache_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_cache_type = &quot;meta_schedule.cache_type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a block as generated by cache_read or cache_write block. 0 means cache_read; 1 means cache_write. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a7f5af02ec48a1be0f1162e2e1bdf7153">meta_schedule_cache_type_read</a> </dd>
<dd>
<a class="el" href="namespacetvm_1_1tir_1_1attr.html#ab6e77542dd6c4d86f8d7d3d1881daa7f">meta_schedule_cache_type_write</a> </dd></dl>

</div>
</div>
<a id="a7f5af02ec48a1be0f1162e2e1bdf7153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5af02ec48a1be0f1162e2e1bdf7153">&#9670;&nbsp;</a></span>meta_schedule_cache_type_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int tvm::tir::attr::meta_schedule_cache_type_read = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4ca5c5953b2047c177c627b794822f04" title="Mark a block as generated by cache_read or cache_write block. 0 means cache_read; 1 means cache_write...">meta_schedule_cache_type</a> </dd></dl>

</div>
</div>
<a id="ab6e77542dd6c4d86f8d7d3d1881daa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e77542dd6c4d86f8d7d3d1881daa7f">&#9670;&nbsp;</a></span>meta_schedule_cache_type_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int tvm::tir::attr::meta_schedule_cache_type_write = 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4ca5c5953b2047c177c627b794822f04" title="Mark a block as generated by cache_read or cache_write block. 0 means cache_read; 1 means cache_write...">meta_schedule_cache_type</a> </dd></dl>

</div>
</div>
<a id="a82bba3064a40ce62c958db4b120471a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bba3064a40ce62c958db4b120471a7">&#9670;&nbsp;</a></span>meta_schedule_cooperative_fetch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_cooperative_fetch = &quot;meta_schedule.cooperative_fetch&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the loop should be further skip and bound to environment threads to enable cooperative fetching. </p>

</div>
</div>
<a id="ae4b1468e0d830201631fd97e1f944e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1468e0d830201631fd97e1f944e07">&#9670;&nbsp;</a></span>meta_schedule_inline_rule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_inline_rule = &quot;meta_schedule.inline_rule&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that a block is disallowed in auto inline. </p>

</div>
</div>
<a id="a763184e47fc7f1423d12e5f919d932be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763184e47fc7f1423d12e5f919d932be">&#9670;&nbsp;</a></span>meta_schedule_layout_rewrite_preproc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_layout_rewrite_preproc = &quot;meta_schedule.layout_rewrite_preproc&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that a block is a preprocessor block for layout rewrite. </p>

</div>
</div>
<a id="afdc8510abcf9d0c3b3dd9f30046b5c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc8510abcf9d0c3b3dd9f30046b5c0f">&#9670;&nbsp;</a></span>meta_schedule_parallel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_parallel = &quot;meta_schedule.parallel&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark auto-parallel setting on the block. </p>

</div>
</div>
<a id="a350918383cf7d7c9a95114ab7fda7781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350918383cf7d7c9a95114ab7fda7781">&#9670;&nbsp;</a></span>meta_schedule_random_compute_producer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_random_compute_producer</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;meta_schedule.random_compute_producer&quot;</span></div></div><!-- fragment -->
<p>Mark the block whose producer needs to be applied by rule Random-Compute-Location. </p>

</div>
</div>
<a id="a3fa5e8f47d3ce634be6091cdb2fb8348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa5e8f47d3ce634be6091cdb2fb8348">&#9670;&nbsp;</a></span>meta_schedule_tensor_core_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_tensor_core_enabled = &quot;meta_schedule.tensor_core_enabled&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that tensor core is enabled in the <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>. </p>

</div>
</div>
<a id="ad73f6ad441e1be3b2e71dead1e89f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73f6ad441e1be3b2e71dead1e89f4bb">&#9670;&nbsp;</a></span>meta_schedule_thread_extent_high_inclusive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_thread_extent_high_inclusive</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;meta_schedule.thread_extent_high_inclusive&quot;</span></div></div><!-- fragment -->
<p>The allowed range of thread extent in thread bindings. </p>

</div>
</div>
<a id="a694f6b5653f5e1ee916abf107462cd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694f6b5653f5e1ee916abf107462cd7b">&#9670;&nbsp;</a></span>meta_schedule_thread_extent_low_inclusive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_thread_extent_low_inclusive</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;meta_schedule.thread_extent_low_inclusive&quot;</span></div></div><!-- fragment -->
<p>The allowed range of thread extent in thread bindings. </p>

</div>
</div>
<a id="a2aa4a05a037f033dfdf56f8d19dd7f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa4a05a037f033dfdf56f8d19dd7f3d">&#9670;&nbsp;</a></span>meta_schedule_tiling_structure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_tiling_structure = &quot;meta_schedule.tiling_structure&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the tiling structure of blocks that are applied by rule Multi-Level-Tiling. </p>

</div>
</div>
<a id="a07e62a6db9189700e996599541506e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e62a6db9189700e996599541506e7c">&#9670;&nbsp;</a></span>meta_schedule_unroll_explicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_unroll_explicit = &quot;meta_schedule.unroll_explicit&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark auto-unroll setting on the block. </p>

</div>
</div>
<a id="a5267857a903d20285f4e0af38d2d9004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5267857a903d20285f4e0af38d2d9004">&#9670;&nbsp;</a></span>meta_schedule_unroll_implicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_unroll_implicit = &quot;meta_schedule.unroll_implicit&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark auto-unroll setting on the block. </p>

</div>
</div>
<a id="af7d82995b58b837ac941af54bb70afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d82995b58b837ac941af54bb70afec">&#9670;&nbsp;</a></span>meta_schedule_vectorize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::meta_schedule_vectorize = &quot;meta_schedule.vectorize&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark auto-vectorize setting on the block. </p>

</div>
</div>
<a id="aee14d4d24b86179fd19938a02bc15512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14d4d24b86179fd19938a02bc15512">&#9670;&nbsp;</a></span>pipeline_exec_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_exec_scope = &quot;pipeline_exec_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline execution scope, implies the scope can be pipelined. </p>

</div>
</div>
<a id="a19ecbf068afc115a2282e533c0fe518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ecbf068afc115a2282e533c0fe518d">&#9670;&nbsp;</a></span>pipeline_stage_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pipeline_stage_scope = &quot;pipeline_stage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline stage scope, implies always execution </p>

</div>
</div>
<a id="a8a8b8af5c21a3c26954d0ae482e7230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8b8af5c21a3c26954d0ae482e7230e">&#9670;&nbsp;</a></span>pragma_auto_unroll_max_step</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_auto_unroll_max_step = &quot;pragma_auto_unroll_max_step&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pragma: auto-unroll, max_step. </p>

</div>
</div>
<a id="a2823f2e8c3ae9eec6c8f797752d1f9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2823f2e8c3ae9eec6c8f797752d1f9b5">&#9670;&nbsp;</a></span>pragma_import_c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_c = &quot;pragma_import_c&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import C source or file into the final code gen module. </p>

</div>
</div>
<a id="af00ba402645b1def7c543af3c48be80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00ba402645b1def7c543af3c48be80d">&#9670;&nbsp;</a></span>pragma_import_llvm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_import_llvm = &quot;pragma_import_llvm&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import llvm source or file into the final code gen module. </p>

</div>
</div>
<a id="ae6bb4bdf780d88ac330ad27c6c94e0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bb4bdf780d88ac330ad27c6c94e0f7">&#9670;&nbsp;</a></span>pragma_loop_partition_hint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_loop_partition_hint = &quot;pragma_loop_partition_hint&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the loop should be partitioned. </p>

</div>
</div>
<a id="af08d3d2b645a914f1a64d81e45f3b86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08d3d2b645a914f1a64d81e45f3b86a">&#9670;&nbsp;</a></span>pragma_scope_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_scope_prefix = &quot;pragma_&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is guarded by the pragma extension. </p>

</div>
</div>
<a id="a96774004fd5b6411f6c37b8923b71834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96774004fd5b6411f6c37b8923b71834">&#9670;&nbsp;</a></span>pragma_tensor_core</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_tensor_core = &quot;pragma_tensor_core&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to modify the AST to support Tensor Core. </p>

</div>
</div>
<a id="a288b5c4a7961450f4007d684a9098010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288b5c4a7961450f4007d684a9098010">&#9670;&nbsp;</a></span>pragma_unroll_explicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::pragma_unroll_explicit = &quot;pragma_unroll_explicit&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pragma: unroll explicit. </p>

</div>
</div>
<a id="ac95fbd1c09a60b10c7a5d07f6c4b68a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95fbd1c09a60b10c7a5d07f6c4b68a6">&#9670;&nbsp;</a></span>prefetch_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::prefetch_scope = &quot;prefetch_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope. </p>

</div>
</div>
<a id="acf70bbdafa7344811d336422bf95cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf70bbdafa7344811d336422bf95cdc5">&#9670;&nbsp;</a></span>realize_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::realize_scope = &quot;realize_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of realization. </p>

</div>
</div>
<a id="a50fc9633b9cfbcefa2393dbb2ece1846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fc9633b9cfbcefa2393dbb2ece1846">&#9670;&nbsp;</a></span>reduce_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::reduce_scope = &quot;reduce_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of reduce scope. </p>

</div>
</div>
<a id="af1b654a57098d16dd2d08efaa949ffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b654a57098d16dd2d08efaa949ffe3">&#9670;&nbsp;</a></span>require_block_var_bound_predicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::require_block_var_bound_predicate = &quot;require_bound_predicate&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the block need to add predicate for block var bounds during lowering. </p>

</div>
</div>
<a id="a5d0392acd85eb3cd406315d3c02eadd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0392acd85eb3cd406315d3c02eadd8">&#9670;&nbsp;</a></span>rolling_buffer_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::rolling_buffer_scope = &quot;rolling_buffer_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark realization for rolling buffer optimization. </p>

</div>
</div>
<a id="af18e3a9ba11d436e02b55e420647b22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18e3a9ba11d436e02b55e420647b22b">&#9670;&nbsp;</a></span>scan_init_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_init_scope = &quot;scan_init_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan init scope. </p>

</div>
</div>
<a id="a84f5d42e968fd8f4cdd7a4aac7ba2137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f5d42e968fd8f4cdd7a4aac7ba2137">&#9670;&nbsp;</a></span>scan_update_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::scan_update_scope = &quot;scan_update_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan update scope. </p>

</div>
</div>
<a id="a3c66b2c968e985c3f4264979c18622e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c66b2c968e985c3f4264979c18622e8">&#9670;&nbsp;</a></span>script_parsing_detect_access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::script_parsing_detect_access = &quot;tir.script_parsing_detect_access&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark whether the script-completer need to fill in missing access region during script parsing. </p>
<dl class="section note"><dt>Note</dt><dd>The result should be a integer mask with range [0, 4). if (mask &amp; 1) the read region should be detected, if (mask &amp; 2) the write region should be detected. </dd></dl>

</div>
</div>
<a id="a7ff3ec02ce6acef9dd5c20f1aacc19bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff3ec02ce6acef9dd5c20f1aacc19bc">&#9670;&nbsp;</a></span>software_pipeline_async_stages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::software_pipeline_async_stages = &quot;software_pipeline_async_stages&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List stages in the software pipeline that should run asynchronously. </p>
<dl class="section note"><dt>Note</dt><dd>All statements in the provided stages are assumed to have asynchronous semantics (e.g. CUDA async global to shared memory copy). </dd></dl>

</div>
</div>
<a id="a064b547bf5b0579f9b42906c6a9c581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064b547bf5b0579f9b42906c6a9c581d">&#9670;&nbsp;</a></span>software_pipeline_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::software_pipeline_order = &quot;software_pipeline_order&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the order of a statement in the software pipeline. </p>

</div>
</div>
<a id="a2e695603b89f78f4a481817dbaf7a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e695603b89f78f4a481817dbaf7a082">&#9670;&nbsp;</a></span>software_pipeline_stage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::software_pipeline_stage = &quot;software_pipeline_stage&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the stage of a statement in the software pipeline. </p>

</div>
</div>
<a id="af27d464f2065dc5f77408df7b94d4bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27d464f2065dc5f77408df7b94d4bb6">&#9670;&nbsp;</a></span>storage_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::storage_alignment = &quot;storage_alignment&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage alignment requirement of buffers. </p>

</div>
</div>
<a id="a399eed804ecc482a607f0f65f07b78dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399eed804ecc482a607f0f65f07b78dd">&#9670;&nbsp;</a></span>thread_extent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::thread_extent = &quot;thread_extent&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching extent of thread, used by device API. </p>

</div>
</div>
<a id="a7a5ec1a12abbc199795176f1da4f9fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5ec1a12abbc199795176f1da4f9fb9">&#9670;&nbsp;</a></span>vector_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::vector_bytes = &quot;vector_bytes&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark vectorization length constraint on block. </p>

</div>
</div>
<a id="a464533c1560ace5e0b5071ba6902482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464533c1560ace5e0b5071ba6902482e">&#9670;&nbsp;</a></span>virtual_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::virtual_thread = &quot;virtual_thread&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching of a virtual thread. </p>

</div>
</div>
<a id="a14c2370f3a08792a6aaf70d7a3c773e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2370f3a08792a6aaf70d7a3c773e4">&#9670;&nbsp;</a></span>volatile_scope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::volatile_scope = &quot;volatile_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as volatile access for certain handle. </p>

</div>
</div>
<a id="a350f417c4c3ed61f4578c5e5cb72d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350f417c4c3ed61f4578c5e5cb72d667">&#9670;&nbsp;</a></span>warp_execution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::tir::attr::warp_execution = &quot;warp_execution&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that a block is executed by a warp. This implies the extend of threadIdx.x is warp size. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
