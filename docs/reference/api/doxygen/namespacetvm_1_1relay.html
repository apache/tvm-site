<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relay Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Relay: a high level functional IR for TVM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1relay_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of the attributes that can be attached to a <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">relay::Function</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1qnn"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1qnn.html">qnn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AdaptivePool1DAttrs.html">AdaptivePool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1d adaptive pool operator.  <a href="structtvm_1_1relay_1_1AdaptivePool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AdaptivePool2DAttrs.html">AdaptivePool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 2d adaptive pool operator.  <a href="structtvm_1_1relay_1_1AdaptivePool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AdaptivePool3DAttrs.html">AdaptivePool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3d adaptive pool operator.  <a href="structtvm_1_1relay_1_1AdaptivePool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AffineGridAttrs.html">AffineGridAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image affine_grid operator.  <a href="structtvm_1_1relay_1_1AffineGridAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AllClassNonMaximumSuppressionAttrs.html">AllClassNonMaximumSuppressionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in all_class_non_maximum_suppression operator.  <a href="structtvm_1_1relay_1_1AllClassNonMaximumSuppressionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AllocStorageAttrs.html">AllocStorageAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for allocating storage.  <a href="structtvm_1_1relay_1_1AllocStorageAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AllocTensorAttrs.html">AllocTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for allocating tensors.  <a href="structtvm_1_1relay_1_1AllocTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1AltPattern.html">AltPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches either of two patterns.  <a href="classtvm_1_1relay_1_1AltPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1AltPatternNode.html">AltPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Alternate Expressions.  <a href="classtvm_1_1relay_1_1AltPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArangeAttrs.html">ArangeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in arange operators.  <a href="structtvm_1_1relay_1_1ArangeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArgReduceAttrs.html">ArgReduceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Reduce operators which reduce by finding a single element. E.g. argmin.  <a href="structtvm_1_1relay_1_1ArgReduceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArgsortAttrs.html">ArgsortAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in argsort operators.  <a href="structtvm_1_1relay_1_1ArgsortAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1AttrPattern.html">AttrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches attributes in another pattern.  <a href="classtvm_1_1relay_1_1AttrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1AttrPatternNode.html">AttrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Attributes.  <a href="classtvm_1_1relay_1_1AttrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AutoSchedulerLayoutTransformAttrs.html">AutoSchedulerLayoutTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for AutoSchedulerLayoutTransform operator.  <a href="structtvm_1_1relay_1_1AutoSchedulerLayoutTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool1DAttrs.html">AvgPool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1D avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool2DAttrs.html">AvgPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool3DAttrs.html">AvgPool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3D avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BatchMatmulAttrs.html">BatchMatmulAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for batch matmul operator.  <a href="structtvm_1_1relay_1_1BatchMatmulAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BatchNormAttrs.html">BatchNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in batch_norm operator.  <a href="structtvm_1_1relay_1_1BatchNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BatchToSpaceNDAttrs.html">BatchToSpaceNDAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in BatchToSpaceND operator.  <a href="structtvm_1_1relay_1_1BatchToSpaceNDAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BiasAddAttrs.html">BiasAddAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a 1D Tensor to an axis of a data.  <a href="structtvm_1_1relay_1_1BiasAddAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BinaryConv2DAttrs.html">BinaryConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribues used in bitserial convolution operators.  <a href="structtvm_1_1relay_1_1BinaryConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BinaryDenseAttrs.html">BinaryDenseAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BitPackAttrs.html">BitPackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in bitpack operators.  <a href="structtvm_1_1relay_1_1BitPackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CallLoweredAttrs.html">CallLoweredAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata for calls to TIR functions, useful for program analysis crossing Relay and TIR.  <a href="structtvm_1_1relay_1_1CallLoweredAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> container.  <a href="classtvm_1_1relay_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1CallPattern.html">CallPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1CallPatternNode.html">CallPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1CallPattern.html">CallPattern</a> container.  <a href="classtvm_1_1relay_1_1CallPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CastAttrs.html">CastAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type cast  <a href="structtvm_1_1relay_1_1CastAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CastHintAttrs.html">CastHintAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate an expression to be cast into specific data type.  <a href="structtvm_1_1relay_1_1CastHintAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ClauseNode.html">ClauseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> container node.  <a href="classtvm_1_1relay_1_1ClauseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ClipAttrs.html">ClipAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Clip operator.  <a href="structtvm_1_1relay_1_1ClipAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CompilerAttrs.html">CompilerAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the operators used to annotate a compiler.  <a href="structtvm_1_1relay_1_1CompilerAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConcatenateAttrs.html">ConcatenateAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in concatenate operators.  <a href="structtvm_1_1relay_1_1ConcatenateAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstantNode.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a> tensor type.  <a href="classtvm_1_1relay_1_1ConstantNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstantPattern.html">ConstantPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstantPatternNode.html">ConstantPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a>.  <a href="classtvm_1_1relay_1_1ConstantPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstructorValue.html">ConstructorValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConstructorValueObj.html">ConstructorValueObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv1DAttrs.html">Conv1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in 1D convolution operators.  <a href="structtvm_1_1relay_1_1Conv1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv1DTransposeAttrs.html">Conv1DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in 1D transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv1DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DAttrs.html">Conv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators.  <a href="structtvm_1_1relay_1_1Conv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html">Conv2DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html">Conv2DWinogradAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators with winograd algorithm.  <a href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html">Conv2DWinogradNNPACKWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv3DAttrs.html">Conv3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators.  <a href="structtvm_1_1relay_1_1Conv3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv3DTransposeAttrs.html">Conv3DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv3DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv3DWinogradAttrs.html">Conv3DWinogradAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in 3d winograd convolution operators.  <a href="structtvm_1_1relay_1_1Conv3DWinogradAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConvGemmWeightTransformAttrs.html">ConvGemmWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in gemm weight transformation operators.  <a href="structtvm_1_1relay_1_1ConvGemmWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConvWinogradWeightTransformAttrs.html">ConvWinogradWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1ConvWinogradWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CorrelationAttrs.html">CorrelationAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in correlation operators.  <a href="structtvm_1_1relay_1_1CorrelationAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CropAndResizeAttrs.html">CropAndResizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image crop_and_resize operator.  <a href="structtvm_1_1relay_1_1CropAndResizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DataTypePattern.html">DataTypePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches a type in another pattern.  <a href="classtvm_1_1relay_1_1DataTypePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DataTypePatternNode.html">DataTypePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Types.  <a href="classtvm_1_1relay_1_1DataTypePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DebugAttrs.html">DebugAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the debug operators.  <a href="structtvm_1_1relay_1_1DebugAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html">DeformableConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for DeformableConv2D operator.  <a href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DenseAttrs.html">DenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for dense operator.  <a href="structtvm_1_1relay_1_1DenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DensePackAttrs.html">DensePackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for dense_pack operator.  <a href="structtvm_1_1relay_1_1DensePackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeviceCopyAttrs.html">DeviceCopyAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the device copy operators.  <a href="structtvm_1_1relay_1_1DeviceCopyAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to dataflow patterns.  <a href="classtvm_1_1relay_1_1DFPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternCallback.html">DFPatternCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to dataflow pattern callbacks.  <a href="classtvm_1_1relay_1_1DFPatternCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternCallbackNode.html">DFPatternCallbackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all dataflow pattern callbacks.  <a href="classtvm_1_1relay_1_1DFPatternCallbackNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternFunctor.html">DFPatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first <a class="el" href="classtvm_1_1relay_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> argument.  <a href="classtvm_1_1relay_1_1DFPatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternFunctor_3_01R_07const_01DFPattern_01_6n_00_01Args_8_8_8_08_4.html">DFPatternFunctor&lt; R(const DFPattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternNode.html">DFPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all dataflow patterns.  <a href="classtvm_1_1relay_1_1DFPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DFPatternVisitor.html">DFPatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1DFPatternFunctor.html" title="A dynamical functor that dispatches on in the first DFPattern argument. ">DFPatternFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relay_1_1DFPatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DilateAttrs.html">DilateAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dilate operator.  <a href="structtvm_1_1relay_1_1DilateAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Dilation2DAttrs.html">Dilation2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dilation operators.  <a href="structtvm_1_1relay_1_1Dilation2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DominatorPattern.html">DominatorPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches a variable length dominator path.  <a href="classtvm_1_1relay_1_1DominatorPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1DominatorPatternNode.html">DominatorPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dominated Graph <a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> <a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for fuzzy subgraphs where all outputs of the parent are used finally by the child, and every operation between the parent and the child matches the path.  <a href="classtvm_1_1relay_1_1DominatorPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DropoutAttrs.html">DropoutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dropout operator.  <a href="structtvm_1_1relay_1_1DropoutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DynExpandDimsAttrs.html">DynExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dynamic expand_dims operators.  <a href="structtvm_1_1relay_1_1DynExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1EinsumAttrs.html">EinsumAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in einsum operator.  <a href="structtvm_1_1relay_1_1EinsumAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference class to <a class="el" href="classtvm_1_1relay_1_1ExecutorNode.html" title="Executor information. ">ExecutorNode</a>.  <a href="classtvm_1_1relay_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExecutorNode.html">ExecutorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Executor.html" title="Managed reference class to ExecutorNode. ">Executor</a> information.  <a href="classtvm_1_1relay_1_1ExecutorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExecutorRegEntry.html">ExecutorRegEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to register Executors.  <a href="classtvm_1_1relay_1_1ExecutorRegEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ExpandDimsAttrs.html">ExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in expand_dims operators.  <a href="structtvm_1_1relay_1_1ExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>.  <a href="classtvm_1_1relay_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprPattern.html">ExprPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches a literal expression.  <a href="classtvm_1_1relay_1_1ExprPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprPatternNode.html">ExprPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Relay Expression.  <a href="classtvm_1_1relay_1_1ExprPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprRewriter.html">ExprRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-iterating Expression Rewriter.  <a href="classtvm_1_1relay_1_1ExprRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relay_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A finite set of Feature.  <a href="classtvm_1_1relay_1_1FeatureSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1FIFOBufferAttrs.html">FIFOBufferAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for FIFO buffer operator.  <a href="structtvm_1_1relay_1_1FIFOBufferAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1FixedPointMultiplyAttrs.html">FixedPointMultiplyAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for FixedPointMultiply operator.  <a href="structtvm_1_1relay_1_1FixedPointMultiplyAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relay_1_1FunctionNode.html" title="Relay Function container. ">FunctionNode</a>.  <a href="classtvm_1_1relay_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FunctionNode.html">FunctionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relay <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> container.  <a href="classtvm_1_1relay_1_1FunctionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FunctionPattern.html">FunctionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relay_1_1FunctionNode.html" title="Relay Function container. ">FunctionNode</a>.  <a href="classtvm_1_1relay_1_1FunctionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FunctionPatternNode.html">FunctionPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relay <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> container.  <a href="classtvm_1_1relay_1_1FunctionPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GatherAttrs.html">GatherAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GatherNDAttrs.html">GatherNDAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GetValidCountsAttrs.html">GetValidCountsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in get_valid_counts operator.  <a href="structtvm_1_1relay_1_1GetValidCountsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html">GlobalPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for global pool operator.  <a href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GridSampleAttrs.html">GridSampleAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image grid_sample operator.  <a href="structtvm_1_1relay_1_1GridSampleAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GroupNormAttrs.html">GroupNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in group_norm operator.  <a href="structtvm_1_1relay_1_1GroupNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IdNode.html">IdNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier of variables.  <a href="classtvm_1_1relay_1_1IdNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IfNode.html">IfNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of <a class="el" href="classtvm_1_1relay_1_1If.html">If</a>  <a href="classtvm_1_1relay_1_1IfNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IfPattern.html">IfPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IfPatternNode.html">IfPatternNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1InitOpAttrs.html">InitOpAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes that specify a tensor.  <a href="structtvm_1_1relay_1_1InitOpAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1InstanceNormAttrs.html">InstanceNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in instance_norm operator.  <a href="structtvm_1_1relay_1_1InstanceNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1InterpreterClosure.html">InterpreterClosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1InterpreterClosureObj.html">InterpreterClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container type of Closures used by the interpreter.  <a href="classtvm_1_1relay_1_1InterpreterClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1L2NormalizeAttrs.html">L2NormalizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for L2Normalize operator.  <a href="structtvm_1_1relay_1_1L2NormalizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LayerNormAttrs.html">LayerNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in layer_norm operator.  <a href="structtvm_1_1relay_1_1LayerNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LayoutTransformAttrs.html">LayoutTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LayoutTransform operator.  <a href="structtvm_1_1relay_1_1LayoutTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LeakyReluAttrs.html">LeakyReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for leaky relu operator.  <a href="structtvm_1_1relay_1_1LeakyReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding of a sub-network.  <a href="classtvm_1_1relay_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1LetPattern.html">LetPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a> binding that binds a local var.  <a href="classtvm_1_1relay_1_1LetPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1LetPatternNode.html">LetPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding of a sub-network.  <a href="classtvm_1_1relay_1_1LetPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LRNAttrs.html">LRNAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LRN operator.  <a href="structtvm_1_1relay_1_1LRNAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1MatchNode.html">MatchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> container node.  <a href="classtvm_1_1relay_1_1MatchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MatmulAttrs.html">MatmulAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for matmul operator.  <a href="structtvm_1_1relay_1_1MatmulAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MatrixSetDiagAttrs.html">MatrixSetDiagAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in matrix_set_diag operator.  <a href="structtvm_1_1relay_1_1MatrixSetDiagAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool1DAttrs.html">MaxPool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1D max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool2DAttrs.html">MaxPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool3DAttrs.html">MaxPool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3D max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MeshgridAttrs.html">MeshgridAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in meshgrid operators.  <a href="structtvm_1_1relay_1_1MeshgridAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MirrorPadAttrs.html">MirrorPadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the MirrorPadding operator.  <a href="structtvm_1_1relay_1_1MirrorPadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1MixedModeMutator.html">MixedModeMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-recursive DFS Graph Traversal for Custom Rewriting Passes.  <a href="classtvm_1_1relay_1_1MixedModeMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1MixedModeVisitor.html">MixedModeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprVisitor.html" title="A simple visitor wrapper around ExprFunctor. Recursively visit the content. ">ExprVisitor</a> which traverses the Dataflow Normal AST.  <a href="classtvm_1_1relay_1_1MixedModeVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html">MultiBoxPriorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in multibox_prior operators.  <a href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxTransformLocAttrs.html">MultiBoxTransformLocAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NdarraySizeAttrs.html">NdarraySizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for ndarray_size operator.  <a href="structtvm_1_1relay_1_1NdarraySizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NLLLossAttrs.html">NLLLossAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in NLLLoss operator.  <a href="structtvm_1_1relay_1_1NLLLossAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html">NonMaximumSuppressionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in non_maximum_suppression operator.  <a href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NormalAttrs.html">NormalAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1OnDeviceAttrs.html">OnDeviceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for the "on_device" annotation (ie operator).  <a href="structtvm_1_1relay_1_1OnDeviceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1OneHotAttrs.html">OneHotAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in one-hot operator.  <a href="structtvm_1_1relay_1_1OneHotAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpImplementation.html">OpImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation class.  <a href="classtvm_1_1relay_1_1OpImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpImplementationNode.html">OpImplementationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation that includes compute and schedule function.  <a href="classtvm_1_1relay_1_1OpImplementationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpSpecialization.html">OpSpecialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator specialization class.  <a href="classtvm_1_1relay_1_1OpSpecialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpSpecializationNode.html">OpSpecializationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized implementations for operators under certain conditions.  <a href="classtvm_1_1relay_1_1OpSpecializationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpStrategy.html">OpStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator strategy class.  <a href="classtvm_1_1relay_1_1OpStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpStrategyNode.html">OpStrategyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator strategy to choose implementation.  <a href="classtvm_1_1relay_1_1OpStrategyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PadAttrs.html">PadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the padding operator.  <a href="structtvm_1_1relay_1_1PadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> is the base type for an ADT match pattern in Relay.  <a href="classtvm_1_1relay_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructor.html">PatternConstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructorNode.html">PatternConstructorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternConstructorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html">PatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more powerful visitor, since it allows you to define the types of further arguments to VisitPattern.  <a href="classtvm_1_1relay_1_1PatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor_3_01R_07const_01Pattern_01_6n_00_01Args_8_8_8_08_4.html">PatternFunctor&lt; R(const Pattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternMutator.html">PatternMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1PatternMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternNode.html">PatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for declaring relay pattern.  <a href="classtvm_1_1relay_1_1PatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternTuple.html">PatternTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternTupleNode.html">PatternTupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternTupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVarNode.html">PatternVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVisitor.html">PatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html" title="A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more...">PatternFunctor</a>.  <a href="classtvm_1_1relay_1_1PatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcardNode.html">PatternWildcardNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a> container node.  <a href="classtvm_1_1relay_1_1PatternWildcardNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PReluAttrs.html">PReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for prelu operator.  <a href="structtvm_1_1relay_1_1PReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ProposalAttrs.html">ProposalAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in proposal operators.  <a href="structtvm_1_1relay_1_1ProposalAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RecClosure.html">RecClosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RecClosureObj.html">RecClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container type of <a class="el" href="classtvm_1_1relay_1_1RecClosure.html">RecClosure</a>.  <a href="classtvm_1_1relay_1_1RecClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReduceAttrs.html">ReduceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Reduce operators.  <a href="structtvm_1_1relay_1_1ReduceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreateNode.html">RefCreateNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefReadNode.html">RefReadNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefValue.html">RefValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RefValueObj.html">RefValueObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWriteNode.html">RefWriteNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RelayNode.html">RelayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base node container of all relay structures.  <a href="classtvm_1_1relay_1_1RelayNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RepeatAttrs.html">RepeatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in repeat operators.  <a href="structtvm_1_1relay_1_1RepeatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReshapeAttrs.html">ReshapeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reshape operators.  <a href="structtvm_1_1relay_1_1ReshapeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReshapeLikeAttrs.html">ReshapeLikeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in MXNet-style reshape_like operators.  <a href="structtvm_1_1relay_1_1ReshapeLikeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReshapeTensorAttrs.html">ReshapeTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for VM reshape_tensor operator.  <a href="structtvm_1_1relay_1_1ReshapeTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Resize1DAttrs.html">Resize1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize1d operator.  <a href="structtvm_1_1relay_1_1Resize1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Resize2DAttrs.html">Resize2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize2d operator.  <a href="structtvm_1_1relay_1_1Resize2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Resize3DAttrs.html">Resize3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize3d operator.  <a href="structtvm_1_1relay_1_1Resize3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReverseAttrs.html">ReverseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reverse operators.  <a href="structtvm_1_1relay_1_1ReverseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReverseSequenceAttrs.html">ReverseSequenceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reverse_sequence operators.  <a href="structtvm_1_1relay_1_1ReverseSequenceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIAlignAttrs.html">ROIAlignAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_align operators.  <a href="structtvm_1_1relay_1_1ROIAlignAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIPoolAttrs.html">ROIPoolAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_pool operators.  <a href="structtvm_1_1relay_1_1ROIPoolAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Runtime.html">Runtime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference class to <a class="el" href="classtvm_1_1relay_1_1RuntimeNode.html" title="Runtime information. ">RuntimeNode</a>.  <a href="classtvm_1_1relay_1_1Runtime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RuntimeNode.html">RuntimeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Runtime.html" title="Managed reference class to RuntimeNode. ">Runtime</a> information.  <a href="classtvm_1_1relay_1_1RuntimeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RuntimeRegEntry.html">RuntimeRegEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to register Runtimes.  <a href="classtvm_1_1relay_1_1RuntimeRegEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ScanopAttrs.html">ScanopAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in cumsum and cumprod operator.  <a href="structtvm_1_1relay_1_1ScanopAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ScatterAddAttrs.html">ScatterAddAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ScatterAttrs.html">ScatterAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ScatterNDAttrs.html">ScatterNDAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SearchSortedAttrs.html">SearchSortedAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SequenceMaskAttrs.html">SequenceMaskAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ShapeFuncAttrs.html">ShapeFuncAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the shape function operator.  <a href="structtvm_1_1relay_1_1ShapeFuncAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ShapeOfAttrs.html">ShapeOfAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for ShapeOf operator.  <a href="structtvm_1_1relay_1_1ShapeOfAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ShapePattern.html">ShapePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches a type in another pattern.  <a href="classtvm_1_1relay_1_1ShapePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ShapePatternNode.html">ShapePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Shapes.  <a href="classtvm_1_1relay_1_1ShapePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SliceLikeAttrs.html">SliceLikeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SlidingWindowAttrs.html">SlidingWindowAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the sliding_window operator.  <a href="structtvm_1_1relay_1_1SlidingWindowAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SoftmaxAttrs.html">SoftmaxAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relay_1_1SoftmaxAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SpaceToBatchNDAttrs.html">SpaceToBatchNDAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in SpaceToBatchND operator.  <a href="structtvm_1_1relay_1_1SpaceToBatchNDAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseConv2DAttrs.html">SparseConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for sparse_dense operator.  <a href="structtvm_1_1relay_1_1SparseConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseDenseAttrs.html">SparseDenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for sparse_dense operator.  <a href="structtvm_1_1relay_1_1SparseDenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseToDenseAttrs.html">SparseToDenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in sparse_to_dense operator.  <a href="structtvm_1_1relay_1_1SparseToDenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseTransposeAttrs.html">SparseTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for sparse_transpose operator.  <a href="structtvm_1_1relay_1_1SparseTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SplitAttrs.html">SplitAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SqueezeAttrs.html">SqueezeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in squeeze operators.  <a href="structtvm_1_1relay_1_1SqueezeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StackAttrs.html">StackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in stack operators.  <a href="structtvm_1_1relay_1_1StackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StridedSliceAttrs.html">StridedSliceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for StridedSlice operator.  <a href="structtvm_1_1relay_1_1StridedSliceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SubPixelAttrs.html">SubPixelAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in subpixel operators.  <a href="structtvm_1_1relay_1_1SubPixelAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TakeAttrs.html">TakeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExprNode.html">TempExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of the temporary expression.  <a href="classtvm_1_1relay_1_1TempExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ThreefryGenerateAttrs.html">ThreefryGenerateAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TileAttrs.html">TileAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tile operators.  <a href="structtvm_1_1relay_1_1TileAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TopKAttrs.html">TopKAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TransposeAttrs.html">TransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transpose operators.  <a href="structtvm_1_1relay_1_1TransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItemNode.html">TupleGetItemNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItemPattern.html">TupleGetItemPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItemPatternNode.html">TupleGetItemPatternNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleNode.html">TupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relay_1_1TupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TuplePattern.html">TuplePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TuplePatternNode.html">TuplePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relay_1_1TuplePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypePattern.html">TypePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches a type in another pattern.  <a href="classtvm_1_1relay_1_1TypePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypePatternNode.html">TypePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> for Types.  <a href="classtvm_1_1relay_1_1TypePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UniformAttrs.html">UniformAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UniqueAttrs.html">UniqueAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in unique operator.  <a href="structtvm_1_1relay_1_1UniqueAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UpSampling3DAttrs.html">UpSampling3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for upsampling3d operator.  <a href="structtvm_1_1relay_1_1UpSampling3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UpSamplingAttrs.html">UpSamplingAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for upsampling operator.  <a href="structtvm_1_1relay_1_1UpSamplingAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1v__info.html">v_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to keep info of traversed expr in ExpandDataflow function.  <a href="structtvm_1_1relay_1_1v__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1VarianceAttrs.html">VarianceAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>.  <a href="classtvm_1_1relay_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1VarPattern.html">VarPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1VarPatternNode.html">VarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>.  <a href="classtvm_1_1relay_1_1VarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1WildcardPattern.html">WildcardPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern which matches anything.  <a href="classtvm_1_1relay_1_1WildcardPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1WildcardPatternNode.html">WildcardPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wildcard <a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a>.  <a href="classtvm_1_1relay_1_1WildcardPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1YoloReorgAttrs.html">YoloReorgAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in yolo reorg operators.  <a href="structtvm_1_1relay_1_1YoloReorgAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aec85bf097deda59bd22e88475c9165e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aec85bf097deda59bd22e88475c9165e9">Constructor</a> = <a class="el" href="classtvm_1_1Constructor.html">tvm::Constructor</a></td></tr>
<tr class="separator:aec85bf097deda59bd22e88475c9165e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b95f70a9b44cc1c96593201594d1345"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b95f70a9b44cc1c96593201594d1345">ConstructorNode</a> = <a class="el" href="classtvm_1_1ConstructorNode.html">tvm::ConstructorNode</a></td></tr>
<tr class="separator:a6b95f70a9b44cc1c96593201594d1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e725a1cb4c83346e261eac7dc7292a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">TypeData</a> = <a class="el" href="classtvm_1_1TypeData.html">tvm::TypeData</a></td></tr>
<tr class="separator:a6e725a1cb4c83346e261eac7dc7292a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8c0d5920eaca88569907e92df6066f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2b8c0d5920eaca88569907e92df6066f">TypeDataNode</a> = <a class="el" href="classtvm_1_1TypeDataNode.html">tvm::TypeDataNode</a></td></tr>
<tr class="separator:a2b8c0d5920eaca88569907e92df6066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae153a27d81399fd266b8d598227764c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> = ::<a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a></td></tr>
<tr class="memdesc:ae153a27d81399fd266b8d598227764c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression for tensor shape.  <a href="#ae153a27d81399fd266b8d598227764c4">More...</a><br /></td></tr>
<tr class="separator:ae153a27d81399fd266b8d598227764c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eacafcb803b0757e48654bb1bac655"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a14eacafcb803b0757e48654bb1bac655">SourceName</a> = <a class="el" href="classtvm_1_1SourceName.html">tvm::SourceName</a></td></tr>
<tr class="separator:a14eacafcb803b0757e48654bb1bac655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ca6124bc2e88f2323eeb79d326cc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> = <a class="el" href="classtvm_1_1Span.html">tvm::Span</a></td></tr>
<tr class="separator:af40ca6124bc2e88f2323eeb79d326cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0fa6578e97d0d64b08865f94f04827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7d0fa6578e97d0d64b08865f94f04827">SpanNode</a> = <a class="el" href="classtvm_1_1SpanNode.html">tvm::SpanNode</a></td></tr>
<tr class="separator:a7d0fa6578e97d0d64b08865f94f04827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e3790f89bb3fad5c7911eeb99531"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> = <a class="el" href="classtvm_1_1RelayExpr.html">tvm::RelayExpr</a></td></tr>
<tr class="separator:a5b84e3790f89bb3fad5c7911eeb99531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387f18e050d016c52ea6c4781e7cff6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a387f18e050d016c52ea6c4781e7cff6c">ExprNode</a> = <a class="el" href="classtvm_1_1RelayExprNode.html">tvm::RelayExprNode</a></td></tr>
<tr class="separator:a387f18e050d016c52ea6c4781e7cff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaff2ae7feec23fea55e025a9cc1b76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">BaseFunc</a> = <a class="el" href="classtvm_1_1BaseFunc.html">tvm::BaseFunc</a></td></tr>
<tr class="separator:acbaff2ae7feec23fea55e025a9cc1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf28d1226abc08d28bc2fd90ce7b42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4edf28d1226abc08d28bc2fd90ce7b42">BaseFuncNode</a> = <a class="el" href="classtvm_1_1BaseFuncNode.html">tvm::BaseFuncNode</a></td></tr>
<tr class="separator:a4edf28d1226abc08d28bc2fd90ce7b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac7c3d0824529fddce7849c9c66289"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a> = <a class="el" href="classtvm_1_1GlobalVar.html">tvm::GlobalVar</a></td></tr>
<tr class="separator:a81ac7c3d0824529fddce7849c9c66289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7144195dbbc914183189444ef6a347"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afe7144195dbbc914183189444ef6a347">GlobalVarNode</a> = <a class="el" href="classtvm_1_1GlobalVarNode.html">tvm::GlobalVarNode</a></td></tr>
<tr class="separator:afe7144195dbbc914183189444ef6a347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46d15e80f1a9916b8e9c264a185c98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6c46d15e80f1a9916b8e9c264a185c98">Op</a> = <a class="el" href="classtvm_1_1Op.html">tvm::Op</a></td></tr>
<tr class="separator:a6c46d15e80f1a9916b8e9c264a185c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4f2cf78a48659817a88d890e1d142"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac9d4f2cf78a48659817a88d890e1d142">OpNode</a> = <a class="el" href="classtvm_1_1OpNode.html">tvm::OpNode</a></td></tr>
<tr class="separator:ac9d4f2cf78a48659817a88d890e1d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">TOpPattern</a> = int</td></tr>
<tr class="memdesc:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">the operator pattern  <a href="#a5dab2ddae20ac7564a81ab3a0a9aba76">More...</a><br /></td></tr>
<tr class="separator:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">TOpIsStateful</a> = bool</td></tr>
<tr class="memdesc:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether operator is stateful or contain internal state.  <a href="#afb8a8d4dd43830d4ce7d566abcd1c450">More...</a><br /></td></tr>
<tr class="separator:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">TNonComputational</a> = bool</td></tr>
<tr class="memdesc:ab4c835287dfc5ec074ea8431bcebbb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator as non-computational.  <a href="#ab4c835287dfc5ec074ea8431bcebbb17">More...</a><br /></td></tr>
<tr class="separator:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c86efe3d58b34726786cfe79f616191"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7c86efe3d58b34726786cfe79f616191">TReshapeOp</a> = bool</td></tr>
<tr class="memdesc:a7c86efe3d58b34726786cfe79f616191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator as reshape op of its first input and can be turned into a nop when the first input and output shares the same piece of memory.  <a href="#a7c86efe3d58b34726786cfe79f616191">More...</a><br /></td></tr>
<tr class="separator:a7c86efe3d58b34726786cfe79f616191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75edb2b00671af1cf3274a5975ecba77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a75edb2b00671af1cf3274a5975ecba77">TShapeDataDependent</a> = <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;</td></tr>
<tr class="memdesc:a75edb2b00671af1cf3274a5975ecba77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator whether output shape is data dependent.  <a href="#a75edb2b00671af1cf3274a5975ecba77">More...</a><br /></td></tr>
<tr class="separator:a75edb2b00671af1cf3274a5975ecba77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f95ef6143dc33382f50734f85bfdf5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af3f95ef6143dc33382f50734f85bfdf5">FTVMCompute</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;inputs, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;out_type)&gt;</td></tr>
<tr class="memdesc:af3f95ef6143dc33382f50734f85bfdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation description interface.  <a href="#af3f95ef6143dc33382f50734f85bfdf5">More...</a><br /></td></tr>
<tr class="separator:af3f95ef6143dc33382f50734f85bfdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3d3515294c3128bb63a75c5d30f596"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aff3d3515294c3128bb63a75c5d30f596">FTVMSchedule</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;outs, const <a class="el" href="classtvm_1_1Target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="memdesc:aff3d3515294c3128bb63a75c5d30f596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the computation schedule for op whose root is at current op.  <a href="#aff3d3515294c3128bb63a75c5d30f596">More...</a><br /></td></tr>
<tr class="separator:aff3d3515294c3128bb63a75c5d30f596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2eb2ad4e7a83e0a28e2ad073d7bf9305">FTVMStrategy</a> = <a class="el" href="classtvm_1_1GenericFunc.html">GenericFunc</a></td></tr>
<tr class="memdesc:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the strategy of operators. This function is a generic function and can be re-defined for different targets.  <a href="#a2eb2ad4e7a83e0a28e2ad073d7bf9305">More...</a><br /></td></tr>
<tr class="separator:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fc035745cb16c86912e1c4155460d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a37fc035745cb16c86912e1c4155460d6">FTVMAlterOpLayout</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;tinfos, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;out_type)&gt;</td></tr>
<tr class="memdesc:a37fc035745cb16c86912e1c4155460d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass.  <a href="#a37fc035745cb16c86912e1c4155460d6">More...</a><br /></td></tr>
<tr class="separator:a37fc035745cb16c86912e1c4155460d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8104bb3261fbc781381333ddef526a3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a8104bb3261fbc781381333ddef526a3f">FTVMConvertOpLayout</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;tinfos, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; &amp;desired_layouts)&gt;</td></tr>
<tr class="memdesc:a8104bb3261fbc781381333ddef526a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the layout of operators or replace the operator with other expressions. This function will be invoked in ConvertLayout pass.  <a href="#a8104bb3261fbc781381333ddef526a3f">More...</a><br /></td></tr>
<tr class="separator:a8104bb3261fbc781381333ddef526a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac788c2310eb8aa5e2449dd8c9dfdf368"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac788c2310eb8aa5e2449dd8c9dfdf368">FTVMLegalize</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a> &gt; &amp;arg_types)&gt;</td></tr>
<tr class="memdesc:ac788c2310eb8aa5e2449dd8c9dfdf368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalizes an expression with another expression. This function will be invoked in Legalize pass. It is a target-dependent pass.  <a href="#ac788c2310eb8aa5e2449dd8c9dfdf368">More...</a><br /></td></tr>
<tr class="separator:ac788c2310eb8aa5e2449dd8c9dfdf368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c78601c3f13f31032b68ef27b528b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a01c78601c3f13f31032b68ef27b528b1">FTVMAnnotateTarget</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; bool(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)&gt;</td></tr>
<tr class="memdesc:a01c78601c3f13f31032b68ef27b528b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates an expression to indicate if an op should be compiled using the given compiler/target.  <a href="#a01c78601c3f13f31032b68ef27b528b1">More...</a><br /></td></tr>
<tr class="separator:a01c78601c3f13f31032b68ef27b528b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27c5a3fe1590a9ffa3877f9b09de45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afa27c5a3fe1590a9ffa3877f9b09de45">FForwardRewrite</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;ref_call, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;new_args, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:afa27c5a3fe1590a9ffa3877f9b09de45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward rewriting rule for a specific op.  <a href="#afa27c5a3fe1590a9ffa3877f9b09de45">More...</a><br /></td></tr>
<tr class="separator:afa27c5a3fe1590a9ffa3877f9b09de45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abada45a4f21ae750c1caba923f1059"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">FPrimalGradient</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;orig_call, const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;output_grad)&gt;</td></tr>
<tr class="memdesc:a9abada45a4f21ae750c1caba923f1059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient for a specific op.  <a href="#a9abada45a4f21ae750c1caba923f1059">More...</a><br /></td></tr>
<tr class="separator:a9abada45a4f21ae750c1caba923f1059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64348ae2b75977e167109fb4af4409"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4d64348ae2b75977e167109fb4af4409">Shape</a> = <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> &gt;</td></tr>
<tr class="memdesc:a4d64348ae2b75977e167109fb4af4409"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime representation of shape.  <a href="#a4d64348ae2b75977e167109fb4af4409">More...</a><br /></td></tr>
<tr class="separator:a4d64348ae2b75977e167109fb4af4409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeda9240bb23d0092992928c6d141729"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afeda9240bb23d0092992928c6d141729">FShapeFunc</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> &gt; &amp;out_ndims)&gt;</td></tr>
<tr class="separator:afeda9240bb23d0092992928c6d141729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c360628faf2eeb9de326634bc6e80e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a63c360628faf2eeb9de326634bc6e80e">AnyNode</a> = <a class="el" href="classtvm_1_1tir_1_1AnyNode.html">tvm::tir::AnyNode</a></td></tr>
<tr class="separator:a63c360628faf2eeb9de326634bc6e80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe473e7f103d7aa63b7b09fee09df932"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abe473e7f103d7aa63b7b09fee09df932">Any</a> = <a class="el" href="classtvm_1_1tir_1_1Any.html">tvm::tir::Any</a></td></tr>
<tr class="separator:abe473e7f103d7aa63b7b09fee09df932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e35e7d791c8dd53bb00ddb6411b38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa44e35e7d791c8dd53bb00ddb6411b38">Kind</a> = <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">TypeKind</a></td></tr>
<tr class="separator:aa44e35e7d791c8dd53bb00ddb6411b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d95f170bca230773914caeef3fe52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> = <a class="el" href="classtvm_1_1Type.html">tvm::Type</a></td></tr>
<tr class="separator:a661d95f170bca230773914caeef3fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6995f0c848d0d5cc4124a38f43aaf12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af6995f0c848d0d5cc4124a38f43aaf12">TypeNode</a> = <a class="el" href="classtvm_1_1TypeNode.html">tvm::TypeNode</a></td></tr>
<tr class="separator:af6995f0c848d0d5cc4124a38f43aaf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63321eb51080f3f57dd7563a3ca0bfa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> = <a class="el" href="classtvm_1_1TypeVar.html">tvm::TypeVar</a></td></tr>
<tr class="separator:a63321eb51080f3f57dd7563a3ca0bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cbe31b81ebd71ea8028a8404a7c9f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab2cbe31b81ebd71ea8028a8404a7c9f3">TypeVarNode</a> = <a class="el" href="classtvm_1_1TypeVarNode.html">tvm::TypeVarNode</a></td></tr>
<tr class="separator:ab2cbe31b81ebd71ea8028a8404a7c9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235e350f9cd1eac3aa0177034976043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">GlobalTypeVar</a> = <a class="el" href="classtvm_1_1GlobalTypeVar.html">tvm::GlobalTypeVar</a></td></tr>
<tr class="separator:a2235e350f9cd1eac3aa0177034976043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a10e2305e3a50dd00e07b043b93b5e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9a10e2305e3a50dd00e07b043b93b5e8">GlobalTypeVarNode</a> = <a class="el" href="classtvm_1_1GlobalTypeVarNode.html">tvm::GlobalTypeVarNode</a></td></tr>
<tr class="separator:a9a10e2305e3a50dd00e07b043b93b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9102638dffea6747ae9fa9be9f00f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ace9102638dffea6747ae9fa9be9f00f2">TupleType</a> = <a class="el" href="classtvm_1_1TupleType.html">tvm::TupleType</a></td></tr>
<tr class="separator:ace9102638dffea6747ae9fa9be9f00f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916609c894ac1000b66f9582f338d965"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a916609c894ac1000b66f9582f338d965">TupleTypeNode</a> = <a class="el" href="classtvm_1_1TupleTypeNode.html">tvm::TupleTypeNode</a></td></tr>
<tr class="separator:a916609c894ac1000b66f9582f338d965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2e93fe04716efd8334ab4e39c92ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a64e2e93fe04716efd8334ab4e39c92ce">TypeConstraint</a> = <a class="el" href="classtvm_1_1TypeConstraint.html">tvm::TypeConstraint</a></td></tr>
<tr class="separator:a64e2e93fe04716efd8334ab4e39c92ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565e027589acded20ca38df22be098dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a565e027589acded20ca38df22be098dc">TypeConstraintNode</a> = <a class="el" href="classtvm_1_1TypeConstraintNode.html">tvm::TypeConstraintNode</a></td></tr>
<tr class="separator:a565e027589acded20ca38df22be098dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475de90506d48a1bb04ef6d1bd99bfb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa475de90506d48a1bb04ef6d1bd99bfb">FuncType</a> = <a class="el" href="classtvm_1_1FuncType.html">tvm::FuncType</a></td></tr>
<tr class="separator:aa475de90506d48a1bb04ef6d1bd99bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab551714015417af28d5ca2b47722997e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab551714015417af28d5ca2b47722997e">FuncTypeNode</a> = <a class="el" href="classtvm_1_1FuncTypeNode.html">tvm::FuncTypeNode</a></td></tr>
<tr class="separator:ab551714015417af28d5ca2b47722997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34535a1f05224c26db569bc134de7647"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a34535a1f05224c26db569bc134de7647">IncompleteType</a> = <a class="el" href="classtvm_1_1IncompleteType.html">tvm::IncompleteType</a></td></tr>
<tr class="separator:a34535a1f05224c26db569bc134de7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ebee34b82bdb80f74ffcdcf361940"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a517ebee34b82bdb80f74ffcdcf361940">IncompleteTypeNode</a> = <a class="el" href="classtvm_1_1IncompleteTypeNode.html">tvm::IncompleteTypeNode</a></td></tr>
<tr class="separator:a517ebee34b82bdb80f74ffcdcf361940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd39dbc2a639262858e9b72e8fb37f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a13fd39dbc2a639262858e9b72e8fb37f">RelayRefType</a> = <a class="el" href="classtvm_1_1RelayRefType.html">tvm::RelayRefType</a></td></tr>
<tr class="separator:a13fd39dbc2a639262858e9b72e8fb37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae665239bd9119c8afb037d47781bf237"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae665239bd9119c8afb037d47781bf237">RelayRefTypeNode</a> = <a class="el" href="classtvm_1_1RelayRefTypeNode.html">tvm::RelayRefTypeNode</a></td></tr>
<tr class="separator:ae665239bd9119c8afb037d47781bf237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c13723bba53f4953dfd10c34d480f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">TensorType</a> = <a class="el" href="classtvm_1_1TensorType.html">tvm::TensorType</a></td></tr>
<tr class="separator:a52c13723bba53f4953dfd10c34d480f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeff91bc774a278a2e9f6103a04387d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acfeff91bc774a278a2e9f6103a04387d">TensorTypeNode</a> = <a class="el" href="classtvm_1_1TensorTypeNode.html">tvm::TensorTypeNode</a></td></tr>
<tr class="separator:acfeff91bc774a278a2e9f6103a04387d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406a37acee11226e3e2e119beee439e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab406a37acee11226e3e2e119beee439e">TypeCall</a> = <a class="el" href="classtvm_1_1TypeCall.html">tvm::TypeCall</a></td></tr>
<tr class="separator:ab406a37acee11226e3e2e119beee439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dccabc877b8fd7db47cb73fb93883e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af4dccabc877b8fd7db47cb73fb93883e">TypeCallNode</a> = <a class="el" href="classtvm_1_1TypeCallNode.html">tvm::TypeCallNode</a></td></tr>
<tr class="separator:af4dccabc877b8fd7db47cb73fb93883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0d56fd993df71df3068dea0cd5456"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#adab0d56fd993df71df3068dea0cd5456">TypeRelation</a> = <a class="el" href="classtvm_1_1TypeRelation.html">tvm::TypeRelation</a></td></tr>
<tr class="separator:adab0d56fd993df71df3068dea0cd5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d812eaf13520b04e89a9414c51748c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a89d812eaf13520b04e89a9414c51748c">TypeRelationNode</a> = <a class="el" href="classtvm_1_1TypeRelationNode.html">tvm::TypeRelationNode</a></td></tr>
<tr class="separator:a89d812eaf13520b04e89a9414c51748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af253112249297a6cfb2a9b94cde0f235"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af253112249297a6cfb2a9b94cde0f235">TypeRelationFn</a> = <a class="el" href="namespacetvm.html#a72dcba4493adfcd8908663898ece3514">tvm::TypeRelationFn</a></td></tr>
<tr class="separator:af253112249297a6cfb2a9b94cde0f235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9be9990c2006832cbfc02ebb35e527"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afa9be9990c2006832cbfc02ebb35e527">TypeReporter</a> = <a class="el" href="classtvm_1_1TypeReporter.html">tvm::TypeReporter</a></td></tr>
<tr class="separator:afa9be9990c2006832cbfc02ebb35e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3b5700ea20db399f539cec1abcb12b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaa3b5700ea20db399f539cec1abcb12b">TypeReporterNode</a> = <a class="el" href="classtvm_1_1TypeReporterNode.html">tvm::TypeReporterNode</a></td></tr>
<tr class="separator:aaa3b5700ea20db399f539cec1abcb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a926750aeda977340aa82bceac863fc9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">Feature</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea42a71e7934e2efe344713b17c426eecd">fVar</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eae9b152650b0ebe6dbc1b42e0f84d567f">fGlobalVar</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea29eacc09610a7fd43026682238aae25f">fConstant</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaa2fe12a180d97822c440e169dc287e66">fTuple</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4d2cb67f2e197880e0971286f2ffb498">fTupleGetItem</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea3b367d0501427ea782137266a2fb77fa">fFunction</a> = 5, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaca21bd0f67c01c6f7b82a1596cdfdf8b">fOp</a> = 6, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea5f3d3030d2ed56e5a47329e29f12ef02">fCall</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea07ce432e7b4b4c044af03e4dbd210ba4">fLet</a> = 8, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4e6b686fb15d50c4aef2316bef53a781">fIf</a> = 9, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea46daa677c87c05e68258acea3579443d">fRefCreate</a> = 10, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea7c9e5e3d738c26c3ed34099f44f66251">fRefRead</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4737da29588504f7f31cf4fb52925d63">fRefWrite</a> = 12, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaff71be930d862c312a5ae263e71167a2">fConstructor</a> = 13, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea53a8eba57c4a3abd37b4c96fb98bf61b">fMatch</a> = 14, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eac6392a0ecc7df38dbfa282a54d3718d1">fGraph</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaff508e399703958af46f99ee8eb7d1a5">fLetRec</a> = 16
<br />
 }<tr class="memdesc:a926750aeda977340aa82bceac863fc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different kinds of relay feature a program might use.  <a href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a926750aeda977340aa82bceac863fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">OpPatternKind</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa">kElemWise</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245">kBroadcast</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00">kInjective</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738">kCommReduce</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4">kOutEWiseFusable</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ae5610688419b90595a0701fe007a2ebb">kTuple</a> = 7, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1">kOpaque</a> = 8
<br />
 }<tr class="memdesc:ab5f4d382bf1bee69c3e484ea6c837578"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator pattern used in graph fusion  <a href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab76fedc831b249d1c80d69c4a620a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">AnyCodegenStrategy</a> { <a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3a1a3550732b0caf3981198af2c1373542">kVariableDimensions</a>
 }<tr class="memdesc:adab76fedc831b249d1c80d69c4a620a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The codegeneration strategy for dynamic dimensions.  <a href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adab76fedc831b249d1c80d69c4a620a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd80501d29e4d951be6746c79934a70c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acd80501d29e4d951be6746c79934a70c">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> clause, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &gt; opt_lhs=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_rhs=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;())</td></tr>
<tr class="memdesc:acd80501d29e4d951be6746c79934a70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the clause with given properties. A null property denotes 'no change'. Returns clause if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#acd80501d29e4d951be6746c79934a70c">More...</a><br /></td></tr>
<tr class="separator:acd80501d29e4d951be6746c79934a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb39b46f86b66a5e7252f6d9102deb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#adb39b46f86b66a5e7252f6d9102deb7b">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> match, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_data=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> &gt;&gt; opt_clauses=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Bool.html">Bool</a> &gt; opt_complete=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Bool.html">Bool</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:adb39b46f86b66a5e7252f6d9102deb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the match with given properties. A null property denotes 'no change'. Returns match if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#adb39b46f86b66a5e7252f6d9102deb7b">More...</a><br /></td></tr>
<tr class="separator:adb39b46f86b66a5e7252f6d9102deb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c09d2d83aa356218069b1def8046ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9c09d2d83aa356218069b1def8046ee7">KindCheck</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt; diag_ctx=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt;())</td></tr>
<tr class="memdesc:a9c09d2d83aa356218069b1def8046ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that types are well kinded by applying "kinding rules".  <a href="#a9c09d2d83aa356218069b1def8046ee7">More...</a><br /></td></tr>
<tr class="separator:a9c09d2d83aa356218069b1def8046ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdade48285a63efffe743e73e41d3b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abdade48285a63efffe743e73e41d3b35">ConstantCheck</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:abdade48285a63efffe743e73e41d3b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an expression is constant.  <a href="#abdade48285a63efffe743e73e41d3b35">More...</a><br /></td></tr>
<tr class="separator:abdade48285a63efffe743e73e41d3b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213c1d2fac14b9fa66d5d41bd261d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae213c1d2fac14b9fa66d5d41bd261d80">BasicBlockNormalFormCheck</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:ae213c1d2fac14b9fa66d5d41bd261d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an expression is in the basic block normal form.  <a href="#ae213c1d2fac14b9fa66d5d41bd261d80">More...</a><br /></td></tr>
<tr class="separator:ae213c1d2fac14b9fa66d5d41bd261d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4cdd4e3db74bf68b315d5730890ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4e4cdd4e3db74bf68b315d5730890ca8">WellFormed</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt; diag_ctx=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt;())</td></tr>
<tr class="memdesc:a4e4cdd4e3db74bf68b315d5730890ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once.  <a href="#a4e4cdd4e3db74bf68b315d5730890ca8">More...</a><br /></td></tr>
<tr class="separator:a4e4cdd4e3db74bf68b315d5730890ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc32688b446d3574932554f6b8c2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0bcc32688b446d3574932554f6b8c2df">BoundVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0bcc32688b446d3574932554f6b8c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="#a0bcc32688b446d3574932554f6b8c2df">More...</a><br /></td></tr>
<tr class="separator:a0bcc32688b446d3574932554f6b8c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb2b290b4f80292eb34afefc41f0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aedcb2b290b4f80292eb34afefc41f0ac">BoundVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &amp;pat)</td></tr>
<tr class="memdesc:aedcb2b290b4f80292eb34afefc41f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from pattern pat.  <a href="#aedcb2b290b4f80292eb34afefc41f0ac">More...</a><br /></td></tr>
<tr class="separator:aedcb2b290b4f80292eb34afefc41f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af2c5771c67f06c0af32c7b4b4269e73f">FreeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:af2c5771c67f06c0af32c7b4b4269e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="#af2c5771c67f06c0af32c7b4b4269e73f">More...</a><br /></td></tr>
<tr class="separator:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b1e94cf8d97514fe4a9493a0dec1559">AllVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="#a6b1e94cf8d97514fe4a9493a0dec1559">More...</a><br /></td></tr>
<tr class="separator:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc529cca9623ac81c8aa6e106cdb5850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acc529cca9623ac81c8aa6e106cdb5850">FreeTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:acc529cca9623ac81c8aa6e106cdb5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from expression expr.  <a href="#acc529cca9623ac81c8aa6e106cdb5850">More...</a><br /></td></tr>
<tr class="separator:acc529cca9623ac81c8aa6e106cdb5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446e2b12f3e907336313004c3e0a0c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a446e2b12f3e907336313004c3e0a0c86">FreeTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a446e2b12f3e907336313004c3e0a0c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from type t.  <a href="#a446e2b12f3e907336313004c3e0a0c86">More...</a><br /></td></tr>
<tr class="separator:a446e2b12f3e907336313004c3e0a0c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1e5aa65b13f8ca172009aa2ff3ba59d6">BoundTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from expression expr.  <a href="#a1e5aa65b13f8ca172009aa2ff3ba59d6">More...</a><br /></td></tr>
<tr class="separator:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419979c48a5e37cd969f6fd6d0fead4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a419979c48a5e37cd969f6fd6d0fead4b">BoundTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a419979c48a5e37cd969f6fd6d0fead4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from type t.  <a href="#a419979c48a5e37cd969f6fd6d0fead4b">More...</a><br /></td></tr>
<tr class="separator:a419979c48a5e37cd969f6fd6d0fead4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67484a25663dfe2f87cbad53075abbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae67484a25663dfe2f87cbad53075abbf">AllTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ae67484a25663dfe2f87cbad53075abbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in expression expr.  <a href="#ae67484a25663dfe2f87cbad53075abbf">More...</a><br /></td></tr>
<tr class="separator:ae67484a25663dfe2f87cbad53075abbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24361b252cdb636192641e6801f2666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad24361b252cdb636192641e6801f2666">AllTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ad24361b252cdb636192641e6801f2666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in type t.  <a href="#ad24361b252cdb636192641e6801f2666">More...</a><br /></td></tr>
<tr class="separator:ad24361b252cdb636192641e6801f2666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8cace40f8056fd6412f39c3eaa605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa3a8cace40f8056fd6412f39c3eaa605">UnmatchedCases</a> (const <a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> &amp;match, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:aa3a8cace40f8056fd6412f39c3eaa605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds cases that the given match expression does not catch, if any.  <a href="#aa3a8cace40f8056fd6412f39c3eaa605">More...</a><br /></td></tr>
<tr class="separator:aa3a8cace40f8056fd6412f39c3eaa605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d10acef75390fa6d1a5e64a379c5036"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2d10acef75390fa6d1a5e64a379c5036">GetExprRefCount</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;body)</td></tr>
<tr class="memdesc:a2d10acef75390fa6d1a5e64a379c5036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference counter of each internal ExprNode in body.  <a href="#a2d10acef75390fa6d1a5e64a379c5036">More...</a><br /></td></tr>
<tr class="separator:a2d10acef75390fa6d1a5e64a379c5036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe1324b2293679c40d1b53b668d3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aeffe1324b2293679c40d1b53b668d3d8">GetCalibrateModule</a> (<a class="el" href="classtvm_1_1IRModule.html">IRModule</a> mod)</td></tr>
<tr class="memdesc:aeffe1324b2293679c40d1b53b668d3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the updated module for collecting calibration data.  <a href="#aeffe1324b2293679c40d1b53b668d3d8">More...</a><br /></td></tr>
<tr class="separator:aeffe1324b2293679c40d1b53b668d3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c8195b0f8b74f23c433857cf34c5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a13c8195b0f8b74f23c433857cf34c5f7">GetCalibrateOutputMap</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a13c8195b0f8b74f23c433857cf34c5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output map between subgrpahs and its inputs/output.  <a href="#a13c8195b0f8b74f23c433857cf34c5f7">More...</a><br /></td></tr>
<tr class="separator:a13c8195b0f8b74f23c433857cf34c5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91168c24ecbf1cbf719d2ba28841da5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">TensorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a91168c24ecbf1cbf719d2ba28841da5c">FlattenTupleType</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;type)</td></tr>
<tr class="separator:a91168c24ecbf1cbf719d2ba28841da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef91b70db1053b9672eafe401abb7304"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aef91b70db1053b9672eafe401abb7304">FromTupleType</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;type, const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="separator:aef91b70db1053b9672eafe401abb7304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6757a008816e31cce4109e8dfc2bc16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae6757a008816e31cce4109e8dfc2bc16">ToTupleType</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const std::vector&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;exprs)</td></tr>
<tr class="separator:ae6757a008816e31cce4109e8dfc2bc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5c12794d464d6e4543b9e5c68d8707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a8e5c12794d464d6e4543b9e5c68d8707">MatchPattern</a> (<a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr)</td></tr>
<tr class="memdesc:a8e5c12794d464d6e4543b9e5c68d8707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a pattern matches an expression.  <a href="#a8e5c12794d464d6e4543b9e5c68d8707">More...</a><br /></td></tr>
<tr class="separator:a8e5c12794d464d6e4543b9e5c68d8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fd478e0f590938f8eb15e1bc45dbec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad9fd478e0f590938f8eb15e1bc45dbec">RewritePatterns</a> (<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1DFPatternCallback.html">DFPatternCallback</a> &gt; callbacks, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> mod=<a class="el" href="classtvm_1_1IRModule.html">IRModule</a>())</td></tr>
<tr class="memdesc:ad9fd478e0f590938f8eb15e1bc45dbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite an expression based on some number of DFPatternCallbacks.  <a href="#ad9fd478e0f590938f8eb15e1bc45dbec">More...</a><br /></td></tr>
<tr class="separator:ad9fd478e0f590938f8eb15e1bc45dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48108863604dc310eb3184b13b42a92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a48108863604dc310eb3184b13b42a92a">PartitionPattern</a> (<a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; attrs, <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">PackedFunc</a> check)</td></tr>
<tr class="memdesc:a48108863604dc310eb3184b13b42a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition all matches of a <a class="el" href="classtvm_1_1relay_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> inside an Expr into separate <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> calls.  <a href="#a48108863604dc310eb3184b13b42a92a">More...</a><br /></td></tr>
<tr class="separator:a48108863604dc310eb3184b13b42a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d491e8dfcb3098241f6d77c3aa5efe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6d491e8dfcb3098241f6d77c3aa5efe2">InferType</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6d491e8dfcb3098241f6d77c3aa5efe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="#a6d491e8dfcb3098241f6d77c3aa5efe2">More...</a><br /></td></tr>
<tr class="separator:a6d491e8dfcb3098241f6d77c3aa5efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ffafe11fe1e83a7fa2e066c1090d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a87ffafe11fe1e83a7fa2e066c1090d16">IsVar</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:a87ffafe11fe1e83a7fa2e066c1090d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1VarPattern.html">VarPattern</a> with a name.  <a href="#a87ffafe11fe1e83a7fa2e066c1090d16">More...</a><br /></td></tr>
<tr class="separator:a87ffafe11fe1e83a7fa2e066c1090d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d18041cd1c616c25de9c73a39c976c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a3d18041cd1c616c25de9c73a39c976c6">IsConstant</a> ()</td></tr>
<tr class="memdesc:a3d18041cd1c616c25de9c73a39c976c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ConstantPattern.html">ConstantPattern</a>.  <a href="#a3d18041cd1c616c25de9c73a39c976c6">More...</a><br /></td></tr>
<tr class="separator:a3d18041cd1c616c25de9c73a39c976c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c78c2a253dbcaf1f8d326e059d95a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5c78c2a253dbcaf1f8d326e059d95a18">IsWildcard</a> ()</td></tr>
<tr class="memdesc:a5c78c2a253dbcaf1f8d326e059d95a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1WildcardPattern.html" title="A pattern which matches anything. ">WildcardPattern</a>.  <a href="#a5c78c2a253dbcaf1f8d326e059d95a18">More...</a><br /></td></tr>
<tr class="separator:a5c78c2a253dbcaf1f8d326e059d95a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc962beca310c25ef857e51fb3553c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a61dc962beca310c25ef857e51fb3553c">IsExpr</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a61dc962beca310c25ef857e51fb3553c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ExprPattern.html" title="A pattern which matches a literal expression. ">ExprPattern</a>.  <a href="#a61dc962beca310c25ef857e51fb3553c">More...</a><br /></td></tr>
<tr class="separator:a61dc962beca310c25ef857e51fb3553c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75eece298ab7741f8a58d48d5ec37fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a75eece298ab7741f8a58d48d5ec37fbf">IsOp</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;op_name)</td></tr>
<tr class="memdesc:a75eece298ab7741f8a58d48d5ec37fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ExprPattern.html" title="A pattern which matches a literal expression. ">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>.  <a href="#a75eece298ab7741f8a58d48d5ec37fbf">More...</a><br /></td></tr>
<tr class="separator:a75eece298ab7741f8a58d48d5ec37fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3834130d66634d032f8e9bffafbe09ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a3834130d66634d032f8e9bffafbe09ad">IsTuple</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:a3834130d66634d032f8e9bffafbe09ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1TuplePattern.html">TuplePattern</a>.  <a href="#a3834130d66634d032f8e9bffafbe09ad">More...</a><br /></td></tr>
<tr class="separator:a3834130d66634d032f8e9bffafbe09ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48710b93ea41c2d528b042010bd12b7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a48710b93ea41c2d528b042010bd12b7b">IsTupleGetItem</a> (const <a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tuple, int index=-1)</td></tr>
<tr class="memdesc:a48710b93ea41c2d528b042010bd12b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1TupleGetItemPattern.html">TupleGetItemPattern</a>.  <a href="#a48710b93ea41c2d528b042010bd12b7b">More...</a><br /></td></tr>
<tr class="separator:a48710b93ea41c2d528b042010bd12b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50696db72ff82971c6849a67c3465559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a50696db72ff82971c6849a67c3465559">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> tuple, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt; opt_fields=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a50696db72ff82971c6849a67c3465559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tuple with given properties. A null property denotes 'no change'. Returns this if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a50696db72ff82971c6849a67c3465559">More...</a><br /></td></tr>
<tr class="separator:a50696db72ff82971c6849a67c3465559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3bb67945ee37070acbf4b3ef84d826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaf3bb67945ee37070acbf4b3ef84d826">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> var, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a> &gt; opt_vid=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt; opt_type_annotation=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:aaf3bb67945ee37070acbf4b3ef84d826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the var with given properties. A null property denotes 'no change'. Returns var if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#aaf3bb67945ee37070acbf4b3ef84d826">More...</a><br /></td></tr>
<tr class="separator:aaf3bb67945ee37070acbf4b3ef84d826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74232e829efcbb5edc54319441417753"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a74232e829efcbb5edc54319441417753">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> call, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_op=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt; opt_args=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt; opt_attrs=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;&gt; opt_type_args=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a74232e829efcbb5edc54319441417753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the call with given properties. A null property denotes 'no change'. Returns call if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a74232e829efcbb5edc54319441417753">More...</a><br /></td></tr>
<tr class="separator:a74232e829efcbb5edc54319441417753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011e68e38e577812bce8d8edd119d2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a011e68e38e577812bce8d8edd119d2f7">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a> let, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt; opt_var=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_value=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_body=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a011e68e38e577812bce8d8edd119d2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the let with given properties. A null property denotes 'no change'. Returns let if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a011e68e38e577812bce8d8edd119d2f7">More...</a><br /></td></tr>
<tr class="separator:a011e68e38e577812bce8d8edd119d2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81b1021fec3ef4b462461601f73614a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac81b1021fec3ef4b462461601f73614a">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1If.html">If</a> if_expr, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_cond=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_true_branch=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_false_branch=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:ac81b1021fec3ef4b462461601f73614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the if_expr with given properties. A null property denotes 'no change'. Returns if_expr if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#ac81b1021fec3ef4b462461601f73614a">More...</a><br /></td></tr>
<tr class="separator:ac81b1021fec3ef4b462461601f73614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa617c64bdfcc9138bc5a6c419da9ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaa617c64bdfcc9138bc5a6c419da9ac9">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a> tuple_get_item, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_tuple=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; opt_index=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:aaa617c64bdfcc9138bc5a6c419da9ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tuple_get_item with given properties. A null property denotes 'no change'. Returns if_expr if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#aaa617c64bdfcc9138bc5a6c419da9ac9">More...</a><br /></td></tr>
<tr class="separator:aaa617c64bdfcc9138bc5a6c419da9ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec82b1d8d2611534213bd8671d33118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1ec82b1d8d2611534213bd8671d33118">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a> ref_create, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_value=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a1ec82b1d8d2611534213bd8671d33118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ref create with given properties. A null property denotes 'no change'. Returns ref_create if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a1ec82b1d8d2611534213bd8671d33118">More...</a><br /></td></tr>
<tr class="separator:a1ec82b1d8d2611534213bd8671d33118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eafdaf84ea176b64ac44ef92808df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a56eafdaf84ea176b64ac44ef92808df4">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a> ref_read, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_ref=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a56eafdaf84ea176b64ac44ef92808df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ref read with given properties. A null property denotes 'no change'. Returns ref_read if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a56eafdaf84ea176b64ac44ef92808df4">More...</a><br /></td></tr>
<tr class="separator:a56eafdaf84ea176b64ac44ef92808df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4685e7d4fd2f1cf296d7623dc1a0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5d4685e7d4fd2f1cf296d7623dc1a0a5">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a> ref_write, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_ref=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_value=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:a5d4685e7d4fd2f1cf296d7623dc1a0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ref write with given properties. A null property denotes 'no change'. Returns ref_write if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a5d4685e7d4fd2f1cf296d7623dc1a0a5">More...</a><br /></td></tr>
<tr class="separator:a5d4685e7d4fd2f1cf296d7623dc1a0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9893f416a18eb31c14adece02bf43f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae9893f416a18eb31c14adece02bf43f8">PostOrderRewrite</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, <a class="el" href="classtvm_1_1relay_1_1ExprRewriter.html">ExprRewriter</a> *rewriter)</td></tr>
<tr class="memdesc:ae9893f416a18eb31c14adece02bf43f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-recursive DFS Graph Traversal for Custom Rewriting Passes.  <a href="#ae9893f416a18eb31c14adece02bf43f8">More...</a><br /></td></tr>
<tr class="separator:ae9893f416a18eb31c14adece02bf43f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ede3d80c546097084cf98b60e600b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5ede3d80c546097084cf98b60e600b80">PostOrderVisit</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;node, std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a5ede3d80c546097084cf98b60e600b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a5ede3d80c546097084cf98b60e600b80">More...</a><br /></td></tr>
<tr class="separator:a5ede3d80c546097084cf98b60e600b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36d7b9ccbc63dfc794e45de7b6af9b6"><td class="memTemplParams" colspan="2">template&lt;typename FCheckVisited , typename FVisitLeaf , typename FExpandExpr &gt; </td></tr>
<tr class="memitem:ae36d7b9ccbc63dfc794e45de7b6af9b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae36d7b9ccbc63dfc794e45de7b6af9b6">ExpandDataflow</a> (<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, FCheckVisited fcheck_visited, FVisitLeaf fvisit_leaf, FExpandExpr fexpand_expr)</td></tr>
<tr class="memdesc:ae36d7b9ccbc63dfc794e45de7b6af9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to iteratively traverse dataflow regions of a graph.  <a href="#ae36d7b9ccbc63dfc794e45de7b6af9b6">More...</a><br /></td></tr>
<tr class="separator:ae36d7b9ccbc63dfc794e45de7b6af9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34311e0bf42aebcf785cfa390a3d5a"><td class="memTemplParams" colspan="2">template&lt;typename FCheckVisited , typename FVisitLeaf &gt; </td></tr>
<tr class="memitem:abd34311e0bf42aebcf785cfa390a3d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abd34311e0bf42aebcf785cfa390a3d5a">ExpandDataflow</a> (<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, FCheckVisited fcheck_visited, FVisitLeaf fvisit_leaf)</td></tr>
<tr class="separator:abd34311e0bf42aebcf785cfa390a3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f47bbeaf5ccedf5e4cf525710a0c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a18f47bbeaf5ccedf5e4cf525710a0c41">ExpandANormalForm</a> (const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *op, std::function&lt; void(const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *)&gt; pre_visit, std::function&lt; void(const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *)&gt; post_visit)</td></tr>
<tr class="separator:a18f47bbeaf5ccedf5e4cf525710a0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b651084b386991221bc32c020cbef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a62b651084b386991221bc32c020cbef5">DetectFeature</a> (const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:a62b651084b386991221bc32c020cbef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a62b651084b386991221bc32c020cbef5">More...</a><br /></td></tr>
<tr class="separator:a62b651084b386991221bc32c020cbef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81978c82e1130854e575ccabc152ad70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a81978c82e1130854e575ccabc152ad70">DetectFeature</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a81978c82e1130854e575ccabc152ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a81978c82e1130854e575ccabc152ad70">More...</a><br /></td></tr>
<tr class="separator:a81978c82e1130854e575ccabc152ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d5425083368521d49cc49cef65aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a191d5425083368521d49cc49cef65aba">DetectFeature</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a191d5425083368521d49cc49cef65aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a191d5425083368521d49cc49cef65aba">More...</a><br /></td></tr>
<tr class="separator:a191d5425083368521d49cc49cef65aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886335a9bb055385ed04d27b74da36c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a886335a9bb055385ed04d27b74da36c7">CheckFeature</a> (const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;expr, const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;fs)</td></tr>
<tr class="memdesc:a886335a9bb055385ed04d27b74da36c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the feature of the program.  <a href="#a886335a9bb055385ed04d27b74da36c7">More...</a><br /></td></tr>
<tr class="separator:a886335a9bb055385ed04d27b74da36c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81527dc5836266c66411b082b01a80c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af81527dc5836266c66411b082b01a80c">CheckFeature</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;fs)</td></tr>
<tr class="memdesc:af81527dc5836266c66411b082b01a80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the feature of the program.  <a href="#af81527dc5836266c66411b082b01a80c">More...</a><br /></td></tr>
<tr class="separator:af81527dc5836266c66411b082b01a80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07d921de65446566e9fb93ff8c4daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a8e07d921de65446566e9fb93ff8c4daf">CheckFeature</a> (const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;fs)</td></tr>
<tr class="memdesc:a8e07d921de65446566e9fb93ff8c4daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the feature of the program.  <a href="#a8e07d921de65446566e9fb93ff8c4daf">More...</a><br /></td></tr>
<tr class="separator:a8e07d921de65446566e9fb93ff8c4daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877823176936e61bad173cba1d8052b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab877823176936e61bad173cba1d8052b">WithFields</a> (<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> function, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&gt; opt_params=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; opt_body=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt; opt_ret_type=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&gt; opt_ty_params=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DictAttrs.html">DictAttrs</a> &gt; opt_attrs=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DictAttrs.html">DictAttrs</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt; opt_virtual_device=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;())</td></tr>
<tr class="memdesc:ab877823176936e61bad173cba1d8052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function with given properties. A null property denotes 'no change'. Returns function if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#ab877823176936e61bad173cba1d8052b">More...</a><br /></td></tr>
<tr class="separator:ab877823176936e61bad173cba1d8052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d286e9f10a08e644c9f047816d0f625"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtvm_1_1relay_1_1FunctionNode.html">FunctionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7d286e9f10a08e644c9f047816d0f625">AsOptimizableFunctionNode</a> (const <a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">BaseFunc</a> &amp;base_func)</td></tr>
<tr class="separator:a7d286e9f10a08e644c9f047816d0f625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb67be9b31bbcbdd0882dc8a7ecee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abbeb67be9b31bbcbdd0882dc8a7ecee8">EvalFunction</a> (<a class="el" href="classtvm_1_1IRModule.html">IRModule</a> mod, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device, <a class="el" href="classtvm_1_1Target.html">Target</a> target)</td></tr>
<tr class="memdesc:abbeb67be9b31bbcbdd0882dc8a7ecee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a packed function over Relay expressions which will evaluate <code>expr</code> applied to those arguments, where <code>expr</code> is w.r.t. the definitions in <code>mod</code>.  <a href="#abbeb67be9b31bbcbdd0882dc8a7ecee8">More...</a><br /></td></tr>
<tr class="separator:abbeb67be9b31bbcbdd0882dc8a7ecee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c7a3eb9be1113b92a7102806ab627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae87c7a3eb9be1113b92a7102806ab627">Eval</a> (<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> expr, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">GlobalTypeVar</a>, <a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">TypeData</a> &gt; type_definitions, std::unordered_set&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt; import_set, <a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a> device, <a class="el" href="classtvm_1_1Target.html">Target</a> target, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; attrs={})</td></tr>
<tr class="memdesc:ae87c7a3eb9be1113b92a7102806ab627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <code>expr</code> and returns its result.  <a href="#ae87c7a3eb9be1113b92a7102806ab627">More...</a><br /></td></tr>
<tr class="separator:ae87c7a3eb9be1113b92a7102806ab627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cfa0b6a4537989b886d47767526726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad7cfa0b6a4537989b886d47767526726">Bind</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;binds)</td></tr>
<tr class="memdesc:ad7cfa0b6a4537989b886d47767526726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the free variables to a Relay expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> any free variables are introduced into a function, those are added to the functoin parameters. Additionally this may change the order of parameters if you map a variable to a variable.  <a href="#ad7cfa0b6a4537989b886d47767526726">More...</a><br /></td></tr>
<tr class="separator:ad7cfa0b6a4537989b886d47767526726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65d5cde84db61b456ce982b5328fae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa65d5cde84db61b456ce982b5328fae2">SubstituteBoundVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;func, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;binds)</td></tr>
<tr class="memdesc:aa65d5cde84db61b456ce982b5328fae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with new variables (including function parameters) in a function. This is a helper function usually called by other pass functions to help optimizations. Expects all values in the bind map to be Vars.  <a href="#aa65d5cde84db61b456ce982b5328fae2">More...</a><br /></td></tr>
<tr class="separator:aa65d5cde84db61b456ce982b5328fae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b761b2455ca384e5b81100069ef9a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a01b761b2455ca384e5b81100069ef9a3">ForwardRewrite</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;rewrite_map_attr_name, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:a01b761b2455ca384e5b81100069ef9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass.  <a href="#a01b761b2455ca384e5b81100069ef9a3">More...</a><br /></td></tr>
<tr class="separator:a01b761b2455ca384e5b81100069ef9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b8ec762f81290872d611c40cc72458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae6b8ec762f81290872d611c40cc72458">ForwardRewrite</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="namespacetvm_1_1relay.html#afa27c5a3fe1590a9ffa3877f9b09de45">FForwardRewrite</a> &amp;rewrite_func, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:ae6b8ec762f81290872d611c40cc72458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass.  <a href="#ae6b8ec762f81290872d611c40cc72458">More...</a><br /></td></tr>
<tr class="separator:ae6b8ec762f81290872d611c40cc72458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917e50fbb560a15995e8a617d65d1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7917e50fbb560a15995e8a617d65d1ab">RewriteAnnotatedOps</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, int fallback_device)</td></tr>
<tr class="memdesc:a7917e50fbb560a15995e8a617d65d1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a7917e50fbb560a15995e8a617d65d1ab">More...</a><br /></td></tr>
<tr class="separator:a7917e50fbb560a15995e8a617d65d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9548d99857f7698f4fe64d056dcd46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab9548d99857f7698f4fe64d056dcd46a">ToCPS</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ab9548d99857f7698f4fe64d056dcd46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression into continuation passing style(CPS).  <a href="#ab9548d99857f7698f4fe64d056dcd46a">More...</a><br /></td></tr>
<tr class="separator:ab9548d99857f7698f4fe64d056dcd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1677d450d58078811f52fd70d67db515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1677d450d58078811f52fd70d67db515">UnCPS</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:a1677d450d58078811f52fd70d67db515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the continuation argument of a CPS function.  <a href="#a1677d450d58078811f52fd70d67db515">More...</a><br /></td></tr>
<tr class="separator:a1677d450d58078811f52fd70d67db515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1ecbcbe35c7abd82b9eabf94f6b797d2">DeDup</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduplicate the bound variables and type variables in the expression.  <a href="#a1ecbcbe35c7abd82b9eabf94f6b797d2">More...</a><br /></td></tr>
<tr class="separator:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac3a576d7d192ce78bafb169c9aa882d1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac3a576d7d192ce78bafb169c9aa882d1">feature_count</a> = 17</td></tr>
<tr class="separator:ac3a576d7d192ce78bafb169c9aa882d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Relay: a high level functional IR for TVM. </p>
<p>This namespace contains the abstract syntax tree, and other essential data structures for the Relay IR.</p>
<p>You can find more about Relay by reading the language reference. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="abe473e7f103d7aa63b7b09fee09df932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe473e7f103d7aa63b7b09fee09df932">&#9670;&nbsp;</a></span>Any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#abe473e7f103d7aa63b7b09fee09df932">tvm::relay::Any</a> = typedef <a class="el" href="classtvm_1_1tir_1_1Any.html">tvm::tir::Any</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c360628faf2eeb9de326634bc6e80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c360628faf2eeb9de326634bc6e80e">&#9670;&nbsp;</a></span>AnyNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a63c360628faf2eeb9de326634bc6e80e">tvm::relay::AnyNode</a> = typedef <a class="el" href="classtvm_1_1tir_1_1AnyNode.html">tvm::tir::AnyNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbaff2ae7feec23fea55e025a9cc1b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaff2ae7feec23fea55e025a9cc1b76">&#9670;&nbsp;</a></span>BaseFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">tvm::relay::BaseFunc</a> = typedef <a class="el" href="classtvm_1_1BaseFunc.html">tvm::BaseFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4edf28d1226abc08d28bc2fd90ce7b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf28d1226abc08d28bc2fd90ce7b42">&#9670;&nbsp;</a></span>BaseFuncNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4edf28d1226abc08d28bc2fd90ce7b42">tvm::relay::BaseFuncNode</a> = typedef <a class="el" href="classtvm_1_1BaseFuncNode.html">tvm::BaseFuncNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec85bf097deda59bd22e88475c9165e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec85bf097deda59bd22e88475c9165e9">&#9670;&nbsp;</a></span>Constructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aec85bf097deda59bd22e88475c9165e9">tvm::relay::Constructor</a> = typedef <a class="el" href="classtvm_1_1Constructor.html">tvm::Constructor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b95f70a9b44cc1c96593201594d1345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b95f70a9b44cc1c96593201594d1345">&#9670;&nbsp;</a></span>ConstructorNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6b95f70a9b44cc1c96593201594d1345">tvm::relay::ConstructorNode</a> = typedef <a class="el" href="classtvm_1_1ConstructorNode.html">tvm::ConstructorNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b84e3790f89bb3fad5c7911eeb99531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84e3790f89bb3fad5c7911eeb99531">&#9670;&nbsp;</a></span>Expr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">tvm::relay::Expr</a> = typedef <a class="el" href="classtvm_1_1RelayExpr.html">tvm::RelayExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a387f18e050d016c52ea6c4781e7cff6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387f18e050d016c52ea6c4781e7cff6c">&#9670;&nbsp;</a></span>ExprNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a387f18e050d016c52ea6c4781e7cff6c">tvm::relay::ExprNode</a> = typedef <a class="el" href="classtvm_1_1RelayExprNode.html">tvm::RelayExprNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa27c5a3fe1590a9ffa3877f9b09de45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27c5a3fe1590a9ffa3877f9b09de45">&#9670;&nbsp;</a></span>FForwardRewrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afa27c5a3fe1590a9ffa3877f9b09de45">tvm::relay::FForwardRewrite</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>( const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>&amp; ref_call, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; new_args, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward rewriting rule for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_call</td><td>The reference old call type to be rewritten. We can make use of the op and type information. </td></tr>
    <tr><td class="paramname">new_args</td><td>The new arguments (some of them could be <a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a>). </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context information about ref_call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewriten result call, can also return nullptr, which indicate the rewriter should use the default fallback rule that realizes all its input and compose the call.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When we register the function, we can register a different signature with ctx to be a specific node type. </dd></dl>

</div>
</div>
<a id="a9abada45a4f21ae750c1caba923f1059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abada45a4f21ae750c1caba923f1059">&#9670;&nbsp;</a></span>FPrimalGradient</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">tvm::relay::FPrimalGradient</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&amp; orig_call, const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&amp; output_grad)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gradient for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_call</td><td>the original Expr. </td></tr>
    <tr><td class="paramname">output_grad</td><td>the gradient of the Expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gradient for each parameters. </dd></dl>

</div>
</div>
<a id="afeda9240bb23d0092992928c6d141729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeda9240bb23d0092992928c6d141729">&#9670;&nbsp;</a></span>FShapeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afeda9240bb23d0092992928c6d141729">tvm::relay::FShapeFunc</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;( const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a>&gt;&amp; out_ndims)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37fc035745cb16c86912e1c4155460d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fc035745cb16c86912e1c4155460d6">&#9670;&nbsp;</a></span>FTVMAlterOpLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a37fc035745cb16c86912e1c4155460d6">tvm::relay::FTVMAlterOpLayout</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; tinfos, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&amp; out_type)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">args</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">tinfos</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a id="a01c78601c3f13f31032b68ef27b528b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c78601c3f13f31032b68ef27b528b1">&#9670;&nbsp;</a></span>FTVMAnnotateTarget</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a01c78601c3f13f31032b68ef27b528b1">tvm::relay::FTVMAnnotateTarget</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;bool(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&amp; expr)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotates an expression to indicate if an op should be compiled using the given compiler/target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The original expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this op should be registered to invoke a specific compiler for codegen, otherwise, false. </dd></dl>

</div>
</div>
<a id="af3f95ef6143dc33382f50734f85bfdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f95ef6143dc33382f50734f85bfdf5">&#9670;&nbsp;</a></span>FTVMCompute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af3f95ef6143dc33382f50734f85bfdf5">tvm::relay::FTVMCompute</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;( const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; inputs, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&amp; out_type)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation description interface. </p>
<dl class="section note"><dt>Note</dt><dd>This function have a special convention for functions with tuple input/output.</dd></dl>
<p>So far we restrict tuple support to the following case:</p><ul>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> which takes a single tuple as input.</li>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> which outputs a single tuple.</li>
</ul>
<p>In both cases, the tuple is flattened as array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the primitive </td></tr>
    <tr><td class="paramname">inputs</td><td>The input tensors. </td></tr>
    <tr><td class="paramname">out_type</td><td>The output type information &amp; these are always placeholders. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output compute description of the operator. </dd></dl>

</div>
</div>
<a id="a8104bb3261fbc781381333ddef526a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8104bb3261fbc781381333ddef526a3f">&#9670;&nbsp;</a></span>FTVMConvertOpLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a8104bb3261fbc781381333ddef526a3f">tvm::relay::FTVMConvertOpLayout</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>( const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; tinfos, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&gt;&amp; desired_layouts)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the layout of operators or replace the operator with other expressions. This function will be invoked in ConvertLayout pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">tinfos</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
    <tr><td class="paramname">desired_layouts</td><td>Specify an array of desired layouts for each input. For example a conv2d op: Array("NHWC", "OHWI"), this specifies the desired layout for data then kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a id="ac788c2310eb8aa5e2449dd8c9dfdf368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac788c2310eb8aa5e2449dd8c9dfdf368">&#9670;&nbsp;</a></span>FTVMLegalize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac788c2310eb8aa5e2449dd8c9dfdf368">tvm::relay::FTVMLegalize</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a>&gt;&amp; arg_types)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalizes an expression with another expression. This function will be invoked in Legalize pass. It is a target-dependent pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">args</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">arg_types</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a id="aff3d3515294c3128bb63a75c5d30f596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3d3515294c3128bb63a75c5d30f596">&#9670;&nbsp;</a></span>FTVMSchedule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aff3d3515294c3128bb63a75c5d30f596">tvm::relay::FTVMSchedule</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>( const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; outs, const <a class="el" href="classtvm_1_1Target.html">Target</a>&amp; target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the computation schedule for op whose root is at current op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the node. </td></tr>
    <tr><td class="paramname">outs</td><td>The output tensors. </td></tr>
    <tr><td class="paramname">target</td><td>The build target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>schedule The computation schedule. </dd></dl>

</div>
</div>
<a id="a2eb2ad4e7a83e0a28e2ad073d7bf9305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb2ad4e7a83e0a28e2ad073d7bf9305">&#9670;&nbsp;</a></span>FTVMStrategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2eb2ad4e7a83e0a28e2ad073d7bf9305">tvm::relay::FTVMStrategy</a> = typedef <a class="el" href="classtvm_1_1GenericFunc.html">GenericFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the strategy of operators. This function is a generic function and can be re-defined for different targets. </p>
<p>The function signature of generic function is: <a class="el" href="classtvm_1_1relay_1_1OpStrategy.html" title="Operator strategy class. ">OpStrategy</a>(const <a class="el" href="classtvm_1_1Attrs.html" title="Managed reference to BaseAttrsNode. ">Attrs</a>&amp; attrs, const Array&lt;Tensor&gt;&amp; inputs, const <a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>&amp; out_type, const <a class="el" href="classtvm_1_1Target.html" title="Managed reference class to TargetNode. ">Target</a>&amp; target) </p>

</div>
</div>
<a id="aa475de90506d48a1bb04ef6d1bd99bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa475de90506d48a1bb04ef6d1bd99bfb">&#9670;&nbsp;</a></span>FuncType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aa475de90506d48a1bb04ef6d1bd99bfb">tvm::relay::FuncType</a> = typedef <a class="el" href="classtvm_1_1FuncType.html">tvm::FuncType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab551714015417af28d5ca2b47722997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab551714015417af28d5ca2b47722997e">&#9670;&nbsp;</a></span>FuncTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab551714015417af28d5ca2b47722997e">tvm::relay::FuncTypeNode</a> = typedef <a class="el" href="classtvm_1_1FuncTypeNode.html">tvm::FuncTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2235e350f9cd1eac3aa0177034976043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2235e350f9cd1eac3aa0177034976043">&#9670;&nbsp;</a></span>GlobalTypeVar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">tvm::relay::GlobalTypeVar</a> = typedef <a class="el" href="classtvm_1_1GlobalTypeVar.html">tvm::GlobalTypeVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a10e2305e3a50dd00e07b043b93b5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a10e2305e3a50dd00e07b043b93b5e8">&#9670;&nbsp;</a></span>GlobalTypeVarNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a9a10e2305e3a50dd00e07b043b93b5e8">tvm::relay::GlobalTypeVarNode</a> = typedef <a class="el" href="classtvm_1_1GlobalTypeVarNode.html">tvm::GlobalTypeVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ac7c3d0824529fddce7849c9c66289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ac7c3d0824529fddce7849c9c66289">&#9670;&nbsp;</a></span>GlobalVar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">tvm::relay::GlobalVar</a> = typedef <a class="el" href="classtvm_1_1GlobalVar.html">tvm::GlobalVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe7144195dbbc914183189444ef6a347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7144195dbbc914183189444ef6a347">&#9670;&nbsp;</a></span>GlobalVarNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afe7144195dbbc914183189444ef6a347">tvm::relay::GlobalVarNode</a> = typedef <a class="el" href="classtvm_1_1GlobalVarNode.html">tvm::GlobalVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34535a1f05224c26db569bc134de7647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34535a1f05224c26db569bc134de7647">&#9670;&nbsp;</a></span>IncompleteType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a34535a1f05224c26db569bc134de7647">tvm::relay::IncompleteType</a> = typedef <a class="el" href="classtvm_1_1IncompleteType.html">tvm::IncompleteType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517ebee34b82bdb80f74ffcdcf361940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517ebee34b82bdb80f74ffcdcf361940">&#9670;&nbsp;</a></span>IncompleteTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a517ebee34b82bdb80f74ffcdcf361940">tvm::relay::IncompleteTypeNode</a> = typedef <a class="el" href="classtvm_1_1IncompleteTypeNode.html">tvm::IncompleteTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae153a27d81399fd266b8d598227764c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae153a27d81399fd266b8d598227764c4">&#9670;&nbsp;</a></span>IndexExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">tvm::relay::IndexExpr</a> = typedef ::<a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic expression for tensor shape. </p>

</div>
</div>
<a id="aa44e35e7d791c8dd53bb00ddb6411b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44e35e7d791c8dd53bb00ddb6411b38">&#9670;&nbsp;</a></span>Kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">tvm::relay::Kind</a> = typedef <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">TypeKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c46d15e80f1a9916b8e9c264a185c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c46d15e80f1a9916b8e9c264a185c98">&#9670;&nbsp;</a></span>Op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6c46d15e80f1a9916b8e9c264a185c98">tvm::relay::Op</a> = typedef <a class="el" href="classtvm_1_1Op.html">tvm::Op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9d4f2cf78a48659817a88d890e1d142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d4f2cf78a48659817a88d890e1d142">&#9670;&nbsp;</a></span>OpNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac9d4f2cf78a48659817a88d890e1d142">tvm::relay::OpNode</a> = typedef <a class="el" href="classtvm_1_1OpNode.html">tvm::OpNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13fd39dbc2a639262858e9b72e8fb37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fd39dbc2a639262858e9b72e8fb37f">&#9670;&nbsp;</a></span>RelayRefType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a13fd39dbc2a639262858e9b72e8fb37f">tvm::relay::RelayRefType</a> = typedef <a class="el" href="classtvm_1_1RelayRefType.html">tvm::RelayRefType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae665239bd9119c8afb037d47781bf237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae665239bd9119c8afb037d47781bf237">&#9670;&nbsp;</a></span>RelayRefTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ae665239bd9119c8afb037d47781bf237">tvm::relay::RelayRefTypeNode</a> = typedef <a class="el" href="classtvm_1_1RelayRefTypeNode.html">tvm::RelayRefTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d64348ae2b75977e167109fb4af4409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d64348ae2b75977e167109fb4af4409">&#9670;&nbsp;</a></span>Shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4d64348ae2b75977e167109fb4af4409">tvm::relay::Shape</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A runtime representation of shape. </p>

</div>
</div>
<a id="a14eacafcb803b0757e48654bb1bac655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eacafcb803b0757e48654bb1bac655">&#9670;&nbsp;</a></span>SourceName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a14eacafcb803b0757e48654bb1bac655">tvm::relay::SourceName</a> = typedef <a class="el" href="classtvm_1_1SourceName.html">tvm::SourceName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af40ca6124bc2e88f2323eeb79d326cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ca6124bc2e88f2323eeb79d326cc0">&#9670;&nbsp;</a></span>Span</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">tvm::relay::Span</a> = typedef <a class="el" href="classtvm_1_1Span.html">tvm::Span</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d0fa6578e97d0d64b08865f94f04827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0fa6578e97d0d64b08865f94f04827">&#9670;&nbsp;</a></span>SpanNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a7d0fa6578e97d0d64b08865f94f04827">tvm::relay::SpanNode</a> = typedef <a class="el" href="classtvm_1_1SpanNode.html">tvm::SpanNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c13723bba53f4953dfd10c34d480f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c13723bba53f4953dfd10c34d480f8">&#9670;&nbsp;</a></span>TensorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">tvm::relay::TensorType</a> = typedef <a class="el" href="classtvm_1_1TensorType.html">tvm::TensorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfeff91bc774a278a2e9f6103a04387d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeff91bc774a278a2e9f6103a04387d">&#9670;&nbsp;</a></span>TensorTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#acfeff91bc774a278a2e9f6103a04387d">tvm::relay::TensorTypeNode</a> = typedef <a class="el" href="classtvm_1_1TensorTypeNode.html">tvm::TensorTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4c835287dfc5ec074ea8431bcebbb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c835287dfc5ec074ea8431bcebbb17">&#9670;&nbsp;</a></span>TNonComputational</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">tvm::relay::TNonComputational</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator as non-computational. </p>

</div>
</div>
<a id="afb8a8d4dd43830d4ce7d566abcd1c450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8a8d4dd43830d4ce7d566abcd1c450">&#9670;&nbsp;</a></span>TOpIsStateful</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">tvm::relay::TOpIsStateful</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether operator is stateful or contain internal state. </p>
<p>All the primitive ops we registered so far are pure. This attribute is left for potential future compatible reasons. We can always work around the stateful ops by adding an additional handle argument and return it. </p>

</div>
</div>
<a id="a5dab2ddae20ac7564a81ab3a0a9aba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dab2ddae20ac7564a81ab3a0a9aba76">&#9670;&nbsp;</a></span>TOpPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">tvm::relay::TOpPattern</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the operator pattern </p>

</div>
</div>
<a id="a7c86efe3d58b34726786cfe79f616191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c86efe3d58b34726786cfe79f616191">&#9670;&nbsp;</a></span>TReshapeOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a7c86efe3d58b34726786cfe79f616191">tvm::relay::TReshapeOp</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator as reshape op of its first input and can be turned into a nop when the first input and output shares the same piece of memory. </p>

</div>
</div>
<a id="a75edb2b00671af1cf3274a5975ecba77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75edb2b00671af1cf3274a5975ecba77">&#9670;&nbsp;</a></span>TShapeDataDependent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a75edb2b00671af1cf3274a5975ecba77">tvm::relay::TShapeDataDependent</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Integer.html">Integer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator whether output shape is data dependent. </p>

</div>
</div>
<a id="ace9102638dffea6747ae9fa9be9f00f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9102638dffea6747ae9fa9be9f00f2">&#9670;&nbsp;</a></span>TupleType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ace9102638dffea6747ae9fa9be9f00f2">tvm::relay::TupleType</a> = typedef <a class="el" href="classtvm_1_1TupleType.html">tvm::TupleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a916609c894ac1000b66f9582f338d965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916609c894ac1000b66f9582f338d965">&#9670;&nbsp;</a></span>TupleTypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a916609c894ac1000b66f9582f338d965">tvm::relay::TupleTypeNode</a> = typedef <a class="el" href="classtvm_1_1TupleTypeNode.html">tvm::TupleTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a661d95f170bca230773914caeef3fe52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661d95f170bca230773914caeef3fe52">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a> = typedef <a class="el" href="classtvm_1_1Type.html">tvm::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab406a37acee11226e3e2e119beee439e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab406a37acee11226e3e2e119beee439e">&#9670;&nbsp;</a></span>TypeCall</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab406a37acee11226e3e2e119beee439e">tvm::relay::TypeCall</a> = typedef <a class="el" href="classtvm_1_1TypeCall.html">tvm::TypeCall</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4dccabc877b8fd7db47cb73fb93883e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dccabc877b8fd7db47cb73fb93883e">&#9670;&nbsp;</a></span>TypeCallNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af4dccabc877b8fd7db47cb73fb93883e">tvm::relay::TypeCallNode</a> = typedef <a class="el" href="classtvm_1_1TypeCallNode.html">tvm::TypeCallNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64e2e93fe04716efd8334ab4e39c92ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e2e93fe04716efd8334ab4e39c92ce">&#9670;&nbsp;</a></span>TypeConstraint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a64e2e93fe04716efd8334ab4e39c92ce">tvm::relay::TypeConstraint</a> = typedef <a class="el" href="classtvm_1_1TypeConstraint.html">tvm::TypeConstraint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a565e027589acded20ca38df22be098dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565e027589acded20ca38df22be098dc">&#9670;&nbsp;</a></span>TypeConstraintNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a565e027589acded20ca38df22be098dc">tvm::relay::TypeConstraintNode</a> = typedef <a class="el" href="classtvm_1_1TypeConstraintNode.html">tvm::TypeConstraintNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e725a1cb4c83346e261eac7dc7292a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e725a1cb4c83346e261eac7dc7292a8">&#9670;&nbsp;</a></span>TypeData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">tvm::relay::TypeData</a> = typedef <a class="el" href="classtvm_1_1TypeData.html">tvm::TypeData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b8c0d5920eaca88569907e92df6066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8c0d5920eaca88569907e92df6066f">&#9670;&nbsp;</a></span>TypeDataNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2b8c0d5920eaca88569907e92df6066f">tvm::relay::TypeDataNode</a> = typedef <a class="el" href="classtvm_1_1TypeDataNode.html">tvm::TypeDataNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6995f0c848d0d5cc4124a38f43aaf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6995f0c848d0d5cc4124a38f43aaf12">&#9670;&nbsp;</a></span>TypeNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af6995f0c848d0d5cc4124a38f43aaf12">tvm::relay::TypeNode</a> = typedef <a class="el" href="classtvm_1_1TypeNode.html">tvm::TypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adab0d56fd993df71df3068dea0cd5456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab0d56fd993df71df3068dea0cd5456">&#9670;&nbsp;</a></span>TypeRelation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#adab0d56fd993df71df3068dea0cd5456">tvm::relay::TypeRelation</a> = typedef <a class="el" href="classtvm_1_1TypeRelation.html">tvm::TypeRelation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af253112249297a6cfb2a9b94cde0f235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af253112249297a6cfb2a9b94cde0f235">&#9670;&nbsp;</a></span>TypeRelationFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af253112249297a6cfb2a9b94cde0f235">tvm::relay::TypeRelationFn</a> = typedef <a class="el" href="namespacetvm.html#a72dcba4493adfcd8908663898ece3514">tvm::TypeRelationFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89d812eaf13520b04e89a9414c51748c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d812eaf13520b04e89a9414c51748c">&#9670;&nbsp;</a></span>TypeRelationNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a89d812eaf13520b04e89a9414c51748c">tvm::relay::TypeRelationNode</a> = typedef <a class="el" href="classtvm_1_1TypeRelationNode.html">tvm::TypeRelationNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa9be9990c2006832cbfc02ebb35e527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9be9990c2006832cbfc02ebb35e527">&#9670;&nbsp;</a></span>TypeReporter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afa9be9990c2006832cbfc02ebb35e527">tvm::relay::TypeReporter</a> = typedef <a class="el" href="classtvm_1_1TypeReporter.html">tvm::TypeReporter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa3b5700ea20db399f539cec1abcb12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3b5700ea20db399f539cec1abcb12b">&#9670;&nbsp;</a></span>TypeReporterNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aaa3b5700ea20db399f539cec1abcb12b">tvm::relay::TypeReporterNode</a> = typedef <a class="el" href="classtvm_1_1TypeReporterNode.html">tvm::TypeReporterNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63321eb51080f3f57dd7563a3ca0bfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63321eb51080f3f57dd7563a3ca0bfa6">&#9670;&nbsp;</a></span>TypeVar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">tvm::relay::TypeVar</a> = typedef <a class="el" href="classtvm_1_1TypeVar.html">tvm::TypeVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2cbe31b81ebd71ea8028a8404a7c9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cbe31b81ebd71ea8028a8404a7c9f3">&#9670;&nbsp;</a></span>TypeVarNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab2cbe31b81ebd71ea8028a8404a7c9f3">tvm::relay::TypeVarNode</a> = typedef <a class="el" href="classtvm_1_1TypeVarNode.html">tvm::TypeVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adab76fedc831b249d1c80d69c4a620a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab76fedc831b249d1c80d69c4a620a3">&#9670;&nbsp;</a></span>AnyCodegenStrategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">tvm::relay::AnyCodegenStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The codegeneration strategy for dynamic dimensions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adab76fedc831b249d1c80d69c4a620a3a1a3550732b0caf3981198af2c1373542"></a>kVariableDimensions&#160;</td><td class="fielddoc"><p>The default strategy of using completely variable dimensions. </p>
</td></tr>
</table>

</div>
</div>
<a id="a926750aeda977340aa82bceac863fc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926750aeda977340aa82bceac863fc9e">&#9670;&nbsp;</a></span>Feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">tvm::relay::Feature</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different kinds of relay feature a program might use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea42a71e7934e2efe344713b17c426eecd"></a>fVar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eae9b152650b0ebe6dbc1b42e0f84d567f"></a>fGlobalVar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea29eacc09610a7fd43026682238aae25f"></a>fConstant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eaa2fe12a180d97822c440e169dc287e66"></a>fTuple&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea4d2cb67f2e197880e0971286f2ffb498"></a>fTupleGetItem&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea3b367d0501427ea782137266a2fb77fa"></a>fFunction&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eaca21bd0f67c01c6f7b82a1596cdfdf8b"></a>fOp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea5f3d3030d2ed56e5a47329e29f12ef02"></a>fCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea07ce432e7b4b4c044af03e4dbd210ba4"></a>fLet&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea4e6b686fb15d50c4aef2316bef53a781"></a>fIf&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea46daa677c87c05e68258acea3579443d"></a>fRefCreate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea7c9e5e3d738c26c3ed34099f44f66251"></a>fRefRead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea4737da29588504f7f31cf4fb52925d63"></a>fRefWrite&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eaff71be930d862c312a5ae263e71167a2"></a>fConstructor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9ea53a8eba57c4a3abd37b4c96fb98bf61b"></a>fMatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eac6392a0ecc7df38dbfa282a54d3718d1"></a>fGraph&#160;</td><td class="fielddoc"><p>Whether any non-atom fragment of the program is shared, making the program a graph. </p>
</td></tr>
<tr><td class="fieldname"><a id="a926750aeda977340aa82bceac863fc9eaff508e399703958af46f99ee8eb7d1a5"></a>fLetRec&#160;</td><td class="fielddoc"><p>Whether there is local fixpoint in the program. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab5f4d382bf1bee69c3e484ea6c837578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f4d382bf1bee69c3e484ea6c837578">&#9670;&nbsp;</a></span>OpPatternKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">tvm::relay::OpPatternKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator pattern used in graph fusion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa"></a>kElemWise&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245"></a>kBroadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00"></a>kInjective&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738"></a>kCommReduce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4"></a>kOutEWiseFusable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578ae5610688419b90595a0701fe007a2ebb"></a>kTuple&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1"></a>kOpaque&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae67484a25663dfe2f87cbad53075abbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67484a25663dfe2f87cbad53075abbf">&#9670;&nbsp;</a></span>AllTypeVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="ad24361b252cdb636192641e6801f2666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24361b252cdb636192641e6801f2666">&#9670;&nbsp;</a></span>AllTypeVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in type t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a id="a6b1e94cf8d97514fe4a9493a0dec1559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1e94cf8d97514fe4a9493a0dec1559">&#9670;&nbsp;</a></span>AllVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::AllVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all variables from expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a7d286e9f10a08e644c9f047816d0f625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d286e9f10a08e644c9f047816d0f625">&#9670;&nbsp;</a></span>AsOptimizableFunctionNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtvm_1_1relay_1_1FunctionNode.html">FunctionNode</a>* tvm::relay::AsOptimizableFunctionNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">BaseFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>base_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae213c1d2fac14b9fa66d5d41bd261d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae213c1d2fac14b9fa66d5d41bd261d80">&#9670;&nbsp;</a></span>BasicBlockNormalFormCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::BasicBlockNormalFormCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an expression is in the basic block normal form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the expression is in the basic block normal form. </dd></dl>

</div>
</div>
<a id="ad7cfa0b6a4537989b886d47767526726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cfa0b6a4537989b886d47767526726">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the free variables to a Relay expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> any free variables are introduced into a function, those are added to the functoin parameters. Additionally this may change the order of parameters if you map a variable to a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">binds</td><td>The variable to expression map that will be used to help the binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated expression. </dd></dl>

</div>
</div>
<a id="a1e5aa65b13f8ca172009aa2ff3ba59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5aa65b13f8ca172009aa2ff3ba59d6">&#9670;&nbsp;</a></span>BoundTypeVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from expression expr. </p>
<p>Bound variables are all type variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a419979c48a5e37cd969f6fd6d0fead4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419979c48a5e37cd969f6fd6d0fead4b">&#9670;&nbsp;</a></span>BoundTypeVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from type t. </p>
<p>Bound variables are all type variables that are declared in the type. They only have meaning inside that type, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a id="a0bcc32688b446d3574932554f6b8c2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcc32688b446d3574932554f6b8c2df">&#9670;&nbsp;</a></span>BoundVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from expression expr. </p>
<p>Bound variables are all variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="aedcb2b290b4f80292eb34afefc41f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcb2b290b4f80292eb34afefc41f0ac">&#9670;&nbsp;</a></span>BoundVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from pattern pat. </p>
<p>Bound variables are all variables that got bound by the pat. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>the <a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a886335a9bb055385ed04d27b74da36c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886335a9bb055385ed04d27b74da36c7">&#9670;&nbsp;</a></span>CheckFeature() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::CheckFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">fs</td><td>The feature set of the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81527dc5836266c66411b082b01a80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81527dc5836266c66411b082b01a80c">&#9670;&nbsp;</a></span>CheckFeature() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::CheckFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module. </td></tr>
    <tr><td class="paramname">fs</td><td>The feature set of the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e07d921de65446566e9fb93ff8c4daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07d921de65446566e9fb93ff8c4daf">&#9670;&nbsp;</a></span>CheckFeature() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::CheckFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">mod</td><td>The module. </td></tr>
    <tr><td class="paramname">fs</td><td>The feature set of the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdade48285a63efffe743e73e41d3b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdade48285a63efffe743e73e41d3b35">&#9670;&nbsp;</a></span>ConstantCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::ConstantCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an expression is constant. </p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the inputs of an expression are all constant, it means the expression itself is constant also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the expression is constant. </dd></dl>

</div>
</div>
<a id="a1ecbcbe35c7abd82b9eabf94f6b797d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecbcbe35c7abd82b9eabf94f6b797d2">&#9670;&nbsp;</a></span>DeDup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::DeDup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduplicate the bound variables and type variables in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deduplicated expression. </dd></dl>

</div>
</div>
<a id="a62b651084b386991221bc32c020cbef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b651084b386991221bc32c020cbef5">&#9670;&nbsp;</a></span>DetectFeature() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a id="a81978c82e1130854e575ccabc152ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81978c82e1130854e575ccabc152ad70">&#9670;&nbsp;</a></span>DetectFeature() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a id="a191d5425083368521d49cc49cef65aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d5425083368521d49cc49cef65aba">&#9670;&nbsp;</a></span>DetectFeature() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">mod</td><td>The module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a id="ae87c7a3eb9be1113b92a7102806ab627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87c7a3eb9be1113b92a7102806ab627">&#9670;&nbsp;</a></span>Eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> tvm::relay::Eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">GlobalTypeVar</a>, <a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">TypeData</a> &gt;&#160;</td>
          <td class="paramname"><em>type_definitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&#160;</td>
          <td class="paramname"><em>import_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Target.html">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <code>expr</code> and returns its result. </p>
<p>This function is intended to support TVM constant evaluation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>An expression to evaluate. </td></tr>
    <tr><td class="paramname">type_definitions</td><td>Global type definitions which <code>expr</code> may references. </td></tr>
    <tr><td class="paramname">import_set</td><td>Already imported external modules. </td></tr>
    <tr><td class="paramname">device</td><td>The device on which all primitives will be executed. </td></tr>
    <tr><td class="paramname">target</td><td>The compiler target flag for compiling primitives. </td></tr>
    <tr><td class="paramname">attrs</td><td>Attributes for the expression to be evaluated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object representing the result. </dd></dl>

</div>
</div>
<a id="abbeb67be9b31bbcbdd0882dc8a7ecee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeb67be9b31bbcbdd0882dc8a7ecee8">&#9670;&nbsp;</a></span>EvalFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;)&gt; tvm::relay::EvalFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a7c2095aed90b2129ba631b90103313a2">Device</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Target.html">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a packed function over Relay expressions which will evaluate <code>expr</code> applied to those arguments, where <code>expr</code> is w.r.t. the definitions in <code>mod</code>. </p>
<p>This function is intended to support the Python 'debug' executor.</p>
<p>The given <code>expr</code> should have function type. The given <code>mod</code> may be empty or undefined if <code>expr</code> is self-contained. Relay arguments passed to the result packed function must be constants, references, or constructors/tuples over such. As much work as possible is done while constructing the result packed function, and that function may be reasonably efficiently applied multiple times without redoing unnecessary work.</p>
<p>Primitives are lowered and compiled to packed functions for execution on <code>device</code> with properties given by <code>target</code>. All other Relay constructs are interpreted.</p>
<p>The interpreter is intended to be a 'reference' implementation of the Relay semantics for testing and interactive use. It is not intended to be particularly efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>A module containing definitions which can be referenced from <code>expr</code>. May be empty or undefined. </td></tr>
    <tr><td class="paramname">expr</td><td>An expression of function type to evaluate. May reference definitions from <code>mod</code>. </td></tr>
    <tr><td class="paramname">device</td><td>The device on which all primitives will be executed. </td></tr>
    <tr><td class="paramname">target</td><td>The compiler target flag for compiling primitives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A packed function that takes an array of Relay expressions and returns the result of applying <code>expr</code> to those arguments. </dd></dl>

</div>
</div>
<a id="a18f47bbeaf5ccedf5e4cf525710a0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f47bbeaf5ccedf5e4cf525710a0c41">&#9670;&nbsp;</a></span>ExpandANormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::ExpandANormalForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>pre_visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>post_visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae36d7b9ccbc63dfc794e45de7b6af9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36d7b9ccbc63dfc794e45de7b6af9b6">&#9670;&nbsp;</a></span>ExpandDataflow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FCheckVisited , typename FVisitLeaf , typename FExpandExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::ExpandDataflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FCheckVisited&#160;</td>
          <td class="paramname"><em>fcheck_visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVisitLeaf&#160;</td>
          <td class="paramname"><em>fvisit_leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FExpandExpr&#160;</td>
          <td class="paramname"><em>fexpand_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to iteratively traverse dataflow regions of a graph. </p>
<p>ExpandDataflow manually manages a stack and performs DFS to determine the processing order of nodes in an input graph.</p>
<p>By default fexpand_expr implemented in a way that if it finds a dataflow node (<a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>, <a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a>, <a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a>), it checks if the arguments to that node need to be processed via fcheck_visited. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> so, the function pushes those arguments to the stack and continues iteratively to process the top of the stack. When it finds a node that doesn't match the dataflow types, or a node who's inputs have all been processed, it visits the current leaf via fvisit_leaf.</p>
<p>This function should be used internally to other classes to implement mixed-mode traversals. The expectation is that fvisit_leaf will perform recursive analysis within mixed-mode traversal if it hits a non-dataflow node.</p>
<p>fcheck_visited, fvisit_leaf and fexpand_expr are templated to encourage reusing. </p>

</div>
</div>
<a id="abd34311e0bf42aebcf785cfa390a3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd34311e0bf42aebcf785cfa390a3d5a">&#9670;&nbsp;</a></span>ExpandDataflow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FCheckVisited , typename FVisitLeaf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::ExpandDataflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FCheckVisited&#160;</td>
          <td class="paramname"><em>fcheck_visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVisitLeaf&#160;</td>
          <td class="paramname"><em>fvisit_leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91168c24ecbf1cbf719d2ba28841da5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91168c24ecbf1cbf719d2ba28841da5c">&#9670;&nbsp;</a></span>FlattenTupleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">TensorType</a>&gt; tvm::relay::FlattenTupleType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01b761b2455ca384e5b81100069ef9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b761b2455ca384e5b81100069ef9a3">&#9670;&nbsp;</a></span>ForwardRewrite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>rewrite_map_attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_map_attr_name</td><td>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>'s attr name which corresponds to the rewrite rule function. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an Expr consumed by multiple callers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a id="ae6b8ec762f81290872d611c40cc72458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b8ec762f81290872d611c40cc72458">&#9670;&nbsp;</a></span>ForwardRewrite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#afa27c5a3fe1590a9ffa3877f9b09de45">FForwardRewrite</a> &amp;&#160;</td>
          <td class="paramname"><em>rewrite_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_func</td><td>The rewrite func that will apply to all operators. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an Expr consumed by multiple callers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a id="acc529cca9623ac81c8aa6e106cdb5850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc529cca9623ac81c8aa6e106cdb5850">&#9670;&nbsp;</a></span>FreeTypeVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from expression expr. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order visited by expr. </dd></dl>

</div>
</div>
<a id="a446e2b12f3e907336313004c3e0a0c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446e2b12f3e907336313004c3e0a0c86">&#9670;&nbsp;</a></span>FreeTypeVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from type t. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a id="af2c5771c67f06c0af32c7b4b4269e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c5771c67f06c0af32c7b4b4269e73f">&#9670;&nbsp;</a></span>FreeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::FreeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free type parameters from expression expr. </p>
<p>Free variables are variables that are not bound by a let or a function parameter in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="aef91b70db1053b9672eafe401abb7304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef91b70db1053b9672eafe401abb7304">&#9670;&nbsp;</a></span>FromTupleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt; tvm::relay::FromTupleType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeffe1324b2293679c40d1b53b668d3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffe1324b2293679c40d1b53b668d3d8">&#9670;&nbsp;</a></span>GetCalibrateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a> tvm::relay::GetCalibrateModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the updated module for collecting calibration data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated module. </dd></dl>

</div>
</div>
<a id="a13c8195b0f8b74f23c433857cf34c5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c8195b0f8b74f23c433857cf34c5f7">&#9670;&nbsp;</a></span>GetCalibrateOutputMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Integer.html">Integer</a>&gt; &gt; tvm::relay::GetCalibrateOutputMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output map between subgrpahs and its inputs/output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module for running calibration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mapping between a subgraph name and its postition in the output tuple. </dd></dl>

</div>
</div>
<a id="a2d10acef75390fa6d1a5e64a379c5036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d10acef75390fa6d1a5e64a379c5036">&#9670;&nbsp;</a></span>GetExprRefCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const <a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a>*, size_t&gt; tvm::relay::GetExprRefCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reference counter of each internal ExprNode in body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The body expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference count mapping. </dd></dl>

</div>
</div>
<a id="a6d491e8dfcb3098241f6d77c3aa5efe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d491e8dfcb3098241f6d77c3aa5efe2">&#9670;&nbsp;</a></span>InferType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::InferType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to rewrite</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return An Expr with unambiguous type information filled in, as well as it's checked type field populated with the result type. </dd></dl>

</div>
</div>
<a id="a3d18041cd1c616c25de9c73a39c976c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d18041cd1c616c25de9c73a39c976c6">&#9670;&nbsp;</a></span>IsConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ConstantPattern.html">ConstantPattern</a>. </p>

</div>
</div>
<a id="a61dc962beca310c25ef857e51fb3553c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dc962beca310c25ef857e51fb3553c">&#9670;&nbsp;</a></span>IsExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ExprPattern.html" title="A pattern which matches a literal expression. ">ExprPattern</a>. </p>

</div>
</div>
<a id="a75eece298ab7741f8a58d48d5ec37fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75eece298ab7741f8a58d48d5ec37fbf">&#9670;&nbsp;</a></span>IsOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1ExprPattern.html" title="A pattern which matches a literal expression. ">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>. </p>

</div>
</div>
<a id="a3834130d66634d032f8e9bffafbe09ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3834130d66634d032f8e9bffafbe09ad">&#9670;&nbsp;</a></span>IsTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1TuplePattern.html">TuplePattern</a>. </p>

</div>
</div>
<a id="a48710b93ea41c2d528b042010bd12b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48710b93ea41c2d528b042010bd12b7b">&#9670;&nbsp;</a></span>IsTupleGetItem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsTupleGetItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1TupleGetItemPattern.html">TupleGetItemPattern</a>. </p>

</div>
</div>
<a id="a87ffafe11fe1e83a7fa2e066c1090d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ffafe11fe1e83a7fa2e066c1090d16">&#9670;&nbsp;</a></span>IsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1VarPattern.html">VarPattern</a> with a name. </p>

</div>
</div>
<a id="a5c78c2a253dbcaf1f8d326e059d95a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c78c2a253dbcaf1f8d326e059d95a18">&#9670;&nbsp;</a></span>IsWildcard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a> tvm::relay::IsWildcard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relay_1_1WildcardPattern.html" title="A pattern which matches anything. ">WildcardPattern</a>. </p>

</div>
</div>
<a id="a9c09d2d83aa356218069b1def8046ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c09d2d83aa356218069b1def8046ee7">&#9670;&nbsp;</a></span>KindCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">Kind</a> tvm::relay::KindCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt;&#160;</td>
          <td class="paramname"><em>diag_ctx</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that types are well kinded by applying "kinding rules". </p>
<p>This pass ensures we do not do things that violate the design of the type system when writing down types.</p>
<p>For example tensors are not allowed to contain functions in Relay.</p>
<p>We check this by ensuring the <code>dtype</code> field of a Tensor always contains a data type such as <code>int</code>, <code>float</code>, <code>uint</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to check. </td></tr>
    <tr><td class="paramname">mod</td><td>The global module. </td></tr>
    <tr><td class="paramname">diag_ctx</td><td>The <a class="el" href="classtvm_1_1Diagnostic.html">Diagnostic</a> context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kind of the passed type. </dd></dl>

</div>
</div>
<a id="a8e5c12794d464d6e4543b9e5c68d8707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5c12794d464d6e4543b9e5c68d8707">&#9670;&nbsp;</a></span>MatchPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::MatchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a pattern matches an expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to match </td></tr>
    <tr><td class="paramname">expr</td><td>The expression to match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the pattern and the expression match, return false otherwise. </dd></dl>

</div>
</div>
<a id="a48108863604dc310eb3184b13b42a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48108863604dc310eb3184b13b42a92a">&#9670;&nbsp;</a></span>PartitionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::PartitionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">PackedFunc</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition all matches of a <a class="el" href="classtvm_1_1relay_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> inside an Expr into separate <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to match </td></tr>
    <tr><td class="paramname">expr</td><td>The expression to patition </td></tr>
    <tr><td class="paramname">attrs</td><td>A set of parameter names and values to apply to the partitioned function </td></tr>
    <tr><td class="paramname">check</td><td>A callback function for checking more complicated properties of the matched expressions, returns true if the match is accepted and false otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the paritioned Expr. </dd></dl>

</div>
</div>
<a id="ae9893f416a18eb31c14adece02bf43f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9893f416a18eb31c14adece02bf43f8">&#9670;&nbsp;</a></span>PostOrderRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::PostOrderRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1ExprRewriter.html">ExprRewriter</a> *&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-recursive DFS Graph Traversal for Custom Rewriting Passes. </p>
<p>PostOrderRewrite does a non-recursive traversal of the graph in Post-DFS order and calls the <a class="el" href="classtvm_1_1relay_1_1ExprRewriter.html" title="A non-iterating Expression Rewriter. ">ExprRewriter</a>'s Rewrite functions on nodes once their inputs are rewritten. At each rewrite call, PostOrderRewrite provides the original node and the node with altered inputs for use by the <a class="el" href="classtvm_1_1relay_1_1ExprRewriter.html" title="A non-iterating Expression Rewriter. ">ExprRewriter</a>. </p>

</div>
</div>
<a id="a5ede3d80c546097084cf98b60e600b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ede3d80c546097084cf98b60e600b80">&#9670;&nbsp;</a></span>PostOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7917e50fbb560a15995e8a617d65d1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7917e50fbb560a15995e8a617d65d1ab">&#9670;&nbsp;</a></span>RewriteAnnotatedOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated program. </dd></dl>

</div>
</div>
<a id="ad9fd478e0f590938f8eb15e1bc45dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fd478e0f590938f8eb15e1bc45dbec">&#9670;&nbsp;</a></span>RewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::RewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1DFPatternCallback.html">DFPatternCallback</a> &gt;&#160;</td>
          <td class="paramname"><em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td>
          <td class="paramname"><em>mod</em> = <code><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite an expression based on some number of DFPatternCallbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbacks</td><td>An array of <a class="el" href="classtvm_1_1relay_1_1DFPatternCallback.html" title="Managed reference to dataflow pattern callbacks. ">DFPatternCallback</a> Nodes </td></tr>
    <tr><td class="paramname">expr</td><td>The expression to rewrite </td></tr>
    <tr><td class="paramname">mod</td><td>The module that associates with the expr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return An Expr with every match of the pattern inside the callbacks rewritten by the functions inside the callbacks </dd></dl>

</div>
</div>
<a id="aa65d5cde84db61b456ce982b5328fae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65d5cde84db61b456ce982b5328fae2">&#9670;&nbsp;</a></span>SubstituteBoundVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::SubstituteBoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with new variables (including function parameters) in a function. This is a helper function usually called by other pass functions to help optimizations. Expects all values in the bind map to be Vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The input function. </td></tr>
    <tr><td class="paramname">binds</td><td>The variable to expression map that will be used to help the binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated expression. </dd></dl>

</div>
</div>
<a id="ab9548d99857f7698f4fe64d056dcd46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9548d99857f7698f4fe64d056dcd46a">&#9670;&nbsp;</a></span>ToCPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::ToCPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression into continuation passing style(CPS). </p>
<p>CPS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.</p>
<p>Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).</p>
<p>Similarly, all other compute will be wrapped and call the continuation as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>. </dd></dl>

</div>
</div>
<a id="ae6757a008816e31cce4109e8dfc2bc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6757a008816e31cce4109e8dfc2bc16">&#9670;&nbsp;</a></span>ToTupleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::ToTupleType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1677d450d58078811f52fd70d67db515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1677d450d58078811f52fd70d67db515">&#9670;&nbsp;</a></span>UnCPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::UnCPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the continuation argument of a CPS function. </p>
<p>Note that this only transform the type back into un-CPS form when there is no higher order input/output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>. </dd></dl>

</div>
</div>
<a id="aa3a8cace40f8056fd6412f39c3eaa605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a8cace40f8056fd6412f39c3eaa605">&#9670;&nbsp;</a></span>UnmatchedCases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a>&gt; tvm::relay::UnmatchedCases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds cases that the given match expression does not catch, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>the match expression to test</td></tr>
    <tr><td class="paramname">mod</td><td>The module used for accessing global type var definitions, can be None.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of cases (as patterns) that are not handled by the match expression. </dd></dl>

</div>
</div>
<a id="a4e4cdd4e3db74bf68b315d5730890ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4cdd4e3db74bf68b315d5730890ca8">&#9670;&nbsp;</a></span>WellFormed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::WellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a> &gt;&#160;</td>
          <td class="paramname"><em>diag_ctx</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1DiagnosticContext.html">DiagnosticContext</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once. </p>
<p>For example, the expression <code>let x = 1 in let x = 2 in 3</code> bound x twice.</p>
<p><code>let f = (x -&gt; x) in let g = (x -&gt; x + 1) in f(g(2))</code> also bound x twice, although x is not shadowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to check. </td></tr>
    <tr><td class="paramname">diag_ctx</td><td>the diagnostic context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff all <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> in expr is bound at most once. </dd></dl>

</div>
</div>
<a id="ab877823176936e61bad173cba1d8052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877823176936e61bad173cba1d8052b">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_params</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_body</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_ret_type</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_ty_params</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1DictAttrs.html">DictAttrs</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_attrs</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1DictAttrs.html">DictAttrs</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the function with given properties. A null property denotes 'no change'. Returns function if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to copy. </td></tr>
    <tr><td class="paramname">opt_params</td><td>The (optional) params for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;params = function-&gt;params. </td></tr>
    <tr><td class="paramname">opt_body</td><td>The (optional) body for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;body = function-&gt;body. </td></tr>
    <tr><td class="paramname">opt_ret_type</td><td>The (optional) return type for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;ret_type = function-&gt;ret_type. </td></tr>
    <tr><td class="paramname">opt_ty_params</td><td>The (optional) type params for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;type_params = function-&gt;type_params. </td></tr>
    <tr><td class="paramname">opt_attrs</td><td>The (optional) attributes for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;attrs = function-&gt;attrs. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;virtual_device = function-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied function. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_function-&gt;span = function-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input function (i.e., opt_params is null or opt_params.value() == function-&gt;params, etc.), then we return function. Otherwise, we return a copy of function with the different fields overwritten. (i.e., if opt_params.value() != function-&gt;params, then ret_function-&gt;params = opt_params.value()). </dd></dl>

</div>
</div>
<a id="a50696db72ff82971c6849a67c3465559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50696db72ff82971c6849a67c3465559">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_fields</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tuple with given properties. A null property denotes 'no change'. Returns this if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>The tuple to copy </td></tr>
    <tr><td class="paramname">opt_fields</td><td>The (optional) fields for the copied tuple. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple-&gt;fields = tuple-&gt;fields. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied tuple. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple-&gt;virtual_device = tuple-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied tuple. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple-&gt;span = tuple-&gt;span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf3bb67945ee37070acbf4b3ef84d826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3bb67945ee37070acbf4b3ef84d826">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_vid</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_type_annotation</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the var with given properties. A null property denotes 'no change'. Returns var if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The var to copy. </td></tr>
    <tr><td class="paramname">opt_vid</td><td>The (optional) vid for the copied var. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_var-&gt;vid = var-&gt;vid. </td></tr>
    <tr><td class="paramname">opt_type_annotation</td><td>The (optional) type_annotation for the copied var. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_var-&gt;type_annotation = var-&gt;type_annotation. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied tuple. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple-&gt;virtual_device = tuple-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied var. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_var-&gt;span = var-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input var (i.e., opt_vid is null or opt_vid.value() == var-&gt;vid, etc.), then we return var. Otherwise, we return a copy of call with the different fields overwritten. (i.e., if opt_vid.value() != var-&gt;vid, then ret_var-&gt;vid = opt_.value()). </dd></dl>

</div>
</div>
<a id="acd80501d29e4d951be6746c79934a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd80501d29e4d951be6746c79934a70c">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a>&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_lhs</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_rhs</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the clause with given properties. A null property denotes 'no change'. Returns clause if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>The clause to copy. </td></tr>
    <tr><td class="paramname">opt_lhs</td><td>The (optional) lhs for the copied clause. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_clause-&gt;lhs = clause-&gt;lhs. </td></tr>
    <tr><td class="paramname">opt_rhs</td><td>The (optional) rhs for the copied clause. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_clause-&gt;rhs = clause-&gt;rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input clause (i.e., opt_lhs is null or opt_lhs.value() == clause-&gt;lhs, etc.), then we return clause. Otherwise, we return a copy of clause with the different fields overwritten. (i.e., if opt_lhs.value() != clause-&gt;lhs, then ret_clause-&gt;lhs = opt_lhs.value()). </dd></dl>

</div>
</div>
<a id="adb39b46f86b66a5e7252f6d9102deb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb39b46f86b66a5e7252f6d9102deb7b">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_data</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_clauses</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Bool.html">Bool</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_complete</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Bool.html">Bool</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the match with given properties. A null property denotes 'no change'. Returns match if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>The match to copy. </td></tr>
    <tr><td class="paramname">opt_data</td><td>The (optional) data for the copied match. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_match-&gt;data = match-&gt;data. </td></tr>
    <tr><td class="paramname">opt_clauses</td><td>The (optional) clauses for the copied match. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_match-&gt;clauses = match-&gt;clauses. </td></tr>
    <tr><td class="paramname">opt_complete</td><td>The (optional) complete for the copied match. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_match-&gt;complete = match-&gt;complete. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied match. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_match-&gt;span = match-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input match (i.e., opt_clauses is null or opt_clauses.value() == match-&gt;clauses, etc.), then we return match. Otherwise, we return a copy of match with the different fields overwritten. (i.e., if opt_clauses.value() != match-&gt;clauses, then ret_match-&gt;clauses = opt_clauses.value()). </dd></dl>

</div>
</div>
<a id="a74232e829efcbb5edc54319441417753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74232e829efcbb5edc54319441417753">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_op</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_args</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_attrs</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_type_args</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the call with given properties. A null property denotes 'no change'. Returns call if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call to copy. </td></tr>
    <tr><td class="paramname">opt_op</td><td>The (optional) op for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;op = call-&gt;op. </td></tr>
    <tr><td class="paramname">opt_args</td><td>The (optional) args for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;args = call-&gt;args. </td></tr>
    <tr><td class="paramname">opt_attrs</td><td>The (optional) attrs for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;attrs = call-&gt;attrs. </td></tr>
    <tr><td class="paramname">opt_type_args</td><td>The (optional) type args for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;type_args = call-&gt;type_args. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;virtual_device = call-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied call. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_call-&gt;span = call-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input call (i.e., opt_op is null or opt_op.value() == call-&gt;op, etc.), then we return call. Otherwise, we return a copy of call with the different fields overwritten. (i.e., if opt_op.value() != call-&gt;op, then ret_call-&gt;op = opt_op.value()). </dd></dl>

</div>
</div>
<a id="a011e68e38e577812bce8d8edd119d2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011e68e38e577812bce8d8edd119d2f7">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a>&#160;</td>
          <td class="paramname"><em>let</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_var</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_value</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_body</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the let with given properties. A null property denotes 'no change'. Returns let if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">let</td><td>The let to copy. </td></tr>
    <tr><td class="paramname">opt_var</td><td>The (optional) var for the copied let. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_let-&gt;op = let-&gt;op. </td></tr>
    <tr><td class="paramname">opt_value</td><td>The (optional) value for the copied let. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_let-&gt;args = let-&gt;args. </td></tr>
    <tr><td class="paramname">opt_body</td><td>The (optional) body for the copied let. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_let-&gt;attrs = let-&gt;attrs. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied let. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_let-&gt;virtual_device = let-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied let. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_let-&gt;span = let-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input let (i.e., opt_var is null or opt_var.value() == let-&gt;var, etc.), then we return let. Otherwise, we return a copy of let with the different fields overwritten. (i.e., if opt_var.value() != let-&gt;var, then ret_let-&gt;var = opt_var.value()). </dd></dl>

</div>
</div>
<a id="ac81b1021fec3ef4b462461601f73614a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81b1021fec3ef4b462461601f73614a">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a>&#160;</td>
          <td class="paramname"><em>if_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_cond</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_true_branch</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_false_branch</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the if_expr with given properties. A null property denotes 'no change'. Returns if_expr if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">if_expr</td><td>The if expression to copy. </td></tr>
    <tr><td class="paramname">opt_cond</td><td>The (optional) cond for the copied if_expr. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_if-&gt;cond = if_expr-&gt;cond. </td></tr>
    <tr><td class="paramname">opt_true_branch</td><td>The (optional) true_branch for the copied if_expr. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_if-&gt;true_branch = ret_if-&gt;false_branch. </td></tr>
    <tr><td class="paramname">opt_false_branch</td><td>The (optional) false_branch for the copied if_expr. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_if-&gt;false_branch = if_expr-&gt;false_branch. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied if_expr. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_if-&gt;virtual_device = if_expr-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied if_expr. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_if-&gt;span = if_expr-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input if_expr (i.e., opt_cond is null or opt_cond.value() == if_expr-&gt;cond, etc.), then we return if_expr. Otherwise, we return a copy of if_expr with the different fields overwritten. (i.e., if opt_cond.value() != if_expr-&gt;cond, then ret_if-&gt;cond = opt_cond.value()). </dd></dl>

</div>
</div>
<a id="aaa617c64bdfcc9138bc5a6c419da9ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa617c64bdfcc9138bc5a6c419da9ac9">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td>
          <td class="paramname"><em>tuple_get_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_tuple</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_index</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Integer.html">Integer</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tuple_get_item with given properties. A null property denotes 'no change'. Returns if_expr if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_get_item</td><td>The tuple_get_item to copy. </td></tr>
    <tr><td class="paramname">opt_tuple</td><td>The (optional) tuple for the copied tuple_get_item. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple_get_item-&gt;tuple = tuple_get_item-&gt;tuple. </td></tr>
    <tr><td class="paramname">opt_index</td><td>The (optional) index for the copied tuple_get_item. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple_get_item-&gt;index = tuple_get_item-&gt;index. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied tuple_get_item. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple_get_item-&gt;virtual_device = tuple_get_item-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied tuple_get_item. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_tuple_get_item-&gt;span = tuple_get_item-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input tuple_get_item (i.e., opt_tuple is null or opt_tuple.value() == tuple_get_item-&gt;tuple, etc.), then we return tuple_get_item. Otherwise, we return a copy of tuple_get_item with the different fields overwritten. (i.e., if opt_tuple.value() != tuple_get_item-&gt;tuple, then ret_tuple_get_item-&gt;tuple = opt_tuple.value()). </dd></dl>

</div>
</div>
<a id="a1ec82b1d8d2611534213bd8671d33118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec82b1d8d2611534213bd8671d33118">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a>&#160;</td>
          <td class="paramname"><em>ref_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_value</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ref create with given properties. A null property denotes 'no change'. Returns ref_create if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_create</td><td>The ref_create to copy. </td></tr>
    <tr><td class="paramname">opt_value</td><td>The (optional) value for the copied ref_create. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_create-&gt;value = ref_create-&gt;value. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied ref_create. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_create-&gt;virtual_device = ref_create-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied ref_create. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_create-&gt;span = ref_create-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input ref_create (i.e., opt_value is null or opt_value.value() == ref_create-&gt;value, etc.), then we return ref_create. Otherwise, we return a copy of ref_create with the different fields overwritten. (i.e., if opt_value.value() != ref_create-&gt;value, then ret_ref_create-&gt;value = opt_value.value()). </dd></dl>

</div>
</div>
<a id="a56eafdaf84ea176b64ac44ef92808df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eafdaf84ea176b64ac44ef92808df4">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a>&#160;</td>
          <td class="paramname"><em>ref_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_ref</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ref read with given properties. A null property denotes 'no change'. Returns ref_read if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_read</td><td>The ref_read to copy. </td></tr>
    <tr><td class="paramname">opt_ref</td><td>The (optional) ref for the copied ref_read. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_read-&gt;ref = ref_read-&gt;ref. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied ref_read. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_read-&gt;virtual_device = ref_read-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied ref_read. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_read-&gt;span = ref_read-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input ref_read (i.e., opt_ref is null or opt_ref.value() == ref_read-&gt;ref, etc.), then we return ref_read. Otherwise, we return a copy of ref_read with the different fields overwritten. (i.e., if opt_ref.value() != ref_read-&gt;ref, then ret_ref_read-&gt;ref = opt_ref.value()). </dd></dl>

</div>
</div>
<a id="a5d4685e7d4fd2f1cf296d7623dc1a0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4685e7d4fd2f1cf296d7623dc1a0a5">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a> tvm::relay::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a>&#160;</td>
          <td class="paramname"><em>ref_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_ref</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_value</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_virtual_device</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1VirtualDevice.html">VirtualDevice</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ref write with given properties. A null property denotes 'no change'. Returns ref_write if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_write</td><td>The ref_write to copy. </td></tr>
    <tr><td class="paramname">opt_ref</td><td>The (optional) ref for the copied ref_write. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_write-&gt;ref = ref_write-&gt;ref. </td></tr>
    <tr><td class="paramname">opt_value</td><td>The (optional) value for the copied ref_write. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_write-&gt;value = ref_write-&gt;value. </td></tr>
    <tr><td class="paramname">opt_virtual_device</td><td>The (optional) virtual_device for the copied ref_write. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_write-&gt;virtual_device = ref_write-&gt;virtual_device. </td></tr>
    <tr><td class="paramname">opt_span</td><td>The (optional) span for the copied ref_write. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> none, ret_ref_write-&gt;span = ref_write-&gt;span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> all properties are null or the same as the property in the input ref_write (i.e., opt_ref is null or opt_ref.value() == ref_write-&gt;ref, etc.), then we return ref_write. Otherwise, we return a copy of ref_write with the different fields overwritten. (i.e., if ref_write.value() != ref_write-&gt;ref, then ret_ref_write-&gt;ref = opt_ref.value()). </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac3a576d7d192ce78bafb169c9aa882d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a576d7d192ce78bafb169c9aa882d1">&#9670;&nbsp;</a></span>feature_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t tvm::relay::feature_count = 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
