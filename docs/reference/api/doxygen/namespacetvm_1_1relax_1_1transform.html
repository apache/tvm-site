<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relax::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relax.html">relax</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relax_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relax::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPatternNode.html">FusionPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pattern object used as the input of FuseOpsByPattern. For bindings to be fused, it needs to be matched with <code>pattern</code> and the <code>check</code> function needs to return true.  <a href="classtvm_1_1relax_1_1transform_1_1FusionPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPattern.html">FusionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1PatternCheckContextNode.html">PatternCheckContextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input of FusionPattern::check.  <a href="classtvm_1_1relax_1_1transform_1_1PatternCheckContextNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1transform_1_1PatternCheckContext.html">PatternCheckContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa3d28b2e48b6d5708052909943dd3282"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> = <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td></tr>
<tr class="separator:aa3d28b2e48b6d5708052909943dd3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cc1b2a0ef5efdeb2298358dacae905"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a81cc1b2a0ef5efdeb2298358dacae905">PassInfo</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td></tr>
<tr class="separator:a81cc1b2a0ef5efdeb2298358dacae905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092572e45f7d7f90fd3270677ed9164"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">PassContext</a> = <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td></tr>
<tr class="separator:a8092572e45f7d7f90fd3270677ed9164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4497453f2323b565eb405e0097fa1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">Function</a> = <a class="el" href="classtvm_1_1relax_1_1Function.html">tvm::relax::Function</a></td></tr>
<tr class="separator:a2dc4497453f2323b565eb405e0097fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a73fe4f7173374898cc8978103ceaee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">DataflowBlock</a> = <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">tvm::relax::DataflowBlock</a></td></tr>
<tr class="separator:a0a73fe4f7173374898cc8978103ceaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86cd9160e38cee85c2122c488dcc9a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a86cd9160e38cee85c2122c488dcc9a02">LowerRuntimeBuiltin</a> ()</td></tr>
<tr class="memdesc:a86cd9160e38cee85c2122c488dcc9a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform builtin lowering to map most of the op to VM builtin functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a86cd9160e38cee85c2122c488dcc9a02">More...</a><br /></td></tr>
<tr class="separator:a86cd9160e38cee85c2122c488dcc9a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f84c6058f570cdef3e463338a8267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a640f84c6058f570cdef3e463338a8267">VMShapeLower</a> ()</td></tr>
<tr class="memdesc:a640f84c6058f570cdef3e463338a8267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower the shape expression in relax to VM shape heap and TIR functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a640f84c6058f570cdef3e463338a8267">More...</a><br /></td></tr>
<tr class="separator:a640f84c6058f570cdef3e463338a8267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5d14cf2410201df1a6a912d1182c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a06c5d14cf2410201df1a6a912d1182c9">CreateFunctionPass</a> (std::function&lt; <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">Function</a>(<a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">PassContext</a>)&gt; pass_func, int opt_level, ffi::String name, tvm::ffi::Array&lt; ffi::String &gt; required, bool traceable=false)</td></tr>
<tr class="memdesc:a06c5d14cf2410201df1a6a912d1182c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function pass.  <a href="namespacetvm_1_1relax_1_1transform.html#a06c5d14cf2410201df1a6a912d1182c9">More...</a><br /></td></tr>
<tr class="separator:a06c5d14cf2410201df1a6a912d1182c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec22c5e6056bd8f5902dc062a9635ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#acec22c5e6056bd8f5902dc062a9635ad">CreateDataflowBlockPass</a> (std::function&lt; <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">DataflowBlock</a>(<a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">DataflowBlock</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">PassContext</a>)&gt; pass_func, int opt_level, ffi::String name, tvm::ffi::Array&lt; ffi::String &gt; required, bool traceable=false)</td></tr>
<tr class="memdesc:acec22c5e6056bd8f5902dc062a9635ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dataflowblock pass.  <a href="namespacetvm_1_1relax_1_1transform.html#acec22c5e6056bd8f5902dc062a9635ad">More...</a><br /></td></tr>
<tr class="separator:acec22c5e6056bd8f5902dc062a9635ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6348965f3158c33e75c2fb780558423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ac6348965f3158c33e75c2fb780558423">LambdaLift</a> ()</td></tr>
<tr class="memdesc:ac6348965f3158c33e75c2fb780558423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform lambda lifting to lift functions from nested into global.  <a href="namespacetvm_1_1relax_1_1transform.html#ac6348965f3158c33e75c2fb780558423">More...</a><br /></td></tr>
<tr class="separator:ac6348965f3158c33e75c2fb780558423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2bed29c2df4141beece380481ddaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#af3d2bed29c2df4141beece380481ddaa">ToNonDataflow</a> ()</td></tr>
<tr class="memdesc:af3d2bed29c2df4141beece380481ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all dataflow structure to non-dataflow version.  <a href="namespacetvm_1_1relax_1_1transform.html#af3d2bed29c2df4141beece380481ddaa">More...</a><br /></td></tr>
<tr class="separator:af3d2bed29c2df4141beece380481ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a792aa8a2b0aa28064b41215bc7d4e93a">RemovePurityChecking</a> ()</td></tr>
<tr class="memdesc:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate force_pure on all pure functions in the module and unwrap all pure override ops into the normal versions.  <a href="namespacetvm_1_1relax_1_1transform.html#a792aa8a2b0aa28064b41215bc7d4e93a">More...</a><br /></td></tr>
<tr class="separator:a792aa8a2b0aa28064b41215bc7d4e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811e8bbe0369530605d02e332bed5dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a1811e8bbe0369530605d02e332bed5dc">CallTIRRewrite</a> ()</td></tr>
<tr class="memdesc:a1811e8bbe0369530605d02e332bed5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform explicit tensor allocation for call_tir and call_dps_packed.  <a href="namespacetvm_1_1relax_1_1transform.html#a1811e8bbe0369530605d02e332bed5dc">More...</a><br /></td></tr>
<tr class="separator:a1811e8bbe0369530605d02e332bed5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39386a8c6dad83320670e691e7a60c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ab39386a8c6dad83320670e691e7a60c0">RewriteDataflowReshape</a> ()</td></tr>
<tr class="memdesc:ab39386a8c6dad83320670e691e7a60c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all reshape-like call_tir whose corresponding binding vars are DataflowVars to relax.reshape operator calls. The relax.reshape calls will be lowered an external builtin function call in a subsequent pass, where the external builtin function does a CreateView operation at runtime, instead of doing real data copy. Here "reshape-like" includes reshape, expand_dims, flatten, etc.  <a href="namespacetvm_1_1relax_1_1transform.html#ab39386a8c6dad83320670e691e7a60c0">More...</a><br /></td></tr>
<tr class="separator:ab39386a8c6dad83320670e691e7a60c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9e9338ca42710bcfb51652793efb9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aef9e9338ca42710bcfb51652793efb9b">StaticPlanBlockMemory</a> ()</td></tr>
<tr class="memdesc:aef9e9338ca42710bcfb51652793efb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static memory planning pass on <a class="el" href="classtvm_1_1relax_1_1BindingBlock.html">BindingBlock</a> level. The pass will reuse allocated memory to its best effort, in order to reduce the total amount of allocated memory size.  <a href="namespacetvm_1_1relax_1_1transform.html#aef9e9338ca42710bcfb51652793efb9b">More...</a><br /></td></tr>
<tr class="separator:aef9e9338ca42710bcfb51652793efb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca6a56c220e2984deb346caeba5d871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a6ca6a56c220e2984deb346caeba5d871">AttachGlobalSymbol</a> ()</td></tr>
<tr class="memdesc:a6ca6a56c220e2984deb346caeba5d871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach global_symbol to Relax functions and TIR Primfuncs for codegen.  <a href="namespacetvm_1_1relax_1_1transform.html#a6ca6a56c220e2984deb346caeba5d871">More...</a><br /></td></tr>
<tr class="separator:a6ca6a56c220e2984deb346caeba5d871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2d5ba892a16b980a687f0dcb4ad84e17">Normalize</a> ()</td></tr>
<tr class="memdesc:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform Relax IR to normal form: transform AST to A-normal form, and fill the struct_info_ of expressions.  <a href="namespacetvm_1_1relax_1_1transform.html#a2d5ba892a16b980a687f0dcb4ad84e17">More...</a><br /></td></tr>
<tr class="separator:a2d5ba892a16b980a687f0dcb4ad84e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8193d3d2f8c7ae4a62dd4b47cc5adeeb">NormalizeGlobalVar</a> ()</td></tr>
<tr class="memdesc:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly rename the <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> in an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to ensure these properties:  <a href="namespacetvm_1_1relax_1_1transform.html#a8193d3d2f8c7ae4a62dd4b47cc5adeeb">More...</a><br /></td></tr>
<tr class="separator:a8193d3d2f8c7ae4a62dd4b47cc5adeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa697394f51af1181825cc5223746f18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa697394f51af1181825cc5223746f18c">CanonicalizeBindings</a> ()</td></tr>
<tr class="memdesc:aa697394f51af1181825cc5223746f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a Relax module by folding var bindings and match shape nodes, as well as tuple indices. Best used alongside constant folding and eliminating unused bindings.  <a href="namespacetvm_1_1relax_1_1transform.html#aa697394f51af1181825cc5223746f18c">More...</a><br /></td></tr>
<tr class="separator:aa697394f51af1181825cc5223746f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265e8a2dd2e30c5e577085a7629f4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ae265e8a2dd2e30c5e577085a7629f4cd">EliminateCommonSubexpr</a> (bool call_only=false)</td></tr>
<tr class="separator:ae265e8a2dd2e30c5e577085a7629f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aceba6fd7c94691d71c1cdaa010b572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a1aceba6fd7c94691d71c1cdaa010b572">BindParams</a> (ffi::String func_name, ffi::Map&lt; Any, ObjectRef &gt; params)</td></tr>
<tr class="memdesc:a1aceba6fd7c94691d71c1cdaa010b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind params of function of the module to constant tensors.  <a href="namespacetvm_1_1relax_1_1transform.html#a1aceba6fd7c94691d71c1cdaa010b572">More...</a><br /></td></tr>
<tr class="separator:a1aceba6fd7c94691d71c1cdaa010b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec8a5cf3c44631bee60f30e71c897a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a4aec8a5cf3c44631bee60f30e71c897a">BindSymbolicVars</a> (ffi::Map&lt; ffi::Variant&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, ffi::String &gt;, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; binding_map, ffi::Optional&lt; ffi::String &gt; func_name=std::nullopt)</td></tr>
<tr class="memdesc:a4aec8a5cf3c44631bee60f30e71c897a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind symbolic vars to constant shape values.  <a href="namespacetvm_1_1relax_1_1transform.html#a4aec8a5cf3c44631bee60f30e71c897a">More...</a><br /></td></tr>
<tr class="separator:a4aec8a5cf3c44631bee60f30e71c897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa26d9a1b7b6b9b7bc575ad8edccb7ca7">FoldConstant</a> ()</td></tr>
<tr class="memdesc:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions within dataflow blocks.  <a href="namespacetvm_1_1relax_1_1transform.html#aa26d9a1b7b6b9b7bc575ad8edccb7ca7">More...</a><br /></td></tr>
<tr class="separator:aa26d9a1b7b6b9b7bc575ad8edccb7ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853600623bebe13a85ac5865c8fddade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a853600623bebe13a85ac5865c8fddade">LegalizeOps</a> (ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Function &gt;&gt; cmap, bool enable_warning=false)</td></tr>
<tr class="memdesc:a853600623bebe13a85ac5865c8fddade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalize high-level operator calls in Relax functions to call_tir with corresponding low-level TIR PrimFuncs.  <a href="namespacetvm_1_1relax_1_1transform.html#a853600623bebe13a85ac5865c8fddade">More...</a><br /></td></tr>
<tr class="separator:a853600623bebe13a85ac5865c8fddade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032567f2efa23079fc71029d4cb13ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a032567f2efa23079fc71029d4cb13ca0">RealizeVDevice</a> ()</td></tr>
<tr class="memdesc:a032567f2efa23079fc71029d4cb13ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate virtual device information.  <a href="namespacetvm_1_1relax_1_1transform.html#a032567f2efa23079fc71029d4cb13ca0">More...</a><br /></td></tr>
<tr class="separator:a032567f2efa23079fc71029d4cb13ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a7dc74fad940d4c416f4095f4aef6e8f3">AttachAttrLayoutFreeBuffers</a> ()</td></tr>
<tr class="memdesc:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach layout free buffers to the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>.  <a href="namespacetvm_1_1relax_1_1transform.html#a7dc74fad940d4c416f4095f4aef6e8f3">More...</a><br /></td></tr>
<tr class="separator:a7dc74fad940d4c416f4095f4aef6e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a2b8f167c50e9749fe05e0552aca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a658a2b8f167c50e9749fe05e0552aca7">SplitLayoutRewritePreproc</a> ()</td></tr>
<tr class="memdesc:a658a2b8f167c50e9749fe05e0552aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the layout rewrite preproc block to a separate <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>.  <a href="namespacetvm_1_1relax_1_1transform.html#a658a2b8f167c50e9749fe05e0552aca7">More...</a><br /></td></tr>
<tr class="separator:a658a2b8f167c50e9749fe05e0552aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313133cbc2c030cc7602d22efb7a3ca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a313133cbc2c030cc7602d22efb7a3ca1">LiftTransformParams</a> (ffi::Variant&lt; <a class="el" href="classtvm_1_1Bool.html">Bool</a>, ffi::Array&lt; ffi::String &gt;&gt; shared_transform=<a class="el" href="classtvm_1_1Bool.html">Bool</a>(false))</td></tr>
<tr class="memdesc:a313133cbc2c030cc7602d22efb7a3ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift transformation of the parameters of a function.  <a href="namespacetvm_1_1relax_1_1transform.html#a313133cbc2c030cc7602d22efb7a3ca1">More...</a><br /></td></tr>
<tr class="separator:a313133cbc2c030cc7602d22efb7a3ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb38ac5d686a9e6feaec6290b92d374e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aeb38ac5d686a9e6feaec6290b92d374e">UpdateVDevice</a> (<a class="el" href="classtvm_1_1VDevice.html">VDevice</a> new_vdevice, int64_t index)</td></tr>
<tr class="memdesc:aeb38ac5d686a9e6feaec6290b92d374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update virtual device.  <a href="namespacetvm_1_1relax_1_1transform.html#aeb38ac5d686a9e6feaec6290b92d374e">More...</a><br /></td></tr>
<tr class="separator:aeb38ac5d686a9e6feaec6290b92d374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9578408fcfdc920ca97d54ae699c431f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a9578408fcfdc920ca97d54ae699c431f">ExpandTupleArguments</a> ()</td></tr>
<tr class="memdesc:a9578408fcfdc920ca97d54ae699c431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand tuple arguments to internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a9578408fcfdc920ca97d54ae699c431f">More...</a><br /></td></tr>
<tr class="separator:a9578408fcfdc920ca97d54ae699c431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a5f8f0e642926291c0554eff604a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a33a5f8f0e642926291c0554eff604a79">RemoveUnusedParameters</a> ()</td></tr>
<tr class="memdesc:a33a5f8f0e642926291c0554eff604a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused parameters to internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a33a5f8f0e642926291c0554eff604a79">More...</a><br /></td></tr>
<tr class="separator:a33a5f8f0e642926291c0554eff604a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a3eef153bbae5089e940ba27e598cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a93a3eef153bbae5089e940ba27e598cf">RemoveUnusedOutputs</a> ()</td></tr>
<tr class="memdesc:a93a3eef153bbae5089e940ba27e598cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused outputs from internal functions.  <a href="namespacetvm_1_1relax_1_1transform.html#a93a3eef153bbae5089e940ba27e598cf">More...</a><br /></td></tr>
<tr class="separator:a93a3eef153bbae5089e940ba27e598cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739adf2cff75a2e14b305f6fbefa982b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a739adf2cff75a2e14b305f6fbefa982b">AnnotateTIROpPattern</a> ()</td></tr>
<tr class="memdesc:a739adf2cff75a2e14b305f6fbefa982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind for TIR functions, which is used in FuseOps.  <a href="namespacetvm_1_1relax_1_1transform.html#a739adf2cff75a2e14b305f6fbefa982b">More...</a><br /></td></tr>
<tr class="separator:a739adf2cff75a2e14b305f6fbefa982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7155cec2bad0e8e64bd78d1459843b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a7155cec2bad0e8e64bd78d1459843b88">FuseOps</a> (int fuse_opt_level=-1)</td></tr>
<tr class="memdesc:a7155cec2bad0e8e64bd78d1459843b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass groups bindings in a dataflow block of Relax functions and generates a new grouped Relax function for each group, according to the fusion algorithm described in the pass implementation. By grouping bindings into new Relax functions, we substitute the bindings in the function being manipulated into function calls to the new grouped function.  <a href="namespacetvm_1_1relax_1_1transform.html#a7155cec2bad0e8e64bd78d1459843b88">More...</a><br /></td></tr>
<tr class="separator:a7155cec2bad0e8e64bd78d1459843b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056853e1c1b4313b0834dba050ac0bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a056853e1c1b4313b0834dba050ac0bce">Gradient</a> (ffi::String func_name, ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&gt; require_grads=std::nullopt, int target_index=0)</td></tr>
<tr class="memdesc:a056853e1c1b4313b0834dba050ac0bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-mode automatic differentiation.  <a href="namespacetvm_1_1relax_1_1transform.html#a056853e1c1b4313b0834dba050ac0bce">More...</a><br /></td></tr>
<tr class="separator:a056853e1c1b4313b0834dba050ac0bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b24c5daa0796d778e803b320bf6766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a12b24c5daa0796d778e803b320bf6766">FuseOpsByPattern</a> (const tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPattern.html">FusionPattern</a> &gt; &amp;patterns, bool bind_constants=true, bool annotate_codegen=false, const tvm::ffi::Array&lt; ffi::String &gt; &amp;entry_function_names={})</td></tr>
<tr class="memdesc:a12b24c5daa0796d778e803b320bf6766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply pattern matching to each function in the given module, and group matched expressions into a new function. The end result is similar to FuseOps, but fusion is driven completely by the provided patterns.  <a href="namespacetvm_1_1relax_1_1transform.html#a12b24c5daa0796d778e803b320bf6766">More...</a><br /></td></tr>
<tr class="separator:a12b24c5daa0796d778e803b320bf6766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a27562367f610b894144546ae0cda8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a07a27562367f610b894144546ae0cda8">MergeCompositeFunctions</a> ()</td></tr>
<tr class="memdesc:a07a27562367f610b894144546ae0cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group one or multiple composite functions created by FuseOpsByPattern into a new function. The new function will be annotated with kCodegen and GlobalSymbol attributes, and it is intented to be offloaded to an external backend.  <a href="namespacetvm_1_1relax_1_1transform.html#a07a27562367f610b894144546ae0cda8">More...</a><br /></td></tr>
<tr class="separator:a07a27562367f610b894144546ae0cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a3feb81c5b5d9b4b907f3e2c72b0ac2d3">FuseTIR</a> ()</td></tr>
<tr class="memdesc:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse relax sub-function into a larger TIR function if possible. this pass works together with FuseOps to perform operator fusion.  <a href="namespacetvm_1_1relax_1_1transform.html#a3feb81c5b5d9b4b907f3e2c72b0ac2d3">More...</a><br /></td></tr>
<tr class="separator:a3feb81c5b5d9b4b907f3e2c72b0ac2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a84533ab0e8770e7f6b2c0ca677e42c56">RunCodegen</a> (ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&gt; target_options, ffi::Array&lt; ffi::String &gt; entry_functions)</td></tr>
<tr class="memdesc:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run codegen.  <a href="namespacetvm_1_1relax_1_1transform.html#a84533ab0e8770e7f6b2c0ca677e42c56">More...</a><br /></td></tr>
<tr class="separator:a84533ab0e8770e7f6b2c0ca677e42c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8366d2c1a552e747c49df617f512bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ada8366d2c1a552e747c49df617f512bb">DecomposeOpsForInference</a> (ffi::Optional&lt; ffi::String &gt; func_name)</td></tr>
<tr class="memdesc:ada8366d2c1a552e747c49df617f512bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose composite operators during inference. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well.  <a href="namespacetvm_1_1relax_1_1transform.html#ada8366d2c1a552e747c49df617f512bb">More...</a><br /></td></tr>
<tr class="separator:ada8366d2c1a552e747c49df617f512bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767be7f56b59f7feed45292854ed934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ab767be7f56b59f7feed45292854ed934">DecomposeOpsForTraining</a> (ffi::Optional&lt; ffi::String &gt; func_name)</td></tr>
<tr class="memdesc:ab767be7f56b59f7feed45292854ed934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose composite operators during training. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well.  <a href="namespacetvm_1_1relax_1_1transform.html#ab767be7f56b59f7feed45292854ed934">More...</a><br /></td></tr>
<tr class="separator:ab767be7f56b59f7feed45292854ed934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8acc5693cd6ed43a8053b905e3b886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aef8acc5693cd6ed43a8053b905e3b886">AlterOpImpl</a> (const ffi::Map&lt; ffi::String, <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &gt; &amp;op_impl_map, const ffi::Map&lt; ffi::String, ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a> &gt;&gt; &amp;op_buffer_transforms, const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt;&gt;&gt; &amp;axis_separators, const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt;&gt;&gt; &amp;input_axis_separators)</td></tr>
<tr class="memdesc:aef8acc5693cd6ed43a8053b905e3b886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pass which replaces PrimFuncs which have matching kOperatorName attribute in <code>op_impl_map</code>, with replacement PrimFunc that could possibly have different layouts on i/o buffers. The layout transformations on i/o buffers is present in the <code>op_buffer_transforms</code>. The pass inserts the layout transformations in the call sites of PrimFuncs being replaced to transform i/o buffers into expected layout.  <a href="namespacetvm_1_1relax_1_1transform.html#aef8acc5693cd6ed43a8053b905e3b886">More...</a><br /></td></tr>
<tr class="separator:aef8acc5693cd6ed43a8053b905e3b886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8de8208a1d4efb9ea263bf599474af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a4d8de8208a1d4efb9ea263bf599474af">ConvertLayout</a> (ffi::Map&lt; ffi::String, ffi::Array&lt; ffi::String &gt;&gt; desired_layouts)</td></tr>
<tr class="memdesc:a4d8de8208a1d4efb9ea263bf599474af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layout conversion pass.  <a href="namespacetvm_1_1relax_1_1transform.html#a4d8de8208a1d4efb9ea263bf599474af">More...</a><br /></td></tr>
<tr class="separator:a4d8de8208a1d4efb9ea263bf599474af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf34717bb1990ef17ddb03db00360ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#adf34717bb1990ef17ddb03db00360ddc">ConvertToDataflow</a> (int min_size=2)</td></tr>
<tr class="memdesc:adf34717bb1990ef17ddb03db00360ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass that converts consecutive dataflow operations inside binding blocks into dataflow blocks.  <a href="namespacetvm_1_1relax_1_1transform.html#adf34717bb1990ef17ddb03db00360ddc">More...</a><br /></td></tr>
<tr class="separator:adf34717bb1990ef17ddb03db00360ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#afc435a69f08a8e5eee5c2bce0dfd6992">DeadCodeElimination</a> (ffi::Array&lt; ffi::String &gt; entry_functions={})</td></tr>
<tr class="memdesc:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead code elimination.  <a href="namespacetvm_1_1relax_1_1transform.html#afc435a69f08a8e5eee5c2bce0dfd6992">More...</a><br /></td></tr>
<tr class="separator:afc435a69f08a8e5eee5c2bce0dfd6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f82e9471203ddc307c67bc858a28d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a11f82e9471203ddc307c67bc858a28d8">DataflowUseInplaceCalls</a> ()</td></tr>
<tr class="memdesc:a11f82e9471203ddc307c67bc858a28d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that changes calls to operators that can be done in-place (generally, these are elementwise operations) in dataflow blocks into in-place implementations. Supported operators will be replaced by calls to <code>call_tir_inplace</code> that invoke in-place PrimFunc implementations of those operators (which are based on the legalizations of those operators).  <a href="namespacetvm_1_1relax_1_1transform.html#a11f82e9471203ddc307c67bc858a28d8">More...</a><br /></td></tr>
<tr class="separator:a11f82e9471203ddc307c67bc858a28d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0363e13a19a156462cab6f097559c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a13b0363e13a19a156462cab6f097559c">ToMixedPrecision</a> (const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;out_dtype, ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt; fp16_input_names=std::nullopt)</td></tr>
<tr class="memdesc:a13b0363e13a19a156462cab6f097559c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic mixed precision pass. Currently the pass assumes the input module to be fp32 only, and will automatically cast fp32 to fp16 for certain ops.  <a href="namespacetvm_1_1relax_1_1transform.html#a13b0363e13a19a156462cab6f097559c">More...</a><br /></td></tr>
<tr class="separator:a13b0363e13a19a156462cab6f097559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#ad769f00c33bd5eac4fa5e608ce92b87b">RewriteCUDAGraph</a> ()</td></tr>
<tr class="memdesc:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a Relax module for executing with CUDA graph. This pass identifies the regions that can be executed with CUDA graph and lifts them into new functions for runtime graph capturing.  <a href="namespacetvm_1_1relax_1_1transform.html#ad769f00c33bd5eac4fa5e608ce92b87b">More...</a><br /></td></tr>
<tr class="separator:ad769f00c33bd5eac4fa5e608ce92b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47edcc1f5a163d830f6a428663d82875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#a47edcc1f5a163d830f6a428663d82875">FewShotTuning</a> (int valid_count, bool benchmark)</td></tr>
<tr class="memdesc:a47edcc1f5a163d830f6a428663d82875"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pass is designed for few shot tuning for static shape PrimFuncs. It examines all the blocks within the PrimFunc and conducts loop fusion, splitting, and other transformations based on MetaSchedule schedule rules but directly samples from the search space instead of using the tuning algorithm. User can specify the number of valid counts to try and whether to use runner for benchmarking.  <a href="namespacetvm_1_1relax_1_1transform.html#a47edcc1f5a163d830f6a428663d82875">More...</a><br /></td></tr>
<tr class="separator:a47edcc1f5a163d830f6a428663d82875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0a73fe4f7173374898cc8978103ceaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a73fe4f7173374898cc8978103ceaee">&#9670;&nbsp;</a></span>DataflowBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">tvm::relax::transform::DataflowBlock</a> = typedef <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">tvm::relax::DataflowBlock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dc4497453f2323b565eb405e0097fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4497453f2323b565eb405e0097fa1">&#9670;&nbsp;</a></span>Function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">tvm::relax::transform::Function</a> = typedef <a class="el" href="classtvm_1_1relax_1_1Function.html">tvm::relax::Function</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3d28b2e48b6d5708052909943dd3282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d28b2e48b6d5708052909943dd3282">&#9670;&nbsp;</a></span>Pass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">tvm::relax::transform::Pass</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8092572e45f7d7f90fd3270677ed9164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8092572e45f7d7f90fd3270677ed9164">&#9670;&nbsp;</a></span>PassContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">tvm::relax::transform::PassContext</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81cc1b2a0ef5efdeb2298358dacae905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cc1b2a0ef5efdeb2298358dacae905">&#9670;&nbsp;</a></span>PassInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a81cc1b2a0ef5efdeb2298358dacae905">tvm::relax::transform::PassInfo</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aef8acc5693cd6ed43a8053b905e3b886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8acc5693cd6ed43a8053b905e3b886">&#9670;&nbsp;</a></span>AlterOpImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::AlterOpImpl </td>
          <td>(</td>
          <td class="paramtype">const ffi::Map&lt; ffi::String, <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op_impl_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; ffi::String, ffi::Array&lt; <a class="el" href="classtvm_1_1tir_1_1IndexMap.html">tir::IndexMap</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>op_buffer_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ffi::Map&lt; ffi::String, ffi::Optional&lt; ffi::Array&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1IntImm.html">IntImm</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input_axis_separators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pass which replaces PrimFuncs which have matching kOperatorName attribute in <code>op_impl_map</code>, with replacement PrimFunc that could possibly have different layouts on i/o buffers. The layout transformations on i/o buffers is present in the <code>op_buffer_transforms</code>. The pass inserts the layout transformations in the call sites of PrimFuncs being replaced to transform i/o buffers into expected layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_impl_map</td><td>Map from kOperatorName attr (e.g., relax.conv2d) to replacement PrimFunc </td></tr>
    <tr><td class="paramname">op_buffer_transforms</td><td>Map from kOperatorName attr to layout transformations on each of the PrimFunc i/o buffers. </td></tr>
    <tr><td class="paramname">axis_separators</td><td>Map from kOperatorName attr to axis_separators of each buffer_transforms </td></tr>
    <tr><td class="paramname">input_axis_separators</td><td>Map from kOperatorName attr to axis_separator for input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a739adf2cff75a2e14b305f6fbefa982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739adf2cff75a2e14b305f6fbefa982b">&#9670;&nbsp;</a></span>AnnotateTIROpPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::AnnotateTIROpPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode.">Op</a> Pattern Kind for TIR functions, which is used in FuseOps. </p>
<dl class="section note"><dt>Note</dt><dd>It is an auto-detect pass for "unscheduled prim_funcs", the op_pattern will be "opaque" of we can't detect it. Users can manually annotate the attr <code>op_pattern</code> to prim_func. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a7dc74fad940d4c416f4095f4aef6e8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc74fad940d4c416f4095f4aef6e8f3">&#9670;&nbsp;</a></span>AttachAttrLayoutFreeBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::AttachAttrLayoutFreeBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach layout free buffers to the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>. </p>
<p>This pass is used to attach layout free buffers to the <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a> according to the function usage in the relax function. Currently, the layout free buffers are the model weights and relax constants.</p>
<dl class="section note"><dt>Note</dt><dd>We recommend applying CanonicalizeBindings before this pass. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a6ca6a56c220e2984deb346caeba5d871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca6a56c220e2984deb346caeba5d871">&#9670;&nbsp;</a></span>AttachGlobalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::AttachGlobalSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach global_symbol to Relax functions and TIR Primfuncs for codegen. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a1aceba6fd7c94691d71c1cdaa010b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aceba6fd7c94691d71c1cdaa010b572">&#9670;&nbsp;</a></span>BindParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::BindParams </td>
          <td>(</td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Map&lt; Any, ObjectRef &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind params of function of the module to constant tensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the function to bind parameters. </td></tr>
    <tr><td class="paramname">params</td><td>The parameters to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a4aec8a5cf3c44631bee60f30e71c897a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aec8a5cf3c44631bee60f30e71c897a">&#9670;&nbsp;</a></span>BindSymbolicVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::BindSymbolicVars </td>
          <td>(</td>
          <td class="paramtype">ffi::Map&lt; ffi::Variant&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, ffi::String &gt;, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>binding_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>func_name</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind symbolic vars to constant shape values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding_map</td><td>The dictionary of symbolic variables and their constant shape values. Dictionary keys may be either a <code><a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR">tir.Var</a></code> or a string name of the variable. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the variables are referred to by name, the name must uniquely identify a symbolic variable in each function where it is used.</td></tr>
    <tr><td class="paramname">func_name</td><td>The name of the function in which to bind shape values. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> std::nullopt, all functions in the module will be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a1811e8bbe0369530605d02e332bed5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1811e8bbe0369530605d02e332bed5dc">&#9670;&nbsp;</a></span>CallTIRRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::CallTIRRewrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform explicit tensor allocation for call_tir and call_dps_packed. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="aa697394f51af1181825cc5223746f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa697394f51af1181825cc5223746f18c">&#9670;&nbsp;</a></span>CanonicalizeBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::CanonicalizeBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify a Relax module by folding var bindings and match shape nodes, as well as tuple indices. Best used alongside constant folding and eliminating unused bindings. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> a dataflow var is used only in a binding to the dataflow block output var (i.e., a non-dataflow var), this pass will also remove the dataflow var and replaces the output var's binding with the dataflow var's direct definition.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a4d8de8208a1d4efb9ea263bf599474af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8de8208a1d4efb9ea263bf599474af">&#9670;&nbsp;</a></span>ConvertLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::ConvertLayout </td>
          <td>(</td>
          <td class="paramtype">ffi::Map&lt; ffi::String, ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>desired_layouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Layout conversion pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_layouts</td><td>The desired layouts for some operators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Operates only on dataflow blocks. ConvertToDataflow may need to be called first. </dd></dl>

</div>
</div>
<a id="adf34717bb1990ef17ddb03db00360ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf34717bb1990ef17ddb03db00360ddc">&#9670;&nbsp;</a></span>ConvertToDataflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::ConvertToDataflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pass that converts consecutive dataflow operations inside binding blocks into dataflow blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_size</td><td>The minimum number of consecutive dataflow bindings required for the pass to create a new dataflow block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="acec22c5e6056bd8f5902dc062a9635ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec22c5e6056bd8f5902dc062a9635ad">&#9670;&nbsp;</a></span>CreateDataflowBlockPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::CreateDataflowBlockPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">DataflowBlock</a>(<a class="el" href="namespacetvm_1_1relax_1_1transform.html#a0a73fe4f7173374898cc8978103ceaee">DataflowBlock</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">PassContext</a>)&gt;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tvm::ffi::Array&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dataflowblock pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass_func</td><td>The packed function that contains the optimization. </td></tr>
    <tr><td class="paramname">opt_level</td><td>The optimization level of the dataflowblock pass. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the dataflowblock pass. </td></tr>
    <tr><td class="paramname">required</td><td>The list of the passes that the dataflowblock pass is dependent on. </td></tr>
    <tr><td class="paramname">traceable</td><td>Boolean variable whether the dataflowblock pass is traceable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created dataflowblock pass. </dd></dl>

</div>
</div>
<a id="a06c5d14cf2410201df1a6a912d1182c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c5d14cf2410201df1a6a912d1182c9">&#9670;&nbsp;</a></span>CreateFunctionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::CreateFunctionPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">Function</a>(<a class="el" href="namespacetvm_1_1relax_1_1transform.html#a2dc4497453f2323b565eb405e0097fa1">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relax_1_1transform.html#a8092572e45f7d7f90fd3270677ed9164">PassContext</a>)&gt;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tvm::ffi::Array&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass_func</td><td>The packed function that contains the optimization. </td></tr>
    <tr><td class="paramname">opt_level</td><td>The optimization level of the function pass. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the function pass. </td></tr>
    <tr><td class="paramname">required</td><td>The list of the passes that the function pass is dependent on. </td></tr>
    <tr><td class="paramname">traceable</td><td>Boolean variable whether the dataflowblock pass is traceable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created function pass. </dd></dl>

</div>
</div>
<a id="a11f82e9471203ddc307c67bc858a28d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f82e9471203ddc307c67bc858a28d8">&#9670;&nbsp;</a></span>DataflowUseInplaceCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::DataflowUseInplaceCalls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass that changes calls to operators that can be done in-place (generally, these are elementwise operations) in dataflow blocks into in-place implementations. Supported operators will be replaced by calls to <code>call_tir_inplace</code> that invoke in-place PrimFunc implementations of those operators (which are based on the legalizations of those operators). </p>
<dl class="section note"><dt>Note</dt><dd>ConvertToDataflow may need to be called first to provide dataflow blocks. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="afc435a69f08a8e5eee5c2bce0dfd6992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc435a69f08a8e5eee5c2bce0dfd6992">&#9670;&nbsp;</a></span>DeadCodeElimination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::DeadCodeElimination </td>
          <td>(</td>
          <td class="paramtype">ffi::Array&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>entry_functions</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dead code elimination. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1relax.html#a32fc012aed7e73dbbe354553614acd14" title="Remove unused statements inside DataflowBlocks.">RemoveAllUnused</a> Currently it removes:<ol type="1">
<li>Unused local VarBindings (those where the bound var is unused and no impure operation is used).</li>
<li>Unused Relax functions in the module. We detect the call chain from the entry function, and remove <a class="el" href="namespacetvm.html#adf00250441f438e8865b198b50c0f9b2" title="logical And of source expression over axis">all</a> unused functions.</li>
</ol>
</dd></dl>
<p>Any binding blocks that are left empty will be removed by the normalizer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_functions</td><td>Names of functions that should be considered as entry points, in addition to any externally exposed functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="ada8366d2c1a552e747c49df617f512bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8366d2c1a552e747c49df617f512bb">&#9670;&nbsp;</a></span>DecomposeOpsForInference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::DecomposeOpsForInference </td>
          <td>(</td>
          <td class="paramtype">ffi::Optional&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>func_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose composite operators during inference. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the specified function. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> not specified, the pass will run in all functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab767be7f56b59f7feed45292854ed934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab767be7f56b59f7feed45292854ed934">&#9670;&nbsp;</a></span>DecomposeOpsForTraining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::DecomposeOpsForTraining </td>
          <td>(</td>
          <td class="paramtype">ffi::Optional&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>func_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose composite operators during training. For example, The result of batch norm (a triple) will be simplified. Operators like Attention, Erf, etc. can be also simplified into several operators as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the specified function. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> not specified, the pass will run in all functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae265e8a2dd2e30c5e577085a7629f4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae265e8a2dd2e30c5e577085a7629f4cd">&#9670;&nbsp;</a></span>EliminateCommonSubexpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::EliminateCommonSubexpr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>call_only</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Eliminate common subexpressions within functions. </p><dl class="section return"><dt>Returns</dt><dd>The pass that eliminates common subexpressions.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For nested functions, this pass performs CSE <em>within</em> those functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_only</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, enable eliminating only call nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9578408fcfdc920ca97d54ae699c431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9578408fcfdc920ca97d54ae699c431f">&#9670;&nbsp;</a></span>ExpandTupleArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::ExpandTupleArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand tuple arguments to internal functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass </dd></dl>

</div>
</div>
<a id="a47edcc1f5a163d830f6a428663d82875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47edcc1f5a163d830f6a428663d82875">&#9670;&nbsp;</a></span>FewShotTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::FewShotTuning </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valid_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>benchmark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pass is designed for few shot tuning for static shape PrimFuncs. It examines all the blocks within the PrimFunc and conducts loop fusion, splitting, and other transformations based on MetaSchedule schedule rules but directly samples from the search space instead of using the tuning algorithm. User can specify the number of valid counts to try and whether to use runner for benchmarking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_count</td><td>The number of valid counts to try. </td></tr>
    <tr><td class="paramname">benchmark</td><td>Whether to use runner for benchmarking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="aa26d9a1b7b6b9b7bc575ad8edccb7ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26d9a1b7b6b9b7bc575ad8edccb7ca7">&#9670;&nbsp;</a></span>FoldConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::FoldConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold constant expressions within dataflow blocks. </p>
<dl class="section note"><dt>Note</dt><dd>ConvertToDataflow may need to be called first to provide dataflow blocks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a7155cec2bad0e8e64bd78d1459843b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7155cec2bad0e8e64bd78d1459843b88">&#9670;&nbsp;</a></span>FuseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::FuseOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuse_opt_level</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This pass groups bindings in a dataflow block of Relax functions and generates a new grouped Relax function for each group, according to the fusion algorithm described in the pass implementation. By grouping bindings into new Relax functions, we substitute the bindings in the function being manipulated into function calls to the new grouped function. </p>
<p>A follow-up pass named "FuseTIR" will generate a TIR PrimFunc for each grouped function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse_opt_level</td><td>The level of fuse optimization. -1 indicates that the level will be inferred from pass context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a12b24c5daa0796d778e803b320bf6766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b24c5daa0796d778e803b320bf6766">&#9670;&nbsp;</a></span>FuseOpsByPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::FuseOpsByPattern </td>
          <td>(</td>
          <td class="paramtype">const tvm::ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1transform_1_1FusionPattern.html">FusionPattern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bind_constants</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_codegen</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tvm::ffi::Array&lt; ffi::String &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_function_names</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply pattern matching to each function in the given module, and group matched expressions into a new function. The end result is similar to FuseOps, but fusion is driven completely by the provided patterns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patterns</td><td>The patterns to detect. The order of the patterns determines the order of priority in which they are matched. Higher-priority patterns should come earlier in the list. </td></tr>
    <tr><td class="paramname">bind_constants</td><td>Whether or not to keep bound constants of the grouped function. </td></tr>
    <tr><td class="paramname">annotate_codegen</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, wrap each created composite function with another function, whose body consists only of a call to the composite function, and annotate the outer function with kCodegen and kGlobalSymbol attributes. The kCodegen attribute is set as the prefix of the corresponding pattern name. For example, "dnnl" if the pattern name is "dnnl.conv2d_relu". This must be True if the created composite functions are intended to be offloaded to an external backend without using the MergeCompositeFunctions pass. </td></tr>
    <tr><td class="paramname">entry_function_names</td><td>The names of functions that should be considered as entry points. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> not specified, all externally exposed functions will be considered as entry points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only operates within dataflow blocks. ConvertToDataflow may need to be called first. </dd></dl>

</div>
</div>
<a id="a3feb81c5b5d9b4b907f3e2c72b0ac2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feb81c5b5d9b4b907f3e2c72b0ac2d3">&#9670;&nbsp;</a></span>FuseTIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::FuseTIR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse relax sub-function into a larger TIR function if possible. this pass works together with FuseOps to perform operator fusion. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a056853e1c1b4313b0834dba050ac0bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056853e1c1b4313b0834dba050ac0bce">&#9670;&nbsp;</a></span>Gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::Gradient </td>
          <td>(</td>
          <td class="paramtype">ffi::String&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>require_grads</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse-mode automatic differentiation. </p>
<p>This pass will differentiate one function in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>. Now the input function must have only one dataflow block.</p>
<p>For a given function specified by <code>func_name</code>, it generates a new function with the name <code>func_name + "_adjoint"</code>. The new function computes the gradient of the <b>differentiation target</b> with respect to the arguments specified by <code>require_grads</code> of the original function.</p>
<p><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the function has only one return value, the return value will be specified as target. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the function has more than one return values, the target will be specified as the target_index-th return value. The target must be a scalar (0-dim tensor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>The name of the specified function. </td></tr>
    <tr><td class="paramname">require_grads</td><td>The relax variables whose adjoints is needed. Must be parameters of the given function and should not be duplicate. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> it is not specified, adjoints of all parameters would be computed. </td></tr>
    <tr><td class="paramname">target_index</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the specified function has more than one return values, specify the index of the return value as the target. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> it is not specified, the first return value will be the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ConvertToDataflow may need to be called first to provide dataflow blocks. </dd></dl>

</div>
</div>
<a id="ac6348965f3158c33e75c2fb780558423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6348965f3158c33e75c2fb780558423">&#9670;&nbsp;</a></span>LambdaLift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::LambdaLift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform lambda lifting to lift functions from nested into global. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a853600623bebe13a85ac5865c8fddade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853600623bebe13a85ac5865c8fddade">&#9670;&nbsp;</a></span>LegalizeOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::LegalizeOps </td>
          <td>(</td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Function &gt;&gt;&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_warning</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalize high-level operator calls in Relax functions to call_tir with corresponding low-level TIR PrimFuncs. </p>
<p>For each high-level operator, we register the way of legalizing it as a function, which takes a context <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> and the <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> being legalized as input, and returns the legalized call. Here the input <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> is mainly used for adding the PrimFunc created by call_te into the context <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>.</p>
<p>The legalization function for each operator is registered as an attribute (with attribute key <code>FLegalize</code>) of the operator.</p>
<p>For customizability, the user can pass their own legalization by an optional customized map, with the key to be the operator name and value to be the legalization function. The default legalization function will be overridden by the customized one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmap</td><td>The customized operator legalization function map. The customized function will override the default one. </td></tr>
    <tr><td class="paramname">enable_warning</td><td>A boolean value indicating if to print warnings for TIR functions not showing up in the database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a313133cbc2c030cc7602d22efb7a3ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313133cbc2c030cc7602d22efb7a3ca1">&#9670;&nbsp;</a></span>LiftTransformParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::LiftTransformParams </td>
          <td>(</td>
          <td class="paramtype">ffi::Variant&lt; <a class="el" href="classtvm_1_1Bool.html">Bool</a>, ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>shared_transform</em> = <code><a class="el" href="classtvm_1_1Bool.html">Bool</a>(false)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift transformation of the parameters of a function. </p>
<p>When some inputs of the function is marked as 'parameters' (the model weights), this pass identifies the transformation of the parameters and lifts them to a separate function called <code>transform_params</code>. <code>transform_params</code> takes a tuple of the original parameters as input and returns a tuple of the transformed parameters. The original function will be rewritten to accept a tuple of transformed parameters as input.</p>
<p>Users are expected to invoke the <code>transform_params</code> function in runtime and pass the transformed parameters to the original function as input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shared_transform</td><td>Indicates how the parameter transformation function will be produced.<ul>
<li><code>False</code> (default): A separate parameter transformation function will be produced for each function with the <code>"num_input"</code> attribute.</li>
<li><code>True</code>: A single parameter transformation function will be produced, containing the preprocessing steps common across all functions with the <code>"num_input"</code> attribute.</li>
<li>List[str]: A single parameter transformation function will be produced, containing the preprocessing steps common across each function whose name is in the list. Passing a list of all functions with the <code>"num_input"</code> attribute or an empty list is equivalent to passing <code>True</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a86cd9160e38cee85c2122c488dcc9a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cd9160e38cee85c2122c488dcc9a02">&#9670;&nbsp;</a></span>LowerRuntimeBuiltin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::LowerRuntimeBuiltin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform builtin lowering to map most of the op to VM builtin functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a07a27562367f610b894144546ae0cda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a27562367f610b894144546ae0cda8">&#9670;&nbsp;</a></span>MergeCompositeFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::MergeCompositeFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group one or multiple composite functions created by FuseOpsByPattern into a new function. The new function will be annotated with kCodegen and GlobalSymbol attributes, and it is intented to be offloaded to an external backend. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a2d5ba892a16b980a687f0dcb4ad84e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5ba892a16b980a687f0dcb4ad84e17">&#9670;&nbsp;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::Normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform Relax IR to normal form: transform AST to A-normal form, and fill the struct_info_ of expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a8193d3d2f8c7ae4a62dd4b47cc5adeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193d3d2f8c7ae4a62dd4b47cc5adeeb">&#9670;&nbsp;</a></span>NormalizeGlobalVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::NormalizeGlobalVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possibly rename the <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> in an <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a> to ensure these properties: </p>
<ol type="1">
<li>(Invariant) First ensure every public function has the same name as its "global_symbol" attribute;</li>
<li>To ensure 1., we may need to rename private functions with conflicting names;</li>
<li>Finally, the name of every <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode.">GlobalVar</a> is unique in the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode.">IRModule</a>. </li>
</ol>

</div>
</div>
<a id="a032567f2efa23079fc71029d4cb13ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032567f2efa23079fc71029d4cb13ca0">&#9670;&nbsp;</a></span>RealizeVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RealizeVDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate virtual device information. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a792aa8a2b0aa28064b41215bc7d4e93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792aa8a2b0aa28064b41215bc7d4e93a">&#9670;&nbsp;</a></span>RemovePurityChecking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RemovePurityChecking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate force_pure on all pure functions in the module and unwrap all pure override ops into the normal versions. </p>
<p>This effectively means that there will be no more purity tracking, useful for low-level code generation.</p>
<dl class="section return"><dt>Returns</dt><dd>The Pass.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Should be used after <a class="el" href="namespacetvm_1_1relax_1_1transform.html#af3d2bed29c2df4141beece380481ddaa" title="Transform all dataflow structure to non-dataflow version.">ToNonDataflow()</a> </dd></dl>

</div>
</div>
<a id="a93a3eef153bbae5089e940ba27e598cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a3eef153bbae5089e940ba27e598cf">&#9670;&nbsp;</a></span>RemoveUnusedOutputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RemoveUnusedOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused outputs from internal functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass </dd></dl>

</div>
</div>
<a id="a33a5f8f0e642926291c0554eff604a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a5f8f0e642926291c0554eff604a79">&#9670;&nbsp;</a></span>RemoveUnusedParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RemoveUnusedParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused parameters to internal functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass </dd></dl>

</div>
</div>
<a id="ad769f00c33bd5eac4fa5e608ce92b87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769f00c33bd5eac4fa5e608ce92b87b">&#9670;&nbsp;</a></span>RewriteCUDAGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RewriteCUDAGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a Relax module for executing with CUDA graph. This pass identifies the regions that can be executed with CUDA graph and lifts them into new functions for runtime graph capturing. </p>

</div>
</div>
<a id="ab39386a8c6dad83320670e691e7a60c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39386a8c6dad83320670e691e7a60c0">&#9670;&nbsp;</a></span>RewriteDataflowReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RewriteDataflowReshape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all reshape-like call_tir whose corresponding binding vars are DataflowVars to relax.reshape operator calls. The relax.reshape calls will be lowered an external builtin function call in a subsequent pass, where the external builtin function does a CreateView operation at runtime, instead of doing real data copy. Here "reshape-like" includes reshape, expand_dims, flatten, etc. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pass is applied at the first stage of Relax VM build, before rewriting call_tir, as this pass requires dataflow information. </dd></dl>

</div>
</div>
<a id="a84533ab0e8770e7f6b2c0ca677e42c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84533ab0e8770e7f6b2c0ca677e42c56">&#9670;&nbsp;</a></span>RunCodegen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::RunCodegen </td>
          <td>(</td>
          <td class="paramtype">ffi::Optional&lt; ffi::Map&lt; ffi::String, ffi::Map&lt; ffi::String, ffi::Any &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>target_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Array&lt; ffi::String &gt;&#160;</td>
          <td class="paramname"><em>entry_functions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run codegen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_options</td><td>pairs of target name and compilation options </td></tr>
    <tr><td class="paramname">entry_functions</td><td>list of entry functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a658a2b8f167c50e9749fe05e0552aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658a2b8f167c50e9749fe05e0552aca7">&#9670;&nbsp;</a></span>SplitLayoutRewritePreproc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::SplitLayoutRewritePreproc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the layout rewrite preproc block to a separate <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode.">tir::PrimFunc</a>. </p>
<p>This pass is used in the prepack weight after <a class="el" href="namespacetvm_1_1meta__schedule.html">meta_schedule</a> tuning.</p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="aef9e9338ca42710bcfb51652793efb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9e9338ca42710bcfb51652793efb9b">&#9670;&nbsp;</a></span>StaticPlanBlockMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::StaticPlanBlockMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The static memory planning pass on <a class="el" href="classtvm_1_1relax_1_1BindingBlock.html">BindingBlock</a> level. The pass will reuse allocated memory to its best effort, in order to reduce the total amount of allocated memory size. </p>
<p>The pass "supports" dynamic shape in the way of TIR variable upper bound annotation. We can optionally annotate the attribute "tir_var_upper_bound" to Relax functions. The attribute value is a dict from strings to integers, denoting the name of TIR variables to the upper bound values of the TIR vars. Note: The annotated upper bound attribute only applies to TIR vars in the function signature for clarity.</p>
<p>For example, we can annotate a Relax function with <code>R.func_attr({"tir_var_upper_bound": {"n": 1024}})</code>. It means the maximum value of variable that names "n" in the function signature will have upper bound 1024. And we will use 1024 as its value during memory planning.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a id="a13b0363e13a19a156462cab6f097559c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0363e13a19a156462cab6f097559c">&#9670;&nbsp;</a></span>ToMixedPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::ToMixedPrecision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>out_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ffi::Optional&lt; ffi::Array&lt; ffi::String &gt;&gt;&#160;</td>
          <td class="paramname"><em>fp16_input_names</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic mixed precision pass. Currently the pass assumes the input module to be fp32 only, and will automatically cast fp32 to fp16 for certain ops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_dtype</td><td>The output data type of gemm/conv, which is the data type of the accumulator. </td></tr>
    <tr><td class="paramname">fp16_input_names</td><td>The names of function parameters whose dtype should become fp16. The function signature would change accordingly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mainly operates within dataflow blocks. ConvertToDataflow may need to be called first. </dd></dl>

</div>
</div>
<a id="af3d2bed29c2df4141beece380481ddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d2bed29c2df4141beece380481ddaa">&#9670;&nbsp;</a></span>ToNonDataflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::ToNonDataflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform all dataflow structure to non-dataflow version. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="aeb38ac5d686a9e6feaec6290b92d374e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb38ac5d686a9e6feaec6290b92d374e">&#9670;&nbsp;</a></span>UpdateVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::UpdateVDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1VDevice.html">VDevice</a>&#160;</td>
          <td class="paramname"><em>new_vdevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update virtual device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_vdevice</td><td>The new virtual device. </td></tr>
    <tr><td class="paramname">index</td><td>The device index indicates the device on which the update will be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a id="a640f84c6058f570cdef3e463338a8267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f84c6058f570cdef3e463338a8267">&#9670;&nbsp;</a></span>VMShapeLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax_1_1transform.html#aa3d28b2e48b6d5708052909943dd3282">Pass</a> tvm::relax::transform::VMShapeLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower the shape expression in relax to VM shape heap and TIR functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
