
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>C++ Guide &#8212; tvm-ffi</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=a5c4661c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=dbebe8bd"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="../_static/downloads/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python Guide" href="python_guide.html" />
    <link rel="prev" title="Packaging" href="packaging.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Sep 02, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">tvm-ffi</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../get_started/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/quick_start.html">Quick Start</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="packaging.html">Packaging</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">C++ Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_guide.html">Python Guide</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../concepts/abi_overview.html">ABI Overview</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/apache/tvm" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/guides/cpp_guide.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>C++ Guide</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#any-and-anyview">Any and AnyView</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#object-and-objectref">Object and ObjectRef</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function">Function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#global-function-registry">Global Function Registry</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exporting-as-library-symbol">Exporting as Library Symbol</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#error-handling">Error Handling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#ndarray">NDArray</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dlpack-conversion">DLPack Conversion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#string-and-bytes">String and Bytes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#container-types">Container Types</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#array">Array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tuple">Tuple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map">Map</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optional">Optional</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variant">Variant</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <!--- Licensed to the Apache Software Foundation (ASF) under one -->
<!--- or more contributor license agreements.  See the NOTICE file -->
<!--- distributed with this work for additional information -->
<!--- regarding copyright ownership.  The ASF licenses this file -->
<!--- to you under the Apache License, Version 2.0 (the -->
<!--- "License"); you may not use this file except in compliance -->
<!--- with the License.  You may obtain a copy of the License at -->
<!---   http://www.apache.org/licenses/LICENSE-2.0 -->
<!--- Unless required by applicable law or agreed to in writing, -->
<!--- software distributed under the License is distributed on an -->
<!--- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -->
<!--- KIND, either express or implied.  See the License for the -->
<!--- specific language governing permissions and limitations -->
<!--- under the License. -->
<section class="tex2jax_ignore mathjax_ignore" id="c-guide">
<h1>C++ Guide<a class="headerlink" href="#c-guide" title="Link to this heading">#</a></h1>
<p>This guide introduces the tvm-ffi C++ API.
We provide C++ API on top of the stable C ABI to provide a type-safe and efficient way to work with the tvm-ffi.
The C++ API is designed to abstract away the complexity of the C ABI while maintaining full compatibility.
The C++ API builds around the following key concepts:</p>
<ul class="simple">
<li><p><strong>Any and AnyView</strong>: Type-erased containers that can hold values of any supported type in tvm-ffi.</p></li>
<li><p><strong>Function</strong>: A type-erased “packed” function that can be invoked like normal functions.</p></li>
<li><p><strong>Objects and ObjectRefs</strong>: Reference-counted objects to manage on-heap data types.</p></li>
</ul>
<p>Code examples in this guide use <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code> for demonstration purposes, which is a testing framework macro. In actual applications, you would use standard C++ assertions or error handling.
You can find runnable code of the examples under tests/cpp/test_example.cc.</p>
<section id="any-and-anyview">
<h2>Any and AnyView<a class="headerlink" href="#any-and-anyview" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Any</span></code> and <code class="docutils literal notranslate"><span class="pre">AnyView</span></code> are the foundation of tvm-ffi, providing
ways to store values that are compatible with the ffi system.
The following example shows how we can interact with Any and AnyView.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/any.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleAny</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Create an Any from various types</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="w"> </span><span class="n">int_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="w"> </span><span class="n">float_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="w"> </span><span class="n">string_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// AnyView provides a lightweight view without ownership</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">AnyView</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_value</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// we can cast Any/AnyView to a specific type</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">extracted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">extracted</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// If we are not sure about the type</span>
<span class="w">  </span><span class="c1">// we can use as to get an optional value</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maybe_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maybe_int</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">maybe_int</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Try cast is another version that will try to run the type</span>
<span class="w">  </span><span class="c1">// conversion even if the type does not exactly match</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maybe_int_try</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">view</span><span class="p">.</span><span class="n">try_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maybe_int_try</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">maybe_int_try</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At a high level, we can perform the following operations:</p>
<ul class="simple">
<li><p>We can store a value into Any, under the hood, Any will record the type of the value by its type_index.</p></li>
<li><p>We can fetch a value from Any or AnyView using the <code class="docutils literal notranslate"><span class="pre">cast</span></code> function.</p></li>
<li><p>If we are unsure about the type in Any, we can use <code class="docutils literal notranslate"><span class="pre">as</span></code> or <code class="docutils literal notranslate"><span class="pre">try_cast</span></code> function to get an optional value.</p></li>
</ul>
<p>Under the hood, Any and AnyView store the value via the ABI convention and also manage the reference
counting correctly when the stored value is an on-heap object.</p>
</section>
<section id="object-and-objectref">
<h2>Object and ObjectRef<a class="headerlink" href="#object-and-objectref" title="Link to this heading">#</a></h2>
<p>The tvm-ffi object system provides the foundation for all managed, reference-counted objects
in the system. It enables type safety, cross-language compatibility, and efficient memory management.</p>
<p>The object system is built around three key classes: Object, ObjectPtr, and ObjectRef.
The <code class="docutils literal notranslate"><span class="pre">Object</span></code> class is the base class of all heap-allocated objects. It contains a common header
that includes the <code class="docutils literal notranslate"><span class="pre">type_index</span></code>, reference counter and deleter for the object.
Users do not need to explicitly manage these fields as part of the C++ API. Instead,
they are automatically managed through a smart pointer <code class="docutils literal notranslate"><span class="pre">ObjectPtr</span></code> which points
to a heap-allocated object instance.
The following code shows an example object and the creation of an <code class="docutils literal notranslate"><span class="pre">ObjectPtr</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/object.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/memory.h&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyIntPairObj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">Object</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">MyIntPairObj</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyIntPairObj</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Required: declare type information</span>
<span class="w">  </span><span class="c1">// to register a dynamic type index through the system</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_type_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;example.MyIntPair&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// This macro registers the class with the FFI system to set up the right type index</span>
<span class="w">  </span><span class="n">TVM_FFI_DECLARE_FINAL_OBJECT_INFO</span><span class="p">(</span><span class="n">MyIntPairObj</span><span class="p">,</span><span class="w"> </span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">Object</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleObjectPtr</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// make_object automatically sets up the deleter correctly</span>
<span class="w">  </span><span class="c1">// This function creates a new ObjectPtr with proper memory management</span>
<span class="w">  </span><span class="c1">// It handles allocation, initialization, and sets up the reference counting system</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">ObjectPtr</span><span class="o">&lt;</span><span class="n">MyIntPairObj</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">make_object</span><span class="o">&lt;</span><span class="n">MyIntPairObj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We typically provide a reference class that wraps the ObjectPtr.
The <code class="docutils literal notranslate"><span class="pre">ObjectRef</span></code> base class provides the interface and reference counting
functionality for these wrapper classes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/object.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/memory.h&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyIntPair</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">ObjectRef</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Constructor</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">MyIntPair</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">make_object</span><span class="o">&lt;</span><span class="n">MyIntPairObj</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Required: define object reference methods</span>
<span class="w">  </span><span class="c1">// This macro provides the necessary methods for ObjectRef functionality</span>
<span class="w">  </span><span class="n">TVM_FFI_DEFINE_OBJECT_REF_METHODS</span><span class="p">(</span><span class="n">MyIntPair</span><span class="p">,</span><span class="w"> </span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">ObjectRef</span><span class="p">,</span><span class="w"> </span><span class="n">MyIntPairObj</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleObjectRef</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyIntPair</span><span class="w"> </span><span class="nf">pair</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">pair</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">pair</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Note:</strong> The ObjectRef provides a user-friendly interface while ObjectPtr handles the low-level memory management.
The ObjectRef acts as a smart pointer wrapper that automatically manages the ObjectPtr lifecycle.</p>
<p>The overall implementation pattern is as follows:</p>
<ul class="simple">
<li><p><strong>Object Class</strong>: Inherits from <code class="docutils literal notranslate"><span class="pre">ffi::Object</span></code>, stores data and implements the core functionality.</p></li>
<li><p><strong>ObjectPtr</strong>: Smart pointer that manages the Object lifecycle and reference counting.</p></li>
<li><p><strong>Ref Class</strong>: Inherits from <code class="docutils literal notranslate"><span class="pre">ffi::ObjectRef</span></code>, provides a user-friendly interface and automatic memory management.</p></li>
</ul>
<p>This design ensures efficient memory management while providing a clean API for users. Once we define an ObjectRef class,
we can integrate it with the Any, AnyView and Functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/object.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/any.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleObjectRefAny</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyIntPair</span><span class="w"> </span><span class="nf">pair</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyIntPair</span><span class="w"> </span><span class="n">pair2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MyIntPair</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Note: EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">pair2</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">pair2</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, ObjectPtr manages the lifecycle of the object through the same mechanism as shared pointers. We designed
the object to be intrusive, which means the reference counter and type index metadata are embedded at the header of each object.
This design allows us to allocate the control block and object memory together. As we will see in future sections,
all of our heap-allocated classes such as Function, on-heap String, Array and Map are managed using subclasses of Object,
and the user-facing classes such as Function are ObjectRefs.</p>
<p>We provide a collection of built-in object and reference types, which are sufficient for common cases.
Developers can also bring new object types as shown in the example of this section. We provide mechanisms
to expose these objects to other language bindings such as Python.</p>
</section>
<section id="function">
<h2>Function<a class="headerlink" href="#function" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class provides a type-safe way to create and invoke callable objects
through tvm-ffi ABI convention. We can create a <code class="docutils literal notranslate"><span class="pre">ffi::Function</span></code> from an existing typed lambda function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/function.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleFunctionFromTyped</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Create a function from a typed lambda</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">fadd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">FromTyped</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fadd1</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, tvm-ffi leverages Any and AnyView to create a unified ABI for
all functions. The following example demonstrates the low-level way of defining
a “packed” function for the same <code class="docutils literal notranslate"><span class="pre">fadd1</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ExampleFunctionFromPacked</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Create a function from a typed lambda</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">fadd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">FromPacked</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">AnyView</span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">num_args</span><span class="p">,</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="o">*</span><span class="w"> </span><span class="n">rv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Check that we have exactly one argument</span>
<span class="w">      </span><span class="n">TVM_FFI_ICHECK_EQ</span><span class="p">(</span><span class="n">num_args</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">      </span><span class="o">*</span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fadd1</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At a high level, <code class="docutils literal notranslate"><span class="pre">ffi::Function</span></code> implements function calling by the following convention:</p>
<ul class="simple">
<li><p>The arguments are passed through an on-stack array of <code class="docutils literal notranslate"><span class="pre">ffi::AnyView</span></code></p></li>
<li><p>Return values are passed through <code class="docutils literal notranslate"><span class="pre">ffi::Any</span></code></p></li>
</ul>
<p>Because the return value is <code class="docutils literal notranslate"><span class="pre">ffi::Any</span></code>, we need to explicitly call <code class="docutils literal notranslate"><span class="pre">cast</span></code> to convert the return
value to the desirable type. Importantly, <code class="docutils literal notranslate"><span class="pre">ffi::Function</span></code> itself is a value type that is compatible
with tvm-ffi, which means we can pass it as an argument and return values. The following code shows
an example of passing a function as an argument and applying it inside.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ExampleFunctionPassFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Create a function from a typed lambda</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">fapply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">FromTyped</span><span class="p">(</span>
<span class="w">      </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">fadd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">FromTyped</span><span class="p">(</span><span class="w">  </span><span class="c1">//</span>
<span class="w">      </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fapply</span><span class="p">(</span><span class="n">fadd1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This pattern is very powerful because we can construct <code class="docutils literal notranslate"><span class="pre">ffi::Function</span></code> not only from C++,
but from any languages that expose to the tvm-ffi ABI. For example, this means we can easily call functions
passed in or registered from Python for quick debugging or other purposes.</p>
<section id="global-function-registry">
<h3>Global Function Registry<a class="headerlink" href="#global-function-registry" title="Link to this heading">#</a></h3>
<p>Besides creating functions locally, tvm-ffi provides a global function registry that allows
functions to be registered and called across different modules and languages.
The following code shows an example</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/function.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/reflection/registry.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleGlobalFunctionRegistry</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">reflection</span><span class="o">::</span><span class="n">GlobalDef</span><span class="p">().</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;xyz.add1&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">fadd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">GetGlobalRequired</span><span class="p">(</span><span class="s">&quot;xyz.add1&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fadd1</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also access and register global functions from the Python API.</p>
</section>
<section id="exporting-as-library-symbol">
<h3>Exporting as Library Symbol<a class="headerlink" href="#exporting-as-library-symbol" title="Link to this heading">#</a></h3>
<p>Besides the API that allows registration of functions into the global table,
we also provide a macro to export static functions as <code class="docutils literal notranslate"><span class="pre">TVMFFISafeCallType</span></code> symbols in a dynamic library.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">AddOne</span><span class="p">(</span><span class="n">DLTensor</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">DLTensor</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... implementation omitted ...</span>
<span class="p">}</span>

<span class="n">TVM_FFI_DLL_EXPORT_TYPED_FUNC</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span><span class="w"> </span><span class="n">my_ffi_extension</span><span class="o">::</span><span class="n">AddOne</span><span class="p">);</span>
</pre></div>
</div>
<p>The new <code class="docutils literal notranslate"><span class="pre">add_one</span></code> takes the signature of <code class="docutils literal notranslate"><span class="pre">TVMFFISafeCallType</span></code> and can be wrapped as <code class="docutils literal notranslate"><span class="pre">ffi::Function</span></code>
through the C++ <code class="docutils literal notranslate"><span class="pre">ffi::Module</span></code> API.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ffi</span><span class="o">::</span><span class="n">Module</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Module</span><span class="o">::</span><span class="n">LoadFromFile</span><span class="p">(</span><span class="s">&quot;path/to/export_lib.so&quot;</span><span class="p">);</span>
<span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">GetFunction</span><span class="p">(</span><span class="s">&quot;add_one&quot;</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Link to this heading">#</a></h2>
<p>We provide a specific <code class="docutils literal notranslate"><span class="pre">ffi::Error</span></code> type that is also made compatible with the ffi ABI.
We also provide a macro <code class="docutils literal notranslate"><span class="pre">TVM_FFI_THROW</span></code> to simplify the error throwing step.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: cpp/test_example.cc</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/error.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">FuncThrowError</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">TVM_FFI_THROW</span><span class="p">(</span><span class="n">TypeError</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;test0&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">ExampleErrorHandling</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FuncThrowError</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">kind</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;TypeError&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;test0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">traceback</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The structured error class records kind, message and traceback that can be mapped to
Pythonic style error types and tracebacks. The traceback follows the Python style,
tvm-ffi will try to preserve the traceback when possible. In the above example,
you can see the traceback output as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">more</span> <span class="n">lines</span> <span class="n">omitted</span>
<span class="n">File</span> <span class="s2">&quot;cpp/test_example.cc&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">106</span><span class="p">,</span> <span class="ow">in</span> <span class="n">ExampleErrorHandling</span>
<span class="n">File</span> <span class="s2">&quot;cpp/test_example.cc&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">100</span><span class="p">,</span> <span class="ow">in</span> <span class="n">void</span> <span class="n">FuncThrowError</span><span class="p">()</span>
</pre></div>
</div>
<p>The ffi ABI provides minimal but sufficient mechanisms to propagate these errors across
language boundaries.
So when we call the function from Python, the Error will be translated into a corresponding
Error type. Similarly, when we call a Python callback from C++, the error will be translated
into the right error kind and message.</p>
</section>
<section id="ndarray">
<h2>NDArray<a class="headerlink" href="#ndarray" title="Link to this heading">#</a></h2>
<p>For many use cases, we do not need to manage the nd-array/Tensor memory.
In such cases, <code class="docutils literal notranslate"><span class="pre">DLTensor*</span></code> can be used as the function arguments.
There can be cases for a managed container for multi-dimensional arrays.
<code class="docutils literal notranslate"><span class="pre">ffi::NDArray</span></code> is a minimal container to provide such support.
Notably, specific logic of device allocations and array operations are non-goals
of the FFI. Instead, we provide minimal generic API <code class="docutils literal notranslate"><span class="pre">ffi::NDArray::FromNDAlloc</span></code>
to enable flexible customization of NDArray allocation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/ndarray.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/shape.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">CPUNDAlloc</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">AllocData</span><span class="p">(</span><span class="n">DLTensor</span><span class="o">*</span><span class="w"> </span><span class="n">tensor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tensor</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">tvm</span><span class="o">::</span><span class="n">ffi</span><span class="o">::</span><span class="n">GetDataSize</span><span class="p">(</span><span class="o">*</span><span class="n">tensor</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">FreeData</span><span class="p">(</span><span class="n">DLTensor</span><span class="o">*</span><span class="w"> </span><span class="n">tensor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">free</span><span class="p">(</span><span class="n">tensor</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleNDArray</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">  </span><span class="n">DLDataType</span><span class="w"> </span><span class="n">dtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">kDLFloat</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="w">  </span><span class="n">DLDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">kDLCPU</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="w"> </span><span class="n">nd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="o">::</span><span class="n">FromNDAlloc</span><span class="p">(</span><span class="n">CPUNDAlloc</span><span class="p">(),</span><span class="w"> </span><span class="n">shape</span><span class="p">,</span><span class="w"> </span><span class="n">dtype</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// now nd is a managed ndarray</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above example shows how we define <code class="docutils literal notranslate"><span class="pre">CPUNDAlloc</span></code> that customizes <code class="docutils literal notranslate"><span class="pre">AllocData</span></code>
and <code class="docutils literal notranslate"><span class="pre">FreeData</span></code> behavior. The CPUNDAlloc struct will be kept alive with the NDArray object.
This pattern allows us to implement various NDArray allocations using the same API:</p>
<ul class="simple">
<li><p>For CUDA allocation, we can change malloc to cudaMalloc</p></li>
<li><p>For memory-pool based allocation, we can update <code class="docutils literal notranslate"><span class="pre">CPUNDAlloc</span></code> to keep a strong reference to the pool,
so we can keep memory-pool alive when the array is alive.</p></li>
</ul>
<p><strong>Working with Shapes</strong> As you may have noticed in the example, we have a <code class="docutils literal notranslate"><span class="pre">ffi::Shape</span></code> container that is used
to represent the shapes in nd-array. This container allows us to have compact and efficient representation
of managed shapes and we provide quick conversions from standard vector types.</p>
<section id="dlpack-conversion">
<h3>DLPack Conversion<a class="headerlink" href="#dlpack-conversion" title="Link to this heading">#</a></h3>
<p>We provide first-class DLPack support to the <code class="docutils literal notranslate"><span class="pre">ffi::NDArray</span></code> that enables efficient exchange
through the DLPack Protocol.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/ndarray.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleNDArrayDLPack</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">  </span><span class="n">DLDataType</span><span class="w"> </span><span class="n">dtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">kDLFloat</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="w">  </span><span class="n">DLDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">kDLCPU</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="w"> </span><span class="n">nd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="o">::</span><span class="n">FromNDAlloc</span><span class="p">(</span><span class="n">CPUNDAlloc</span><span class="p">(),</span><span class="w"> </span><span class="n">shape</span><span class="p">,</span><span class="w"> </span><span class="n">dtype</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// convert to DLManagedTensorVersioned</span>
<span class="w">  </span><span class="n">DLManagedTensorVersioned</span><span class="o">*</span><span class="w"> </span><span class="n">dlpack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nd</span><span class="p">.</span><span class="n">ToDLPackVersioned</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// load back from DLManagedTensorVersioned</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="w"> </span><span class="n">nd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">NDArray</span><span class="o">::</span><span class="n">FromDLPackVersioned</span><span class="p">(</span><span class="n">dlpack</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These APIs are also available through the C APIs
<code class="docutils literal notranslate"><span class="pre">TVMFFINDArrayFromDLPackVersioned</span></code> and <code class="docutils literal notranslate"><span class="pre">TVMFFINDArrayToDLPackVersioned</span></code>.</p>
</section>
</section>
<section id="string-and-bytes">
<h2>String and Bytes<a class="headerlink" href="#string-and-bytes" title="Link to this heading">#</a></h2>
<p>The tvm-ffi provides first-class support for <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Bytes</span></code> types that are efficient,
FFI-compatible, and interoperable with standard C++ string types.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/string.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">11</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">std_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">std_str</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, users can always directly use <code class="docutils literal notranslate"><span class="pre">std::string</span></code> in function arguments, conversion
will happen automatically.</p>
<p><strong>Rationale:</strong> We need to have separate Bytes and String so they map well to corresponding Python types.
<code class="docutils literal notranslate"><span class="pre">ffi::String</span></code> is backed by a possibly managed object that makes it more compatible with the Object system.</p>
</section>
<section id="container-types">
<h2>Container Types<a class="headerlink" href="#container-types" title="Link to this heading">#</a></h2>
<p>To enable effective passing and storing of collections of values that are compatible with tvm-ffi,
we provide several built-in container types.</p>
<section id="array">
<h3>Array<a class="headerlink" href="#array" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> provides an array data type that can be used as function arguments.
When we use <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> as an argument of a Function, it will
perform runtime checks of the elements to ensure the values match the expected type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/array.h&gt;</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleArray</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">FromTyped</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="n">numbers</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// throw an error because 2.2 is not int</span>
<span class="w">    </span><span class="n">head</span><span class="p">(</span><span class="n">ffi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">ffi</span><span class="o">::</span><span class="n">Any</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.2</span><span class="p">}));</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">kind</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;TypeError&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, Array is backed by a reference-counted Object <code class="docutils literal notranslate"><span class="pre">ArrayObj</span></code> that stores
a collection of Any values. Note that conversion from Any to <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> will result in
runtime checks of elements because the type index only indicates <code class="docutils literal notranslate"><span class="pre">ArrayObj</span></code> as the backing storage.
If you want to defer such checks at the FFI function boundary, consider using <code class="docutils literal notranslate"><span class="pre">Array&lt;Any&gt;</span></code> instead.
When passing lists and tuples from Python, the values will be converted to <code class="docutils literal notranslate"><span class="pre">Array&lt;Any&gt;</span></code> before
being passed into the Function.</p>
<p><strong>Performance note:</strong> Repeatedly converting Any to <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> can incur repeated
checking overhead at each element. Consider using <code class="docutils literal notranslate"><span class="pre">Array&lt;Any&gt;</span></code> to defer checking or only run conversion once.</p>
</section>
<section id="tuple">
<h3>Tuple<a class="headerlink" href="#tuple" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Tuple&lt;Types...&gt;</span></code> provides type-safe fixed-size collections.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/tuple.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleTuple</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tup</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">tup</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">tup</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">tup</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, Tuple is backed by the same <code class="docutils literal notranslate"><span class="pre">ArrayObj</span></code> as the Array container.
This enables zero-cost exchange with input arguments.</p>
<p><strong>Rationale:</strong> This design unifies the conversion rules from Python list/tuple to
Array/Tuple. We always need a container representation for tuples
to be stored in Any.</p>
</section>
<section id="map">
<h3>Map<a class="headerlink" href="#map" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Map&lt;K,</span> <span class="pre">V&gt;</span></code> provides a key-value based hashmap container that can accept dict-style parameters.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/map.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleMap</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">95</span><span class="p">}};</span>

<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">map0</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">map0</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">map0</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, Map is backed by a reference-counted Object <code class="docutils literal notranslate"><span class="pre">MapObj</span></code> that stores
a collection of Any values. The implementation provides a SmallMap variant that stores
values as an array and another variant that is based on a hashmap. The Map preserves insertion
order like Python dictionaries. Conversion from Any to <code class="docutils literal notranslate"><span class="pre">Map&lt;K,</span> <span class="pre">V&gt;</span></code> will result in
runtime checks of its elements because the type index only indicates <code class="docutils literal notranslate"><span class="pre">MapObj</span></code> as the backing storage.
If you want to defer such checks at the FFI function boundary, consider using <code class="docutils literal notranslate"><span class="pre">Map&lt;Any,</span> <span class="pre">Any&gt;</span></code> instead.
When passing dictionaries from Python, the values will be converted to <code class="docutils literal notranslate"><span class="pre">Map&lt;Any,</span> <span class="pre">Any&gt;</span></code> before
being passed into the Function.</p>
<p><strong>Performance note:</strong> Repeatedly converting Any to <code class="docutils literal notranslate"><span class="pre">Map&lt;K,</span> <span class="pre">V&gt;</span></code> can incur repeated
checking overhead at each element. Consider using <code class="docutils literal notranslate"><span class="pre">Map&lt;Any,</span> <span class="pre">Any&gt;</span></code> to defer checking or only run conversion once.</p>
</section>
<section id="optional">
<h3>Optional<a class="headerlink" href="#optional" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Optional&lt;T&gt;</span></code> provides a safe way to handle values that may or may not exist.
We specialize Optional for <code class="docutils literal notranslate"><span class="pre">ffi::String</span></code> and Object types to be more compact,
using nullptr to indicate non-existence.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/optional.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleOptional</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">opt0</span><span class="p">.</span><span class="n">has_value</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">opt0</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>

<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt1</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">opt1</span><span class="p">.</span><span class="n">has_value</span><span class="p">(),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">opt1</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="s">&quot;default&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="variant">
<h3>Variant<a class="headerlink" href="#variant" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Variant&lt;Types...&gt;</span></code> provides a type-safe union of different types.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tvm/ffi/container/variant.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExampleVariant</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">tvm</span><span class="o">::</span><span class="nn">ffi</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi</span><span class="o">::</span><span class="n">Variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">var0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// EXPECT_EQ is used here for demonstration purposes (testing framework)</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">var0</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>

<span class="w">  </span><span class="n">var0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maybe_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var0</span><span class="p">.</span><span class="n">as</span><span class="o">&lt;</span><span class="n">ffi</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">maybe_str</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maybe_int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var0</span><span class="p">.</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">maybe_int2</span><span class="p">.</span><span class="n">has_value</span><span class="p">(),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Under the hood, Variant is a wrapper around Any that restricts the type to the specific types in the list.</p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="packaging.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Packaging</p>
      </div>
    </a>
    <a class="right-next"
       href="python_guide.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Python Guide</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#any-and-anyview">Any and AnyView</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#object-and-objectref">Object and ObjectRef</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function">Function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#global-function-registry">Global Function Registry</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exporting-as-library-symbol">Exporting as Library Symbol</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#error-handling">Error Handling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#ndarray">NDArray</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dlpack-conversion">DLPack Conversion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#string-and-bytes">String and Bytes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#container-types">Container Types</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#array">Array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tuple">Tuple</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#map">Map</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optional">Optional</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variant">Variant</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
  Last updated on Sep 02, 2025.
  <br/>
</p>
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  
  <div class="footer-container" style="margin: 5px 0; font-size: 0.9em; color: #6c757d;">
      <div class="footer-line1" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px;">
          <div class="footer-copyright-short">
              Copyright © 2025, Apache Software Foundation
          </div>
          <div class="footer-dropdown">
              <div class="dropdown">
                  <button class="btn btn-link dropdown-toggle" type="button" id="footerDropdown" data-bs-toggle="dropdown"
                  aria-expanded="false" style="font-size: 0.9em; color: #6c757d; text-decoration: none; padding: 0; border: none; background: none;">
                      ASF
                  </button>
                  <ul class="dropdown-menu" aria-labelledby="footerDropdown" style="font-size: 0.9em;">
<li><a class="dropdown-item" href="https://apache.org/" target="_blank" style="font-size: 0.9em;">ASF Homepage</a></li>
<li><a class="dropdown-item" href="https://www.apache.org/licenses/" target="_blank" style="font-size: 0.9em;">License</a></li>
<li><a class="dropdown-item" href="https://www.apache.org/foundation/sponsorship.html" target="_blank" style="font-size: 0.9em;">Sponsorship</a></li>
<li><a class="dropdown-item" href="https://tvm.apache.org/docs/reference/security.html" target="_blank" style="font-size: 0.9em;">Security</a></li>
<li><a class="dropdown-item" href="https://www.apache.org/foundation/thanks.html" target="_blank" style="font-size: 0.9em;">Thanks</a></li>
<li><a class="dropdown-item" href="https://www.apache.org/events/current-event" target="_blank" style="font-size: 0.9em;">Events</a></li>
                  </ul>
              </div>
          </div>
      </div>
      <div class="footer-line2" style="font-size: 0.9em; color: #6c757d;">
          Apache TVM, Apache, the Apache feather, and the Apache TVM project logo are either trademarks or registered trademarks of the Apache Software Foundation.
      </div>
  </div>
  
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>